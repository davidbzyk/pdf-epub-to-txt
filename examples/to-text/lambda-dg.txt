AWS Lambda
Developer Guide
AWS Lambda Developer Guide
AWS Lambda: Developer Guide
Copyright © 2023 Amazon Web Services, Inc. and/or its aﬃliates. All rights reserved.
Amazon's trademarks and trade dress may not be used in connection with any product or service that is not 
Amazon's, in any manner that is likely to cause confusion among customers, or in any manner that disparages or 
discredits Amazon. All other trademarks not owned by Amazon are the property of their respective owners, who may 
or may not be aﬃliated with, connected to, or sponsored by Amazon.AWS Lambda Developer Guide
Table of Contents
What is AWS Lambda?........................................................................................................................1
When to use Lambda .................................................................................................................1
Key features..............................................................................................................................2
Getting started..................................................................................................................................3
Prerequisites..............................................................................................................................3
Create a function.......................................................................................................................4
Invoke the function....................................................................................................................4
Clean up ...................................................................................................................................5
Additional resources...................................................................................................................6
Accessing Lambda......................................................................................................................6
Authoring and deploying functions..............................................................................................6
Lambda foundations ...........................................................................................................................8
Concepts...................................................................................................................................9
Function............................................................................................................................9
Trigger..............................................................................................................................9
Event................................................................................................................................9
Execution environment......................................................................................................10
Instruction set architecture................................................................................................10
Deployment package........................................................................................................10
Runtime ..........................................................................................................................10
Layer..............................................................................................................................11
Extension........................................................................................................................11
Concurrency.....................................................................................................................11
Qualiﬁer ..........................................................................................................................11
Destination ......................................................................................................................12
Programming model.................................................................................................................13
Execution environment..............................................................................................................14
Runtime environment lifecycle...........................................................................................14
Deployment packages...............................................................................................................18
Container images .............................................................................................................18
.zip ﬁle archives...............................................................................................................18
Layers.............................................................................................................................19
Using other AWS services..................................................................................................19
Private networking...................................................................................................................21
VPC network elements......................................................................................................21
Connecting Lambda functions to your VPC..........................................................................22
Shared subnets................................................................................................................22
Lambda Hyperplane ENIs ..................................................................................................22
Connections.....................................................................................................................24
Security...........................................................................................................................24
Observability...................................................................................................................24
Lambda console.......................................................................................................................25
Applications .....................................................................................................................25
Functions........................................................................................................................25
Code signing ....................................................................................................................25
Layers.............................................................................................................................25
Edit code using the console editor......................................................................................25
Instruction sets (ARM/x86)........................................................................................................33
Advantages of using arm64 architecture.............................................................................33
Requirements for migration to arm64 architecture...............................................................33
Function code compatibility with arm64 architecture............................................................34
How to migrate to arm64 architecture................................................................................34
Conﬁguring the instruction set architecture.........................................................................34
Additional features...................................................................................................................36
iiiAWS Lambda Developer Guide
Scaling ............................................................................................................................36
Concurrency controls........................................................................................................36
Function URLs..................................................................................................................36
Asynchronous invocation...................................................................................................37
Event source mappings.....................................................................................................37
Destinations .....................................................................................................................38
Function blueprints...........................................................................................................39
Testing and deployment tools............................................................................................39
Application templates .......................................................................................................40
Learn how to build serverless solutions.......................................................................................40
Lambda runtimes .............................................................................................................................41
Runtime deprecation policy.......................................................................................................42
Runtime updates ......................................................................................................................45
Runtime management controls..........................................................................................45
Two-phase runtime version rollout.....................................................................................46
Roll back a runtime version...............................................................................................46
Identifying runtime version changes...................................................................................47
Conﬁgure runtime management settings.............................................................................49
Shared responsibility model...............................................................................................49
High-compliance applications............................................................................................50
Supported Regions...........................................................................................................51
Runtime modiﬁcations ..............................................................................................................52
Language-speciﬁc environment variables.............................................................................52
Wrapper scripts................................................................................................................52
Runtime API ............................................................................................................................55
Next invocation................................................................................................................55
Invocation response..........................................................................................................56
Initialization error.............................................................................................................56
Invocation error...............................................................................................................57
Custom runtimes ......................................................................................................................60
Using a custom runtime ....................................................................................................60
Building a custom runtime ................................................................................................60
Implementing response streaming in a custom runtime.........................................................61
Tutorial – Custom runtime.........................................................................................................63
Prerequisites....................................................................................................................63
Create a function.............................................................................................................63
Create a layer..................................................................................................................65
Update the function.........................................................................................................66
Update the runtime ..........................................................................................................67
Share the layer................................................................................................................67
Clean up .........................................................................................................................67
AVX2 vectorization...................................................................................................................69
Compiling from source......................................................................................................69
Enabling AVX2 for Intel MKL.............................................................................................69
AVX2 support in other languages.......................................................................................69
Conﬁguring functions.......................................................................................................................71
Conﬁguring function options.....................................................................................................72
Function versions.............................................................................................................72
Using the function overview..............................................................................................72
Conﬁguring functions (console)..........................................................................................73
Conﬁguring functions (API)................................................................................................74
Conﬁguring function memory (console)...............................................................................74
Conﬁguring function timeout (console)...............................................................................74
Conﬁguring ephemeral storage (console).............................................................................75
Accepting function memory recommendations (console).......................................................75
Conﬁguring triggers (console)............................................................................................75
Testing functions (console)................................................................................................76
ivAWS Lambda Developer Guide
Environment variables...............................................................................................................77
Conﬁguring environment variables.....................................................................................77
Conﬁguring environment variables with the API...................................................................78
Example scenario for environment variables........................................................................79
Retrieve environment variables..........................................................................................79
Deﬁned runtime environment variables...............................................................................80
Securing environment variables..........................................................................................81
Sample code and templates..............................................................................................83
Outbound networking...............................................................................................................85
Managing VPC connections................................................................................................85
Execution role and user permissions...................................................................................86
Conﬁguring VPC access (console)........................................................................................86
Conﬁguring VPC access (API).............................................................................................87
Using IAM condition keys for VPC settings...........................................................................88
Internet and service access for VPC-connected functions.......................................................91
VPC tutorials ...................................................................................................................91
Sample VPC conﬁgurations................................................................................................91
Inbound networking.................................................................................................................92
Considerations for Lambda interface endpoints....................................................................92
Creating an interface endpoint for Lambda.........................................................................93
Creating an interface endpoint policy for Lambda................................................................94
Database proxy........................................................................................................................95
Creating a database proxy (console)....................................................................................95
Using the function's permissions for authentication..............................................................96
Sample application ...........................................................................................................96
File system ..............................................................................................................................99
Execution role and user permissions...................................................................................99
Conﬁguring a ﬁle system and access point..........................................................................99
Connecting to a ﬁle system (console)................................................................................100
Conﬁguring ﬁle system access with the Lambda API...........................................................101
AWS CloudFormation and AWS SAM.................................................................................101
Sample applications ........................................................................................................103
Aliases ...................................................................................................................................104
Creating a function alias (Console)....................................................................................104
Managing aliases with the Lambda API .............................................................................104
Managing aliases with AWS SAM and AWS CloudFormation..................................................105
Using aliases ..................................................................................................................105
Resource policies............................................................................................................105
Alias routing conﬁguration..............................................................................................105
Versions................................................................................................................................108
Creating function versions...............................................................................................108
Using versions................................................................................................................109
Granting permissions ......................................................................................................109
Response streaming................................................................................................................110
Writing response streaming-enabled functions...................................................................110
Invoking a response streaming enabled function using Lambda function URLs........................111
Bandwidth limits for response streaming...........................................................................112
Tutorial: Creating a response streaming function with a function URL....................................112
Deploying functions........................................................................................................................117
.zip ﬁle archives.....................................................................................................................117
Container images ....................................................................................................................117
.zip ﬁle archives.....................................................................................................................118
Creating the function......................................................................................................118
Using the console code editor..........................................................................................119
Updating function code...................................................................................................119
Changing the runtime .....................................................................................................120
Changing the architecture...............................................................................................120
vAWS Lambda Developer Guide
Using the Lambda API ......................................................................................................74
AWS CloudFormation......................................................................................................121
Container images ....................................................................................................................122
Requirements.................................................................................................................122
Using an AWS base image...............................................................................................123
Using an AWS base image for custom runtimes..................................................................123
Using a non-AWS base image..........................................................................................124
Runtime interface clients.................................................................................................124
Amazon ECR permissions.................................................................................................124
Container image settings.................................................................................................126
Testing images.......................................................................................................................127
Guidelines ......................................................................................................................127
Environment variables.....................................................................................................127
Testing AWS base images................................................................................................128
Testing provided.al2 base images.....................................................................................128
Testing non-AWS images.................................................................................................130
Invoking functions..........................................................................................................................135
Testing in console...................................................................................................................137
Invoking functions with test events..................................................................................137
Private test events..........................................................................................................137
Shareable test events......................................................................................................137
Deleting shareable test event schemas..............................................................................138
Synchronous invocation...........................................................................................................139
Asynchronous invocation.........................................................................................................142
How Lambda handles asynchronous invocations.................................................................142
Conﬁguring error handling for asynchronous invocation......................................................144
Conﬁguring destinations for asynchronous invocation.........................................................144
Asynchronous invocation conﬁguration API........................................................................147
Dead-letter queues.........................................................................................................148
Event source mapping.............................................................................................................150
Batching behavior...........................................................................................................151
Event ﬁltering........................................................................................................................155
Event ﬁltering basics.......................................................................................................155
Handling records that don't meet ﬁlter criteria...................................................................157
Filter rule syntax ............................................................................................................157
Attaching ﬁlter criteria to an event source mapping (console)...............................................158
Attaching ﬁlter criteria to an event source mapping (AWS CLI)..............................................159
Attaching ﬁlter criteria to an event source mapping (AWS SAM)............................................160
Using ﬁlters with diﬀerent AWS services............................................................................160
Filtering with DynamoDB .................................................................................................161
Filtering with Kinesis .......................................................................................................165
Filtering with Amazon MQ...............................................................................................168
Filtering with Amazon MSK and self-managed Apache Kafka................................................172
Filtering with Amazon SQS..............................................................................................175
Function states.......................................................................................................................179
Function states while updating.........................................................................................179
Error handling........................................................................................................................181
Invoking functions deﬁned as container images..........................................................................183
Function lifecycle............................................................................................................183
Invoking the function......................................................................................................183
Image security................................................................................................................183
Recursive loop detection.........................................................................................................184
Understanding recursive loop detection.............................................................................184
Supported AWS services and SDKs....................................................................................185
Recursive loop notiﬁcations.............................................................................................186
Responding to recursive loop detection notiﬁcations...........................................................187
Function URLs........................................................................................................................189
viAWS Lambda Developer Guide
Creating and managing function URLs..............................................................................190
Security and auth model.................................................................................................195
Invoking function URLs...................................................................................................200
Monitoring function URLs................................................................................................207
Tutorial: Creating a function with a function URL................................................................209
Managing functions........................................................................................................................213
Tutorial - Lambda with CLI......................................................................................................214
Prerequisites..................................................................................................................214
Create the execution role................................................................................................214
Create the function.........................................................................................................215
Update the function.......................................................................................................218
List the Lambda functions in your account.........................................................................218
Retrieve a Lambda function.............................................................................................219
Clean up ........................................................................................................................219
Function scaling.....................................................................................................................220
Understanding and visualizing concurrency........................................................................220
How to calculate concurrency..........................................................................................223
Concurrency vs. requests per second.................................................................................224
Reserved concurrency and provisioned concurrency.............................................................225
Concurrency quotas........................................................................................................232
Conﬁguring reserved concurrency.....................................................................................234
Conﬁguring provisioned concurrency.................................................................................237
Burst concurrency...........................................................................................................243
Monitoring concurrency...................................................................................................251
Code signing ..........................................................................................................................253
Signature validation........................................................................................................253
Conﬁguration prerequisites..............................................................................................254
Creating code signing conﬁgurations.................................................................................254
Updating a code signing conﬁguration..............................................................................254
Deleting a code signing conﬁguration...............................................................................255
Enabling code signing for a function.................................................................................255
Conﬁguring IAM policies ..................................................................................................255
Conﬁguring code signing with the Lambda API..................................................................256
Tags......................................................................................................................................257
Permissions....................................................................................................................257
Using tags with the console.............................................................................................257
Using tags with the AWS CLI...........................................................................................259
Requirements for tags.....................................................................................................260
Testing functions............................................................................................................................261
Targeted business outcomes....................................................................................................261
What to test ..........................................................................................................................262
How to test serverless.............................................................................................................262
Testing techniques..................................................................................................................263
Testing in the cloud........................................................................................................263
Testing with mocks.........................................................................................................265
Testing with emulation....................................................................................................266
Best practices.........................................................................................................................266
Prioritize testing in the cloud...........................................................................................266
Structure your code for testability....................................................................................266
Accelerate development feedback loops............................................................................267
Focus on integration tests...............................................................................................267
Create isolated test environments.....................................................................................267
Use mocks for isolated business logic ...............................................................................268
Use emulators sparingly ..................................................................................................268
Challenges testing locally ........................................................................................................269
Example: Lambda function creates an S3 bucket................................................................269
Example: Lambda function processes messages from an Amazon SQS queue..........................269
viiAWS Lambda Developer Guide
FAQ......................................................................................................................................270
Next steps and resources.........................................................................................................271
Building with Node.js ......................................................................................................................272
Node.js initialization ................................................................................................................273
Designating a function handler as an ES module................................................................274
Using keep-alive.....................................................................................................................274
Handler .................................................................................................................................276
Using async/await..........................................................................................................276
Using callbacks ...............................................................................................................278
Deploy .zip ﬁle archives...........................................................................................................281
Runtime dependencies in Node.js .....................................................................................281
Creating a .zip deployment package with no dependencies..................................................281
Creating a .zip deployment package with dependencies.......................................................282
Dependency search path and runtime-included libraries......................................................283
Creating and updating Node.js Lambda functions using .zip ﬁles...........................................283
Deploy container images.........................................................................................................288
AWS base images for Node.js...........................................................................................288
Using an AWS base image...............................................................................................289
Using a non-AWS base image..........................................................................................292
Context.................................................................................................................................297
Logging .................................................................................................................................299
Creating a function that returns logs................................................................................299
Using the Lambda console...............................................................................................300
Using the CloudWatch console.........................................................................................300
Using the AWS Command Line Interface (AWS CLI).............................................................300
Deleting logs .................................................................................................................303
Errors....................................................................................................................................304
Syntax...........................................................................................................................304
How it works.................................................................................................................304
Using the Lambda console...............................................................................................305
Using the AWS Command Line Interface (AWS CLI).............................................................305
Error handling in other AWS services................................................................................306
What's next?..................................................................................................................307
Tracing..................................................................................................................................308
Using ADOT to instrument your Node.js functions..............................................................308
Using the X-Ray SDK to instrument your Node.js functions..................................................308
Activating tracing with the Lambda console.......................................................................309
Activating tracing with the Lambda API.............................................................................310
Activating tracing with AWS CloudFormation.....................................................................310
Interpreting an X-Ray trace..............................................................................................310
Storing runtime dependencies in a layer (X-Ray SDK)..........................................................312
Building with TypeScript..................................................................................................................314
Development environment.......................................................................................................314
Handler .................................................................................................................................316
Using async/await..........................................................................................................316
Using callbacks ...............................................................................................................317
Using types for the event object......................................................................................318
Deploy .zip ﬁle archives...........................................................................................................319
Using AWS SAM.............................................................................................................319
Using the AWS CDK........................................................................................................320
Using the AWS CLI and esbuild........................................................................................322
Deploy container images.........................................................................................................324
Using a Node.js base image to build and package TypeScript function code............................324
Context.................................................................................................................................328
Logging .................................................................................................................................330
Tools and libraries..........................................................................................................330
Using Powertools for AWS Lambda (TypeScript) and AWS SAM for structured logging..............330
viiiAWS Lambda Developer Guide
Using Powertools for AWS Lambda (TypeScript) and the AWS CDK for structured logging.........332
Using the Lambda console...............................................................................................335
Using the CloudWatch console.........................................................................................335
Testing..................................................................................................................................336
Testing your serverless applications..................................................................................336
Errors....................................................................................................................................338
Tracing..................................................................................................................................340
Using Powertools for AWS Lambda (TypeScript) and AWS SAM for tracing.............................340
Using Powertools for AWS Lambda (TypeScript) and the AWS CDK for tracing.........................342
Interpreting an X-Ray trace..............................................................................................345
Building with Python......................................................................................................................346
Handler .................................................................................................................................348
Naming .........................................................................................................................348
How it works.................................................................................................................348
Returning a value...........................................................................................................349
Examples .......................................................................................................................349
Deploy .zip ﬁle archives...........................................................................................................352
Runtime dependencies in Python.....................................................................................352
Creating a .zip deployment package with no dependencies..................................................353
Creating a .zip deployment package with dependencies.......................................................353
Dependency search path and runtime-included libraries......................................................355
Using __pycache__ folders...............................................................................................356
Creating .zip deployment packages with native libraries.......................................................356
Creating and updating Python Lambda functions using .zip ﬁles...........................................357
Deploy container images.........................................................................................................362
AWS base images for Python...........................................................................................362
Using an AWS base image...............................................................................................363
Using a non-AWS base image..........................................................................................366
Context.................................................................................................................................372
Logging .................................................................................................................................374
Tools and libraries..........................................................................................................374
Creating a function that returns logs................................................................................374
Using Powertools for AWS Lambda (Python) and AWS SAM for structured logging...................375
Using Powertools for AWS Lambda (Python) and the AWS CDK for structured logging..............378
Using the Lambda console...............................................................................................382
Using the CloudWatch console.........................................................................................382
Using the AWS Command Line Interface (AWS CLI).............................................................383
Deleting logs .................................................................................................................385
Logging library...............................................................................................................385
Testing..................................................................................................................................386
Testing your serverless applications..................................................................................386
Errors....................................................................................................................................388
How it works.................................................................................................................388
Using the Lambda console...............................................................................................389
Using the AWS Command Line Interface (AWS CLI).............................................................389
Error handling in other AWS services................................................................................390
Error examples...............................................................................................................390
Sample applications ........................................................................................................391
What's next?..................................................................................................................307
Tracing..................................................................................................................................392
Using Powertools for AWS Lambda (Python) and AWS SAM for tracing..................................392
Using Powertools for AWS Lambda (Python) and the AWS CDK for tracing.............................378
Using ADOT to instrument your Python functions...............................................................398
Using the X-Ray SDK to instrument your Python functions...................................................398
Activating tracing with the Lambda console.......................................................................398
Activating tracing with the Lambda API.............................................................................399
Activating tracing with AWS CloudFormation.....................................................................399
ixAWS Lambda Developer Guide
Interpreting an X-Ray trace..............................................................................................399
Storing runtime dependencies in a layer (X-Ray SDK)..........................................................401
Building with Ruby.........................................................................................................................403
Enabling Yet Another Ruby JIT (YJIT)........................................................................................404
Handler .................................................................................................................................405
Deploy Ruby .zip ﬁle archives...................................................................................................406
Dependencies in Ruby.....................................................................................................406
Creating a .zip deployment package with no dependencies..................................................407
Creating a .zip deployment packaged with dependencies.....................................................407
Creating .zip deployment packages with native libraries.......................................................408
Creating and updating Ruby Lambda functions using .zip ﬁles..............................................409
Deploy container images.........................................................................................................414
AWS base images for Ruby..............................................................................................414
Using an AWS base image...............................................................................................415
Using a non-AWS base image..........................................................................................418
Context.................................................................................................................................423
Logging .................................................................................................................................424
Creating a function that returns logs................................................................................424
Using the Lambda console...............................................................................................425
Using the CloudWatch console.........................................................................................425
Using the AWS Command Line Interface (AWS CLI).............................................................425
Deleting logs .................................................................................................................428
Logger library................................................................................................................428
Errors....................................................................................................................................429
Syntax...........................................................................................................................429
How it works.................................................................................................................429
Using the Lambda console...............................................................................................430
Using the AWS Command Line Interface (AWS CLI).............................................................430
Error handling in other AWS services................................................................................431
Sample applications ........................................................................................................432
What's next?..................................................................................................................432
Tracing..................................................................................................................................433
Enabling active tracing with the Lambda API.....................................................................436
Enabling active tracing with AWS CloudFormation..............................................................436
Storing runtime dependencies in a layer............................................................................437
Building with Java..........................................................................................................................438
Handler .................................................................................................................................440
Example handler: Java 17 runtimes..................................................................................440
Example handler: Java 11 runtimes and below...................................................................441
Initialization code...........................................................................................................442
Choosing input and output types.....................................................................................442
Handler interfaces..........................................................................................................443
Sample handler code......................................................................................................444
Deploy .zip ﬁle archives...........................................................................................................446
Prerequisites..................................................................................................................446
Tools and libraries..........................................................................................................446
Building a deployment package with Gradle......................................................................447
Building a deployment package with Maven......................................................................448
Uploading a deployment package with the Lambda console.................................................449
Uploading a deployment package with the AWS CLI...........................................................450
Uploading a deployment package with AWS SAM...............................................................451
Deploy container images.........................................................................................................453
AWS base images for Java...............................................................................................453
Using an AWS base image...............................................................................................454
Using an alternative base image.......................................................................................458
Java customization.................................................................................................................464
JAVA_TOOL_OPTIONS  environment variable......................................................................464
xAWS Lambda Developer Guide
Context.................................................................................................................................466
Context in sample applications.........................................................................................467
Logging .................................................................................................................................469
Tools and libraries..........................................................................................................469
Creating a function that returns logs................................................................................469
Using Powertools for AWS Lambda (Java) and AWS SAM for structured logging......................471
Using Powertools for AWS Lambda (Java) and the AWS CDK for structured logging..................474
Using the Lambda console...............................................................................................482
Using the CloudWatch console.........................................................................................482
Using the AWS Command Line Interface (AWS CLI).............................................................482
Deleting logs .................................................................................................................484
Advanced logging with Log4j 2 and SLF4J.........................................................................484
Sample logging code......................................................................................................486
Errors....................................................................................................................................488
Syntax...........................................................................................................................488
How it works.................................................................................................................489
Creating a function that returns exceptions.......................................................................489
Using the Lambda console...............................................................................................490
Using the AWS Command Line Interface (AWS CLI).............................................................491
Error handling in other AWS services................................................................................491
Sample applications ........................................................................................................492
What's next?..................................................................................................................492
Tracing..................................................................................................................................493
Using Powertools for AWS Lambda (Java) and AWS SAM for tracing......................................493
Using Powertools for AWS Lambda (Java) and the AWS CDK for tracing.................................495
Using ADOT to instrument your Java functions..................................................................503
Using the X-Ray SDK to instrument your Java functions.......................................................503
Activating tracing with the Lambda console.......................................................................504
Activating tracing with the Lambda API.............................................................................504
Activating tracing with AWS CloudFormation.....................................................................504
Interpreting an X-Ray trace..............................................................................................505
Storing runtime dependencies in a layer (X-Ray SDK)..........................................................506
X-Ray tracing in sample applications (X-Ray SDK)...............................................................507
Tutorial - Eclipse IDE...............................................................................................................508
Prerequisites..................................................................................................................508
Create and build a project...............................................................................................508
Sample apps ..........................................................................................................................511
Building with Go ............................................................................................................................512
Go runtime support................................................................................................................512
Tools and libraries..................................................................................................................512
Handler .................................................................................................................................514
Naming .........................................................................................................................515
Lambda function handler using structured types................................................................515
Using global state ..........................................................................................................517
Context.................................................................................................................................518
Accessing invoke context information................................................................................518
Deploy .zip ﬁle archives...........................................................................................................520
Creating a .zip ﬁle on macOS and Linux............................................................................520
Creating a .zip ﬁle on Windows........................................................................................522
Creating and updating Go Lambda functions using .zip ﬁles.................................................524
Deploy container images.........................................................................................................529
AWS base images for Go.................................................................................................529
Go runtime interface client..............................................................................................529
Using the provided.al2 AWS base image............................................................................529
Using a non-AWS base image..........................................................................................533
Using the Go 1.x base image ...........................................................................................537
Logging .................................................................................................................................542
xiAWS Lambda Developer Guide
Creating a function that returns logs................................................................................542
Using the Lambda console...............................................................................................543
Using the CloudWatch console.........................................................................................543
Using the AWS Command Line Interface (AWS CLI).............................................................543
Deleting logs .................................................................................................................546
Errors....................................................................................................................................547
Creating a function that returns exceptions.......................................................................547
How it works.................................................................................................................547
Using the Lambda console...............................................................................................548
Using the AWS Command Line Interface (AWS CLI).............................................................548
Error handling in other AWS services................................................................................549
What's next?..................................................................................................................550
Tracing..................................................................................................................................551
Using ADOT to instrument your Go functions.....................................................................551
Using the X-Ray SDK to instrument your Go functions.........................................................551
Activating tracing with the Lambda console.......................................................................552
Activating tracing with the Lambda API.............................................................................552
Activating tracing with AWS CloudFormation.....................................................................552
Interpreting an X-Ray trace..............................................................................................553
Environment variables.............................................................................................................555
Building with C# .............................................................................................................................556
Handler .................................................................................................................................558
Handling streams...........................................................................................................558
Handling standard data types..........................................................................................559
Handler signatures..........................................................................................................561
Using top-level statements..............................................................................................561
Using Lambda Annotations ..............................................................................................562
Serializing Lambda functions...........................................................................................563
Lambda function handler restrictions................................................................................564
Using async in C# functions with Lambda..........................................................................564
Deployment package..............................................................................................................566
.NET Core CLI.................................................................................................................566
AWS Toolkit for Visual Studio..........................................................................................569
Deploy container images.........................................................................................................571
AWS base images for .NET...............................................................................................571
Using an AWS base image...............................................................................................572
Using a non-AWS base image..........................................................................................573
Context.................................................................................................................................577
Logging .................................................................................................................................578
Tools and libraries..........................................................................................................578
Creating a function that returns logs................................................................................578
Using log levels..............................................................................................................580
Using Powertools for AWS Lambda (.NET) and AWS SAM for structured logging......................580
Using the Lambda console...............................................................................................582
Using the CloudWatch console.........................................................................................582
Using the AWS Command Line Interface (AWS CLI).............................................................583
Deleting logs .................................................................................................................585
Errors....................................................................................................................................586
Syntax...........................................................................................................................586
How it works.................................................................................................................588
Using the Lambda console...............................................................................................589
Using the AWS Command Line Interface (AWS CLI).............................................................589
Error handling in other AWS services................................................................................590
What's next?..................................................................................................................590
Tracing..................................................................................................................................591
Using Powertools for AWS Lambda (.NET) and AWS SAM for tracing......................................591
Using the X-Ray SDK to instrument your .NET functions......................................................593
xiiAWS Lambda Developer Guide
Activating tracing with the Lambda console.......................................................................594
Activating tracing with the Lambda API.............................................................................594
Activating tracing with AWS CloudFormation.....................................................................594
Interpreting an X-Ray trace..............................................................................................595
Native AOT compilation...........................................................................................................597
Limitations .....................................................................................................................597
Prerequisites..................................................................................................................597
Lambda runtime .............................................................................................................598
Set up your project.........................................................................................................598
Edit your Lambda function code.......................................................................................598
Deploy your Lambda function..........................................................................................598
Add support for complex types........................................................................................598
Troubleshooting.............................................................................................................599
Building with PowerShell.................................................................................................................600
Development Environment......................................................................................................601
Deployment package..............................................................................................................602
Creating a Lambda function.............................................................................................602
Handler .................................................................................................................................604
Returning data...............................................................................................................604
Context.................................................................................................................................605
Logging .................................................................................................................................606
Creating a function that returns logs................................................................................606
Using the Lambda console...............................................................................................607
Using the CloudWatch console.........................................................................................607
Using the AWS Command Line Interface (AWS CLI).............................................................608
Deleting logs .................................................................................................................610
Errors....................................................................................................................................611
Syntax...........................................................................................................................611
How it works.................................................................................................................612
Using the Lambda console...............................................................................................612
Using the AWS Command Line Interface (AWS CLI).............................................................613
Error handling in other AWS services................................................................................613
What's next?..................................................................................................................614
Building with Rust ..........................................................................................................................615
Handler .................................................................................................................................617
Using shared state..........................................................................................................617
Context.................................................................................................................................619
Accessing invoke context information................................................................................619
HTTP events..........................................................................................................................620
Deploy .zip ﬁle archives...........................................................................................................622
Prerequisites..................................................................................................................622
Building the function......................................................................................................622
Deploying the function...................................................................................................623
Invoking the function......................................................................................................624
Logging .................................................................................................................................625
Creating a function that writes logs..................................................................................625
Advanced logging with the Tracing crate...........................................................................625
Errors....................................................................................................................................627
Creating a function that returns errors..............................................................................627
Integrating other services................................................................................................................628
Listing of services and links to more information........................................................................628
Event-driven invocation...........................................................................................................630
Lambda polling ......................................................................................................................630
Use cases ...............................................................................................................................631
Example 1: Amazon S3 pushes events and invokes a Lambda function...................................631
Example 2: AWS Lambda pulls events from a Kinesis stream and invokes a Lambda function.....632
Alexa .....................................................................................................................................633
xiiiAWS Lambda Developer Guide
API Gateway..........................................................................................................................634
Adding an endpoint to your Lambda function....................................................................634
Proxy integration............................................................................................................634
Event format..................................................................................................................635
Response format............................................................................................................636
Permissions....................................................................................................................636
Handling errors with an API Gateway API..........................................................................638
Choosing an API type......................................................................................................639
Sample applications ........................................................................................................640
Tutorial.........................................................................................................................640
Sample template ............................................................................................................654
CloudTrail..............................................................................................................................655
CloudTrail logs...............................................................................................................657
Sample code..................................................................................................................660
EventBridge (CloudWatch Events).............................................................................................663
Tutorial.........................................................................................................................664
Schedule expressions......................................................................................................667
CloudWatch Logs....................................................................................................................669
CloudFormation......................................................................................................................670
CloudFront (Lambda@Edge).....................................................................................................673
CodeCommit ..........................................................................................................................675
CodePipeline ..........................................................................................................................676
Permissions....................................................................................................................677
CodeWhisperer.......................................................................................................................678
Cognito .................................................................................................................................679
Conﬁg ...................................................................................................................................680
Connect.................................................................................................................................681
DocumentDB ..........................................................................................................................682
Example Amazon DocumentDB event................................................................................682
Prerequisites and permissions..........................................................................................683
Network conﬁguration....................................................................................................684
Creating an Amazon DocumentDB event source mapping (console).......................................684
Creating an Amazon DocumentDB event source mapping (SDK or CLI)...................................685
Monitoring your Amazon DocumentDB event source...........................................................687
Tutorial.........................................................................................................................688
DynamoDB .............................................................................................................................707
Example event...............................................................................................................707
Polling and batching streams...........................................................................................708
Simultaneous readers......................................................................................................709
Execution role permissions...............................................................................................709
Conﬁguring a stream as an event source...........................................................................709
Event source mapping APIs..............................................................................................710
Error handling................................................................................................................712
Amazon CloudWatch metrics............................................................................................713
Time windows................................................................................................................713
Reporting batch item failures...........................................................................................717
Amazon DynamoDB Streams conﬁguration parameters.......................................................719
Tutorial.........................................................................................................................720
Sample code..................................................................................................................725
Sample template ............................................................................................................728
EC2.......................................................................................................................................730
Permissions....................................................................................................................730
ElastiCache ............................................................................................................................732
Prerequisites..................................................................................................................732
Create the execution role................................................................................................732
Create an ElastiCache cluster...........................................................................................733
Create a deployment package..........................................................................................733
xivAWS Lambda Developer Guide
Create the Lambda function............................................................................................734
Test the Lambda function................................................................................................734
Clean up your resources..................................................................................................116
Elastic Load Balancing .............................................................................................................736
EFS .......................................................................................................................................738
Connections...................................................................................................................738
Throughput....................................................................................................................739
IOPS .............................................................................................................................739
IoT........................................................................................................................................740
IoT Events.............................................................................................................................741
Apache Kafka .........................................................................................................................743
Example event...............................................................................................................743
Kafka cluster authentication ............................................................................................744
Managing API access and permissions...............................................................................746
Authentication and authorization errors............................................................................748
Network conﬁguration....................................................................................................749
Adding a Kafka cluster as an event source.........................................................................749
Using a Kafka cluster as an event source...........................................................................752
Auto scaling of the Kafka event source.............................................................................752
Event source API operations.............................................................................................753
Event source errors.........................................................................................................753
Amazon CloudWatch metrics............................................................................................753
Self-managed Apache Kafka conﬁguration parameters........................................................754
Kinesis Firehose......................................................................................................................755
Kinesis Streams......................................................................................................................756
Example event..............................................................................................................756
Polling and batching streams..........................................................................................757
Conﬁguring your data stream and function........................................................................758
Execution role permissions...............................................................................................758
Conﬁguring a stream as an event source...........................................................................759
Filtering Kinesis events....................................................................................................760
Event source mapping API...............................................................................................760
Error handling................................................................................................................762
Amazon CloudWatch metrics............................................................................................763
Time windows................................................................................................................763
Reporting batch item failures...........................................................................................765
Amazon Kinesis conﬁguration parameters..........................................................................767
Tutorial.........................................................................................................................768
Sample code..................................................................................................................773
Sample template ............................................................................................................776
Lex.......................................................................................................................................778
Roles and permissions.....................................................................................................778
MQ.......................................................................................................................................780
Lambda consumer group.................................................................................................781
Execution role permissions...............................................................................................783
Network conﬁguration....................................................................................................784
Conﬁguring a broker as an event source............................................................................784
Event source mapping API...............................................................................................785
Event source mapping errors............................................................................................787
Amazon MQ and RabbitMQ conﬁguration parameters.........................................................787
MSK ......................................................................................................................................789
Example event..............................................................................................................789
MSK cluster authentication ..............................................................................................790
Managing API access and permissions...............................................................................793
Authentication and authorization errors............................................................................795
Network conﬁguration....................................................................................................796
Adding Amazon MSK as an event source...........................................................................797
xvAWS Lambda Developer Guide
Auto scaling of the Amazon MSK event source...................................................................798
Amazon CloudWatch metrics............................................................................................799
Amazon MSK conﬁguration parameters.............................................................................799
RDS......................................................................................................................................801
RDS Tutorial...................................................................................................................801
Conﬁguring the function.................................................................................................814
S3.........................................................................................................................................815
Tutorial: Use an S3 trigger...............................................................................................816
Tutorial: Use an Amazon S3 trigger to create thumbnails.....................................................831
S3 Batch ................................................................................................................................857
Invoking Lambda functions from Amazon S3 batch operations.............................................858
S3 Object Lambda..................................................................................................................859
Secrets Manager.....................................................................................................................860
SES .......................................................................................................................................861
SNS ......................................................................................................................................863
Tutorial.........................................................................................................................864
Sample code..................................................................................................................872
SQS......................................................................................................................................875
Example standard queue message event..........................................................................875
Example FIFO queue message event................................................................................876
Conﬁguring a queue to use with Lambda ..........................................................................877
Execution role permissions...............................................................................................877
Conﬁguring a queue as an event source............................................................................877
Scaling and processing....................................................................................................879
Maximum concurrency....................................................................................................879
Event source mapping APIs..............................................................................................880
Backoﬀ strategy for failed invocations..............................................................................881
Implementing partial batch responses...............................................................................881
Amazon SQS conﬁguration parameters.............................................................................883
Tutorial.........................................................................................................................884
SQS cross-account tutorial...............................................................................................892
Sample code..................................................................................................................896
Sample template ............................................................................................................899
VPC Lattice............................................................................................................................900
VPC Lattice concepts.......................................................................................................900
Prerequisites and permissions..........................................................................................901
Limitations .....................................................................................................................902
Registering your Lambda function with a VPC Lattice network..............................................902
Updating the target of a service in a VPC Lattice network....................................................904
Deregistering a Lambda function target............................................................................905
Cross-account networking................................................................................................905
Receiving events from VPC Lattice....................................................................................906
Sending responses back to VPC Lattice.............................................................................906
Monitoring a service in a VPC Lattice network....................................................................907
Best practices.................................................................................................................................908
Function code........................................................................................................................908
Function conﬁguration............................................................................................................909
Metrics and alarms .................................................................................................................910
Working with streams.............................................................................................................910
Security best practices............................................................................................................911
Access permissions..........................................................................................................................912
Execution role........................................................................................................................913
Creating an execution role in the IAM console....................................................................913
Grant least privilege access to your Lambda execution role..................................................914
Managing roles with the IAM API......................................................................................914
Session duration for temporary security credentials............................................................915
AWS managed policies for Lambda features.......................................................................915
xviAWS Lambda Developer Guide
Working with Lambda execution environment credentials....................................................917
User policies ..........................................................................................................................920
Function development....................................................................................................920
Layer development and use.............................................................................................923
Cross-account roles.........................................................................................................924
Condition keys for VPC settings......................................................................................924
Control access using tags........................................................................................................925
Prerequisites..................................................................................................................925
Step 1: Require tags.......................................................................................................925
Step 2: Control actions using tags....................................................................................926
Step 3: Grant list permissions ..........................................................................................926
Step 4: Grant IAM permissions .........................................................................................927
Step 5: Create the IAM role.............................................................................................927
Step 6: Create the IAM user.............................................................................................927
Step 7: Test the permissions............................................................................................928
Resource-based policies...........................................................................................................929
Supported API actions.....................................................................................................930
Granting function access to AWS services..........................................................................931
Granting function access to an organization.......................................................................931
Granting function access to other accounts........................................................................932
Granting layer access to other accounts.............................................................................933
Cleaning up resource-based policies..................................................................................934
Resources and conditions........................................................................................................935
Policy conditions............................................................................................................936
Function resource names.................................................................................................936
Function actions.............................................................................................................938
Event source mapping actions..........................................................................................940
Layer actions..................................................................................................................940
Permissions boundaries...........................................................................................................942
Security compliance........................................................................................................................944
Data protection......................................................................................................................944
Encryption in transit.......................................................................................................945
Encryption at rest...........................................................................................................945
Identity and access management..............................................................................................946
Audience.......................................................................................................................946
Authenticating with identities ..........................................................................................946
Managing access using policies.........................................................................................948
How AWS Lambda works with IAM...................................................................................950
Identity-based policy examples........................................................................................950
AWS managed policies....................................................................................................952
Troubleshooting.............................................................................................................955
Compliance validation.............................................................................................................957
Resilience..............................................................................................................................958
Infrastructure security.............................................................................................................959
Conﬁguration and vulnerability analysis....................................................................................959
Detect vulnerabilities in your Lambda functions With Amazon Inspector................................959
Monitoring functions.......................................................................................................................961
Monitoring console.................................................................................................................962
Pricing ...........................................................................................................................962
Using the Lambda console...............................................................................................962
Types of monitoring graphs.............................................................................................962
Viewing graphs on the Lambda console............................................................................962
Viewing queries on the CloudWatch Logs console...............................................................963
What's next?..................................................................................................................964
Function metrics.....................................................................................................................965
Viewing metrics on the CloudWatch console......................................................................965
Types of metrics.............................................................................................................965
xviiAWS Lambda Developer Guide
Function logs.........................................................................................................................969
Prerequisites..................................................................................................................969
Pricing ...........................................................................................................................969
Using the Lambda console...............................................................................................969
Using the AWS CLI..........................................................................................................970
Runtime function logging................................................................................................972
What's next?..................................................................................................................972
AWS X-Ray............................................................................................................................973
Execution role permissions...............................................................................................974
The AWS X-Ray daemon..................................................................................................975
Enabling active tracing with the Lambda API.....................................................................975
Enabling active tracing with AWS CloudFormation..............................................................975
Function insights....................................................................................................................977
How it works.................................................................................................................977
Pricing ...........................................................................................................................977
Supported runtimes........................................................................................................977
Enabling Lambda Insights in the console...........................................................................977
Enabling Lambda Insights programmatically......................................................................978
Using the Lambda Insights dashboard...............................................................................978
Detecting function anomalies...........................................................................................980
Troubleshooting a function..............................................................................................981
What's next?..................................................................................................................964
Code proﬁler..........................................................................................................................983
Supported runtimes........................................................................................................983
Activating CodeGuru Proﬁler from the Lambda console.......................................................983
What happens when you activate CodeGuru Proﬁler from the Lambda console?......................983
What's next?..................................................................................................................984
Example workﬂows.................................................................................................................985
Prerequisites..................................................................................................................985
Pricing ...........................................................................................................................986
Viewing a service map....................................................................................................986
Viewing trace details.......................................................................................................986
Using Trusted Advisor to view recommendations................................................................987
What's next?..................................................................................................................987
Lambda layers................................................................................................................................988
How to use layers...................................................................................................................990
Layers and layer versions.........................................................................................................990
Sample applications ................................................................................................................990
Packaging layers.....................................................................................................................991
Layer paths for each Lambda runtime...............................................................................991
Creating and deleting layers....................................................................................................993
Creating a layer..............................................................................................................993
Deleting a layer version...................................................................................................994
Adding layers.........................................................................................................................995
Accessing layer content from your function........................................................................996
Finding layer information................................................................................................996
Layers with AWS CloudFormation.............................................................................................998
Layers with AWS SAM.............................................................................................................999
Lambda extensions.......................................................................................................................1000
Execution environment..........................................................................................................1000
Impact on performance and resources.....................................................................................1001
Permissions..........................................................................................................................1001
Conﬁguring extensions..........................................................................................................1002
Conﬁguring extensions (.zip ﬁle archive)..........................................................................1002
Using extensions in container images..............................................................................1002
Next steps...................................................................................................................1002
Extensions partners...............................................................................................................1004
xviiiAWS Lambda Developer Guide
AWS managed extensions..............................................................................................1004
Extensions API......................................................................................................................1006
Lambda execution environment lifecycle..........................................................................1006
Extensions API reference................................................................................................1012
Telemetry API......................................................................................................................1017
Creating extensions using the Telemetry API....................................................................1018
Registering your extension.............................................................................................1019
Creating a telemetry listener..........................................................................................1019
Specifying a destination protocol....................................................................................1020
Conﬁguring memory usage and buﬀering........................................................................1021
Sending a subscription request to the Telemetry API.........................................................1022
Inbound Telemetry API messages...................................................................................1022
API reference...............................................................................................................1025
Event schema reference...............................................................................................1028
Converting events to OTel Spans....................................................................................1041
Logs API ......................................................................................................................1045
Troubleshooting............................................................................................................................1054
Deployment.........................................................................................................................1054
General: Permission is denied / Cannot load such ﬁle........................................................1054
General: Error occurs when calling the UpdateFunctionCode...............................................1054
Amazon S3: Error Code PermanentRedirect......................................................................1055
General: Cannot ﬁnd, cannot load, unable to import, class not found, no such ﬁle or directory.1055
General: Undeﬁned method handler ...............................................................................1055
Lambda: Layer conversion failed.....................................................................................1056
Lambda: InvalidParameterValueException or RequestEntityTooLargeException......................1056
Lambda: InvalidParameterValueException........................................................................1057
Lambda: Concurrency and memory quotas.......................................................................1057
Invocation............................................................................................................................1057
IAM: lambda:InvokeFunction not authorized.....................................................................1057
Lambda: Operation cannot be performed ResourceConﬂictException...................................1058
Lambda: Function is stuck in Pending..............................................................................1058
Lambda: One function is using all concurrency.................................................................1058
General: Cannot invoke function with other accounts or services.........................................1058
General: Function invocation is looping...........................................................................1058
Lambda: Alias routing with provisioned concurrency..........................................................1059
Lambda: Cold starts with provisioned concurrency............................................................1059
Lambda: Latency variability with provisioned concurrency..................................................1059
Lambda: Variability between initialization and invocation times..........................................1060
Lambda: Cold starts with new versions............................................................................1060
EFS: Function could not mount the EFS ﬁle system...........................................................1060
EFS: Function could not connect to the EFS ﬁle system......................................................1060
EFS: Function could not mount the EFS ﬁle system due to timeout......................................1061
Lambda: Lambda detected an IO process that was taking too long......................................1061
Execution.............................................................................................................................1061
Lambda: Execution takes too long..................................................................................1061
Lambda: Logs or traces don't appear...............................................................................1061
Lambda: The function returns before execution ﬁnishes.....................................................1062
AWS SDK: Versions and updates.....................................................................................1062
Python: Libraries load incorrectly....................................................................................1063
Networking..........................................................................................................................1063
VPC: Function loses internet access or times out...............................................................1063
VPC: Function needs access to AWS services without using the internet................................1063
VPC: Elastic network interface limit reached.....................................................................1064
Container images ..................................................................................................................1064
Container: CodeArtifactUserException errors related to the code artifact..............................1064
Container: ManifestKeyCustomerException errors related to the code manifest key.................1064
Container: Error occurs on runtime InvalidEntrypoint.........................................................1065
xixAWS Lambda Developer Guide
Lambda: System provisioning additional capacity..............................................................1065
CloudFormation: ENTRYPOINT is being overridden with a null or empty value.......................1065
Lambda applications .....................................................................................................................1066
Manage applications .............................................................................................................1067
Monitoring applications .................................................................................................1067
Custom monitoring dashboards......................................................................................1067
Tutorial – Create an application..............................................................................................1070
Prerequisites................................................................................................................1071
Create an application....................................................................................................1071
Invoke the function.......................................................................................................1072
Add an AWS resource....................................................................................................1073
Update the permissions boundary...................................................................................1075
Update the function code..............................................................................................1075
Next steps...................................................................................................................1076
Troubleshooting............................................................................................................1077
Clean up ......................................................................................................................1078
Rolling deployments.............................................................................................................1079
Example AWS SAM Lambda template..............................................................................1079
Mobile SDK for Android.........................................................................................................1081
Tutorial........................................................................................................................1081
Sample code................................................................................................................1087
Orchestrating functions.................................................................................................................1089
Application patterns..............................................................................................................1089
State machine components............................................................................................1089
State machine application patterns.................................................................................1089
Applying patterns to state machines...............................................................................1090
Example branching application pattern............................................................................1090
Manage state machines .........................................................................................................1092
Viewing state machine details ........................................................................................1093
Editing a state machine.................................................................................................1093
Running a state machine ...............................................................................................1093
Orchestration examples.........................................................................................................1094
Conﬁguring a Lambda function as a task.........................................................................1094
Conﬁguring a state machine as an event source................................................................1094
Handling function and service errors...............................................................................1095
AWS CloudFormation and AWS SAM...............................................................................1096
Lambda SnapStart........................................................................................................................1098
Supported features and limitations.........................................................................................1098
Supported Regions...............................................................................................................1098
Compatibility considerations..................................................................................................1099
Pricing .................................................................................................................................1099
SnapStart and provisioned concurrency...................................................................................1100
Additional resources..............................................................................................................1100
Activating SnapStart.............................................................................................................1101
Activating SnapStart (console)........................................................................................1101
Activating SnapStart (AWS CLI)......................................................................................1101
Activating SnapStart (API)..............................................................................................1103
Function states.............................................................................................................1103
Updating a snapshot .....................................................................................................1104
Using SnapStart with the AWS SDK for Java....................................................................1104
Using SnapStart with AWS CloudFormation, AWS SAM, and AWS CDK..................................1104
Deleting snapshots .......................................................................................................1104
Handling uniqueness .............................................................................................................1105
Avoid saving state that depends on uniqueness during initialization....................................1105
Use CSPRNGs ...............................................................................................................1105
Scanning tool ...............................................................................................................1106
Runtime hooks .....................................................................................................................1107
xxAWS Lambda Developer Guide
Step 1: Update the build conﬁguration............................................................................1107
Step 2: Update the Lambda handler ...............................................................................1107
Monitoring ...........................................................................................................................1109
CloudWatch logs...........................................................................................................1109
AWS X-Ray...................................................................................................................1109
Telemetry API..............................................................................................................1110
API Gateway and function URL metrics............................................................................1110
Security model.....................................................................................................................1111
Best practices.......................................................................................................................1112
Network connections.....................................................................................................1112
Performance tuning......................................................................................................1112
Sample applications ......................................................................................................................1114
Blank function......................................................................................................................1116
Architecture and handler code........................................................................................1116
Deployment automation with AWS CloudFormation and the AWS CLI..................................1117
Instrumentation with the AWS X-Ray..............................................................................1119
Dependency management with layers.............................................................................1119
Error processor.....................................................................................................................1121
Architecture and event structure.....................................................................................1121
Instrumentation with AWS X-Ray....................................................................................1122
AWS CloudFormation template and additional resources....................................................1122
List manager ........................................................................................................................1124
Architecture and event structure.....................................................................................1124
Instrumentation with AWS X-Ray....................................................................................1126
AWS CloudFormation templates and additional resources..................................................1126
Working with AWS SDKs................................................................................................................1127
Code examples .............................................................................................................................1128
Actions................................................................................................................................1132
Create a function..........................................................................................................1133
Delete a function..........................................................................................................1142
Get a function..............................................................................................................1148
Invoke a function..........................................................................................................1153
List functions...............................................................................................................1160
Update function code....................................................................................................1165
Update function conﬁguration........................................................................................1172
Scenarios.............................................................................................................................1177
Get started with functions.............................................................................................1178
Serverless snippets...............................................................................................................1251
Invoke a Lambda function from an Amazon S3 trigger......................................................1252
Cross-service examples..........................................................................................................1258
Create a REST API to track COVID-19 data.......................................................................1258
Create a lending library REST API...................................................................................1259
Create a messenger application......................................................................................1259
Create a serverless application to manage photos.............................................................1260
Create a websocket chat application...............................................................................1262
Create an application to analyze customer feedback.........................................................1263
Invoke a Lambda function from a browser.......................................................................1264
Use API Gateway to invoke a Lambda function.................................................................1264
Use Step Functions to invoke Lambda functions...............................................................1266
Use scheduled events to invoke a Lambda function...........................................................1266
Lambda Quotas ............................................................................................................................1269
Compute and storage ............................................................................................................1269
Function conﬁguration, deployment, and execution...................................................................1269
Lambda API requests............................................................................................................1271
Other services......................................................................................................................1272
AWS glossary...............................................................................................................................1273
API reference...............................................................................................................................1274
xxiAWS Lambda Developer Guide
Actions................................................................................................................................1274
AddLayerVersionPermission............................................................................................1276
AddPermission..............................................................................................................1280
CreateAlias...................................................................................................................1285
CreateCodeSigningConﬁg...............................................................................................1289
CreateEventSourceMapping............................................................................................1292
CreateFunction.............................................................................................................1304
CreateFunctionUrlConﬁg................................................................................................1317
DeleteAlias ...................................................................................................................1321
DeleteCodeSigningConﬁg ...............................................................................................1323
DeleteEventSourceMapping............................................................................................1325
DeleteFunction.............................................................................................................1332
DeleteFunctionCodeSigningConﬁg..................................................................................1334
DeleteFunctionConcurrency............................................................................................1336
DeleteFunctionEventInvokeConﬁg...................................................................................1338
DeleteFunctionUrlConﬁg................................................................................................1340
DeleteLayerVersion........................................................................................................1342
DeleteProvisionedConcurrencyConﬁg...............................................................................1344
GetAccountSettings.......................................................................................................1346
GetAlias .......................................................................................................................1348
GetCodeSigningConﬁg ...................................................................................................1351
GetEventSourceMapping................................................................................................1353
GetFunction.................................................................................................................1359
GetFunctionCodeSigningConﬁg.......................................................................................1363
GetFunctionConcurrency................................................................................................1366
GetFunctionConﬁguration..............................................................................................1368
GetFunctionEventInvokeConﬁg.......................................................................................1376
GetFunctionUrlConﬁg....................................................................................................1379
GetLayerVersion............................................................................................................1382
GetLayerVersionByArn...................................................................................................1386
GetLayerVersionPolicy...................................................................................................1389
GetPolicy.....................................................................................................................1391
GetProvisionedConcurrencyConﬁg...................................................................................1393
GetRuntimeManagementConﬁg ......................................................................................1396
Invoke.........................................................................................................................1399
InvokeAsync.................................................................................................................1405
InvokeWithResponseStream...........................................................................................1407
ListAliases ....................................................................................................................1413
ListCodeSigningConﬁgs .................................................................................................1416
ListEventSourceMappings...............................................................................................1418
ListFunctionEventInvokeConﬁgs......................................................................................1422
ListFunctions................................................................................................................1425
ListFunctionsByCodeSigningConﬁg..................................................................................1429
ListFunctionUrlConﬁgs...................................................................................................1431
ListLayers.....................................................................................................................1434
ListLayerVersions..........................................................................................................1437
ListProvisionedConcurrencyConﬁgs..................................................................................1440
ListTags.......................................................................................................................1443
ListVersionsByFunction..................................................................................................1445
PublishLayerVersion......................................................................................................1449
PublishVersion..............................................................................................................1454
PutFunctionCodeSigningConﬁg.......................................................................................1463
PutFunctionConcurrency................................................................................................1466
PutFunctionEventInvokeConﬁg.......................................................................................1469
PutProvisionedConcurrencyConﬁg...................................................................................1473
PutRuntimeManagementConﬁg ......................................................................................1476
RemoveLayerVersionPermission......................................................................................1480
xxiiAWS Lambda Developer Guide
RemovePermission........................................................................................................1482
TagResource.................................................................................................................1484
UntagResource.............................................................................................................1486
UpdateAlias ..................................................................................................................1488
UpdateCodeSigningConﬁg .............................................................................................1492
UpdateEventSourceMapping...........................................................................................1495
UpdateFunctionCode.....................................................................................................1506
UpdateFunctionConﬁguration.........................................................................................1516
UpdateFunctionEventInvokeConﬁg..................................................................................1528
UpdateFunctionUrlConﬁg...............................................................................................1532
Data Types...........................................................................................................................1535
AccountLimit................................................................................................................1538
AccountUsage...............................................................................................................1539
AliasConﬁguration .........................................................................................................1540
AliasRoutingConﬁguration..............................................................................................1542
AllowedPublishers.........................................................................................................1543
AmazonManagedKafkaEventSourceConﬁg........................................................................1544
CodeSigningConﬁg ........................................................................................................1545
CodeSigningPolicies......................................................................................................1547
Concurrency.................................................................................................................1548
Cors ............................................................................................................................1549
DeadLetterConﬁg..........................................................................................................1551
DestinationConﬁg .........................................................................................................1552
DocumentDBEventSourceConﬁg......................................................................................1553
Environment................................................................................................................1554
EnvironmentError..........................................................................................................1555
EnvironmentResponse...................................................................................................1556
EphemeralStorage ........................................................................................................1557
EventSourceMappingConﬁguration..................................................................................1558
FileSystemConﬁg..........................................................................................................1563
Filter ...........................................................................................................................1564
FilterCriteria .................................................................................................................1565
FunctionCode...............................................................................................................1566
FunctionCodeLocation...................................................................................................1568
FunctionConﬁguration...................................................................................................1569
FunctionEventInvokeConﬁg............................................................................................1575
FunctionUrlConﬁg.........................................................................................................1577
ImageConﬁg .................................................................................................................1579
ImageConﬁgError..........................................................................................................1580
ImageConﬁgResponse...................................................................................................1581
InvokeResponseStreamUpdate........................................................................................1582
InvokeWithResponseStreamCompleteEvent......................................................................1583
InvokeWithResponseStreamResponseEvent......................................................................1584
Layer...........................................................................................................................1585
LayersListItem..............................................................................................................1586
LayerVersionContentInput..............................................................................................1587
LayerVersionContentOutput...........................................................................................1588
LayerVersionsListItem....................................................................................................1589
OnFailure.....................................................................................................................1591
OnSuccess....................................................................................................................1592
ProvisionedConcurrencyConﬁgListItem............................................................................1593
RuntimeVersionConﬁg...................................................................................................1595
RuntimeVersionError.....................................................................................................1596
ScalingConﬁg ...............................................................................................................1597
SelfManagedEventSource...............................................................................................1598
SelfManagedKafkaEventSourceConﬁg..............................................................................1599
SnapStart....................................................................................................................1600
xxiiiAWS Lambda Developer Guide
SnapStartResponse.......................................................................................................1601
SourceAccessConﬁguration.............................................................................................1602
TracingConﬁg...............................................................................................................1604
TracingConﬁgResponse..................................................................................................1605
VpcConﬁg....................................................................................................................1606
VpcConﬁgResponse.......................................................................................................1607
Certiﬁcate errors when using an SDK......................................................................................1607
Common Errors....................................................................................................................1608
Common Parameters.............................................................................................................1609
Document history.........................................................................................................................1612
Earlier updates .....................................................................................................................1624
xxivAWS Lambda Developer Guide
When to use Lambda
What is AWS Lambda?
AWS Lambda is a compute service that lets you run code without provisioning or managing servers.
Lambda runs your code on a high-availability compute infrastructure and performs all of the 
administration of the compute resources, including server and operating system maintenance, capacity 
provisioning and automatic scaling, and logging. With Lambda, all you need to do is supply your code in 
one of the language runtimes that Lambda supports.
You organize your code into Lambda functions. The Lambda service runs your function only when 
needed and scales automatically. You only pay for the compute time that you consume—there is no 
charge when your code is not running. For more information, see AWS Lambda Pricing.
Tip
To learn how to build serverless solutions, check out the Serverless Developer Guide.
When to use Lambda
Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale 
down to zero when not in demand. For example, you can use Lambda for:
•File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing 
in real time after an upload.
•Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for 
application activity tracking, transaction order processing, clickstream analysis, data cleansing, log 
ﬁltering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
•Web applications: Combine Lambda with other AWS services to build powerful web applications 
that automatically scale up and down and run in a highly available conﬁguration across multiple data 
centers.
•IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API 
requests.
•Mobile backends: Build backends using Lambda and Amazon API Gateway to authenticate and process 
API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native 
frontends.
When using Lambda, you are responsible only for your code. Lambda manages the compute ﬂeet that 
oﬀers a balance of memory, CPU, network, and other resources to run your code. Because Lambda 
manages these resources, you cannot log in to compute instances or customize the operating system on 
provided runtimes.
Lambda performs operational and administrative activities on your behalf, including managing capacity, 
monitoring, and logging your Lambda functions.
If you do need to manage your compute resources, AWS has other compute services to consider, such as:
•AWS App Runner builds and deploys containerized web applications automatically, load balances 
traﬃc with encryption, scales to meet your traﬃc needs, and allows for the conﬁguration of how 
services are accessed and communicate with other AWS applications in a private Amazon VPC.
•AWS Fargate with Amazon ECS runs containers without having to provision, conﬁgure, or scale clusters 
of virtual machines.
•Amazon EC2 lets you customize operating system, network and security settings, and the entire 
software stack. You are responsible for provisioning capacity, monitoring ﬂeet health and 
performance, and using Availability Zones for fault tolerance.
1AWS Lambda Developer Guide
Key features
Key features
The following key features help you develop Lambda applications that are scalable, secure, and easily 
extensible:
Conﬁguring function options (p. 72)
Conﬁgure your Lambda function using the console or AWS CLI.
Environment variables (p. 77)
Use environment variables to adjust your function's behavior without updating code.
Versions (p. 108)
Manage the deployment of your functions with versions, so that, for example, a new function can be 
used for beta testing without aﬀecting users of the stable production version.
Container images  (p. 122)
Create a container image for a Lambda function by using an AWS provided base image or an 
alternative base image so that you can reuse your existing container tooling or deploy larger 
workloads that rely on sizable dependencies, such as machine learning.
Layers (p. 988)
Package libraries and other dependencies to reduce the size of deployment archives and makes it 
faster to deploy your code.
Lambda extensions (p. 1006 )
Augment your Lambda functions with tools for monitoring, observability, security, and governance.
Function URLs (p. 189)
Add a dedicated HTTP(S) endpoint to your Lambda function.
Response streaming (p. 110)
Conﬁgure your Lambda function URLs to stream response payloads back to clients from Node.js 
functions, to improve time to ﬁrst byte (TTFB) performance or to return larger payloads.
Concurrency and scaling controls (p. 220)
Apply ﬁne-grained control over the scaling and responsiveness of your production applications.
Code signing  (p. 253)
Verify that only approved developers publish unaltered, trusted code in your Lambda functions
Private networking (p. 21)
Create a private network for resources such as databases, cache instances, or internal services.
Database access and proxy (p. 95)
Create an Amazon RDS Proxy database proxy to manage a pool of database connections and relay 
queries from a function. With a proxy, your function can achieve high concurrency (p. 11) levels 
without exhausting database connections.
File system access (p. 99)
Conﬁgure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so 
that your function code can access and modify shared resources safely and at high concurrency.
Lambda SnapStart for Java (p. 1098 )
Improve startup performance for Java runtimes by up to 10x at no extra cost, typically with no 
changes to your function code.
2AWS Lambda Developer Guide
Prerequisites
Getting started with Lambda
To get started with Lambda, use the Lambda console to create a function. In a few minutes, you can 
create and deploy a function, invoke it, and then view logs and metrics.
Tip
To learn how to build serverless solutions, check out the Serverless Developer Guide.
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
3AWS Lambda Developer Guide
Create a function
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Create a Lambda function with the console
In this getting started exercise, create a Lambda function using a blueprint. A blueprint provides sample 
code to do some minimal processing. Most blueprints process events from speciﬁc event sources, such as 
Amazon Simple Storage Service (Amazon S3), Amazon DynamoDB, or a custom application.
To create a Lambda function with the console
1. Open the Functions page of the Lambda console.
2. Choose Create function.
3. Select Use a blueprint .
4. Open the Select blueprint dropdown list and search for Hello world function. Select nodejs  or
python .
5. Enter a Function name.
6. For Execution role, choose Create a new role with basic Lambda permissions. Lambda creates an
execution role (p. 913) that grants the function permission to upload logs to Amazon CloudWatch. 
The Lambda function assumes the execution role when you invoke your function, and uses the 
execution role to create credentials for the AWS SDK and to read data from event sources.
Invoke the function
To invoke the function from the console, create a test event.
1. Choose the Test tab.
2. For Test event action, choose Create new event.
3. For Event name, enter a name for the test event.
4. For Event sharing settings, choose Private .
5. For Template, leave the default hello-world option.
6. In the Event JSON, replace value1  with hello, world!  Don't change key1 or the event structure. 
Example:
{ 
    "key1": " hello, world! ", 
    "key2": "value2", 
    "key3": "value3" 
  }
7. Choose Save, and then choose Test. Lambda invokes the function on your behalf. The function 
handler  (p. 348) receives and then processes the sample event.
8. Review the Execution result. Under Details , you should see the value that you entered in step 6:
"hello, world!" . The execution result also includes the following information:
4AWS Lambda Developer Guide
Clean up
•The Summary section shows the key information from the REPORT line in the invocation log.
•The Log output  section shows the complete invocation log. Lambda writes all invocation logs to 
Amazon CloudWatch.
9. Choose Test to invoke the function a few more times and gather additional metrics that you can 
view in the next step.
10. Choose the Monitor  tab. This page shows graphs of the metrics that Lambda sends to CloudWatch.
Note
It mights take 5 to 10 minutes for logs to show up after a function invocation.
For more information on these graphs, see Monitoring functions on the Lambda console (p. 962).
Clean up
If you are done working with the example function, delete it. You can also delete the log group that 
stores the function's logs, and the execution role that the console created.
To delete a Lambda function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Actions, Delete.
4. In the Delete function dialog box, enter delete , and then choose Delete.
To delete the log group
1. Open the Log groups page of the CloudWatch console.
2. Select the function's log group (/aws/lambda/my-function ).
3. Choose Actions, Delete log group(s).
4. In the Delete log group(s) dialog box, choose Delete.
To delete the execution role
1. Open the Roles page of the AWS Identity and Access Management (IAM) console.
2. Select the function's execution role (for example, my-function-role- 31exxmpl ).
3. Choose Delete.
4. In the Delete role dialog box, enter the role name and then choose Delete.
5AWS Lambda Developer Guide
Additional resources
You can automate the creation and cleanup of functions, log groups, and roles with AWS 
CloudFormation and the AWS Command Line Interface (AWS CLI). For fully functional sample 
applications, see Lambda sample applications  (p. 1114 ).
Additional resources
After creating your ﬁrst Lambda function, try a tutorial:
•Tutorial: Using an Amazon S3 trigger to invoke a Lambda function (p. 816): Use the Lambda console 
to create a trigger that invokes your function every time that you add an object to an Amazon S3 
bucket.
•Tutorial: Using Lambda with API Gateway (p. 640): Create an Amazon API Gateway REST API that 
invokes a Lambda function.
•Tutorial: Using AWS Lambda with scheduled events (p. 664): Conﬁgure a Lambda function to 
run every minute. Conﬁgure Amazon Simple Notiﬁcation Service (Amazon SNS) to email you if the 
function returns an error.
To learn more about serverless application development, see the following:
•Serverless Developer Guide for directed learning paths to build serverless solutions. Also see the 
related Serverless Patterns Workshop for a hands-on experience.
•AWS Compute Blog
•AWS Serverless Land
•The AWS Online Tech Talks YouTube channel includes videos about Lambda-related topics. For an 
overview of serverless applications and Lambda, see the Introduction to AWS Lambda & Serverless 
Applications  video.
Accessing Lambda
You can create, invoke, and manage Lambda functions using any of the following interfaces:
•AWS Management Console – Provides a web interface for you to access your functions. For more 
information, see Lambda console (p. 25).
•AWS Command Line Interface (AWS CLI) – Provides commands for a broad set of AWS services, 
including Lambda, and is supported on Windows, macOS, and Linux. For more information, see Using 
Lambda with the AWS CLI (p. 214).
•AWS SDKs – Provide language-speciﬁc APIs and manage many of the connection details, such as 
signature calculation, request retry handling, and error handling. For more information, see AWS SDKs.
•AWS CloudFormation – Enables you to create templates that deﬁne your Lambda applications. For 
more information, see AWS Lambda applications (p. 1066 ). AWS CloudFormation also supports the
AWS Cloud Development Kit (AWS CDK).
•AWS Serverless Application Model (AWS SAM) – Provides templates and a CLI to conﬁgure and 
manage AWS serverless applications. For more information, see Getting started with AWS SAM.
Authoring and deploying functions
The following table lists the languages that Lambda supports (p. 41) and the tools and options that 
you can use with them. The available tools and options depend on:
6AWS Lambda Developer Guide
Authoring and deploying functions
•The language that you use to write your Lambda function code.
•The libraries that you use in your code. The Lambda runtimes provide some of the libraries, and you 
must upload any additional libraries that you use.
Language Tools and options for authoring code
Node.js  (p. 272) •Lambda console
•Visual Studio, with IDE plugin (see AWS Lambda Support in Visual 
Studio  on the AWS Developer Blog)
•Your own authoring environment
Java (p. 438) •Eclipse, with the AWS Toolkit for Eclipse
•IntelliJ, with the AWS Toolkit for JetBrains
•Your own authoring environment
C# (p. 556) •Visual Studio, with IDE plugin (see AWS Toolkit for Visual Studio)
•.NET Core (see Download .NET on the Microsoft website)
•Your own authoring environment
Python (p. 346) •Lambda console
•PyCharm, with the AWS Toolkit for JetBrains
•Your own authoring environment
Ruby (p. 403) •Lambda console
•Your own authoring environment
Go (p. 512) •Your own authoring environment
PowerShell (p. 600) •Your own authoring environment
•PowerShell Core 6.0 (see Installing various versions of PowerShell
on the Microsoft Docs website)
•.NET Core 3.1 SDK (see Download .NET on the Microsoft website)
•AWSLambdaPSCore module (see AWSLambdaPSCore on the 
PowerShell Gallery website)
You deploy your function code to Lambda using a deployment package. Lambda supports two types of 
deployment packages:
•A .zip ﬁle archive (p. 118) that contains your function code and its dependencies.
•A container image (p. 122) that is compatible with the Open Container Initiative (OCI) speciﬁcation.
7AWS Lambda Developer Guide
AWS Lambda foundations
The Lambda function is the principal resource of the Lambda service.
You can conﬁgure your functions using the Lambda console, Lambda API, AWS CloudFormation or 
AWS SAM. You create code for the function and upload the code using a deployment package. Lambda 
invokes the function when an event occurs. Lambda runs multiple instances of your function in parallel, 
governed by concurrency and scaling limits.
Topics
•Lambda concepts (p. 9)
•Lambda programming model (p. 13)
•Lambda execution environment (p. 14)
•Lambda deployment packages (p. 18)
•Private networking with VPC (p. 21)
•Lambda console (p. 25)
•Lambda instruction set architectures (ARM/x86) (p. 33)
•Additional Lambda features (p. 36)
•Learn how to build serverless solutions (p. 40)
8AWS Lambda Developer Guide
Concepts
Lambda concepts
Lambda runs instances of your function to process events. You can invoke your function directly using 
the Lambda API, or you can conﬁgure an AWS service or resource to invoke your function.
Concepts
•Function (p. 9)
•Trigger (p. 9)
•Event (p. 9)
•Execution environment (p. 10)
•Instruction set architecture (p. 10)
•Deployment package (p. 10)
•Runtime  (p. 10)
•Layer (p. 11)
•Extension (p. 11)
•Concurrency (p. 11)
•Qualiﬁer  (p. 11)
•Destination  (p. 12)
Function
A function  is a resource that you can invoke to run your code in Lambda. A function has code to process 
the events (p. 9) that you pass into the function or that other AWS services send to the function.
Trigger
A trigger  is a resource or conﬁguration that invokes a Lambda function. Triggers include AWS services 
that you can conﬁgure to invoke a function and event source mappings (p. 150). An event source 
mapping is a resource in Lambda that reads items from a stream or queue and invokes a function. 
For more information, see Invoking Lambda functions (p. 135) and Using AWS Lambda with other 
services (p. 628).
Event
An event  is a JSON-formatted document that contains data for a Lambda function to process. The 
runtime converts the event to an object and passes it to your function code. When you invoke a function, 
you determine the structure and contents of the event.
Example custom event – weather data
{ 
  "TemperatureK": 281, 
  "WindKmh": -3, 
  "HumidityPct": 0.55, 
  "PressureHPa": 1020
}
When an AWS service invokes your function, the service deﬁnes the shape of the event.
9AWS Lambda Developer Guide
Execution environment
Example service event – Amazon SNS notiﬁcation
{ 
  "Records": [ 
    { 
      "Sns": { 
        "Timestamp": "2019-01-02T12:45:07.000Z", 
        "Signature": "tcc6faL2yUC6dgZdmrwh1Y4cGa/ebXEkAi6RibDsvpi+tE/1+82j...65r==", 
        "MessageId": "95df01b4-ee98-5cb9-9903-4c221d41eb5e", 
        "Message": "Hello from SNS!", 
        ...
For more information about events from AWS services, see Using AWS Lambda with other 
services (p. 628).
Execution environment
An execution environment provides a secure and isolated runtime environment for your Lambda function. 
An execution environment manages the processes and resources that are required to run the function. 
The execution environment provides lifecycle support for the function and for any extensions (p. 11)
associated with your function.
For more information, see Lambda execution environment (p. 14).
Instruction set architecture
The instruction set architecture  determines the type of computer processor that Lambda uses to run the 
function. Lambda provides a choice of instruction set architectures:
•arm64 – 64-bit ARM architecture, for the AWS Graviton2 processor.
•x86_64 – 64-bit x86 architecture, for x86-based processors.
For more information, see Lambda instruction set architectures (ARM/x86) (p. 33).
Deployment package
You deploy your Lambda function code using a deployment package . Lambda supports two types of 
deployment packages:
•A .zip ﬁle archive that contains your function code and its dependencies. Lambda provides the 
operating system and runtime for your function.
•A container image that is compatible with the Open Container Initiative (OCI) speciﬁcation. You add 
your function code and dependencies to the image. You must also include the operating system and a 
Lambda runtime.
For more information, see Lambda deployment packages (p. 18).
Runtime
The runtime  provides a language-speciﬁc environment that runs in an execution environment. The 
runtime relays invocation events, context information, and responses between Lambda and the function. 
You can use runtimes that Lambda provides, or build your own. If you package your code as a .zip ﬁle 
archive, you must conﬁgure your function to use a runtime that matches your programming language. 
For a container image, you include the runtime when you build the image.
10AWS Lambda Developer Guide
Layer
For more information, see Lambda runtimes  (p. 41).
Layer
A Lambda layer  is a .zip ﬁle archive that can contain additional code or other content. A layer can contain 
libraries, a custom runtime  (p. 60), data, or conﬁguration ﬁles.
Layers provide a convenient way to package libraries and other dependencies that you can use with your 
Lambda functions. Using layers reduces the size of uploaded deployment archives and makes it faster to 
deploy your code. Layers also promote code sharing and separation of responsibilities so that you can 
iterate faster on writing business logic.
You can include up to ﬁve layers per function. Layers count towards the standard Lambda deployment 
size quotas (p. 1269 ). When you include a layer in a function, the contents are extracted to the /opt
directory in the execution environment.
By default, the layers that you create are private to your AWS account. You can choose to share a layer 
with other accounts or to make the layer public. If your functions consume a layer that a diﬀerent 
account published, your functions can continue to use the layer version after it has been deleted, or after 
your permission to access the layer is revoked. However, you cannot create a new function or update 
functions using a deleted layer version.
Functions deployed as a container image do not use layers. Instead, you package your preferred runtime, 
libraries, and other dependencies into the container image when you build the image.
For more information, see Lambda layers  (p. 988).
Extension
Lambda extensions enable you to augment your functions. For example, you can use extensions to 
integrate your functions with your preferred monitoring, observability, security, and governance tools. 
You can choose from a broad set of tools that AWS Lambda Partners provides, or you can create your 
own Lambda extensions (p. 1006 ).
An internal extension runs in the runtime process and shares the same lifecycle as the runtime. An 
external extension runs as a separate process in the execution environment. The external extension is 
initialized before the function is invoked, runs in parallel with the function's runtime, and continues to 
run after the function invocation is complete.
For more information, see Lambda extensions (p. 1000 ).
Concurrency
Concurrency is the number of requests that your function is serving at any given time. When your 
function is invoked, Lambda provisions an instance of it to process the event. When the function code 
ﬁnishes running, it can handle another request. If the function is invoked again while a request is still 
being processed, another instance is provisioned, increasing the function's concurrency.
Concurrency is subject to quotas  (p. 1269 ) at the AWS Region level. You can conﬁgure individual 
functions to limit their concurrency, or to enable them to reach a speciﬁc level of concurrency. For more 
information, see Conﬁguring reserved concurrency (p. 234).
Qualiﬁer
When you invoke or view a function, you can include a qualiﬁer  to specify a version or alias. A version
is an immutable snapshot of a function's code and conﬁguration that has a numerical qualiﬁer. For 
11AWS Lambda Developer Guide
Destination
example, my-function:1 . An alias  is a pointer to a version that you can update to map to a diﬀerent 
version, or split traﬃc between two versions. For example, my-function:BLUE . You can use versions 
and aliases together to provide a stable interface for clients to invoke your function.
For more information, see Lambda function versions (p. 108).
Destination
A destination  is an AWS resource where Lambda can send events from an asynchronous invocation. You 
can conﬁgure a destination for events that fail processing. Some services also support a destination for 
events that are successfully processed.
For more information, see Conﬁguring destinations for asynchronous invocation (p. 144).
12AWS Lambda Developer Guide
Programming model
Lambda programming model
Lambda provides a programming model that is common to all of the runtimes. The programming model 
deﬁnes the interface between your code and the Lambda system. You tell Lambda the entry point to 
your function by deﬁning a handler  in the function conﬁguration. The runtime passes in objects to the 
handler that contain the invocation event  and the context, such as the function name and request ID.
When the handler ﬁnishes processing the ﬁrst event, the runtime sends it another. The function's class 
stays in memory, so clients and variables that are declared outside of the handler method in initialization 
code  can be reused. To save processing time on subsequent events, create reusable resources like AWS 
SDK clients during initialization. Once initialized, each instance of your function can process thousands of 
requests.
Your function also has access to local storage in the /tmp directory. The directory content remains 
when the execution environment is frozen, providing a transient cache that can be used for multiple 
invocations. For more information, see Lambda execution environment.
When AWS X-Ray tracing (p. 973) is enabled, the runtime records separate subsegments for 
initialization and execution.
The runtime captures logging output from your function and sends it to Amazon CloudWatch Logs. In 
addition to logging your function's output, the runtime also logs entries when function invocation starts 
and ends. This includes a report log with the request ID, billed duration, initialization duration, and other 
details. If your function throws an error, the runtime returns that error to the invoker.
Note
Logging is subject to CloudWatch Logs quotas. Log data can be lost due to throttling or, in some 
cases, when an instance of your function is stopped.
Lambda scales your function by running additional instances of it as demand increases, and by stopping 
instances as demand decreases. This model leads to variations in application architecture, such as:
•Unless noted otherwise, incoming requests might be processed out of order or concurrently.
•Do not rely on instances of your function being long lived, instead store your application's state 
elsewhere.
•Use local storage and class-level objects to increase performance, but keep to a minimum the size of 
your deployment package and the amount of data that you transfer onto the execution environment.
For a hands-on introduction to the programming model in your preferred programming language, see 
the following chapters.
•Building Lambda functions with Node.js (p. 272)
•Building Lambda functions with Python (p. 346)
•Building Lambda functions with Ruby (p. 403)
•Building Lambda functions with Java (p. 438)
•Building Lambda functions with Go (p. 512)
•Building Lambda functions with C# (p. 556)
•Building Lambda functions with PowerShell (p. 600)
13AWS Lambda Developer Guide
Execution environment
Lambda execution environment
Lambda invokes your function in an execution environment, which provides a secure and isolated 
runtime environment. The execution environment manages the resources required to run your function. 
The execution environment also provides lifecycle support for the function's runtime and any external 
extensions (p. 1000 ) associated with your function.
The function's runtime communicates with Lambda using the Runtime API  (p. 55). Extensions 
communicate with Lambda using the Extensions API (p. 1006 ). Extensions can also receive log messages 
and other telemetry from the function by using the Telemetry API (p. 1017 ).
When you create your Lambda function, you specify conﬁguration information, such as the amount 
of memory available and the maximum execution time allowed for your function. Lambda uses this 
information to set up the execution environment.
The function's runtime and each external extension are processes that run within the execution 
environment. Permissions, resources, credentials, and environment variables are shared between the 
function and the extensions.
Topics
•Lambda execution environment lifecycle (p. 14)
Lambda execution environment lifecycle
Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The 
runtime and each extension indicate completion by sending a Next API request. Lambda freezes the 
execution environment when the runtime and each extension have completed and there are no pending 
events.
Topics
•Init phase  (p. 15)
•Restore phase (Lambda SnapStart only) (p. 15)
•Invoke phase (p. 15)
•Failures during the invoke phase (p. 16)
14AWS Lambda Developer Guide
Runtime environment lifecycle
•Shutdown phase (p. 16)
Init phase
In the Init phase, Lambda performs three tasks:
•Start all extensions (Extension init )
•Bootstrap the runtime ( Runtime init )
•Run the function's static code (Function init )
•Run any beforeCheckpoint  runtime hooks  (p. 1107 ) (Lambda SnapStart only)
The Init phase ends when the runtime and all extensions signal that they are ready by sending a
Next API request. The Init phase is limited to 10 seconds. If all three tasks do not complete within 10 
seconds, Lambda retries the Init phase at the time of the ﬁrst function invocation with the conﬁgured 
function timeout.
When Lambda SnapStart (p. 1098 ) is activated, the Init phase happens when you publish a function 
version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, 
persists the encrypted snapshot, and caches it for low-latency access. If you have a beforeCheckpoint
runtime hook  (p. 1107 ), then the code runs at the end of Init  phase.
Note
The 10-second timeout doesn't apply to SnapStart functions. When Lambda creates a snapshot, 
your initialization code can run for up to 15 minutes. The time limit is 130 seconds or the
conﬁgured function timeout (p. 74) (maximum 900 seconds), whichever is higher.
When you use provisioned concurrency, Lambda begins the init phase shortly after you publish a 
function version. There can be a large gap between your function's initialization and invocation phases. 
For functions using unreserved (on-demand) concurrency, Lambda may proactively initialize a function 
instance, even if there's no invocation. When this happens, you can observe an unexpected time gap 
between your function's initialization and invocation phases. This gap can appear similar to what you 
would observe when using provisioned concurrency.
Restore phase (Lambda SnapStart only)
When you ﬁrst invoke a SnapStart (p. 1098 ) function and as the function scales up, Lambda resumes 
new execution environments from the persisted snapshot instead of initializing the function from 
scratch. If you have an afterRestore()  runtime hook  (p. 1107 ), the code runs at the end of the
Restore phase. You are charged for the duration of afterRestore()  runtime hooks. The runtime 
(JVM) must load and afterRestore()  runtime hooks must complete within the timeout limit (10 
seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, 
Lambda invokes the function handler (the Invoke  phase).
Invoke phase
When a Lambda function is invoked in response to a Next API request, Lambda sends an Invoke event 
to the runtime and to each extension.
The function's timeout setting limits the duration of the entire Invoke phase. For example, if you set the 
function timeout as 360 seconds, the function and all extensions need to complete within 360 seconds. 
Note that there is no independent post-invoke phase. The duration is the sum of all invocation time 
(runtime + extensions) and is not calculated until the function and all extensions have ﬁnished executing.
The invoke phase ends after the runtime and all extensions signal that they are done by sending a Next
API request.
15AWS Lambda Developer Guide
Runtime environment lifecycle
Failures during the invoke phase
If the Lambda function crashes or times out during the Invoke phase, Lambda resets the execution 
environment. The following diagram illustrates Lambda execution environment behavior when there's an 
invoke failure:
In the previous diagram:
•The ﬁrst phase is the INIT  phase, which runs without errors.
•The second phase is the INVOKE phase, which runs without errors.
•At some point, suppose your function runs into an invoke failure (such as a function timeout or 
runtime error). The third phase, labeled INVOKE WITH ERROR , illustrates this scenario. When this 
happens, the Lambda service performs a reset. The reset behaves like a Shutdown  event. First, 
Lambda shuts down the runtime, then sends a Shutdown  event to each registered external extension. 
The event includes the reason for the shutdown. If this environment is used for a new invocation, 
Lambda re-initializes the extension and runtime together with the next invocation.
Note
The Lambda reset does not clear the /tmp directory content prior to the next init phase. This 
behavior is consistent with the regular shutdown phase.
•The fourth phase represents the INVOKE phase immediately following an invoke failure. Here, Lambda 
initializes the environment again by re-running the INIT  phase. This is called a suppressed init . When 
suppressed inits occur, Lambda doesn't explicitly report an additional INIT  phase in CloudWatch Logs. 
Instead, you may notice that the duration in the REPORT line includes an additional INIT  duration + 
the INVOKE duration. For example, suppose you see the following logs in CloudWatch:
2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST  
2022-12-20T01:00:02.500-08:00 END RequestId: XXX  
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms  
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
In this example, the diﬀerence between the REPORT and START timestamps is 2.5 seconds. This 
doesn't match the reported duration of 3022.91 millseconds, because it doesn't take into account the 
extra INIT  (suppressed init) that Lambda performed. In this example, you can infer that the actual
INVOKE phase took 2.5 seconds.
For more insight into this behavior, you can use the Lambda Telemetry API (p. 1017 ). The Telemetry 
API emits INIT_START , INIT_RUNTIME_DONE , and INIT_REPORT  events with phase=invoke
whenever suppressed inits occur in between invoke phases.
•The ﬁfth phase represents the SHUTDOWN phase, which runs without errors.
Shutdown phase
When Lambda is about to shut down the runtime, it sends a Shutdown  event to each registered external 
extension. Extensions can use this time for ﬁnal cleanup tasks. The Shutdown  event is a response to a
Next API request.
Duration : The entire Shutdown  phase is capped at 2 seconds. If the runtime or any extension does not 
respond, Lambda terminates it via a signal (SIGKILL ).
16AWS Lambda Developer Guide
Runtime environment lifecycle
After the function and all extensions have completed, Lambda maintains the execution environment 
for some time in anticipation of another function invocation. In eﬀect, Lambda freezes the execution 
environment. When the function is invoked again, Lambda thaws the environment for reuse. Reusing the 
execution environment has the following implications:
•Objects declared outside of the function's handler method remain initialized, providing additional 
optimization when the function is invoked again. For example, if your Lambda function establishes 
a database connection, instead of reestablishing the connection, the original connection is used in 
subsequent invocations. We recommend adding logic in your code to check if a connection exists 
before creating a new one.
•Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk 
space in the /tmp directory. The directory content remains when the execution environment is frozen, 
providing a transient cache that can be used for multiple invocations. You can add extra code to check 
if the cache has the data that you stored. For more information on deployment size limits, see Lambda 
quotas  (p. 1269 ).
•Background processes or callbacks that were initiated by your Lambda function and did not complete 
when the function ended resume if Lambda reuses the execution environment. Make sure that any 
background processes or callbacks in your code are complete before the code exits.
When you write your function code, do not assume that Lambda automatically reuses the execution 
environment for subsequent function invocations. Other factors may dictate a need for Lambda to 
create a new execution environment, which can lead to unexpected results, such as database connection 
failures.
17AWS Lambda Developer Guide
Deployment packages
Lambda deployment packages
Your AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package  to deploy your function code to Lambda. Lambda supports two types of 
deployment packages: container images and .zip ﬁle archives.
Topics
•Container images  (p. 18)
•.zip ﬁle archives (p. 18)
•Layers (p. 19)
•Using other AWS services to build a deployment package (p. 19)
Container images
A container image includes the base operating system, the runtime, Lambda extensions, your application 
code and its dependencies. You can also add static data, such as machine learning models, into the 
image.
Lambda provides a set of open-source base images that you can use to build your container image. 
To create and test container images, you can use the AWS Serverless Application Model (AWS SAM) 
command line interface (CLI) or native container tools such as the Docker CLI.
You upload your container images to Amazon Elastic Container Registry (Amazon ECR), a managed AWS 
container image registry service. To deploy the image to your function, you specify the Amazon ECR 
image URL using the Lambda console, the Lambda API, command line tools, or the AWS SDKs.
For more information about Lambda container images, see Working with Lambda container 
images  (p. 122).
.zip ﬁle archives
A .zip ﬁle archive includes your application code and its dependencies. When you author functions using 
the Lambda console or a toolkit, Lambda automatically creates a .zip ﬁle archive of your code.
When you create functions with the Lambda API, command line tools, or the AWS SDKs, you must create 
a deployment package. You also must create a deployment package if your function uses a compiled 
language, or to add dependencies to your function. To deploy your function's code, you upload the 
deployment package from Amazon Simple Storage Service (Amazon S3) or your local machine.
You can upload a .zip ﬁle as your deployment package using the Lambda console, AWS Command Line 
Interface (AWS CLI), or to an Amazon Simple Storage Service (Amazon S3) bucket.
Using the Lambda console
The following steps demonstrate how to upload a .zip ﬁle as your deployment package using the 
Lambda console.
To upload a .zip ﬁle on the Lambda console
1. Open the Functions page on the Lambda console.
2. Select a function.
3. In the Code Source pane, choose Upload from and then .zip ﬁle.
4. Choose Upload to select your local .zip ﬁle.
18AWS Lambda Developer Guide
Layers
5. Choose Save.
Using the AWS CLI
You can upload a .zip ﬁle as your deployment package using the AWS Command Line Interface (AWS 
CLI). For language-speciﬁc instructions, see the following topics.
Node.js
Deploy Node.js Lambda functions with .zip ﬁle archives (p. 281)
Python
Working with .zip ﬁle archives for Python Lambda functions (p. 352)
Ruby
Working with .zip ﬁle archives for Ruby Lambda functions (p. 406)
Java
Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446)
Go
Deploy Go Lambda functions with .zip ﬁle archives (p. 520)
C#
Deploy C# Lambda functions with .zip ﬁle archives (p. 566)
PowerShell
Deploy PowerShell Lambda functions with .zip ﬁle archives (p. 602)
Using Amazon S3
You can upload a .zip ﬁle as your deployment package using Amazon Simple Storage Service (Amazon 
S3). For more information, see the section called “Using other AWS services”.
Layers
If you deploy your function code using a .zip ﬁle archive, you can use Lambda layers as a distribution 
mechanism for libraries, custom runtimes, and other function dependencies. Layers enable you to 
manage your in-development function code independently from the unchanging code and resources that 
it uses. You can conﬁgure your function to use layers that you create, layers that AWS provides, or layers 
from other AWS customers.
You do not use layers with container images. Instead, you package your preferred runtime, libraries, and 
other dependencies into the container image when you build the image.
For more information about layers, see Lambda layers  (p. 988).
Using other AWS services to build a deployment 
package
The following section describes other AWS services you can use to package dependencies for your 
Lambda function.
19AWS Lambda Developer Guide
Using other AWS services
Deployment packages with C or C++ libraries
If your deployment package contains native libraries, you can build the deployment package with AWS 
Serverless Application Model (AWS SAM). You can use the AWS SAM CLI sam build  command with the
--use-container  to create your deployment package. This option builds a deployment package inside 
a Docker image that is compatible with the Lambda execution environment.
For more information, see sam build  in the AWS Serverless Application Model Developer Guide.
Deployment packages over 50 MB
If your deployment package is larger than 50 MB, upload your function code and dependencies to an 
Amazon S3 bucket.
You can create a deployment package and upload the .zip ﬁle to your Amazon S3 bucket in the AWS 
Region where you want to create a Lambda function. When you create your Lambda function, specify the 
S3 bucket name and object key name on the Lambda console, or using the AWS CLI.
To create a bucket using the Amazon S3 console, see How do I create an S3 Bucket? in the Amazon 
Simple Storage Service Console User Guide.
20AWS Lambda Developer Guide
Private networking
Private networking with VPC
Amazon Virtual Private Cloud (Amazon VPC) is a virtual network in the AWS cloud, dedicated to your 
AWS account. You can use Amazon VPC to create a private network for resources such as databases, 
cache instances, or internal services. For more information about Amazon VPC, see What is Amazon VPC?
A Lambda function always runs inside a VPC owned by the Lambda service. Lambda applies network 
access and security rules to this VPC and Lambda maintains and monitors the VPC automatically. If your 
Lambda function needs to access the resources in your account VPC,  conﬁgure the function to access 
the VPC  (p. 85). Lambda provides managed resources named Hyperplane ENIs, which your Lambda 
function uses to connect from the Lambda VPC to an ENI (Elastic network interface) in your account VPC.
There's no additional charge for using a VPC or a Hyperplane ENI. There are charges for some VPC 
components, such as NAT gateways. For more information, see Amazon VPC Pricing.
Topics
•VPC network elements (p. 21)
•Connecting Lambda functions to your VPC (p. 22)
•Shared subnets (p. 22)
•Lambda Hyperplane ENIs  (p. 22)
•Connections (p. 24)
•Security (p. 24)
•Observability (p. 24)
VPC network elements
Amazon VPC networks includes the following network elements:
•Elastic network interface – elastic network interface is a logical networking component in a VPC that 
represents a virtual network card.
•Subnet – A range of IP addresses in your VPC. You can add AWS resources to a speciﬁed subnet. Use a 
public subnet for resources that must connect to the internet, and a private subnet for resources that 
don't connect to the internet.
•Security group – use security groups to control access to the AWS resources in each subnet.
•Access control list (ACL) – use a network ACL to provide additional security in a subnet. The default 
subnet ACL allows all inbound and outbound traﬃc.
•Route table – contains a set of routes that AWS uses to direct the network traﬃc for your VPC. You can 
explicitly associate a subnet with a particular route table. By default, the subnet is associated with the 
main route table.
•Route – each route in a route table speciﬁes a range of IP addresses and the destination where Lambda 
sends the traﬃc for that range. The route also speciﬁes a target, which is the gateway, network 
interface, or connection through which to send the traﬃc.
•NAT gateway – An AWS Network Address Translation (NAT) service that controls access from a private 
VPC private subnet to the Internet.
•VPC endpoints – You can use an Amazon VPC endpoint to create private connectivity to services 
hosted in AWS, without requiring access over the internet or through a NAT device, VPN connection, or 
AWS Direct Connect connection. For more information, see AWS PrivateLink and VPC endpoints.
Tip
To conﬁgure your Lambda function to access a VPC and subnet, you can use the Lambda 
Console or the API.
21AWS Lambda Developer Guide
Connecting Lambda functions to your VPC
Refer to the VpcConfig  section in CreateFunction (p. 1304 ) to conﬁgure your function. See
Conﬁguring VPC access (console) (p. 86) and Conﬁguring VPC access (API) (p. 87) for 
detailed steps.
For more information about Amazon VPC networking deﬁnitions, see  How Amazon VPC works in the 
Amazon VPC Developer Guide and the Amazon VPC FAQs.
Connecting Lambda functions to your VPC
A Lambda function always runs inside a VPC owned by the Lambda service. By default, a Lambda 
function isn't connected to VPCs in your account. When you connect a function to a VPC in your account, 
the function can't access the internet unless your VPC provides access.
Lambda accesses resources in your VPC using a Hyperplane ENI. Hyperplane ENIs provide NAT 
capabilities from the Lambda VPC to your account VPC using VPC-to-VPC NAT (V2N). V2N provides 
connectivity from the Lambda VPC to your account VPC, but not in the other direction.
When you create a Lambda function (or update its VPC settings), Lambda allocates a Hyperplane ENI 
for each subnet in your function's VPC conﬁguration. Multiple Lambda functions can share a network 
interface, if the functions share the same subnet and security group.
To connect to another AWS service, you can use VPC endpoints  for private communications between 
your VPC and supported AWS services. An alternative approach is to use a NAT gateway to route 
outbound traﬃc to another AWS service.
To give your function access to the internet, route outbound traﬃc to a NAT gateway in a public subnet. 
The NAT gateway has a public IP address and can connect to the internet through the VPC's internet 
gateway.
For information about how to conﬁgure Lambda VPC networking, see ??? (p. 85) and ??? (p. 92).
Shared subnets
VPC sharing allows multiple AWS accounts to create their application resources, such as Amazon 
EC2 instances and Lambda functions, in shared, centrally-managed virtual private clouds (VPCs). In 
this model, the account that owns the VPC (owner) shares one or more subnets with other accounts 
(participants) that belong to the same AWS Organization.
To access private resources, connect your function to a private shared subnet in your VPC. The subnet 
owner must share a subnet with you before you can connect a function to it. The subnet owner can also 
unshare the subnet a later time, thereby removing connectivity. For details on how to share, unshare, and 
manage VPC resources in shared subnets, see How to share your VPC with other accounts in the Amazon 
VPC guide.
Lambda Hyperplane ENIs
The Hyperplane ENI is a managed network resource that the Lambda service creates and manages. 
Multiple execution environments in the Lambda VPC can use a Hyperplane ENI to securely access 
resources inside of VPCs in your account. Hyperplane ENIs provide NAT capabilities from the Lambda VPC 
to your account VPC. For more information about Hyperplane ENIs, see Improved VPC networking for 
AWS Lambda functions  in the AWS compute blog.
Each unique security group and subnet combination in your account requires a diﬀerent network 
interface. Functions in the account that share the same security group and subnet combination use the 
same network interfaces.
Because the functions in your account share the ENI resources, the ENI lifecycle is more complex than 
other Lambda resources. The following sections describe the ENI lifecycle.
22AWS Lambda Developer Guide
Lambda Hyperplane ENIs
ENI lifecycle
•Creating ENIs (p. 23)
•Managing ENIs  (p. 23)
•Deleting ENIs  (p. 23)
Creating ENIs
Lambda may create Hyperplane ENI resources for a newly created VPC-enabled function or for a VPC 
conﬁguration change to an existing function. The function remains in pending state while Lambda 
creates the required resources. When the Hyperplane ENI is ready, the function transitions to active state 
and the ENI becomes available for use. Lambda can require several minutes to create a Hyperplane ENI.
For a newly created VPC-enabled function, any invocations or other API actions that operate on the 
function fail until the function state transitions to active.
For a VPC conﬁguration change to an existing function, any function invocations continue to use the 
Hyperplane ENI associated with the old subnet and security group conﬁguration until the function state 
transitions to active.
If a Lambda function remains idle for consecutive weeks, Lambda reclaims the unused Hyperplane ENIs 
and sets the function state to idle. The next invocation causes Lambda to reactivate the idle function. 
The invocation fails, and the function enters pending state until Lambda completes the creation or 
allocation of a Hyperplane ENI.
For more information about function states, see Lambda function states (p. 179).
Managing ENIs
Lambda uses permissions in your function's execution role to create and manage network interfaces. 
Lambda creates a Hyperplane ENI when you deﬁne a unique subnet plus security group combination 
for a VPC-enabled function in an account. Lambda reuses the Hyperplane ENI for other VPC-enabled 
functions in your account that use the same subnet and security group combination.
There is no quota on the number of Lambda functions that can use the same Hyperplane ENI. However, 
each Hyperplane ENI supports up to 65,000 connections/ports. If the number of connections exceeds 
65,000, Lambda creates a new Hyperplane ENI to provide additional connections.
When you update your function conﬁguration to access a diﬀerent VPC, Lambda terminates connectivity 
to the Hyperplane ENI in the previous VPC. The process to update the connectivity to a new VPC can take 
several minutes. During this time, invocations to the function continue to use the previous VPC. After the 
update is complete, new invocations start using the Hyperplane ENI in the new VPC. At this point, the 
Lambda function is no longer connected to the previous VPC.
Deleting ENIs
When you update a function to remove its VPC conﬁguration, Lambda requires up to 20 minutes to 
delete the attached Hyperplane ENI. Lambda only deletes the ENI if no other function (or published 
function version) is using that Hyperplane ENI.
Lambda relies on permissions in the function  execution role (p. 913) to delete the Hyperplane ENI. 
If you delete the execution role before Lambda deletes the Hyperplane ENI, Lambda won't be able to 
delete the Hyperplane ENI. You can manually perform the deletion.
Lambda doesn't delete network interfaces that are in use by functions or function versions in your 
account. You can use the Lambda ENI Finder  to identify the functions or function versions that are using 
a Hyperplane ENI. For any functions or function versions that you no longer need, you can remove the 
VPC conﬁguration so that Lambda deletes the Hyperplane ENI.
23AWS Lambda Developer Guide
Connections
Connections
Lambda supports two types of connections: TCP (Transmission Control Protocol) and UDP (User 
Datagram Protocol).
When you create a VPC, Lambda automatically creates a set of DHCP options and associates them with 
the VPC. You can conﬁgure your own DHCP options set for your VPC. For more details, refer to Amazon 
VPC DHCP options .
Amazon provides a DNS server (the Amazon Route 53 resolver) for your VPC. For more information, see
DNS support for your VPC.
Security
AWS provides security groups  and network ACLs to increase security in your VPC. Security groups control 
inbound and outbound traﬃc for your instances, and network ACLs control inbound and outbound traﬃc 
for your subnets. Security groups provide enough access control for most subnets. You can use network 
ACLs if you want an additional layer of security for your VPC. For more information, see Internetwork 
traﬃc privacy in Amazon VPC. Every subnet that you create is automatically associated with the VPC's 
default network ACL. You can change the association, and you can change the contents of the default 
network ACL.
For general security best practices, see VPC security best practices. For details on how you can use IAM to 
manage access to the Lambda API and resources, see AWS Lambda permissions (p. 912).
You can use Lambda-speciﬁc condition keys for VPC settings to provide additional permission controls 
for your Lambda functions. For more information about VPC condition keys, see Using IAM condition 
keys for VPC settings (p. 88).
Note
Lambda functions can be invoked from the public internet or AWS PrivateLink endpoints. 
You can access your Function URLs (p. 189) through the public Internet only. While Lambda 
functions do support AWS PrivateLink, Function URLs do not.
Observability
You can use VPC Flow Logs to capture information about the IP traﬃc going to and from network 
interfaces in your VPC. You can publish Flow log data to Amazon CloudWatch Logs or Amazon S3. After 
you've created a ﬂow log, you can retrieve and view its data in the chosen destination.
Note: when you attach a function to a VPC, the CloudWatch log messages do not use the VPC routes. 
Lambda sends them using the regular routing for logs.
24AWS Lambda Developer Guide
Lambda console
Lambda console
You can use the Lambda console to conﬁgure applications, functions, code signing conﬁgurations, and 
layers. This page provides an explanation for how to edit code using the console editor.
Topics
•Applications  (p. 25)
•Functions (p. 25)
•Code signing  (p. 25)
•Layers (p. 25)
•Edit code using the console editor (p. 25)
Applications
The Applications  (p. 1066 ) page displays a list of applications that were deployed using AWS 
CloudFormation or other tools, including the AWS Serverless Application Model (AWS SAM). Filter to ﬁnd 
applications based on keywords.
Functions
The functions page shows you a list of functions deﬁned for your account in this region. The initial 
console ﬂow to create a function depends on whether the function uses a container image (p. 122)
or .zip ﬁle archive (p. 118) for the deployment package. Many of the optional conﬁguration 
tasks  (p. 72) are common to both types of function.
The console provides a code editor (p. 25) for your convenience.
Code signing
You can attach a code signing (p. 253) conﬁguration to a function. With code signing, you can ensure 
that the code has been signed by an approved source and has not been altered since signing, and that 
the code signature has not expired or been revoked.
Layers
Create layers (p. 988) to separate your .zip archive function code from its dependencies. A layer is a .zip 
ﬁle archive that contains libraries, a custom runtime, or other dependencies. With layers, you can use 
libraries in your function without needing to include them in your deployment package.
Edit code using the console editor
You can use the code editor in the Lambda console to write, test, and view the execution results of 
your Lambda function code. The code editor supports languages that do not require compiling, such as 
Node.js and Python. The code editor supports only .zip ﬁle archive deployment packages, and the size of 
the deployment package must be less than 3 MB.
The code editor includes the menu bar , windows , and the editor pane .
25AWS Lambda Developer Guide
Edit code using the console editor
For a list of what the commands do, see the menu bar commands reference in the AWS Cloud9 User 
Guide . Note that some of the commands listed in that reference are not available in the code editor.
Topics
•Working with ﬁles and folders (p. 26)
•Working with code (p. 28)
•Working in fullscreen mode (p. 31)
•Working with preferences (p. 32)
Working with ﬁles and folders
You can use the Environment window in the code editor to create, open, and manage ﬁles for your 
function.
To show or hide the Environment window, choose the Environment button. If the Environment button 
is not visible, choose Window, Environment on the menu bar.
26AWS Lambda Developer Guide
Edit code using the console editor
To open a single ﬁle and show its contents in the editor pane, double-click the ﬁle in the Environment
window.
To open multiple ﬁles and show their contents in the editor pane, choose the ﬁles in the Environment
window. Right-click the selection, and then choose Open .
To create a new ﬁle, do one of the following:
•In the Environment window, right-click the folder where you want the new ﬁle to go, and then choose
New File. Enter the ﬁle's name and extension, and then press Enter .
•Choose File, New File on the menu bar. When you're ready to save the ﬁle, choose File, Save or File, 
Save As on the menu bar. Then use the Save As dialog box that displays to name the ﬁle and choose 
where to save it.
•In the tab buttons bar in the editor pane, choose the + button, and then choose New File. When you're 
ready to save the ﬁle, choose File, Save or File, Save As on the menu bar. Then use the Save As dialog 
box that displays to name the ﬁle and choose where to save it.
To create a new folder, right-click the folder in the Environment window where you want the new 
folder to go, and then choose New Folder. Enter the folder's name, and then press Enter .
To save a ﬁle, with the ﬁle open and its contents visible in the editor pane, choose File, Save on the 
menu bar.
To rename a ﬁle or folder, right-click the ﬁle or folder in the Environment window. Enter the 
replacement name, and then press Enter .
To delete ﬁles or folders, choose the ﬁles or folders in the Environment window. Right-click the 
selection, and then choose Delete. Then conﬁrm the deletion by choosing Yes (for a single selection) or
Yes to All.
27AWS Lambda Developer Guide
Edit code using the console editor
To cut, copy, paste, or duplicate ﬁles or folders, choose the ﬁles or folders in the Environment window. 
Right-click the selection, and then choose Cut, Copy, Paste, or Duplicate , respectively.
To collapse folders, choose the gear icon in the Environment window, and then choose Collapse All 
Folders.
To show or hide hidden ﬁles, choose the gear icon in the Environment window, and then choose Show 
Hidden Files.
To see environment variables that are conﬁgured for the function, do the following:
1. Choose the Code  tab.
2. Choose the Environment Variables tab.
3. Choose Tools, Show Environment Variables.
Environment variables remain encrypted when listed in the console code editor. If you enabled 
encryption helpers for encryption in transit, then those settings remain unchanged. For more 
information, see Securing environment variables (p. 81).
The environment variables list is read-only and is available only on the Lambda console. This ﬁle is not 
included when you download the function's .zip ﬁle archive, and you can't add environment variables by 
uploading this ﬁle.
Working with code
Use the editor pane in the code editor to view and write code.
Working with tab buttons
Use the tab buttons bar  to select, view, and create ﬁles.
28AWS Lambda Developer Guide
Edit code using the console editor
To display an open ﬁle's contents, do one of the following:
•Choose the ﬁle's tab.
•Choose the drop-down menu button in the tab buttons bar, and then choose the ﬁle's name.
To close an open ﬁle, do one of the following:
•Choose the X icon in the ﬁle's tab.
•Choose the ﬁle's tab. Then choose the drop-down menu button in the tab buttons bar, and choose
Close Pane.
To close multiple open ﬁles, choose the drop-down menu in the tab buttons bar, and then choose Close 
All Tabs in All Panes or Close All But Current Tab as needed.
To create a new ﬁle, choose the + button in the tab buttons bar, and then choose New File. When you're 
ready to save the ﬁle, choose File, Save or File, Save As on the menu bar. Then use the Save As dialog 
box that displays to name the ﬁle and choose where to save it.
Working with the status bar
Use the status bar to move quickly to a line in the active ﬁle and to change how code is displayed.
29AWS Lambda Developer Guide
Edit code using the console editor
To move quickly to a line in the active ﬁle, choose the line selector, enter the line number to go to, and 
then press Enter .
To change the code color scheme in the active ﬁle, choose the code color scheme selector, and then 
choose the new code color scheme.
To change in the active ﬁle whether soft tabs or spaces are used, the tab size, or whether to convert 
to spaces or tabs, choose the spaces and tabs selector, and then choose the new settings.
30AWS Lambda Developer Guide
Edit code using the console editor
To change for all ﬁles whether to show or hide invisible characters or the gutter, auto-pair brackets 
or quotes, wrap lines, or the font size, choose the gear icon, and then choose the new settings.
Working in fullscreen mode
You can expand the code editor to get more room to work with your code.
To expand the code editor to the edges of the web browser window, choose the Toggle fullscreen
button in the menu bar.
To shrink the code editor to its original size, choose the Toggle fullscreen button again.
In fullscreen mode, additional options are displayed on the menu bar: Save and Test. Choosing Save
saves the function code. Choosing Test or Conﬁgure Events enables you to create or edit the function's 
test events.
31AWS Lambda Developer Guide
Edit code using the console editor
Working with preferences
You can change various code editor settings such as which coding hints and warnings are displayed, code 
folding behaviors, code autocompletion behaviors, and much more.
To change code editor settings, choose the Preferences gear icon in the menu bar.
For a list of what the settings do, see the following references in the AWS Cloud9 User Guide.
•Project settings that you can change
•User setting changes you can make
Note that some of the settings listed in those references are not available in the code editor.
32AWS Lambda Developer Guide
Instruction sets (ARM/x86)
Lambda instruction set architectures (ARM/x86)
The instruction set architecture  of a Lambda function determines the type of computer processor that 
Lambda uses to run the function. Lambda provides a choice of instruction set architectures:
•arm64 – 64-bit ARM architecture, for the AWS Graviton2 processor.
•x86_64 – 64-bit x86 architecture, for x86-based processors.
Note
The arm64 architecture is available in most AWS Regions. For more information, see AWS 
Lambda Pricing . In the memory prices table, choose the Arm Price tab, and then open the
Region dropdown list to see which AWS Regions support arm64 with Lambda.
For an example of how to create a function with arm64 architecture, see AWS Lambda Functions 
Powered by AWS Graviton2 Processor.
Topics
•Advantages of using arm64 architecture (p. 33)
•Requirements for migration to arm64 architecture (p. 33)
•Function code compatibility with arm64 architecture (p. 34)
•How to migrate to arm64 architecture  (p. 34)
•Conﬁguring the instruction set architecture (p. 34)
Advantages of using arm64 architecture
Lambda functions that use arm64 architecture (AWS Graviton2 processor) can achieve signiﬁcantly 
better price and performance than the equivalent function running on x86_64 architecture. Consider 
using arm64 for compute-intensive applications such as high-performance computing, video encoding, 
and simulation workloads.
The Graviton2 CPU uses the Neoverse N1 core and supports Armv8.2 (including CRC and crypto 
extensions) plus several other architectural extensions.
Graviton2 reduces memory read time by providing a larger L2 cache per vCPU, which improves the 
latency performance of web and mobile backends, microservices, and data processing systems. 
Graviton2 also provides improved encryption performance and supports instruction sets that improve 
the latency of CPU-based machine learning inference.
For more information about AWS Graviton2, see AWS Graviton Processor.
Requirements for migration to arm64 architecture
When you select a Lambda function to migrate to arm64 architecture, to ensure a smooth migration, 
make sure that your function meets the following requirements:
•The function currently uses a Lambda Amazon Linux 2 runtime.
•The deployment package contains only open-source components and source code that you control, so 
that you can make any necessary updates for the migration.
•If the function code includes third-party dependencies, each library or package provides an arm64 
version.
33AWS Lambda Developer Guide
Function code compatibility with arm64 architecture
Function code compatibility with arm64 architecture
Your Lambda function code must be compatible with the instruction set architecture of the function. 
Before you migrate a function to arm64 architecture, note the following points about the current 
function code:
•If you added your function code using the embedded code editor, your code probably runs on either 
architecture without modiﬁcation.
•If you uploaded your function code, you must upload new code that is compatible with your target 
architecture.
•If your function uses layers, you must check each layer (p. 996) to ensure that it is compatible with 
the new architecture. If a layer is not compatible, edit the function to replace the current layer version 
with a compatible layer version.
•If your function uses Lambda extensions, you must check each extension to ensure that it is compatible 
with the new architecture.
•If your function uses a container image deployment package type, you must create a new container 
image that is compatible with the architecture of the function.
How to migrate to arm64 architecture
To migrate a Lambda function to the arm64 architecture, we recommend following these steps:
1.Build the list of dependencies for your application or workload. Common dependencies include:
•All the libraries and packages that the function uses.
•The tools that you use to build, deploy, and test the function, such as compilers, test suites, 
continuous integration and continuous delivery (CI/CD) pipelines, provisioning tools, and scripts.
•The Lambda extensions and third-party tools that you use to monitor the function in production.
2.For each of the dependencies, check the version, and then check whether arm64 versions are 
available.
3.Build an environment to migrate your application.
4.Bootstrap the application.
5.Test and debug the application.
6.Test the performance of the arm64 function. Compare the performance with the x86_64 version.
7.Update your infrastructure pipeline to support arm64 Lambda functions.
8.Stage your deployment to production.
For example, use alias routing conﬁguration (p. 105) to split traﬃc between the x86 and arm64 
versions of the function, and compare the performance and latency.
For more information about how to create a code environment for arm64 architecture, including 
language-speciﬁc information for Java, Go, .NET, and Python, see the Getting started with AWS Graviton
GitHub repository.
Conﬁguring the instruction set architecture
You can conﬁgure the instruction set architecture for new and existing Lambda functions using the 
Lambda console, AWS SDKs, AWS Command Line Interface (AWS CLI), or AWS CloudFormation. Follow 
these steps to change the instruction set architecture for an existing Lambda function from the console.
1. Open the Functions page of the Lambda console.
34AWS Lambda Developer Guide
Conﬁguring the instruction set architecture
2. Choose the name of the function that you want to conﬁgure the instruction set architecture for.
3. On the main Code  tab, for the Runtime settings section, choose Edit.
4. Under Architecture, choose the instruction set architecture you want your function to use.
5. Choose Save.
Note
All Amazon Linux 2 runtimes  (p. 41) support both  x86_64 and ARM CPU architectures.
Runtimes that do not use Amazon Linux 2, such as Go 1.x, do not support the arm64 
architecture. To use arm64 architecture with Go 1.x, you can run your function in a provided.al2 
runtime. For more information, see the deployment instructions for .zip packages  (p. 520) and
container images (p. 529).
35AWS Lambda Developer Guide
Additional features
Additional Lambda features
Lambda provides a management console and API for managing and invoking functions. It provides 
runtimes that support a standard set of features so that you can easily switch between languages and 
frameworks, depending on your needs. In addition to functions, you can also create versions, aliases, 
layers, and custom runtimes.
Advanced features
•Scaling  (p. 36)
•Concurrency controls (p. 36)
•Function URLs (p. 36)
•Asynchronous invocation (p. 37)
•Event source mappings (p. 37)
•Destinations  (p. 38)
•Function blueprints (p. 39)
•Testing and deployment tools (p. 39)
•Application templates  (p. 40)
Scaling
Lambda manages the infrastructure that runs your code, and scales automatically in response to 
incoming requests. When your function is invoked more quickly than a single instance of your function 
can process events, Lambda scales up by running additional instances. When traﬃc subsides, inactive 
instances are frozen or stopped. You pay only for the time that your function is initializing or processing 
events.
For more information, see Lambda function scaling (p. 220).
Concurrency controls
Use concurrency settings to ensure that your production applications are highly available and highly 
responsive.
To prevent a function from using too much concurrency, and to reserve a portion of your account's 
available concurrency for a function, use reserved concurrency. Reserved concurrency splits the pool of 
available concurrency into subsets. A function with reserved concurrency only uses concurrency from its 
dedicated pool.
To enable functions to scale without ﬂuctuations in latency, use provisioned concurrency. For functions 
that take a long time to initialize, or that require extremely low latency for all invocations, provisioned 
concurrency enables you to pre-initialize instances of your function and keep them running at all times. 
Lambda integrates with Application Auto Scaling to support autoscaling for provisioned concurrency 
based on utilization.
For more information, see Conﬁguring reserved concurrency (p. 234).
Function URLs
Lambda oﬀers built-in HTTP(S) endpoint support through function URLs . With function URLs, you can 
assign a dedicated HTTP endpoint to your Lambda function. When your function URL is conﬁgured, you 
can use it to invoke your function through a web browser, curl, Postman, or any HTTP client.
36AWS Lambda Developer Guide
Asynchronous invocation
You can add a function URL to an existing function, or create a new function with a function URL. For 
more information, see Invoking Lambda function URLs (p. 200).
Asynchronous invocation
When you invoke a function, you can choose to invoke it synchronously or asynchronously. With
synchronous invocation (p. 139), you wait for the function to process the event and return a response. 
With asynchronous invocation, Lambda queues the event for processing and returns a response 
immediately.
For asynchronous invocations, Lambda handles retries if the function returns an error or is throttled. To 
customize this behavior, you can conﬁgure error handling settings on a function, version, or alias. You 
can also conﬁgure Lambda to send events that failed processing to a dead-letter queue, or to send a 
record of any invocation to a destination  (p. 38).
For more information, see Asynchronous invocation (p. 142).
Event source mappings
To process items from a stream or queue, you can create an event source mapping . An event source 
mapping is a resource in Lambda that reads items from an Amazon Simple Queue Service (Amazon 
SQS) queue, an Amazon Kinesis stream, or an Amazon DynamoDB stream, and sends the items to your 
function in batches. Each event that your function processes can contain hundreds or thousands of items.
37AWS Lambda Developer Guide
Destinations
Event source mappings maintain a local queue of unprocessed items and handle retries if the function 
returns an error or is throttled. You can conﬁgure an event source mapping to customize batching 
behavior and error handling, or to send a record of items that fail processing to a destination.
For more information, see Lambda event source mappings (p. 150).
Destinations
A destination is an AWS resource that receives invocation records for a function. For asynchronous 
invocation (p. 37), you can conﬁgure Lambda to send invocation records to a queue, topic, function, 
or event bus. You can conﬁgure separate destinations for successful invocations and events that failed 
processing. The invocation record contains details about the event, the function's response, and the 
reason that the record was sent.
38AWS Lambda Developer Guide
Function blueprints
For event source mappings (p. 37) that read from streams, you can conﬁgure Lambda to send a record 
of batches that failed processing to a queue or topic. A failure record for an event source mapping 
contains metadata about the batch, and it points to the items in the stream.
For more information, see Conﬁguring destinations for asynchronous invocation (p. 144) and the error 
handling sections of Using AWS Lambda with Amazon DynamoDB (p. 707) and Using AWS Lambda 
with Amazon Kinesis (p. 756).
Function blueprints
When you create a function in the Lambda console, you can choose to start from scratch, use a blueprint, 
or use a container image (p. 18). A blueprint provides sample code that shows how to use Lambda 
with an AWS service or a popular third-party application. Blueprints include sample code and function 
conﬁguration presets for Node.js and Python runtimes.
Blueprints are provided for use under the Amazon Software License. They are available only in the 
Lambda console.
Testing and deployment tools
Lambda supports deploying code as is or as container images (p. 18). You can use AWS services and 
popular community tools like the Docker command line interface (CLI) to author, build, and deploy 
your Lambda functions. To set up the Docker CLI, see Get Docker on the Docker Docs website. For an 
introduction to using Docker with AWS, see Getting started with Amazon ECR using the AWS CLI in the
Amazon Elastic Container Registry User Guide.
The AWS CLI and AWS SAM CLI are command line tools for managing Lambda application stacks. In 
addition to commands for managing application stacks with the AWS CloudFormation API, the AWS 
CLI supports higher-level commands that simplify tasks such as uploading deployment packages and 
39AWS Lambda Developer Guide
Application templates
updating templates. The AWS SAM CLI provides additional functionality, including validating templates, 
testing locally, and integrating with CI/CD systems.
•Installing the AWS SAM CLI
•Testing and debugging serverless applications with AWS SAM
•Deploying serverless applications using CI/CD systems with AWS SAM
Application templates
You can use the Lambda console to create an application with a continuous delivery pipeline. Application 
templates in the Lambda console include code for one or more functions, an application template that 
deﬁnes functions and supporting AWS resources, and an infrastructure template that deﬁnes an AWS 
CodePipeline pipeline. The pipeline has build and deploy stages that run every time you push changes to 
the included Git repository.
Application templates are provided for use under the MIT No Attribution license. They are available only 
in the Lambda console.
For more information, see Creating an application with continuous delivery in the Lambda 
console (p. 1070 ).
Learn how to build serverless solutions
Tip
To learn how to build serverless solutions, check out the Serverless Developer Guide.
40AWS Lambda Developer Guide
Lambda runtimes
Lambda supports multiple languages through the use of runtimes . A runtime provides a language-
speciﬁc environment that relays invocation events, context information, and responses between Lambda 
and the function. You can use runtimes that Lambda provides, or build your own.
Each major programming language release has a separate runtime, with a unique runtime identiﬁer , such 
as python3.10  or nodejs18.x . To conﬁgure a function to use a new major language version, you need 
to change the runtime identiﬁer. Since AWS Lambda cannot guarantee backward compatibility between 
major versions, this is a customer-driven operation.
For a function deﬁned as a container image (p. 122), you choose a runtime and the Linux distribution 
when you create the container image. To change the runtime, you create a new container image.
When you use a .zip ﬁle archive for the deployment package, you choose a runtime when you create the 
function. To change the runtime, you can update your function's conﬁguration (p. 118). The runtime 
is paired with one of the Amazon Linux distributions. The underlying execution environment provides 
additional libraries and environment variables (p. 77) that you can access from your function code.
Amazon Linux 2
•Image – Custom
•Linux kernel – 4.14
Amazon Linux
•Image – amzn-ami-hvm-2018.03.0.20220802.0-x86_64-gp2
•Linux kernel – 4.14
Lambda invokes your function in an execution environment (p. 14). The execution environment provides 
a secure and isolated runtime environment that manages the resources required to run your function. 
Lambda re-uses the execution environment from a previous invocation if one is available, or it can create 
a new execution environment.
To use other languages in Lambda, you can implement a custom runtime  (p. 60). The Lambda 
execution environment provides a runtime interface (p. 55) for getting invocation events and sending 
responses. You can deploy a custom runtime alongside your function code, or in a layer (p. 988).
Note
For new regions, Lambda will not support runtimes that are set to be deprecated within the next 
six months.
Supported Runtimes
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Node.js 18 nodejs18.x 3.188.0 Amazon Linux 
2x86_64, arm64
Node.js 16 nodejs16.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Mar 11, 2024
Node.js 14 nodejs14.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Nov 27, 2023
41AWS Lambda Developer Guide
Runtime deprecation policy
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Python 3.11python3.11 boto3-1.27.1 
botocore-1.30.1Amazon Linux 
2x86_64, arm64
Python 3.10python3.10 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.9python3.9 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.8python3.8 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.7python3.7 boto3-1.26.90 
botocore-1.29.90Amazon Linux x86_64Nov 27, 2023
Java 17 java17 Amazon Linux 
2x86_64, arm64
Java 11 java11 Amazon Linux 
2x86_64, arm64
Java 8 java8.al2 Amazon Linux 
2x86_64, arm64
Java 8 java8 Amazon Linux x86_64 Dec 31, 2023
.NET 7 
(container 
only)dotnet7 Amazon Linux 
2x86_64, arm64May 14, 2024
.NET 6 dotnet6 Amazon Linux 
2x86_64, arm64
Go 1.x go1.x Amazon Linux x86_64 Dec 31, 2023
Ruby 3.2 ruby3.2 3.1.0Amazon Linux 
2x86_64, arm64
Ruby 2.7 ruby2.7 3.1.0Amazon Linux 
2x86_64, arm64 Dec 7, 2023
Custom 
Runtimeprovided.al2 Amazon Linux 
2x86_64, arm64
Custom 
Runtimeprovided Amazon Linux x86_64 Dec 31, 2023
Lambda keeps managed runtimes up to date with patches and support for minor version releases. For 
more information see Lambda runtime updates .
Runtime deprecation policy
Lambda runtimes  (p. 41) for .zip ﬁle archives are built around a combination of operating system, 
programming language, and software libraries that are subject to maintenance and security updates. 
42AWS Lambda Developer Guide
Runtime deprecation policy
When security updates are no longer available for a component of a runtime, Lambda deprecates the 
runtime.
Deprecation (end of support) for a runtime occurs in two phases.
Phase 1 - Lambda no longer applies security patches or other updates to the runtime. You can no 
longer create  functions that use the runtime, but you can continue to update existing functions. This 
includes updating the runtime, and rolling back to the previous runtime. Note that functions that use a 
deprecated runtime are no longer eligible for technical support.
Phase 2 - you can no longer create or update  functions that use the runtime. To update a function, you 
need to migrate it to a supported runtime. After you migrate the function to a supported runtime, you 
cannot rollback the function to the previous runtime. Phase 2 starts at least 30 days after the start of 
Phase 1.
Lambda does not block invocations of functions that use deprecated runtime. Function invocations 
continue indeﬁnitely after the runtime reaches end of support. However, AWS strongly recommends 
that you migrate functions to a supported runtime so that you continue to receive security patches and 
remain eligible for technical support.
In the table below, each phase starts at midnight (Paciﬁc time zone) on the speciﬁed date. The following 
runtimes have reached end of support:
Deprecated runtimes
Name Identiﬁer Operating system Deprecation 
Phase 1Deprecation 
Phase 2
.NET Core 3.1dotnetcore3.1 Amazon Linux 2 Apr 3, 2023 May 3, 2023
Node.js 12 nodejs12.x Amazon Linux 2 Mar 31, 2023 Apr 30, 2023
Python 3.6 python3.6 Amazon Linux Jul 18, 2022 Aug 29, 2022
Python 2.7 python2.7 Amazon Linux Jul 15, 2021 May 30, 2022
.NET 5 (container 
only)dotnet5.0 Amazon Linux 2 May 10, 2022 May 10, 2022
.NET Core 2.1dotnetcore2.1 Amazon Linux Jan 5, 2022 Apr 13, 2022
Ruby 2.5 ruby2.5 Amazon Linux Jul 30, 2021 Mar 31, 2022
Node.js 10 nodejs10.x Amazon Linux 2 Jul 30, 2021 Feb 14, 2022
Node.js 8.10 nodejs8.10 Amazon Linux Mar 6, 2020
Node.js 4.3 nodejs4.3 Amazon Linux Mar 5, 2020
Node.js 6.10 nodejs6.10 Amazon Linux Aug 12, 2019
.NET Core 1.0dotnetcore1.0 Amazon Linux Jul 30, 2019
.NET Core 2.0dotnetcore2.0 Amazon Linux May 30, 2019
Node.js 4.3 edge nodejs4.3-edge Amazon Linux Apr 30, 2019
Node.js 0.10 nodejs Amazon Linux Oct 31, 2016
In almost all cases, the end-of-life date of a language version or operating system is known well in 
advance. The links below give end-of-life schedules for each language that Lambda supports as a 
43AWS Lambda Developer Guide
Runtime deprecation policy
managed runtime. In addition, Trusted Advisor includes a check that provides  120 days' notice of 
upcoming Lambda runtime end of support, and Lambda notiﬁes you by email if you have functions using 
a runtime that is scheduled for end of support in the next 60 days.
Language and framework support policies
•Node.js  – github.com
•Python – devguide.python.org
•Ruby – www.ruby-lang.org
•Java – www.oracle.com and Corretto FAQs
•Go – golang.org
•.NET Core  – dotnet.microsoft.com
44AWS Lambda Developer Guide
Runtime updates
Lambda runtime updates
Lambda keeps each managed runtime up to date with security updates, bug ﬁxes, new features, 
performance enhancements, and support for minor version releases. These runtime updates are 
published as runtime versions . Lambda applies runtime updates to functions by migrating the function 
from an earlier runtime version to a new runtime version.
By default, for functions using managed runtimes, Lambda applies runtime updates automatically. 
With automatic runtime updates, Lambda takes on the operational burden of patching the runtime 
versions. For most customers, automatic updates are the right choice. For more information, see Runtime 
management controls (p. 45).
Lambda also publishes each new runtime version as a container image. To update runtime versions for 
container-based functions, you must create a new container image (p. 122) from the updated base 
image and redeploy your function.
Each runtime version is associated with a version number and an ARN (Amazon Resource Name). Runtime 
version numbers use a numbering scheme that Lambda deﬁnes, independent of the version numbers 
that the programming language uses. The runtime version ARN is a unique identiﬁer for each runtime 
version.
You can view the ARN of your function's current runtime version in the INIT_START  line of your function 
logs and in the Lambda console (p. 49).
Runtime versions should not be confused with runtime identiﬁers. Each runtime has a unique runtime 
identiﬁer , such as python3.9  or nodejs18.x . These correspond to each major programming language 
release. Runtime versions describe the patch version of an individual runtime.
Note
The ARN for the same runtime version number can vary between AWS Regions and CPU 
architectures.
Topics
•Runtime management controls (p. 45)
•Two-phase runtime version rollout (p. 46)
•Roll back a runtime version (p. 46)
•Identifying runtime version changes (p. 47)
•Conﬁgure runtime management settings (p. 49)
•Shared responsibility model (p. 49)
•High-compliance applications (p. 50)
•Supported Regions (p. 51)
Runtime management controls
Lambda strives to provide runtime updates that are backward compatible with existing functions. 
However, as with software patching, there are rare cases in which a runtime update can negatively 
impact an existing function. For example, security patches can expose an underlying issue with an 
existing function that depends on the previous, insecure behavior. Lambda runtime management 
controls help reduce the risk of impact to your workloads in the rare event of a runtime version 
incompatibility. For each function version (p. 108) ($LATEST or published version), you can choose one 
of the following runtime update modes:
•Auto (default)  – Automatically update to the most recent and secure runtime version using Two-phase 
runtime version rollout (p. 46). We recommend this mode for most customers so that you always 
beneﬁt from runtime updates.
45AWS Lambda Developer Guide
Two-phase runtime version rollout
•Function update – Update to the most recent and secure runtime version when you update your 
function. When you update your function, Lambda updates the runtime of your function to the 
most recent and secure runtime version. This approach synchronizes runtime updates with function 
deployments, giving you control over when Lambda applies runtime updates. With this mode, you 
can detect and mitigate rare runtime update incompatibilities early. When using this mode, you must 
regularly update your functions to keep their runtime up to date.
•Manual  – Manually update your runtime version. You specify a runtime version in your function 
conﬁguration. The function uses this runtime version indeﬁnitely. In the rare case in which a new 
runtime version is incompatible with an existing function, you can use this mode to roll back 
your function to an earlier runtime version. We recommend against using Manual  mode to try to 
achieve runtime consistency across deployments. For more information, see Roll back a runtime 
version (p. 46).
Responsibility for applying runtime updates to your functions varies according to which runtime update 
mode you choose. For more information, see Shared responsibility model (p. 49).
Two-phase runtime version rollout
Lambda introduces new runtime versions in the following order:
1.In the ﬁrst phase, Lambda applies the new runtime version whenever you create or update 
a function. A function gets updated when you call the UpdateFunctionCode (p. 1506 ) or
UpdateFunctionConﬁguration (p. 1516 ) API operations.
2.In the second phase, Lambda updates any function that uses the Auto  runtime update mode and that 
hasn't already been updated to the new runtime version.
The overall duration of the rollout process varies according to multiple factors, including the severity of 
any security patches included in the runtime update.
If you're actively developing and deploying your functions, you will most likely pick up new runtime 
versions during the ﬁrst phase. This synchronizes runtime updates with function updates. In the rare 
event that the latest runtime version negatively impacts your application, this approach lets you take 
prompt corrective action. Functions that aren't in active development still receive the operational beneﬁt 
of automatic runtime updates during the second phase.
This approach doesn't aﬀect functions set to Function update or Manual  mode. Functions using
Function update mode receive the latest runtime updates only when you create or update them. 
Functions using Manual  mode don't receive runtime updates.
Lambda publishes new runtime versions in a gradual, rolling fashion across AWS Regions. If your 
functions are set to Auto  or Function update modes, it's possible that functions deployed at the same 
time to diﬀerent Regions, or at diﬀerent times in the same Region, will pick up diﬀerent runtime 
versions. Customers who require guaranteed runtime version consistency across their environments 
should use container images to deploy their Lambda functions (p. 122). The Manual  mode is designed 
as a temporary mitigation to enable runtime version rollback in the rare event that a runtime version is 
incompatible with your function.
Roll back a runtime version
In the rare event that a new runtime version is incompatible with your existing function, you can roll 
back its runtime version to an earlier one. This keeps your application working and minimizes disruption, 
providing time to remedy the incompatibility before returning to the latest runtime version.
Lambda doesn't impose a time limit on how long you can use any particular runtime version. However, 
we strongly recommend updating to the latest runtime version as soon as possible to beneﬁt from the 
46AWS Lambda Developer Guide
Identifying runtime version changes
latest security patches, performance improvements, and features. Lambda provides the option to roll 
back to an earlier runtime version only as a temporary mitigation in the rare event of a runtime update 
compatibility issue. Functions using an earlier runtime version for an extended period may eventually 
experience degraded performance or issues, such as a certiﬁcate expiry, which can cause them to stop 
working properly.
You can roll back a runtime version in the following ways:
•Using the Manual  runtime update mode  (p. 47)
•Using published function versions (p. 47)
For more information, see Introducing AWS Lambda runtime management controls on the AWS Compute 
Blog.
Roll back a runtime version using Manual  runtime update mode
If you're using the Auto  runtime version update mode, or you're using the $LATEST runtime version, you 
can roll back your runtime version using the Manual  mode. For the function version (p. 108) you want 
to roll back, change the runtime version update mode to Manual  and specify the ARN of the previous 
runtime version. For more information about ﬁnding the ARN of the previous runtime version, see
Identifying runtime version changes (p. 47).
Note
If the $LATEST version of your function is conﬁgured to use Manual  mode, then you can't 
change the CPU architecture or runtime version that your function uses. To make these changes, 
you must change to Auto  or Function update mode.
Roll back a runtime version using published function versions
Published function versions (p. 108) are an immutable snapshot of the $LATEST function code and 
conﬁguration at the time that you created them. In Auto  mode, Lambda automatically updates the 
runtime version of published function versions during phase two of the runtime version rollout. In
Function update mode, Lambda doesn't update the runtime version of published function versions.
Published function versions using Function update mode therefore create a static snapshot of the 
function code, conﬁguration, and runtime version. By using Function update mode with function 
versions, you can synchronize runtime updates with your deployments. You can also coordinate rollback 
of code, conﬁguration, and runtime versions by redirecting traﬃc to an earlier published function 
version. You can integrate this approach into your continuous integration and continuous delivery (CI/
CD) for fully automatic rollback in the rare event of runtime update incompatibility. When using this 
approach, you must update your function regularly and publish new function versions to pick up the 
latest runtime updates. For more information, see Shared responsibility model (p. 49).
Identifying runtime version changes
The runtime version number and ARN are logged in the INIT_START  log line, which Lambda emits to 
CloudWatch Logs each time that it creates a new execution environment (p. 10). Because the execution 
environment uses the same runtime version for all function invocations, Lambda emits the INIT_START
log line only when Lambda executes the init phase. Lambda doesn't emit this log line for each function 
invocation. Lambda emits the log line to CloudWatch Logs, but it is not visible in the console.
Example Example INIT_START log line
INIT_START Runtime Version: python:3.9.v14    Runtime Version ARN: arn:aws:lambda:eu-
south-1::runtime:7b620fc2e66107a1046b140b9d320295811af3ad5d4c6a011fad1fa65127e9e6I
47AWS Lambda Developer Guide
Identifying runtime version changes
Rather than working directly with the logs, you can use Amazon CloudWatch Contributor Insights to 
identify transitions between runtime versions. The following rule counts the distinct runtime versions 
from each INIT_START  log line. To use the rule, replace the example log group name /aws/lambda/*
with the appropriate preﬁx for your function or group of functions.
{ 
  "Schema": { 
    "Name": "CloudWatchLogRule", 
    "Version": 1 
  }, 
  "AggregateOn": "Count", 
  "Contribution": { 
    "Filters": [ 
      { 
        "Match": "eventType", 
        "In": [ 
          "INIT_START" 
        ] 
      } 
    ], 
    "Keys": [ 
      "runtimeVersion", 
      "runtimeVersionArn" 
    ] 
  }, 
  "LogFormat": "CLF", 
  "LogGroupNames": [ 
    "/aws/lambda/* " 
  ], 
  "Fields": { 
    "1": "eventType", 
    "4": "runtimeVersion", 
    "8": "runtimeVersionArn" 
  }
}
The following CloudWatch Contributor Insights report shows an example of a runtime version transition 
as captured by the preceding rule. The orange line shows execution environment initialization for the 
earlier runtime version (python:3.9.v12), and the blue line shows execution environment initialization for 
the new runtime version (python:3.9.v14).
48AWS Lambda Developer Guide
Conﬁgure runtime management settings
Conﬁgure runtime management settings
You can conﬁgure runtime management settings using the Lambda console or the AWS Command Line 
Interface (AWS CLI).
Note
You can conﬁgure runtime management settings separately for each function version (p. 108).
To conﬁgure how Lambda updates your runtime version (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. On the Code  tab, under Runtime settings, choose Edit runtime management conﬁguration.
4. Under Runtime management conﬁguration, choose one of the following:
•To have your function update to the latest runtime version automatically, choose Auto .
•To have your function update to the latest runtime version when you change the function, choose
Function update.
•To have your function update to the latest runtime version only when you change the runtime 
version ARN, choose Manual .
Note
You can ﬁnd the runtime version ARN under Runtime management conﬁguration. You 
can also ﬁnd the ARN in the INIT_START  line of your function logs.
5. Choose Save.
To conﬁgure how Lambda updates your runtime version (AWS CLI)
To conﬁgure runtime management for a function, you can use the put-runtime-management-config
AWS CLI command, together with the runtime update mode. When using Manual mode, you must also 
provide the runtime version ARN.
aws lambda put-runtime-management-config --function-
name arn:aws:lambda:eu-west-1:069549076217:function:myfunction  --
update-runtime-on Manual --runtime-version-arn arn:aws:lambda:eu-
west-1::runtime:8eeff65f6809a3ce81507fe733fe09b835899b99481ba22fd75b5a7338290ec1
You should see output similar to the following:
{ 
  "UpdateRuntimeOn": "Manual", 
  "FunctionArn": "arn:aws:lambda:eu-west-1:069549076217:function:myfunction", 
  "RuntimeVersionArn": "arn:aws:lambda:eu-
west-1::runtime:8eeff65f6809a3ce81507fe733fe09b835899b99481ba22fd75b5a7338290ec1"
}
Shared responsibility model
Lambda is responsible for curating and publishing security updates for all supported managed runtimes 
and container images. Responsibility for updating existing functions to use the latest runtime version 
varies depending on which runtime update mode you use.
Lambda is responsible for applying runtime updates to all functions conﬁgured to use the Auto  runtime 
update mode.
49AWS Lambda Developer Guide
High-compliance applications
For functions conﬁgured with the Function update runtime update mode, you're responsible for 
regularly updating your function. Lambda is responsible for applying runtime updates when you make 
those updates. If you don't update your function, then Lambda doesn't update the runtime. If you don't 
regularly update your function, then we strongly recommend conﬁguring it for automatic runtime 
updates so that it continues to receive security updates.
For functions conﬁgured to use the Manual  runtime update mode, you're responsible for updating your 
function to use the latest runtime version. We strongly recommend that you use this mode only to roll 
back the runtime version as a temporary mitigation in the rare event of runtime update incompatibility. 
We also recommend that you change to Auto  mode as quickly as possible to minimize the time in which 
your functions aren't patched.
If you're using container images to deploy your functions (p. 122), then Lambda is responsible for 
publishing updated base images. In this case, you're responsible for rebuilding your function's container 
image from the latest base image and redeploying the container image.
This is summarized in the following table:
Deployment 
modeLambda's responsibility Customer's responsibility
Managed 
runtime, Auto
modePublish new runtime versions 
containing the latest patches.
Apply runtime patches to 
existing functions.Roll back to a previous runtime version in the rare 
event of a runtime update compatibility issue.
Managed 
runtime,
Function 
update  modePublish new runtime versions 
containing the latest patches.Update functions regularly to pick up the latest 
runtime version.
Switch a function to Auto  mode when you're not 
regularly updating the function.
Roll back to a previous runtime version in the rare 
event of a runtime update compatibility issue.
Managed 
runtime,
Manual  modePublish new runtime versions 
containing the latest patches.Use this mode only for temporary runtime 
rollback in the rare event of a runtime update 
compatibility issue.
Switch functions to Auto  or Function update
mode and the latest runtime version as soon as 
possible.
Container 
imagePublish new container images 
containing the latest patches.Redeploy functions regularly using the latest 
container base image to pick up the latest 
patches.
For more information about shared responsibility with AWS, see Shared Responsibility Model on the AWS 
Cloud Security site.
High-compliance applications
To meet patching requirements, Lambda customers typically rely on automatic runtime updates. 
If your application is subject to strict patching freshness requirements, you may want to limit use 
of earlier runtime versions. You can restrict Lambda's runtime management controls by using 
AWS Identity and Access Management (IAM) to deny users in your AWS account access to the
50AWS Lambda Developer Guide
Supported Regions
PutRuntimeManagementConﬁg  (p. 1476 ) API operation. This operation is used to choose the runtime 
update mode for a function. Denying access to this operation causes all functions to default to the Auto
mode. You can apply this restriction across your organization by using a service control policies (SCP). 
In the event that you must roll back a function to an earlier runtime version, you can grant a policy 
exception on a case-by-case basis.
Supported Regions
Lambda supports runtime version numbers, runtime management controls, the INIT_START  log line, 
and two-phase version rollout in the following AWS Regions:
•US East (N. Virginia)
•US East (Ohio)
•US West (N. California)
•US West (Oregon)
•Europe (Ireland)
•Europe (London)
•Europe (Paris)
•Europe (Stockholm)
•Europe (Frankfurt)
•Europe (Milan)
•Asia Paciﬁc (Hong Kong)
•Asia Paciﬁc (Tokyo)
•Asia Paciﬁc (Seoul)
•Asia Paciﬁc (Osaka)
•Asia Paciﬁc (Mumbai)
•Asia Paciﬁc (Singapore)
•Asia Paciﬁc (Sydney)
•Asia Paciﬁc (Jakarta)
•Canada (Central)
•South America (São Paulo)
•Africa (Cape Town)
•Middle East (Bahrain)
In other Regions, Lambda automatically applies runtime updates to all functions in a Region-by-Region 
deployment sequence.
51AWS Lambda Developer Guide
Runtime modiﬁcations
Modifying the runtime environment
You can use internal extensions (p. 1000 ) to modify the runtime process. Internal extensions are not 
separate processes—they run as part of the runtime process.
Lambda provides language-speciﬁc environment variables (p. 77) that you can set to add options and 
tools to the runtime. Lambda also provides wrapper scripts  (p. 52), which allow Lambda to delegate 
the runtime startup to your script. You can create a wrapper script to customize the runtime startup 
behavior.
Language-speciﬁc environment variables
Lambda supports conﬁguration-only ways to enable code to be pre-loaded during function initialization 
through the following language-speciﬁc environment variables:
•JAVA_TOOL_OPTIONS  – On Java, Lambda supports this environment variable to set additional 
command-line variables in Lambda. This environment variable allows you to specify the initialization 
of tools, speciﬁcally the launching of native or Java programming language agents using the
agentlib  or javaagent  options. For more information, see JAVA_TOOL_OPTIONS  environment 
variable .
•NODE_OPTIONS  – On Node.js 10x and above, Lambda supports this environment variable.
•DOTNET_STARTUP_HOOKS  – On .NET Core 3.1 and above, this environment variable speciﬁes a path to 
an assembly (dll) that Lambda can use.
Using language-speciﬁc environment variables is the preferred way to set startup properties.
Wrapper scripts
You can create a wrapper script  to customize the runtime startup behavior of your Lambda function. A 
wrapper script enables you to set conﬁguration parameters that cannot be set through language-speciﬁc 
environment variables.
Note
Invocations may fail if the wrapper script does not successfully start the runtime process.
Wrapper scripts are supported on all native Lambda runtimes  (p. 41) which use the Amazon Linux 2 
operating system. The custom provided.al2  runtime does not support wrapper scripts.
When you use a wrapper script for your function, Lambda starts the runtime using your script. Lambda 
sends to your script the path to the interpreter and all of the original arguments for the standard 
runtime startup. Your script can extend or transform the startup behavior of the program. For example, 
the script can inject and alter arguments, set environment variables, or capture metrics, errors, and other 
diagnostic information.
You specify the script by setting the value of the AWS_LAMBDA_EXEC_WRAPPER  environment variable as 
the ﬁle system path of an executable binary or script.
Example: Create and use a wrapper script with Python 3.8
In the following example, you create a wrapper script to start the Python interpreter with the -X 
importtime  option. When you run the function, Lambda generates a log entry to show the duration of 
the import time for each import.
To create and use a wrapper script with Python 3.8
1. To create the wrapper script, paste the following code into a ﬁle named importtime_wrapper :
52AWS Lambda Developer Guide
Wrapper scripts
  #!/bin/bash 
  # the path to the interpreter and all of the originally intended arguments 
  args=("$@") 
  # the extra options to pass to the interpreter 
  extra_args=("-X" "importtime") 
  # insert the extra options 
  args=("${args[@]:0:$#-1}" "${extra_args[@]}" "${args[@]: -1}") 
  # start the runtime with the extra options 
  exec "${args[@]}" 
           
2. To give the script executable permissions, enter chmod +x importtime_wrapper  from the 
command line.
3. Deploy the script as a Lambda layer (p. 988).
4. Create a function using the Lambda console.
a. Open the Lambda console.
b. Choose Create function.
c. Under Basic information , for Function name, enter wrapper-test-function .
d. For Runtime , choose Python 3.8.
e. Choose Create function.
5. Add the layer to your function.
a. Choose your function, and then choose Code  if it is not already selected.
b. Choose Add a layer.
c. Under Choose a layer, choose the Name  and Version of the compatible layer that you created 
earlier.
d. Choose Add.
6. Add the code and the environment variable to your function.
a. In the function code editor (p. 25), paste the following function code:
import json 
  def lambda_handler(event, context): 
      # TODO implement 
      return { 
          'statusCode': 200, 
          'body': json.dumps('Hello from Lambda!') 
      } 
               
b. Choose Save.
c. Under Environment variables, choose Edit.
d. Choose Add environment variable.
e. For Key, enter AWS_LAMBDA_EXEC_WRAPPER .
f.For Value, enter /opt/importtime_wrapper .
g. Choose Save.
7. To run the function, choose Test.
53AWS Lambda Developer Guide
Wrapper scripts
Because your wrapper script started the Python interpreter with the -X importtime  option, the 
logs show the time required for each import. For example:
  ... 
  2020-06-30T18:48:46.780+01:00 import time: 213 | 213 | simplejson 
  2020-06-30T18:48:46.780+01:00 import time: 50 | 263 | simplejson.raw_json 
  ... 
           
54AWS Lambda Developer Guide
Runtime API
Lambda runtime API
AWS Lambda provides an HTTP API for custom runtimes  (p. 60) to receive invocation events from 
Lambda and send response data back within the Lambda execution environment (p. 41).
The OpenAPI speciﬁcation for the runtime API version 2018-06-01  is available in runtime-api.zip
To create an API request URL, runtimes get the API endpoint from the AWS_LAMBDA_RUNTIME_API
environment variable, add the API version, and add the desired resource path.
Example Request
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next"
API methods
•Next invocation (p. 55)
•Invocation response (p. 56)
•Initialization error (p. 56)
•Invocation error (p. 57)
Next invocation
Path – /runtime/invocation/next
Method  – GET
The runtime sends this message to Lambda to request an invocation event. The response body contains 
the payload from the invocation, which is a JSON document that contains event data from the function 
trigger. The response headers contain additional data about the invocation.
Response headers
•Lambda-Runtime-Aws-Request-Id  – The request ID, which identiﬁes the request that triggered the 
function invocation.
For example, 8476a536-e9f4-11e8-9739-2dfe598c3fcd .
•Lambda-Runtime-Deadline-Ms  – The date that the function times out in Unix time milliseconds.
For example, 1542409706888 .
•Lambda-Runtime-Invoked-Function-Arn  – The ARN of the Lambda function, version, or alias 
that's speciﬁed in the invocation.
55AWS Lambda Developer Guide
Invocation response
For example, arn:aws:lambda:us-east-2:123456789012:function:custom-runtime .
•Lambda-Runtime-Trace-Id  – The AWS X-Ray tracing header.
For example, Root=1-5bef4de7-
ad49b0e87f6ef6c87fc2e700;Parent=9a9197af755a6419;Sampled=1 .
•Lambda-Runtime-Client-Context  – For invocations from the AWS Mobile SDK, data about the 
client application and device.
•Lambda-Runtime-Cognito-Identity  – For invocations from the AWS Mobile SDK, data about the 
Amazon Cognito identity provider.
Do not set a timeout on the GET request as the response may be delayed. Between when Lambda 
bootstraps the runtime and when the runtime has an event to return, the runtime process may be frozen 
for several seconds.
The request ID tracks the invocation within Lambda. Use it to specify the invocation when you send the 
response.
The tracing header contains the trace ID, parent ID, and sampling decision. If the request is 
sampled, the request was sampled by Lambda or an upstream service. The runtime should set the
_X_AMZN_TRACE_ID  with the value of the header. The X-Ray SDK reads this to get the IDs and 
determine whether to trace the request.
Invocation response
Path – /runtime/invocation/ AwsRequestId /response
Method  – POST
After the function has run to completion, the runtime sends an invocation response to Lambda. For 
synchronous invocations, Lambda sends the response to the client.
Example success request
REQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response"  
 -d "SUCCESS"
Initialization error
If the function returns an error or the runtime encounters an error during initialization, the runtime uses 
this method to report the error to Lambda.
Path – /runtime/init/error
Method  – POST
Headers
Lambda-Runtime-Function-Error-Type  – Error type that the runtime encountered. Required: no.
This header consists of a string value. Lambda accepts any string, but we recommend a format of 
<category.reason>. For example:
•Runtime.NoSuchHandler
•Runtime.APIKeyNotFound
56AWS Lambda Developer Guide
Invocation error
•Runtime.ConﬁgInvalid
•Runtime.UnknownReason
Body parameters
ErrorRequest  – Information about the error. Required: no.
This ﬁeld is a JSON object with the following structure:
{ 
      errorMessage: string (text description of the error), 
      errorType: string, 
      stackTrace: array of strings
}
Note that Lambda accepts any value for errorType .
The following example shows a Lambda function error message in which the function could not parse 
the event data provided in the invocation.
Example Function error
{ 
      "errorMessage" : "Error parsing event data.", 
      "errorType" : "InvalidEventDataException", 
      "stackTrace": [ ]
}       
Response body parameters
•StatusResponse  – String. Status information, sent with 202 response codes.
•ErrorResponse  – Additional error information, sent with the error response codes. ErrorResponse 
contains an error type and an error message.
Response codes
•202 – Accepted
•403 – Forbidden
•500 – Container error. Non-recoverable state. Runtime should exit promptly.
Example initialization error request
ERROR="{\"errorMessage\" : \"Failed to load function.\", \"errorType\" : 
 \"InvalidFunctionException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" -d "$ERROR" --header 
 "Lambda-Runtime-Function-Error-Type: Unhandled"
Invocation error
If the function returns an error or the runtime encounters an error, the runtime uses this method to 
report the error to Lambda.
Path – /runtime/invocation/ AwsRequestId /error
57AWS Lambda Developer Guide
Invocation error
Method  – POST
Headers
Lambda-Runtime-Function-Error-Type  – Error type that the runtime encountered. Required: no.
This header consists of a string value. Lambda accepts any string, but we recommend a format of 
<category.reason>. For example:
•Runtime.NoSuchHandler
•Runtime.APIKeyNotFound
•Runtime.ConﬁgInvalid
•Runtime.UnknownReason
Body parameters
ErrorRequest  – Information about the error. Required: no.
This ﬁeld is a JSON object with the following structure:
{ 
      errorMessage: string (text description of the error), 
      errorType: string, 
      stackTrace: array of strings
}
Note that Lambda accepts any value for errorType .
The following example shows a Lambda function error message in which the function could not parse 
the event data provided in the invocation.
Example Function error
{ 
      "errorMessage" : "Error parsing event data.", 
      "errorType" : "InvalidEventDataException", 
      "stackTrace": [ ]
}       
Response body parameters
•StatusResponse  – String. Status information, sent with 202 response codes.
•ErrorResponse  – Additional error information, sent with the error response codes. ErrorResponse 
contains an error type and an error message.
Response codes
•202 – Accepted
•400 – Bad Request
•403 – Forbidden
•500 – Container error. Non-recoverable state. Runtime should exit promptly.
Example error request
REQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
58AWS Lambda Developer Guide
Invocation error
ERROR="{\"errorMessage\" : \"Error parsing event data.\", \"errorType\" : 
 \"InvalidEventDataException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/error" -d 
 "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
59AWS Lambda Developer Guide
Custom runtimes
Custom Lambda runtimes
You can implement an AWS Lambda runtime in any programming language. A runtime is a program that 
runs a Lambda function's handler method when the function is invoked. You can include a runtime in 
your function's deployment package as an executable ﬁle named bootstrap .
A runtime runs the function's setup code, reads the handler name from an environment variable, and 
reads invocation events from the Lambda runtime API. The runtime passes the event data to the function 
handler, and posts the response from the handler back to Lambda.
Your custom runtime runs in the standard Lambda execution environment (p. 41). It can be a shell script, 
a script in a language that's included in Amazon Linux, or a binary executable ﬁle that's compiled in 
Amazon Linux.
To get started with custom runtimes, see Tutorial – Publishing a custom runtime (p. 63). You can also 
explore a custom runtime implemented in C++ at awslabs/aws-lambda-cpp on GitHub.
Topics
•Using a custom runtime  (p. 60)
•Building a custom runtime  (p. 60)
•Implementing response streaming in a custom runtime (p. 61)
Using a custom runtime
To use a custom runtime, set your function's runtime to provided.al2 . The runtime can be included in 
your function's deployment package, or in a layer (p. 988).
Example function.zip
.
### bootstrap
### function.sh
If there's a ﬁle named bootstrap  in your deployment package, Lambda runs that ﬁle. If not, Lambda 
looks for a runtime in the function's layers. If the bootstrap ﬁle isn't found or isn't executable, your 
function returns an error upon invocation.
Building a custom runtime
A custom runtime's entry point is an executable ﬁle named bootstrap . The bootstrap ﬁle can be the 
runtime, or it can invoke another ﬁle that creates the runtime. The following example uses a bundled 
version of Node.js to run a JavaScript runtime in a separate ﬁle named runtime.js .
Example bootstrap
#!/bin/sh
cd $LAMBDA_TASK_ROOT
./node-v11.1.0-linux-x64/bin/node runtime.js
Your runtime code is responsible for completing some initialization tasks. Then it processes invocation 
events in a loop until it's shut down. The initialization tasks run once per instance of the function (p. 14)
to prepare the environment to handle invocations.
60AWS Lambda Developer Guide
Implementing response streaming in a custom runtime
Initialization tasks
•Retrieve settings – Read environment variables to get details about the function and environment.
•_HANDLER  – The location to the handler, from the function's conﬁguration. The standard format is
file.method, where file is the name of the ﬁle without an extension, and method  is the name of 
a method or function that's deﬁned in the ﬁle.
•LAMBDA_TASK_ROOT  – The directory that contains the function code.
•AWS_LAMBDA_RUNTIME_API  – The host and port of the runtime API.
For a full list of available variables, see Deﬁned runtime environment variables (p. 80).
•Initialize the function – Load the handler ﬁle and run any global or static code that it contains. 
Functions should create static resources like SDK clients and database connections once, and reuse 
them for multiple invocations.
•Handle errors – If an error occurs, call the initialization error (p. 56) API and exit immediately.
Initialization counts towards billed execution time and timeout. When an execution triggers the 
initialization of a new instance of your function, you can see the initialization time in the logs and AWS 
X-Ray trace (p. 973).
Example log
REPORT RequestId: f8ac1208... Init Duration: 48.26 ms   Duration: 237.17 ms   Billed 
 Duration: 300 ms   Memory Size: 128 MB   Max Memory Used: 26 MB
While it runs, a runtime uses the Lambda runtime interface (p. 55) to manage incoming events and 
report errors. After completing initialization tasks, the runtime processes incoming events in a loop. In 
your runtime code, perform the following steps in order.
Processing tasks
•Get an event – Call the next invocation (p. 55) API to get the next event. The response body contains 
the event data. Response headers contain the request ID and other information.
•Propagate the tracing header  – Get the X-Ray tracing header from the Lambda-Runtime-Trace-Id
header in the API response. Set the _X_AMZN_TRACE_ID  environment variable locally with the same 
value. The X-Ray SDK uses this value to connect trace data between services.
•Create a context object – Create an object with context information from environment variables and 
headers in the API response.
•Invoke the function handler – Pass the event and context object to the handler.
•Handle the response – Call the invocation response (p. 56) API to post the response from the handler.
•Handle errors – If an error occurs, call the invocation error (p. 57) API.
•Cleanup – Release unused resources, send data to other services, or perform additional tasks before 
getting the next event.
You can include the runtime in your function's deployment package, or distribute the runtime separately 
in a function layer. For an example walkthrough, see Tutorial – Publishing a custom runtime (p. 63).
Implementing response streaming in a custom 
runtime
For response streaming functions, the response  and error endpoints have slightly modiﬁed behavior 
that lets the runtime stream partial responses to the client and return payloads in chunks. For more 
information about the speciﬁc behavior, see the following:
61AWS Lambda Developer Guide
Implementing response streaming in a custom runtime
•/runtime/invocation/AwsRequestId/response  – Propagates the Content-Type  header 
from the runtime to send to the client. Lambda returns the response payload in chunks via HTTP/1.1 
chunked transfer encoding. The response stream can be a maximum size of 20 MiB. To stream the 
response to Lambda, the runtime must:
•Set the Lambda-Runtime-Function-Response-Mode  HTTP header to streaming .
•Set the Transfer-Encoding  header to chunked .
•Write the response conforming to the HTTP/1.1 chunked transfer encoding speciﬁcation.
•Close the underlying connection after it has successfully written the response.
•/runtime/invocation/AwsRequestId/error  – The runtime can use this endpoint to report 
function or runtime errors to Lambda, which also accepts the Transfer-Encoding  header. This 
endpoint can only be called before the runtime begins sending an invocation response.
•Report midstream errors using error trailers in /runtime/invocation/AwsRequestId/response
– To report errors that occur after the runtime starts writing the invocation response, the runtime 
can optionally attach HTTP trailing headers named Lambda-Runtime-Function-Error-Type
and Lambda-Runtime-Function-Error-Body . Lambda treats this as a successful response and 
forwards the error metadata that the runtime provides to the client.
Note
To attach trailing headers, the runtime must set the Trailer  header value at the beginning 
of the HTTP request. This is a requirement of the HTTP/1.1 chunked transfer encoding 
speciﬁcation.
•Lambda-Runtime-Function-Error-Type  – The error type that the runtime encountered. 
This header consists of a string value. Lambda accepts any string, but we recommend a format of
<category.reason> . For example, Runtime.APIKeyNotFound .
•Lambda-Runtime-Function-Error-Body  – Base64-encoded information about the error.
62AWS Lambda Developer Guide
Tutorial – Custom runtime
Tutorial – Publishing a custom runtime
In this tutorial, you create a Lambda function with a custom runtime. You start by including the runtime 
in the function's deployment package. Then you migrate it to a layer that you manage independently 
from the function. Finally, you share the runtime layer with the world by updating its resource-based 
permissions policy.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
You need an IAM role to create a Lambda function. The role needs permission to send logs to 
CloudWatch Logs and access the AWS services that your function uses. If you don't have a role for 
function development, create one now.
To create an execution role
1. Open the roles page in the IAM console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – Lambda .
•Permissions – AWSLambdaBasicExecutionRole.
•Role name – lambda-role .
The AWSLambdaBasicExecutionRole policy has the permissions that the function needs to write 
logs to CloudWatch Logs.
Create a function
Create a Lambda function with a custom runtime. This example includes two ﬁles, a runtime bootstrap
ﬁle, and a function handler. Both are implemented in Bash.
63AWS Lambda Developer Guide
Create a function
The runtime loads a function script from the deployment package. It uses two variables to locate the 
script. LAMBDA_TASK_ROOT  tells it where the package was extracted, and _HANDLER  includes the name 
of the script.
Example bootstrap
#!/bin/sh
set -euo pipefail
# Initialization - load function handler
source $LAMBDA_TASK_ROOT/"$(echo $_HANDLER | cut -d. -f1).sh"
# Processing
while true
do 
  HEADERS="$(mktemp)" 
  # Get an event. The HTTP request will block until one is received 
  EVENT_DATA=$(curl -sS -LD "$HEADERS" "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/
runtime/invocation/next") 
  # Extract request ID by scraping response headers received above 
  REQUEST_ID=$(grep -Fi Lambda-Runtime-Aws-Request-Id "$HEADERS" | tr -d '[:space:]' | cut 
 -d: -f2) 
  # Run the handler function from the script 
  RESPONSE=$($(echo "$_HANDLER" | cut -d. -f2) "$EVENT_DATA") 
  # Send the response 
  curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/
response"  -d "$RESPONSE"
done
After loading the script, the runtime processes events in a loop. It uses the runtime API to retrieve an 
invocation event from Lambda, passes the event to the handler, and posts the response back to Lambda. 
To get the request ID, the runtime saves the headers from the API response to a temporary ﬁle, and 
reads the Lambda-Runtime-Aws-Request-Id  header from the ﬁle.
Note
Runtimes have additional responsibilities, including error handling, and providing context 
information to the handler. For details, see Building a custom runtime  (p. 60).
The script deﬁnes a handler function that takes event data, logs it to stderr, and returns it.
Example function.sh
function handler () { 
  EVENT_DATA=$1 
  echo "$EVENT_DATA" 1>&2; 
  RESPONSE="Echoing request: '$EVENT_DATA'" 
  echo $RESPONSE
}
Save both ﬁles in a project directory named runtime-tutorial .
runtime-tutorial
# bootstrap
# function.sh
Make the ﬁles executable and add them to a .zip ﬁle archive.
64AWS Lambda Developer Guide
Create a layer
runtime-tutorial$ chmod 755 function.sh bootstrap
runtime-tutorial$ zip function.zip function.sh bootstrap
  adding: function.sh (deflated 24%) 
  adding: bootstrap (deflated 39%)
Create a function named bash-runtime .
runtime-tutorial$ aws lambda create-function --function-name bash-runtime \
--zip-file fileb://function.zip --handler function.handler --runtime provided \
--role arn:aws:iam:: 123456789012 :role/lambda-role
{ 
    "FunctionName": "bash-runtime", 
    "FunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:bash-runtime", 
    "Runtime": "provided", 
    "Role": "arn:aws:iam::123456789012:role/lambda-role", 
    "Handler": "function.handler", 
    "CodeSha256": "mv/xRv84LPCxdpcbKvmwuuFzwo7sLwUO1VxcUv3wKlM=", 
    "Version": "$LATEST", 
    "TracingConfig": { 
        "Mode": "PassThrough" 
    }, 
    "RevisionId": "2e1d51b0-6144-4763-8e5c-7d5672a01713", 
    ...
}
Invoke the function and verify the response.
runtime-tutorial$ aws lambda invoke --function-name bash-runtime --payload 
 '{"text":"Hello"}' response.txt --cli-binary-format raw-in-base64-out
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
runtime-tutorial$ cat response.txt
Echoing request: '{"text":"Hello"}'
Create a layer
To separate the runtime code from the function code, create a layer that only contains the runtime. 
Layers let you develop your function's dependencies independently, and can reduce storage usage when 
you use the same layer with multiple functions.
Create a layer archive that contains the bootstrap  ﬁle.
runtime-tutorial$ zip runtime.zip bootstrap
  adding: bootstrap (deflated 39%)
Create a layer with the publish-layer-version  command.
runtime-tutorial$ aws lambda publish-layer-version --layer-name bash-runtime --zip-file 
 fileb://runtime.zip
 { 
    "Content": { 
        "Location": "https://awslambda-us-east-1-layers.s3.us-east-1.amazonaws.com/
snapshots/123456789012/bash-runtime-018c209b...", 
        "CodeSha256": "bXVLhHi+D3H1QbDARUVPrDwlC7bssPxySQqt1QZqusE=", 
        "CodeSize": 584, 
        "UncompressedCodeSize": 0 
    }, 
65AWS Lambda Developer Guide
Update the function
    "LayerArn": "arn:aws:lambda:us-east-1:123456789012:layer:bash-runtime", 
    "LayerVersionArn": "arn:aws:lambda:us-east-1:123456789012:layer:bash-runtime:1", 
    "Description": "", 
    "CreatedDate": "2018-11-28T07:49:14.476+0000", 
    "Version": 1
}
This creates the ﬁrst version of the layer.
Update the function
To use the runtime layer with the function, conﬁgure the function to use the layer, and remove the 
runtime code from the function.
Update the function conﬁguration to pull in the layer.
runtime-tutorial$ aws lambda update-function-configuration --function-name bash-runtime \
--layers arn:aws:lambda:us-east-1: 123456789012 :layer:bash-runtime:1
{ 
    "FunctionName": "bash-runtime", 
    "Layers": [ 
        { 
            "Arn": "arn:aws:lambda:us-east-1:123456789012:layer:bash-runtime:1", 
            "CodeSize": 584, 
            "UncompressedCodeSize": 679 
        } 
    ] 
    ...
}
This adds the runtime to the function in the /opt directory. Lambda uses this runtime, but only if you 
remove it from the function's deployment package. Update the function code to only include the handler 
script.
runtime-tutorial$ zip function-only.zip function.sh
  adding: function.sh (deflated 24%)
runtime-tutorial$ aws lambda update-function-code --function-name bash-runtime --zip-file 
 fileb://function-only.zip
{ 
    "FunctionName": "bash-runtime", 
    "CodeSize": 270, 
    "Layers": [ 
        { 
            "Arn": "arn:aws:lambda:us-east-1:123456789012:layer:bash-runtime:7", 
            "CodeSize": 584, 
            "UncompressedCodeSize": 679 
        } 
    ] 
    ...
}
Invoke the function to verify that it works with the runtime layer.
runtime-tutorial$ aws lambda invoke --function-name bash-runtime --payload 
 '{"text":"Hello"}' response.txt --cli-binary-format raw-in-base64-out
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
runtime-tutorial$ cat response.txt
66AWS Lambda Developer Guide
Update the runtime
Echoing request: '{"text":"Hello"}'
Update the runtime
To log information about the execution environment, update the runtime script to output environment 
variables.
Example bootstrap
#!/bin/sh
set -euo pipefail
echo "##  Environment variables:"
env
# Initialization - load function handler
source $LAMBDA_TASK_ROOT/"$(echo $_HANDLER | cut -d. -f1).sh"
...
Create a second version of the layer with the new code.
runtime-tutorial$ zip runtime.zip bootstrap
updating: bootstrap (deflated 39%)
runtime-tutorial$ aws lambda publish-layer-version --layer-name bash-runtime --zip-file 
 fileb://runtime.zip
Conﬁgure the function to use the new version of the layer.
runtime-tutorial$ aws lambda update-function-configuration --function-name bash-runtime \
--layers arn:aws:lambda:us-east-1: 123456789012 :layer:bash-runtime:2
Share the layer
Add a permission statement to your runtime layer to share it with other accounts.
runtime-tutorial$ aws lambda add-layer-version-permission --layer-name bash-runtime --
version-number 2 \
--principal "*" --statement-id publish --action lambda:GetLayerVersion
{ 
    "Statement": "{\"Sid\":\"publish\",\"Effect\":\"Allow\",\"Principal\":\"*\",\"Action\":
\"lambda:GetLayerVersion\",\"Resource\":\"arn:aws:lambda:us-east-1:123456789012:layer:bash-
runtime:2\"}", 
    "RevisionId": "9d5fe08e-2a1e-4981-b783-37ab551247ff"
}
You can add multiple statements that each grant permission to a single account, accounts in an 
organization, or all accounts.
Clean up
Delete each version of the layer.
runtime-tutorial$ aws lambda delete-layer-version --layer-name bash-runtime --version-
number 1
67AWS Lambda Developer Guide
Clean up
runtime-tutorial$ aws lambda delete-layer-version --layer-name bash-runtime --version-
number 2
Because the function holds a reference to version 2 of the layer, it still exists in Lambda. The function 
continues to work, but functions can no longer be conﬁgured to use the deleted version. If you then 
modify the list of layers on the function, you must specify a new version or omit the deleted layer.
Delete the tutorial function with the delete-function  command.
runtime-tutorial$ aws lambda delete-function --function-name bash-runtime
68AWS Lambda Developer Guide
AVX2 vectorization
Using AVX2 vectorization in Lambda
Advanced Vector Extensions 2 (AVX2) is a vectorization extension to the Intel x86 instruction set that can 
perform single instruction multiple data (SIMD) instructions over vectors of 256 bits. For vectorizable 
algorithms with highly parallelizable  operation, using AVX2 can enhance CPU performance, resulting in 
lower latencies and higher throughput. Use the AVX2 instruction set for compute-intensive workloads 
such as machine learning inferencing, multimedia processing, scientiﬁc simulations, and ﬁnancial 
modeling applications.
Note
Lambda arm64 uses NEON SIMD architecture and does not support the x86 AVX2 extensions.
To use AVX2 with your Lambda function, make sure that your function code is accessing AVX2-optimized 
code. For some languages, you can install the AVX2-supported version of libraries and packages. For 
other languages, you can recompile your code and dependencies with the appropriate compiler ﬂags 
set (if the compiler supports auto-vectorization). You can also compile your code with third-party 
libraries that use AVX2 to optimize math operations. For example, Intel Math Kernel Library (Intel MKL), 
OpenBLAS (Basic Linear Algebra Subprograms), and AMD BLAS-like Library Instantiation Software (BLIS). 
Auto-vectorized languages, such as Java, automatically use AVX2 for computations.
You can create new Lambda workloads or move existing AVX2-enabled workloads to Lambda at no 
additional cost.
For more information about AVX2, see Advanced Vector Extensions 2 in Wikipedia.
Compiling from source
If your Lambda function uses a C or C++ library to perform compute-intensive vectorizable operations, 
you can set the appropriate compiler ﬂags and recompile the function code. Then, the compiler 
automatically vectorizes your code.
For the gcc or clang compiler, add -march=haswell  to the command or set -mavx2 as a command 
option.
~ gcc -march=haswell main.c
or
~ gcc -mavx2 main.c   
  
~ clang -march=haswell main.c
or
~ clang -mavx2 main.c 
     
To use a speciﬁc library, follow instructions in the library's documentation to compile and build the 
library. For example, to build TensorFlow from source, you can follow the  installation instructions on the 
TensorFlow website. Make sure to use the -march=haswell  compile option.
Enabling AVX2 for Intel MKL
Intel MKL is a library of optimized math operations that implicitly use AVX2 instructions when the 
compute platform supports them. Frameworks such as PyTorch build with Intel MKL by default, so you 
don't need to enable AVX2.
Some libraries, such as TensorFlow, provide options in their build process to specify Intel MKL 
optimization. For example, with TensorFlow, use the --config=mkl  option.
69AWS Lambda Developer Guide
AVX2 support in other languages
You can also build popular scientiﬁc Python libraries, such as SciPy and NumPy, with Intel MKL. For 
instructions on building these libraries with Intel MKL, see Numpy/Scipy with Intel MKL and Intel 
Compilers  on the Intel website.
For more information about Intel MKL and similar libraries, see Math Kernel Library in Wikipedia, the
OpenBLAS website, and the AMD BLIS repository on GitHub.
AVX2 support in other languages
If you don't use C or C++ libraries and don't build with Intel MKL, you can still get some AVX2 
performance improvement for your applications. Note that the actual improvement depends on the 
compiler or interpreter's ability to utilize the AVX2 capabilities on your code.
Python
Python users generally use SciPy and NumPy libraries for compute-intensive workloads. You can 
compile these libraries to enable AVX2, or you can use the Intel MKL-enabled versions of the 
libraries.
Node
For compute-intensive workloads, use AVX2-enabled or Intel MKL-enabled versions of the libraries 
that you need.
Java
Java's JIT compiler can auto-vectorize your code to run with AVX2 instructions. For information 
about detecting vectorized code, see the Code vectorization in the JVM presentation on the 
OpenJDK website.
Go
The standard Go compiler doesn't currently support auto-vectorization, but you can use gccgo, the 
GCC compiler for Go. Set the -mavx2  option:
gcc -o avx2 -mavx2 -Wall main.c
Intrinsics
It's possible to use intrinsic functions in many languages to manually vectorize your code to use 
AVX2. However, we don't recommend this approach. Manually writing vectorized code takes 
signiﬁcant eﬀort. Also, debugging and maintaining such code is more diﬃcult than using code that 
depends on auto-vectorization.
70AWS Lambda Developer Guide
Conﬁguring AWS Lambda functions
Learn how to conﬁgure the core capabilities and options for your Lambda function using the Lambda API 
or console. These conﬁgurations apply to a function deployed as a container image (p. 122) and for a 
function deployed as a .zip ﬁle archive (p. 118).
Conﬁguring function options  (p. 72)
You can ﬁnd an overview of how to conﬁgure your Lambda function using the console and AWS CLI.
Environment variables (p. 77)
You can make your function code portable and keep secrets out of your code by storing them in your 
function's conﬁguration by using environment variables.
Creating layers (p. 988)
You create a layer manage your function's dependencies independently and keep your development 
package small.
Outbound networking (p. 85)
You can use your Lambda function with AWS resources in an Amazon VPC. Connecting your function 
to a VPC lets you access resources in a private subnet such as relational databases and caches.
Inbound networking (p. 92)
You can use an interface VPC endpoint to invoke your Lambda functions without crossing the public 
internet.
Database  (p. 95)
You can create a database proxy for MySQL and Aurora DB instances. A database proxy enables a 
function to reach high concurrency levels without exhausting database connections.
File system (p. 99)
You can use your Lambda function to mount a Amazon EFS to a local directory. A ﬁle system allows 
your function code to access and modify shared resources safely and at high concurrency.
Aliases  (p. 104)
You can conﬁgure your clients to invoke a speciﬁc Lambda function version by using an alias, instead 
of updating the client.
Versions (p. 108)
By publishing a version of your function, you can store your code and conﬁguration as a separate 
resource that cannot be changed.
Response streaming (p. 110)
You can conﬁgure your Lambda function URLs to stream response payloads back to clients. 
Response streaming can beneﬁt latency sensitive applications by improving time to ﬁrst byte 
(TTFB) performance. This is because you can send partial responses back to the client as they 
become available. Additionally, you can use response streaming to build functions that return larger 
payloads.
71AWS Lambda Developer Guide
Conﬁguring function options
Conﬁguring Lambda function options
After you create a function, you can conﬁgure additional capabilities for the function, such as triggers, 
network access, and ﬁle system access. You can also adjust resources associated with the function, such 
as memory and concurrency. These conﬁgurations apply to functions deﬁned as .zip ﬁle archives and to 
functions deﬁned as container images.
You can also create and edit test events to test your function using the console.
For function conﬁguration best practices, see Function conﬁguration (p. 909).
Sections
•Function versions (p. 72)
•Using the function overview (p. 72)
•Conﬁguring functions (console) (p. 73)
•Conﬁguring functions (API) (p. 74)
•Conﬁguring function memory (console) (p. 74)
•Conﬁguring function timeout (console) (p. 74)
•Conﬁguring ephemeral storage (console) (p. 75)
•Accepting function memory recommendations (console) (p. 75)
•Conﬁguring triggers (console) (p. 75)
•Testing functions (console) (p. 76)
Function versions
A function has an unpublished version, and can have published versions and aliases. By default, the 
console displays conﬁguration information for the unpublished version of the function. You change the 
unpublished version when you update your function's code and conﬁguration.
A published version is a snapshot of your function code and conﬁguration that can't be changed (except 
for a few conﬁguration items relevant to a function version, such as provisioned concurrency).
Using the function overview
The Function overview shows a visualization of your function and its upstream and downstream 
resources. You can use it to jump to trigger and destination conﬁguration. You can use it to jump to layer 
conﬁguration for functions deﬁned as .zip ﬁle archives.
72AWS Lambda Developer Guide
Conﬁguring functions (console)
Conﬁguring functions (console)
For the following function conﬁgurations, you can change the settings only for the unpublished version 
of a function. In the console, the function Conﬁguration  tab provides the following sections:
•General conﬁguration – Conﬁgure memory (p. 74) or opt in to the AWS Compute 
Optimizer (p. 75). You can also conﬁgure function timeout  (p. 74) and the execution role.
•Permissions – Conﬁgure the execution role and other permissions  (p. 912).
•Environment variables – Key-value pairs that Lambda sets in the execution environment. To extend 
your function's conﬁguration outside of code, use environment variables (p. 77).
•Tags – Key-value pairs that Lambda attaches to your function resource. Use tags  (p. 257) to organize 
Lambda functions into groups for cost reporting and ﬁltering in the Lambda console.
Tags apply to the entire function, including all versions and aliases.
•Virtual private cloud (VPC) – If your function needs network access to resources that are not available 
over the internet, conﬁgure it to connect to a virtual private cloud (VPC) (p. 85).
•Monitoring and operations tools  – conﬁgure CloudWatch and other monitoring tools  (p. 961).
•Concurrency – Reserve concurrency for a function (p. 234) to set the maximum number of 
simultaneous executions for a function. Provision concurrency to ensure that a function can scale 
without ﬂuctuations in latency. Reserved concurrency applies to the entire function, including all 
versions and aliases.
•Function URL – Conﬁgure a function URL (p. 189) to add a unique HTTP(S) endpoint to your Lambda 
function. You can conﬁgure a function URL on the $LATEST unpublished function version, or on any 
function alias.
You can conﬁgure the following options on a function, a function version, or an alias.
•Triggers – Conﬁgure triggers  (p. 75).
•Destinations  – Conﬁgure destinations  (p. 144) for asynchronous invocations.
•Asynchronous invocation – Conﬁgure error handling behavior (p. 142) to reduce the number of 
retries that Lambda attempts, or the amount of time that unprocessed events stay queued before 
Lambda discards them. Conﬁgure a dead-letter queue (p. 148) to retain discarded events.
•Code signing  – To use Code signing  (p. 253) with your function, conﬁgure the function to include a 
code-signing conﬁguration.
•Database proxies – Create a database proxy (p. 95) for functions that use an Amazon RDS DB 
instance or cluster.
•File systems – Connect your function to a ﬁle system  (p. 99).
•State machines  – Use a state machine to orchestrate and apply error handling to your function.
The console provides separate tabs to conﬁgure aliases and versions:
•Aliases  – An alias is a named resource that maps to a function version. You can change an alias to map 
to a diﬀerent function version.
•Versions – Lambda assigns a new version number each time you publish your function. For more 
information about managing versions, see Lambda function versions (p. 108).
You can conﬁgure the following items for a published function version:
•Triggers
•Destinations
•Provisioned concurrency
73AWS Lambda Developer Guide
Conﬁguring functions (API)
•Asynchronous invocation
•Database proxies
Conﬁguring functions (API)
To conﬁgure functions with the Lambda API, use the following actions:
•UpdateFunctionCode (p. 1506 ) – Update the function's code.
•UpdateFunctionConﬁguration (p. 1516 ) – Update version-speciﬁc settings.
•TagResource (p. 1484 ) – Tag a function.
•AddPermission (p. 1280 ) – Modify the resource-based policy (p. 929) of a function, version, or alias.
•PutFunctionConcurrency (p. 1466 ) – Conﬁgure a function's reserved concurrency.
•PublishVersion (p. 1454 ) – Create an immutable version with the current code and conﬁguration.
•CreateAlias (p. 1285 ) – Create aliases for function versions.
•PutFunctionEventInvokeConﬁg – Conﬁgure error handling for asynchronous invocation.
•CreateFunctionUrlConﬁg – Create a function URL conﬁguration.
•UpdateFunctionUrlConﬁg – Update an existing function URL conﬁguration.
Conﬁguring function memory (console)
Lambda allocates CPU power in proportion to the amount of memory conﬁgured. Memory is the amount 
of memory available to your Lambda function at runtime. You can increase or decrease the memory and 
CPU power allocated to your function using the Memory (MB) setting. To conﬁgure the memory for your 
function, set a value between 128 MB and 10,240 MB in 1-MB increments. At 1,769 MB, a function has 
the equivalent of one vCPU (one vCPU-second of credits per second).
You can conﬁgure the memory of your function in the Lambda console.
To update the memory of a function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. On the function conﬁguration page, on the General conﬁguration pane, choose Edit.
4. For Memory (MB), set a value from 128 MB to 10,240 MB.
5. Choose Save.
Conﬁguring function timeout (console)
Lambda runs your code for a set amount of time before timing out. Timeout  is the maximum amount of 
time in seconds that a Lambda function can run. The default value for this setting is 3 seconds, but you 
can adjust this in increments of 1 second up to a maximum value of 15 minutes.
You can conﬁgure the timeout of your function in the Lambda console.
To change the timeout of a function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. On the function conﬁguration page, on the General conﬁguration pane, choose Edit.
74AWS Lambda Developer Guide
Conﬁguring ephemeral storage (console)
4. For Timeout , set a value from 1 second to 15 minutes.
5. Choose Save.
Conﬁguring ephemeral storage (console)
By default, Lambda allocates 512 MB for a function’s /tmp directory. You can increase or decrease this 
amount using the Ephemeral storage (MB)  setting. To conﬁgure the size of a function’s /tmp directory, 
set a whole number value between 512 MB and 10,240 MB, in 1-MB increments.
Note
Conﬁguring ephemeral storage past the default 512 MB allocated incurs a cost. For more 
information, see Lambda pricing .
You can conﬁgure the size of a function’s /tmp directory in the Lambda console.
To update the size of a function’s /tmp directory
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. On the function conﬁguration page, on the General conﬁguration pane, choose Edit.
4. For Ephemeral storage (MB) , set a value from 512 MB to 10,240 MB.
5. Choose Save.
Accepting function memory recommendations 
(console)
If you have administrator permissions in AWS Identity and Access Management (IAM), you can opt in 
to receive Lambda function memory setting recommendations from AWS Compute Optimizer. For 
instructions on opting in to memory recommendations for your account or organization, see Opting in 
your account in the AWS Compute Optimizer User Guide.
Note
Compute Optimizer supports only functions that use x86_64 architecture.
When you've opted in and your Lambda function meets Compute Optimizer requirements, you can view 
and accept function memory recommendations from Compute Optimizer in the Lambda console.
To accept a function memory recommendation
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. On the function conﬁguration page, on the General conﬁguration pane, choose Edit.
4. Under Memory (MB), in the memory alert, choose Update .
5. Choose Save.
Conﬁguring triggers (console)
You can conﬁgure other AWS services to trigger your function each time a speciﬁed event occurs.
For details about how services trigger Lambda functions, see Using AWS Lambda with other 
services (p. 628).
75AWS Lambda Developer Guide
Testing functions (console)
To add a trigger to your function.
1. Open the Functions page of the Lambda console.
2. Choose the function to update.
3. Under Function overview, choose Add trigger .
4. From the drop-down list of triggers, choose a trigger. The console displays additional conﬁguration 
ﬁelds required for this trigger.
5. Choose Add.
Testing functions (console)
You can create test events for your function from the Test tab. For more information, see Testing 
Lambda functions in the console.
You can also invoke your function without saving your test event by choosing Test before saving. This 
creates an unsaved test event that Lambda will preserve for the duration of the session. You can access 
your unsaved test events from either the Test or Code  tab.
76AWS Lambda Developer Guide
Environment variables
Using Lambda environment variables
You can use environment variables to adjust your function's behavior without updating code. An 
environment variable is a pair of strings that is stored in a function's version-speciﬁc conﬁguration. The 
Lambda runtime makes environment variables available to your code and sets additional environment 
variables that contain information about the function and invocation request.
Note
To increase database security, we recommend that you use AWS Secrets Manager instead of 
environment variables to store database credentials. For more information, see Conﬁguring 
database access for a Lambda function (p. 95).
Environment variables are not evaluated before the function invocation. Any value you deﬁne is 
considered a literal string and not expanded. Perform the variable evaluation in your function code.
Sections
•Conﬁguring environment variables (p. 77)
•Conﬁguring environment variables with the API (p. 78)
•Example scenario for environment variables (p. 79)
•Retrieve environment variables (p. 79)
•Deﬁned runtime environment variables (p. 80)
•Securing environment variables (p. 81)
•Sample code and templates (p. 83)
Conﬁguring environment variables
You deﬁne environment variables on the unpublished version of your function. When you publish 
a version, the environment variables are locked for that version along with other version-speciﬁc 
conﬁguration (p. 72).
You create an environment variable for your function by deﬁning a key and a value. Your function uses 
the name of the key to retrieve the value of the environment variable.
To set environment variables in the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration , then choose Environment variables.
4. Under Environment variables, choose Edit.
5. Choose Add environment variable.
6. Enter a key and value.
Requirements
•Keys start with a letter and are at least two characters.
•Keys only contain letters, numbers, and the underscore character (_).
•Keys aren't reserved by Lambda (p. 80).
•The total size of all environment variables doesn't exceed 4 KB.
7. Choose Save.
77AWS Lambda Developer Guide
Conﬁguring environment variables with the API
To generate a list of environment variables in the console code editor
You can generate a list of environment variables in the Lambda code editor. This is a quick way to 
reference your environment variables while you code.
1. Choose the Code  tab.
2. Choose the Environment Variables tab.
3. Choose Tools, Show Environment Variables.
Environment variables remain encrypted when listed in the console code editor. If you enabled 
encryption helpers for encryption in transit, then those settings remain unchanged. For more 
information, see Securing environment variables (p. 81).
The environment variables list is read-only and is available only on the Lambda console. This ﬁle is not 
included when you download the function's .zip ﬁle archive, and you can't add environment variables by 
uploading this ﬁle.
Conﬁguring environment variables with the API
To manage environment variables with the AWS CLI or AWS SDK, use the following API operations.
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example sets two environment variables on a function named my-function .
aws lambda update-function-configuration --function-name my-function \ 
    --environment "Variables={BUCKET=my-bucket,KEY=file.txt}"
When you apply environment variables with the update-function-configuration  command, the 
entire contents of the Variables  structure is replaced. To retain existing environment variables when 
you add a new one, include all existing values in your request.
To get the current conﬁguration, use the get-function-configuration  command.
aws lambda get-function-configuration --function-name my-function
You should see the following output:
{ 
    "FunctionName": "my-function", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "Runtime": "nodejs18.x", 
    "Role": "arn:aws:iam::123456789012:role/lambda-role", 
    "Environment": { 
        "Variables": { 
            "BUCKET": "my-bucket", 
            "KEY": "file.txt" 
        } 
    }, 
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15", 
    ...
}
78AWS Lambda Developer Guide
Example scenario for environment variables
You can pass the revision ID from the output of get-function-configuration  as a parameter to
update-function-configuration . This ensures that the values don't change between when you 
read the conﬁguration and when you update it.
To conﬁgure a function's encryption key, set the KMSKeyARN  option.
aws lambda update-function-configuration --function-name my-function \ 
   --kms-key-arn arn:aws:kms:us-east-2:123456789012:key/055efbb4-xmpl-4336-
ba9c-538c7d31f599
Example scenario for environment variables
You can use environment variables to customize function behavior in your test environment and 
production environment. For example, you can create two functions with the same code but diﬀerent 
conﬁgurations. One function connects to a test database, and the other connects to a production 
database. In this situation, you use environment variables to pass the hostname and other connection 
details for the database to the function.
The following example shows how to deﬁne the database host and database name as environment 
variables.
If you want your test environment to generate more debug information than the production 
environment, you could set an environment variable to conﬁgure your test environment to use more 
verbose logging or more detailed tracing.
Retrieve environment variables
To retrieve environment variables in your function code, use the standard method for your programming 
language.
Node.js
let region = process.env.AWS_REGION
Python
import os 
  region = os.environ['AWS_REGION']
Note
In some cases, you may need to use the following format:
region = os.environ.get('AWS_REGION')
79AWS Lambda Developer Guide
Deﬁned runtime environment variables
Ruby
region = ENV["AWS_REGION"]
Java
String region = System.getenv("AWS_REGION");
Go
var region = os.Getenv("AWS_REGION")
C#
string region = Environment.GetEnvironmentVariable("AWS_REGION");
PowerShell
$region = $env:AWS_REGION
Lambda stores environment variables securely by encrypting them at rest. You can conﬁgure Lambda to 
use a diﬀerent encryption key (p. 81), encrypt environment variable values on the client side, or set 
environment variables in an AWS CloudFormation template with AWS Secrets Manager.
Deﬁned runtime environment variables
Lambda runtimes  (p. 41) set several environment variables during initialization. Most of the environment 
variables provide information about the function or runtime. The keys for these environment variables 
are reserved and cannot be set in your function conﬁguration.
Reserved environment variables
•_HANDLER  – The handler location conﬁgured on the function.
•_X_AMZN_TRACE_ID  – The X-Ray tracing header (p. 973). This environment variable is not deﬁned 
for custom runtimes (for example, runtimes that use the provided  or provided.al2  identiﬁers). You 
can set _X_AMZN_TRACE_ID  for custom runtimes using the Lambda-Runtime-Trace-Id  response 
header from the Next invocation (p. 55).
•AWS_DEFAULT_REGION  – The default AWS Region where the Lambda function is executed.
•AWS_REGION  – The AWS Region where the Lambda function is executed. If deﬁned, this value 
overrides the AWS_DEFAULT_REGION .
•AWS_EXECUTION_ENV  – The runtime identiﬁer  (p. 41), preﬁxed by AWS_Lambda_  (for example,
AWS_Lambda_java8 ). This environment variable is not deﬁned for custom runtimes (for example, 
runtimes that use the provided  or provided.al2  identiﬁers).
•AWS_LAMBDA_FUNCTION_NAME  – The name of the function.
•AWS_LAMBDA_FUNCTION_MEMORY_SIZE  – The amount of memory available to the function in MB.
•AWS_LAMBDA_FUNCTION_VERSION  – The version of the function being executed.
•AWS_LAMBDA_INITIALIZATION_TYPE  – The initialization type of the function, which is on-demand ,
provisioned-concurrency , or snap-start . For information, see  Conﬁguring provisioned 
concurrency (p. 237) or Improving startup performance with Lambda SnapStart (p. 1098 ).
80AWS Lambda Developer Guide
Securing environment variables
•AWS_LAMBDA_LOG_GROUP_NAME , AWS_LAMBDA_LOG_STREAM_NAME  – The name of the Amazon 
CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME  and
AWS_LAMBDA_LOG_STREAM_NAME  environment variables (p. 80) are not available in Lambda 
SnapStart functions.
•AWS_ACCESS_KEY , AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , AWS_SESSION_TOKEN  – The 
access keys obtained from the function's execution role (p. 913).
•AWS_LAMBDA_RUNTIME_API  – (Custom runtime  (p. 60)) The host and port of the runtime API  (p. 55).
•LAMBDA_TASK_ROOT  – The path to your Lambda function code.
•LAMBDA_RUNTIME_DIR  – The path to runtime libraries.
The following additional environment variables aren't reserved and can be extended in your function 
conﬁguration.
Unreserved environment variables
•LANG  – The locale of the runtime ( en_US.UTF-8 ).
•PATH – The execution path (/usr/local/bin:/usr/bin/:/bin:/opt/bin ).
•LD_LIBRARY_PATH  – The system library path (/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:
$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib ).
•NODE_PATH  – (Node.js  (p. 272)) The Node.js library path (/opt/nodejs/node12/
node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules ).
•PYTHONPATH  – (Python 2.7, 3.6, 3.8 (p. 346)) The Python library path ($LAMBDA_RUNTIME_DIR ).
•GEM_PATH  – (Ruby (p. 403)) The Ruby library path ($LAMBDA_TASK_ROOT/vendor/bundle/
ruby/2.5.0:/opt/ruby/gems/2.5.0 ).
•AWS_XRAY_CONTEXT_MISSING  – For X-Ray tracing, Lambda sets this to LOG_ERROR  to avoid throwing 
runtime errors from the X-Ray SDK.
•AWS_XRAY_DAEMON_ADDRESS  – For X-Ray tracing, the IP address and port of the X-Ray daemon.
•AWS_LAMBDA_DOTNET_PREJIT  – For the .NET 6 and .NET 7 runtimes, set this variable to enable or 
disable .NET speciﬁc runtime optimizations. Values include always , never , and provisioned-
concurrency . For more information, see Conﬁguring provisioned concurrency (p. 237).
•TZ – The environment's time zone (UTC). The execution environment uses NTP to synchronize the 
system clock.
The sample values shown reﬂect the latest runtimes. The presence of speciﬁc variables or their values 
can vary on earlier runtimes.
Securing environment variables
For securing your environment variables, you can use server-side encryption to protect your data at rest 
and client-side encryption to protect your data in transit.
Note
To increase database security, we recommend that you use AWS Secrets Manager instead of 
environment variables to store database credentials. For more information, see Conﬁguring 
database access for a Lambda function (p. 95).
Security at rest
Lambda always provides server-side encryption at rest with an AWS KMS key. By default, Lambda uses 
an AWS managed key. If this default behavior suits your workﬂow, you don't need to set up anything 
81AWS Lambda Developer Guide
Securing environment variables
else. Lambda creates the AWS managed key in your account and manages permissions to it for you. AWS 
doesn't charge you to use this key.
If you prefer, you can provide an AWS KMS customer managed key instead. You might do this to have 
control over rotation of the KMS key or to meet the requirements of your organization for managing 
KMS keys. When you use a customer managed key, only users in your account with access to the KMS key 
can view or manage environment variables on the function.
Customer managed keys incur standard AWS KMS charges. For more information, see AWS Key 
Management Service pricing.
Security in transit
For additional security, you can enable helpers for encryption in transit, which ensures that your 
environment variables are encrypted client-side for protection in transit.
To conﬁgure encryption for your environment variables
1. Use the AWS Key Management Service (AWS KMS) to create any customer managed keys for Lambda 
to use for server-side and client-side encryption. For more information, see Creating keys in the AWS 
Key Management Service Developer Guide.
2. Using the Lambda console, navigate to the Edit environment variables page.
a. Open the Functions page of the Lambda console.
b. Choose a function.
c. Choose Conﬁguration , then choose Environment variables from the left navigation bar.
d. In the Environment variables section, choose Edit.
e. Expand Encryption conﬁguration.
3. (Optional) Enable console encryption helpers to use client-side encryption to protect your data in 
transit.
a. Under Encryption in transit, choose Enable helpers for encryption in transit.
b. For each environment variable that you want to enable console encryption helpers for, choose
Encrypt next to the environment variable.
c. Under AWS KMS key to encrypt in transit, choose a customer managed key that you created at 
the beginning of this procedure.
d. Choose Execution role policy and copy the policy. This policy grants permission to your 
function's execution role to decrypt the environment variables.
Save this policy to use in the last step of this procedure.
e. Add code to your function that decrypts the environment variables. To see an example, choose
Decrypt secrets snippet.
4. (Optional) Specify your customer managed key for encryption at rest.
a. Choose Use a customer master key.
b. Choose a customer managed key that you created at the beginning of this procedure.
5. Choose Save.
6. Set up permissions.
If you're using a customer managed key with server-side encryption, grant permissions to any users 
or roles that you want to be able to view or manage environment variables on the function. For 
more information, see Managing permissions to your server-side encryption KMS key (p. 83).
If you're enabling client-side encryption for security in transit, your function needs permission to call 
the kms:Decrypt  API operation. Add the policy that you saved previously in this procedure to the 
function's execution role (p. 913).
82AWS Lambda Developer Guide
Sample code and templates
Managing permissions to your server-side encryption KMS key
No AWS KMS permissions are required for your user or the function's execution role to use the default 
encryption key. To use a customer managed key, you need permission to use the key. Lambda uses your 
permissions to create a grant on the key. This allows Lambda to use it for encryption.
•kms:ListAliases  – To view keys in the Lambda console.
•kms:CreateGrant , kms:Encrypt  – To conﬁgure a customer managed key on a function.
•kms:Decrypt  – To view and manage environment variables that are encrypted with a customer 
managed key.
You can get these permissions from your AWS account or from a key's resource-based permissions 
policy. ListAliases  is provided by the managed policies for Lambda  (p. 920). Key policies grant the 
remaining permissions to users in the Key users group.
Users without Decrypt permissions can still manage functions, but they can't view environment 
variables or manage them in the Lambda console. To prevent a user from viewing environment variables, 
add a statement to the user's permissions that denies access to the default key, a customer managed key, 
or all keys.
Example IAM policy – Deny access by key ARN
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "VisualEditor0", 
            "Effect": "Deny", 
            "Action": [ 
                "kms:Decrypt" 
            ], 
            "Resource": "arn:aws:kms:us-east-2:123456789012:key/3be10e2d-xmpl-4be4-
bc9d-0405a71945cc" 
        } 
    ]
}
For details on managing key permissions, see Key policies in AWS KMS in the AWS Key Management 
Service Developer Guide.
Sample code and templates
Sample applications in this guide's GitHub repository demonstrate the use of environment variables in 
function code and AWS CloudFormation templates.
83AWS Lambda Developer Guide
Sample code and templates
Sample applications
•Blank function (p. 1116 ) – Create a basic function that shows the use of logging, environment 
variables, AWS X-Ray tracing, layers, unit tests, and the AWS SDK.
•RDS MySQL – Create a VPC and an Amazon Relational Database Service (Amazon RDS) DB instance 
in one template, with a password stored in Secrets Manager. In the application template, import 
database details from the VPC stack, read the password from Secrets Manager, and pass all connection 
conﬁguration to the function in environment variables.
84AWS Lambda Developer Guide
Outbound networking
Connecting outbound networking to resources in a 
VPC
You can conﬁgure a Lambda function to connect to private subnets in a virtual private cloud (VPC) 
in your AWS account. Use Amazon Virtual Private Cloud (Amazon VPC) to create a private network 
for resources such as databases, cache instances, or internal services. Connect your function to the 
VPC to access private resources while the function is running. This section provides a summary of 
Lambda VPC connections. For details about VPC networking in Lambda, see the section called “Private 
networking” (p. 21).
Tip
To conﬁgure your Lambda function to access a VPC and subnet, you can use the Lambda 
Console or the API.
Refer to the VpcConfig  section in CreateFunction (p. 1304 ) to conﬁgure your function. See
Conﬁguring VPC access (console) (p. 86) and Conﬁguring VPC access (API) (p. 87) for 
detailed steps.
When you connect a function to a VPC, Lambda assigns your function to a Hyperplane ENI (elastic 
network interface) for each subnet in your function's VPC conﬁguration. Lambda creates a Hyperplane 
ENI the ﬁrst time a unique subnet and security group combination is deﬁned for a VPC-enabled function 
in an account.
While Lambda creates a Hyperplane ENI, you can't perform additional operations that target the 
function, such as creating versions (p. 108) or updating the function's code. For new functions, you 
can't invoke the function until its state changes from Pending  to Active. For existing functions, you 
can still invoke an earlier version while the update is in progress. For details about the Hyperplane ENI 
lifecycle, see the section called “Lambda Hyperplane ENIs” (p. 22).
Lambda functions can't connect directly to a VPC with  dedicated instance tenancy. To connect to 
resources in a dedicated VPC, peer it to a second VPC with default tenancy.
Sections
•Managing VPC connections (p. 85)
•Execution role and user permissions (p. 86)
•Conﬁguring VPC access (console) (p. 86)
•Conﬁguring VPC access (API) (p. 87)
•Using IAM condition keys for VPC settings (p. 88)
•Internet and service access for VPC-connected functions (p. 91)
•VPC tutorials  (p. 91)
•Sample VPC conﬁgurations (p. 91)
Managing VPC connections
Multiple functions can share a network interface, if the functions share the same subnet and security 
group. Connecting additional functions to the same VPC conﬁguration (subnet and security group) 
that has an existing Lambda-managed network interface is much quicker than creating a new network 
interface.
If your functions aren't active for a long period of time, Lambda reclaims its network interfaces, and the 
functions become Idle. To reactivate an idle function, invoke it. This invocation fails, and the function 
enters a Pending state again until a network interface is available.
85AWS Lambda Developer Guide
Execution role and user permissions
If you update your function to access a diﬀerent VPC, it terminates connectivity from the Hyperplane 
ENI to the previous VPC. The process to update the connectivity to a new VPC can take several minutes. 
During this time, Lambda connects function invocations to the previous VPC. After the update is 
complete, new invocations start using the new VPC and the Lambda function is no longer connected to 
the older VPC.
For short-lived operations, such as DynamoDB queries, the latency overhead of setting up a TCP 
connection might be greater than the operation itself. To ensure connection reuse for short-lived/
infrequently invoked functions, we recommend that you use TCP keep-alive  for connections that were 
created during your function initialization, to avoid creating new connections for subsequent invokes. For 
more information on reusing connections using keep-alive, refer to Lambda documentation on reusing 
connections.
Execution role and user permissions
Lambda uses your function's permissions to create and manage network interfaces. To connect to a VPC, 
your function's execution role (p. 913) must have the following permissions:
Execution role permissions
•ec2:CreateNetworkInterface
•ec2:DescribeNetworkInterfaces – This action only works if it's allowed on all resources ("Resource": 
"*").
•ec2:DeleteNetworkInterface – If you don't specify a resource ID for DeleteNetworkInterface
in the execution role, your function may not be able to access the VPC. Either specify a unique 
resource ID, or include all resource IDs, for example, "Resource": "arn:aws:ec2:us-
west-2:123456789012:*/*" .
These permissions are included in the AWS managed policy AWSLambdaVPCAccessExecutionRole. 
Note that these permissions are required only to create ENIs, not to invoke your VPC function. In other 
words, you are still able to invoke your VPC function successfully even if you remove these permissions 
from your execution role. To completely disassociate your Lambda function from the VPC, update the 
function's VPC conﬁguration settings using the console or the UpdateFunctionConﬁguration (p. 1516 )
API.
When you conﬁgure VPC connectivity, Lambda uses your permissions to verify network resources. To 
conﬁgure a function to connect to a VPC, your user needs the following permissions:
User permissions
•ec2:DescribeSecurityGroups
•ec2:DescribeSubnets
•ec2:DescribeVpcs
Conﬁguring VPC access (console)
If your IAM permissions  (p. 88) allow you only to create Lambda functions that connect to your VPC, 
you must conﬁgure the VPC when you create the function. If your IAM permissions allow you to create 
functions that aren't connected to your VPC, you can add the VPC conﬁguration after you create the 
function.
To conﬁgure a VPC when you create a function
1. Open the Functions page of the Lambda console.
86AWS Lambda Developer Guide
Conﬁguring VPC access (API)
2. Choose Create function.
3. Under Basic information , for Function name, enter a name for your function.
4. Expand Advanced settings.
5. Under Network, choose a VPC for your function to access.
6. Choose subnets and security groups. When you choose a security group, the console displays the 
inbound and outbound rules for that security group.
Note
To access private resources, connect your function to private subnets. If your function needs 
internet access, use network address translation (NAT) (p. 91). Connecting a function to a 
public subnet doesn't give it internet access or a public IP address.
7. Choose Create function.
To conﬁgure a VPC for an existing function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose VPC.
4. Under VPC, choose Edit.
5. Choose a VPC, subnets, and security groups.
Note
To access private resources, connect your function to private subnets. If your function needs 
internet access, use network address translation (NAT) (p. 91). Connecting a function to a 
public subnet doesn't give it internet access or a public IP address.
6. Choose Save.
Conﬁguring VPC access (API)
To connect a Lambda function to a VPC, you can use the following API operations:
•CreateFunction (p. 1304 )
•UpdateFunctionConﬁguration (p. 1516 )
To create a function and connect it to a VPC using the AWS Command Line Interface (AWS CLI), you can 
use the create-function  command with the vpc-config  option. The following example creates a 
function with a connection to a VPC with two subnets and one security group.
aws lambda create-function --function-name my-function \
--runtime nodejs18.x --handler index.js --zip-file fileb://function.zip \
--role arn:aws:iam:: 123456789012 :role/lambda-role  \
--vpc-config 
 SubnetIds= subnet-071f712345678e7c8,subnet-07fd123456788a036 ,SecurityGroupIds= sg-085912345678492fb
To connect an existing function to a VPC, use the update-function-configuration  command with 
the vpc-config  option.
aws lambda update-function-configuration --function-name my-function \
--vpc-config 
 SubnetIds= subnet-071f712345678e7c8,subnet-07fd123456788a036 ,SecurityGroupIds= sg-085912345678492fb
To disconnect your function from a VPC, update the function conﬁguration with an empty list of subnets 
and security groups.
87AWS Lambda Developer Guide
Using IAM condition keys for VPC settings
aws lambda update-function-configuration --function-name my-function \
--vpc-config SubnetIds=[],SecurityGroupIds=[]
Using IAM condition keys for VPC settings
You can use Lambda-speciﬁc condition keys for VPC settings to provide additional permission controls 
for your Lambda functions. For example, you can require that all functions in your organization are 
connected to a VPC. You can also specify the subnets and security groups that the function's users can 
and can't use.
Lambda supports the following condition keys in IAM policies:
•lambda:VpcIds – Allow or deny one or more VPCs.
•lambda:SubnetIds  – Allow or deny one or more subnets.
•lambda:SecurityGroupIds – Allow or deny one or more security groups.
The Lambda API operations CreateFunction (p. 1304 ) and UpdateFunctionConﬁguration (p. 1516 )
support these condition keys. For more information about using condition keys in IAM policies, see IAM 
JSON Policy Elements: Condition in the IAM User Guide .
Tip
If your function already includes a VPC conﬁguration from a previous API request, you can send 
an UpdateFunctionConfiguration  request without the VPC conﬁguration.
Example policies with condition keys for VPC settings
The following examples demonstrate how to use condition keys for VPC settings. After you create a 
policy statement with the desired restrictions, append the policy statement for the target user or role.
Ensure that users deploy only VPC-connected functions
To ensure that all users deploy only VPC-connected functions, you can deny function create and update 
operations that don't include a valid VPC ID.
Note that VPC ID is not an input parameter to the CreateFunction  or
UpdateFunctionConfiguration  request. Lambda retrieves the VPC ID value based on the subnet and 
security group parameters.
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "EnforceVPCFunction", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Deny", 
      "Resource": "*", 
      "Condition": { 
        "Null": { 
           "lambda:VpcIds": "true" 
        } 
      } 
    } 
  ]
} 
88AWS Lambda Developer Guide
Using IAM condition keys for VPC settings
        
Deny users access to speciﬁc VPCs, subnets, or security groups
To deny users access to speciﬁc VPCs, use StringEquals  to check the value of the lambda:VpcIds
condition. The following example denies users access to vpc-1  and vpc-2 .
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "EnforceOutOfVPC", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Deny", 
      "Resource": "*", 
      "Condition": { 
        "StringEquals": { 
            "lambda:VpcIds": ["vpc-1", "vpc-2"] 
        } 
      } 
    }  
         
To deny users access to speciﬁc subnets, use StringEquals  to check the value of the
lambda:SubnetIds  condition. The following example denies users access to subnet-1  and subnet-2 .
{ 
      "Sid": "EnforceOutOfSubnet", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Deny", 
      "Resource": "*", 
      "Condition": { 
        "ForAnyValue:StringEquals": { 
            "lambda:SubnetIds": ["subnet-1", "subnet-2"] 
        } 
      } 
    } 
        
To deny users access to speciﬁc security groups, use StringEquals  to check the value of the
lambda:SecurityGroupIds  condition. The following example denies users access to sg-1  and sg-2 .
{ 
      "Sid": "EnforceOutOfSecurityGroups", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Deny", 
      "Resource": "*", 
      "Condition": { 
        "ForAnyValue:StringEquals": { 
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"] 
        } 
      } 
89AWS Lambda Developer Guide
Using IAM condition keys for VPC settings
    } 
  ]
} 
         
Allow users to create and update functions with speciﬁc VPC settings
To allow users to access speciﬁc VPCs, use StringEquals  to check the value of the lambda:VpcIds
condition. The following example allows users to access vpc-1  and vpc-2 .
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "EnforceStayInSpecificVpc", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Allow", 
      "Resource": "*", 
      "Condition": { 
        "StringEquals": { 
            "lambda:VpcIds": ["vpc-1", "vpc-2"] 
        } 
      } 
    } 
         
To allow users to access speciﬁc subnets, use StringEquals  to check the value of the
lambda:SubnetIds  condition. The following example allows users to access subnet-1  and subnet-2 .
{ 
      "Sid": "EnforceStayInSpecificSubnets", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Allow", 
      "Resource": "*", 
      "Condition": { 
        "ForAllValues:StringEquals": { 
            "lambda:SubnetIds": ["subnet-1", "subnet-2"] 
        } 
      } 
    } 
       
To allow users to access speciﬁc security groups, use StringEquals  to check the value of the
lambda:SecurityGroupIds  condition. The following example allows users to access sg-1  and sg-2 .
{ 
      "Sid": "EnforceStayInSpecificSecurityGroup", 
      "Action": [ 
          "lambda:CreateFunction", 
          "lambda:UpdateFunctionConfiguration" 
       ], 
      "Effect": "Allow", 
      "Resource": "*", 
      "Condition": { 
        "ForAllValues:StringEquals": { 
90AWS Lambda Developer Guide
Internet and service access for VPC-connected functions
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"] 
        } 
      } 
    } 
  ]
}  
         
Internet and service access for VPC-connected 
functions
By default, Lambda runs your functions in a secure VPC with access to AWS services and the internet. 
Lambda owns this VPC, which isn't connected to your account's default VPC . When you connect a 
function to a VPC in your account, the function can't access the internet unless your VPC provides access.
Note
Several AWS services oﬀer VPC endpoints . You can use VPC endpoints to connect to AWS 
services from within a VPC without internet access.
Internet access from a private subnet requires network address translation (NAT). To give your function 
access to the internet, route outbound traﬃc to a NAT gateway in a public subnet. The NAT gateway 
has a public IP address and can connect to the internet through the VPC's internet gateway. An idle NAT 
gateway connection will  time out after 350 seconds. For more information, see How do I give internet 
access to my Lambda function in a VPC?
VPC tutorials
In the following tutorials, you connect a Lambda function to resources in your VPC.
•Tutorial: Using a Lambda function to access Amazon RDS in an Amazon VPC (p. 801)
•Tutorial: Conﬁguring a Lambda function to access Amazon ElastiCache in an Amazon VPC (p. 732)
Sample VPC conﬁgurations
You can use the following sample AWS CloudFormation templates to create VPC conﬁgurations to use 
with Lambda functions. There are two templates available in this guide's GitHub repository:
•vpc-private.yaml – A VPC with two private subnets and VPC endpoints for Amazon Simple Storage 
Service (Amazon S3) and Amazon DynamoDB. Use this template to create a VPC for functions that 
don't need internet access. This conﬁguration supports use of Amazon S3 and DynamoDB with the 
AWS SDKs, and access to database resources in the same VPC over a local network connection.
•vpc-privatepublic.yaml – A VPC with two private subnets, VPC endpoints, a public subnet with a NAT 
gateway, and an internet gateway. Internet-bound traﬃc from functions in the private subnets is 
routed to the NAT gateway using a route table.
To create a VPC using a template, on the AWS CloudFormation console Stacks page , choose Create stack , 
and then follow the instructions in the Create stack  wizard.
91AWS Lambda Developer Guide
Inbound networking
Connecting inbound interface VPC endpoints for 
Lambda
If you use Amazon Virtual Private Cloud (Amazon VPC) to host your AWS resources, you can establish a 
connection between your VPC and Lambda. You can use this connection to invoke your Lambda function 
without crossing the public internet.
To establish a private connection between your VPC and Lambda, create an interface VPC endpoint. 
Interface endpoints are powered by AWS PrivateLink, which enables you to privately access Lambda APIs 
without an internet gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances 
in your VPC don't need public IP addresses to communicate with Lambda APIs. Traﬃc between your VPC 
and Lambda does not leave the AWS network.
Each interface endpoint is represented by one or more elastic network interfaces in your subnets. A 
network interface provides a private IP address that serves as an entry point for traﬃc to Lambda.
Sections
•Considerations for Lambda interface endpoints (p. 92)
•Creating an interface endpoint for Lambda (p. 93)
•Creating an interface endpoint policy for Lambda (p. 94)
Considerations for Lambda interface endpoints
Before you set up an interface endpoint for Lambda, be sure to review Interface endpoint properties and 
limitations  in the Amazon VPC User Guide .
You can call any of the Lambda API operations from your VPC. For example, you can invoke the Lambda 
function by calling the Invoke API from within your VPC. For the full list of Lambda APIs, see Actions in 
the Lambda API reference.
use1-az3  is a limited capacity Region for Lambda VPC functions. You shouldn't use subnets in this 
availability zone with your Lambda functions because this can result in reduced zonal redundancy in the 
event of an outage.
Keep-alive for persistent connections
Lambda purges idle connections over time, so you must use a keep-alive directive to maintain persistent 
connections. Attempting to reuse an idle connection when invoking a function results in a connection 
error. To maintain your persistent connection, use the keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js in the AWS SDK for JavaScript 
Developer Guide .
Billing Considerations
There is no additional cost to access a Lambda function through an interface endpoint. For more Lambda 
pricing information, see AWS Lambda Pricing.
Standard pricing for AWS PrivateLink applies to interface endpoints for Lambda. Your AWS account 
is billed for every hour an interface endpoint is provisioned in each Availability Zone and for data 
processed through the interface endpoint. For more interface endpoint pricing information, see AWS 
PrivateLink pricing .
92AWS Lambda Developer Guide
Creating an interface endpoint for Lambda
VPC Peering Considerations
You can connect other VPCs to the VPC with interface endpoints using VPC peering . VPC peering is 
a networking connection between two VPCs. You can establish a VPC peering connection between 
your own two VPCs, or with a VPC in another AWS account. The VPCs can also be in two diﬀerent AWS 
Regions.
Traﬃc between peered VPCs stays on the AWS network and does not traverse the public internet. 
Once VPCs are peered, resources like Amazon Elastic Compute Cloud (Amazon EC2) instances, Amazon 
Relational Database Service (Amazon RDS) instances, or VPC-enabled Lambda functions in both VPCs can 
access the Lambda API through interface endpoints created in the one of the VPCs.
Creating an interface endpoint for Lambda
You can create an interface endpoint for Lambda using either the Amazon VPC console or the AWS 
Command Line Interface (AWS CLI). For more information, see Creating an interface endpoint in the
Amazon VPC User Guide .
To create an interface endpoint for Lambda (console)
1. Open the Endpoints page  of the Amazon VPC console.
2. Choose Create Endpoint .
3. For Service category, verify that AWS services is selected.
4. For Service Name, choose com.amazonaws.region .lambda . Verify that the Type is Interface.
5. Choose a VPC and subnets.
6. To enable private DNS for the interface endpoint, select the Enable DNS Name check box.
7. For Security group, choose one or more security groups.
8. Choose Create endpoint .
To use the private DNS option, you must set the enableDnsHostnames  and
enableDnsSupportattributes  of your VPC. For more information, see Viewing and updating 
DNS support for your VPC in the Amazon VPC User Guide . If you enable private DNS for the interface 
endpoint, you can make API requests to Lambda using its default DNS name for the Region, for example,
lambda.us-east-1.amazonaws.com . For more service endpoints, see Service endpoints and quotas in 
the AWS General Reference.
For more information, see Accessing a service through an interface endpoint in the Amazon VPC User 
Guide .
For information about creating and conﬁguring an endpoint using AWS CloudFormation, see the
AWS::EC2::VPCEndpoint resource in the AWS CloudFormation User Guide.
To create an interface endpoint for Lambda (AWS CLI)
Use the create-vpc-endpoint  command and specify the VPC ID, VPC endpoint type (interface), 
service name, subnets that will use the endpoint, and security groups to associate with the endpoint's 
network interfaces. For example:
aws ec2 create-vpc-endpoint --vpc-id vpc-ec43eb89 --vpc-endpoint-type Interface --service-
name \ 
   com.amazonaws.us-east-1.lambda --subnet-id subnet-abababab --security-group-id 
 sg-1a2b3c4d       
     
93AWS Lambda Developer Guide
Creating an interface endpoint policy for Lambda
Creating an interface endpoint policy for Lambda
To control who can use your interface endpoint and which Lambda functions the user can access, you can 
attach an endpoint policy to your endpoint. The policy speciﬁes the following information:
•The principal that can perform actions.
•The actions that the principal can perform.
•The resources on which the principal can perform actions.
For more information, see Controlling access to services with VPC endpoints in the Amazon VPC User 
Guide .
Example: Interface endpoint policy for Lambda actions
The following is an example of an endpoint policy for Lambda. When attached to an endpoint, this policy 
allows user MyUser to invoke the function my-function .
Note
You need to include both the qualiﬁed and the unqualiﬁed function ARN in the resource.
{ 
   "Statement":[ 
      { 
         "Principal": 
         {  
             "AWS": "arn:aws:iam::111122223333:user/MyUser"  
         }, 
         "Effect":"Allow", 
         "Action":[ 
            "lambda:InvokeFunction" 
         ], 
         "Resource": [ 
               "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
               "arn:aws:lambda:us-east-2:123456789012:function:my-function:*" 
            ] 
      } 
   ]
}
94AWS Lambda Developer Guide
Database proxy
Conﬁguring database access for a Lambda 
function
You can create an Amazon RDS Proxy database proxy for your function. A database proxy manages a 
pool of database connections and relays queries from a function. With a proxy, high concurrency (p. 11)
levels can be achieved without exhausting database connections.
Sections
•Creating a database proxy (console) (p. 95)
•Using the function's permissions for authentication (p. 96)
•Sample application  (p. 96)
Creating a database proxy (console)
You can use the Lambda console to create an Amazon RDS Proxy database proxy.
To create a database proxy
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Database proxies.
4. Choose Add database proxy.
5. Conﬁgure the following options.
•Proxy identiﬁer – The name of the proxy.
•RDS DB instance – A supported MySQL or PostgreSQL DB instance or cluster.
•Secret  – A Secrets Manager secret with the database user name and password.
Example secret
{ 
    "username": "admin", 
    "password": "e2abcecxmpldc897" 
  }
•IAM role – An IAM role with permission to use the secret, and a trust policy that allows Amazon 
RDS to assume the role.
•Authentication  – The authentication and authorization method for connecting to the proxy from 
your function code.
6. Choose Add.
Pricing
Amazon RDS charges a hourly price for proxies that is determined by the instance size of your 
database. For details, see RDS Proxy pricing.
Proxy creation takes a few minutes. When the proxy is available, conﬁgure your function to connect to 
the proxy endpoint instead of the database endpoint.
Standard Amazon RDS Proxy pricing applies. For more information, see Managing connections with the 
Amazon RDS Proxy in the Amazon Aurora User Guide.
95AWS Lambda Developer Guide
Using the function's permissions for authentication
Using the function's permissions for authentication
By default, you can connect to a proxy with the same username and password that it uses to connect to 
the database. The only diﬀerence in your function code is the endpoint that the database client connects 
to. The drawback of this method is that you must expose the password to your function code, either by 
conﬁguring it in a secure environment variable or by retrieving it from Secrets Manager.
You can create a database proxy that uses the function's IAM credentials for authentication and 
authorization instead of a password. To use the function's permissions to connect to the proxy, set
Authentication  to Execution role.
The Lambda console adds the required permission (rds-db:connect ) to the execution role. You can 
then use the AWS SDK to generate a token that allows it to connect to the proxy. The following example 
shows how to conﬁgure a database connection with the mysql2 library in Node.js.
Example dbadmin/index-iam.js  – AWS SDK signer
const signer = new AWS.RDS.Signer({ 
  region: region, 
  hostname: host, 
  port: sqlport, 
  username: username
})
exports.handler = async (event) => { 
  let connectionConfig = { 
    host     : host, 
    user     : username, 
    database : database, 
    ssl: 'Amazon RDS', 
     authPlugins: { mysql_clear_password: () => () => signer.getAuthToken() }
  } 
  var connection = mysql.createConnection(connectionConfig) 
  var query = event.query 
  var result 
  connection.connect()
}
For more information, see IAM database authentication  in the Amazon RDS User Guide.
Sample application
Sample applications that demonstrate the use of Lambda with an Amazon RDS database are available in 
this guide's GitHub repository. There are two applications:
•RDS MySQL – The AWS CloudFormation template template-vpcrds.yml  creates a MySQL 5.7 
database in a private VPC. In the sample application, a Lambda function proxies queries to the 
database. The function and database templates both use Secrets Manager to access database 
credentials.
96AWS Lambda Developer Guide
Sample application
•List Manager  – A processor function reads events from a Kinesis stream. It uses the data from the 
events to update DynamoDB tables, and stores a copy of the event in a MySQL database.
97AWS Lambda Developer Guide
Sample application
To use the sample applications, follow the instructions in the GitHub repository: RDS MySQL, List 
Manager .
98AWS Lambda Developer Guide
File system
Conﬁguring ﬁle system access for Lambda 
functions
You can conﬁgure a function to mount an Amazon Elastic File System (Amazon EFS) ﬁle system to a local 
directory. With Amazon EFS, your function code can access and modify shared resources safely and at 
high concurrency.
Sections
•Execution role and user permissions (p. 99)
•Conﬁguring a ﬁle system and access point (p. 99)
•Connecting to a ﬁle system (console) (p. 100)
•Conﬁguring ﬁle system access with the Lambda API (p. 101)
•AWS CloudFormation and AWS SAM (p. 101)
•Sample applications  (p. 103)
Execution role and user permissions
If the ﬁle system doesn't have a user-conﬁgured AWS Identity and Access Management (IAM) policy, EFS 
uses a default policy that grants full access to any client that can connect to the ﬁle system using a ﬁle 
system mount target. If the ﬁle system has a user-conﬁgured IAM policy, your function's execution role 
must have the correct elasticfilesystem  permissions.
Execution role permissions
•elasticﬁlesystem:ClientMount
•elasticﬁlesystem:ClientWrite (not required for read-only connections)
These permissions are included in the AmazonElasticFileSystemClientReadWriteAccess managed policy. 
Additionally, your execution role must have the permissions required to connect to the ﬁle system's 
VPC (p. 86).
When you conﬁgure a ﬁle system, Lambda uses your permissions to verify mount targets. To conﬁgure a 
function to connect to a ﬁle system, your user needs the following permissions:
User permissions
•elasticﬁlesystem:DescribeMountTargets
Conﬁguring a ﬁle system and access point
Create a ﬁle system in Amazon EFS with a mount target in every Availability Zone that your function 
connects to. For performance and resilience, use at least two Availability Zones. For example, in a simple 
conﬁguration you could have a VPC with two private subnets in separate Availability Zones. The function 
connects to both subnets and a mount target is available in each. Ensure that NFS traﬃc (port 2049) is 
allowed by the security groups used by the function and mount targets.
Note
When you create a ﬁle system, you choose a performance mode that can't be changed later.
General purpose  mode has lower latency, and Max I/O  mode supports a higher maximum 
throughput and IOPS. For help choosing, see Amazon EFS performance in the Amazon Elastic 
File System User Guide.
99AWS Lambda Developer Guide
Connecting to a ﬁle system (console)
An access point connects each instance of the function to the right mount target for the Availability 
Zone it connects to. For best performance, create an access point with a non-root path, and limit the 
number of ﬁles that you create in each directory. The following example creates a directory named my-
function  on the ﬁle system and sets the owner ID to 1001 with standard directory permissions (755).
Example access point conﬁguration
•Name  – files
•User ID  – 1001
•Group ID  – 1001
•Path – /my-function
•Permissions – 755
•Owner user ID  – 1001
•Group user ID  – 1001
When a function uses the access point, it is given user ID 1001 and has full access to the directory.
For more information, see the following topics in the Amazon Elastic File System User Guide:
•Creating resources for Amazon EFS
•Working with users, groups, and permissions
Connecting to a ﬁle system (console)
A function connects to a ﬁle system over the local network in a VPC. The subnets that your function 
connects to can be the same subnets that contain mount points for your ﬁle system, or subnets in the 
same Availability Zone that can route NFS traﬃc (port 2049) to the ﬁle system.
Note
If your function is not already connected to a VPC, see Connecting outbound networking to 
resources in a VPC (p. 85).
To conﬁgure ﬁle system access
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose File systems.
4. Under File system, choose Add ﬁle system.
5. Conﬁgure the following properties:
•EFS ﬁle system – The access point for a ﬁle system in the same VPC.
•Local mount path  – The location where the ﬁle system is mounted on the Lambda function, 
starting with /mnt/ .
Pricing
Amazon EFS charges for storage and throughput, with rates that vary by storage class. For 
details, see Amazon EFS pricing.
Lambda charges for data transfer between VPCs. This only applies if your function's VPC is 
peered to another VPC with a ﬁle system. The rates are the same as for Amazon EC2 data 
transfer between VPCs in the same Region. For details, see Lambda pricing .
For more information about Lambda's integration with Amazon EFS, see Using Amazon EFS with 
Lambda  (p. 738).
100AWS Lambda Developer Guide
Conﬁguring ﬁle system access with the Lambda API
Conﬁguring ﬁle system access with the Lambda API
Use the following API operations to connect your Lambda function to a ﬁle system:
•CreateFunction (p. 1304 )
•UpdateFunctionConﬁguration (p. 1516 )
To connect a function to a ﬁle system, use the update-function-configuration  command. The 
following example connects a function named my-function  to a ﬁle system with ARN of an access 
point.
ARN=arn:aws:elasticfilesystem: us-east-2 :123456789012 :access-point/fsap- 015cxmplb72b405fd
aws lambda update-function-configuration --function-name my-function \ 
      --file-system-configs Arn=$ARN,LocalMountPath= /mnt/efs0
You can get the ARN of a ﬁle system's access point with the describe-access-points  command.
aws efs describe-access-points
You should see the following output:
{ 
    "AccessPoints": [ 
        { 
            "ClientToken": "console-aa50c1fd-xmpl-48b5-91ce-57b27a3b1017", 
            "Name": "lambda-ap", 
            "Tags": [ 
                { 
                    "Key": "Name", 
                    "Value": "lambda-ap" 
                } 
            ], 
            "AccessPointId": "fsap-015cxmplb72b405fd", 
            "AccessPointArn": "arn:aws:elasticfilesystem:us-east-2:123456789012:access-
point/fsap-015cxmplb72b405fd", 
            "FileSystemId": "fs-aea3xmpl", 
            "RootDirectory": { 
                "Path": "/" 
            }, 
            "OwnerId": "123456789012", 
            "LifeCycleState": "available" 
        } 
    ]
}
AWS CloudFormation and AWS SAM
You can use AWS CloudFormation and the AWS Serverless Application Model (AWS SAM) to 
automate the creation of Lambda applications. To enable a ﬁle system connection on an AWS SAM
AWS::Serverless::Function  resource, use the FileSystemConfigs  property.
Example template.yml – File system conﬁguration
Transform: AWS::Serverless-2016-10-31
Resources: 
101AWS Lambda Developer Guide
AWS CloudFormation and AWS SAM
  VPC: 
    Type: AWS::EC2::VPC 
    Properties: 
      CidrBlock: 10.0.0.0/16 
  Subnet1: 
    Type: AWS::EC2::Subnet 
    Properties: 
      VpcId: 
        Ref: VPC 
      CidrBlock: 10.0.1.0/24 
      AvailabilityZone: "us-west-2a"
  EfsSecurityGroup: 
    Type: AWS::EC2::SecurityGroup 
    Properties: 
      VpcId: 
        Ref: VPC 
      GroupDescription: "mnt target sg" 
      SecurityGroupIngress: 
      - IpProtocol: -1 
        CidrIp: "0.0.0.0/0" 
  FileSystem: 
    Type: AWS::EFS::FileSystem 
    Properties: 
      PerformanceMode: generalPurpose 
  AccessPoint: 
    Type: AWS::EFS::AccessPoint 
    Properties: 
      FileSystemId: 
        Ref: FileSystem 
      PosixUser: 
        Uid: "1001" 
        Gid: "1001" 
      RootDirectory: 
        CreationInfo: 
          OwnerGid: "1001" 
          OwnerUid: "1001" 
          Permissions: "755" 
  MountTarget1: 
    Type: AWS::EFS::MountTarget 
    Properties: 
      FileSystemId: 
        Ref: FileSystem 
      SubnetId: 
        Ref: Subnet1 
      SecurityGroups: 
      - Ref: EfsSecurityGroup 
  MyFunctionWithEfs: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler 
      Runtime: python3.10 
      VpcConfig: 
        SecurityGroupIds: 
        - Ref: EfsSecurityGroup 
        SubnetIds: 
        - Ref: Subnet1 
      FileSystemConfigs: 
      - Arn: !GetAtt AccessPoint.Arn 
        LocalMountPath: "/mnt/efs" 
      Description: Use a file system. 
    DependsOn: "MountTarget1"  
       
You must add the DependsOn  to ensure that the mount targets are fully created before the Lambda runs 
for the ﬁrst time.
102AWS Lambda Developer Guide
Sample applications
For the AWS CloudFormation AWS::Lambda::Function  type, the property name and ﬁelds are the 
same. For more information, see Using AWS Lambda with AWS CloudFormation (p. 670).
Sample applications
The GitHub repository for this guide includes a sample application that demonstrates the use of Amazon 
EFS with a Lambda function.
•efs-nodejs  – A function that uses an Amazon EFS ﬁle system in a Amazon VPC. This sample includes a 
VPC, ﬁle system, mount targets, and access point conﬁgured for use with Lambda.
103AWS Lambda Developer Guide
Aliases
Lambda function aliases
You can create one or more aliases for your Lambda function. A Lambda alias is like a pointer to a 
speciﬁc function version. Users can access the function version using the alias Amazon Resource Name 
(ARN).
Sections
•Creating a function alias (Console) (p. 104)
•Managing aliases with the Lambda API  (p. 104)
•Managing aliases with AWS SAM and AWS CloudFormation (p. 105)
•Using aliases  (p. 105)
•Resource policies (p. 105)
•Alias routing conﬁguration (p. 105)
Creating a function alias (Console)
You can create a function alias using the Lambda console.
To create an alias
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Aliases  and then choose Create alias .
4. On the Create alias  page, do the following:
a. Enter a Name  for the alias.
b. (Optional) Enter a Description  for the alias.
c. For Version, choose a function version that you want the alias to point to.
d. (Optional) To conﬁgure routing on the alias, expand Weighted alias. For more information, see
Alias routing conﬁguration (p. 105).
e. Choose Save.
Managing aliases with the Lambda API
To create an alias using the AWS Command Line Interface (AWS CLI), use the create-alias  command.
aws lambda create-alias --function-name my-function  --name alias-name  --function-
version version-number  --description " "
To change an alias to point a new version of the function, use the update-alias  command.
aws lambda update-alias --function-name my-function  --name alias-name  --function-
version version-number  
To delete an alias, use the delete-alias  command.
aws lambda delete-alias --function-name my-function  --name alias-name  
The AWS CLI commands in the preceding steps correspond to the following Lambda API operations:
104AWS Lambda Developer Guide
Managing aliases with AWS SAM and AWS CloudFormation
•CreateAlias (p. 1285 )
•UpdateAlias  (p. 1488 )
•DeleteAlias  (p. 1321 )
Managing aliases with AWS SAM and AWS 
CloudFormation
You can create and manage function aliases using the AWS Serverless Application Model (AWS SAM) and 
AWS CloudFormation.
To see how to declare a function alias in an AWS SAM template, refer to the AWS::Serverless::Function
page in the AWS SAM Developer Guide. For information on creating and conﬁguring aliases using AWS 
CloudFormation, see AWS::Lambda::Alias in the AWS CloudFormation User Guide.
Using aliases
Each alias has a unique ARN. An alias can point only to a function version, not to another alias. You can 
update an alias to point to a new version of the function.
Event sources such as Amazon Simple Storage Service (Amazon S3) invoke your Lambda function. These 
event sources maintain a mapping that identiﬁes the function to invoke when events occur. If you specify 
a Lambda function alias in the mapping conﬁguration, you don't need to update the mapping when the 
function version changes. For more information, see Lambda event source mappings (p. 150).
In a resource policy, you can grant permissions for event sources to use your Lambda function. If you 
specify an alias ARN in the policy, you don't need to update the policy when the function version 
changes.
Resource policies
You can use a resource-based policy (p. 929) to give a service, resource, or account access to your 
function. The scope of that permission depends on whether you apply it to an alias, a version, or the 
entire function. For example, if you use an alias name (such as helloworld:PROD ), the permission 
allows you to invoke the helloworld  function using the alias ARN (helloworld:PROD ).
If you attempt to invoke the function without an alias or a speciﬁc version, then you get a permission 
error. This permission error still occurs even if you attempt to directly invoke the function version 
associated with the alias.
For example, the following AWS CLI command grants Amazon S3 permissions to invoke the PROD alias 
of the helloworld  function when Amazon S3 is acting on behalf of examplebucket .
aws lambda add-permission --function-name helloworld \
--qualifier PROD --statement-id 1 --principal s3.amazonaws.com --action 
 lambda:InvokeFunction \
--source-arn arn:aws:s3:::examplebucket --source-account 123456789012 
For more information about using resource names in policies, see Resources and conditions for Lambda 
actions (p. 935).
Alias routing conﬁguration
Use routing conﬁguration on an alias to send a portion of traﬃc to a second function version. For 
example, you can reduce the risk of deploying a new version by conﬁguring the alias to send most of the 
traﬃc to the existing version, and only a small percentage of traﬃc to the new version.
105AWS Lambda Developer Guide
Alias routing conﬁguration
Note that Lambda uses a simple probabilistic model to distribute the traﬃc between the two function 
versions. At low traﬃc levels, you might see a high variance between the conﬁgured and actual 
percentage of traﬃc on each version. If your function uses provisioned concurrency, you can avoid
spillover invocations (p. 966) by conﬁguring a higher number of provisioned concurrency instances 
during the time that alias routing is active.
You can point an alias to a maximum of two Lambda function versions. The versions must meet the 
following criteria:
•Both versions must have the same execution role (p. 913).
•Both versions must have the same dead-letter queue (p. 148) conﬁguration, or no dead-letter queue 
conﬁguration.
•Both versions must be published. The alias cannot point to $LATEST .
To conﬁgure routing on an alias
Note
Verify that the function has at least two published versions. To create additional versions, follow 
the instructions in Lambda function versions (p. 108).
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Aliases  and then choose Create alias .
4. On the Create alias  page, do the following:
a. Enter a Name  for the alias.
b. (Optional) Enter a Description  for the alias.
c. For Version, choose the ﬁrst function version that you want the alias to point to.
d. Expand Weighted alias.
e. For Additional version, choose the second function version that you want the alias to point to.
f.For Weight (%), enter a weight value for the function. Weight is the percentage of traﬃc that is 
assigned to that version when the alias is invoked. The ﬁrst version receives the residual weight. 
For example, if you specify 10 percent to Additional version, the ﬁrst version is assigned 90 
percent automatically.
g. Choose Save.
Conﬁguring alias routing using CLI
Use the create-alias  and update-alias  AWS CLI commands to conﬁgure the traﬃc weights 
between two function versions. When you create or update the alias, you specify the traﬃc weight in the
routing-config  parameter.
The following example creates a Lambda function alias named routing-alias  that points to version 1 
of the function. Version 2 of the function receives 3 percent of the traﬃc. The remaining 97 percent of 
traﬃc is routed to version 1.
aws lambda create-alias --name routing-alias --function-name my-function --function-version 
 1  \
--routing-config AdditionalVersionWeights={"2"=0.03}
Use the update-alias  command to increase the percentage of incoming traﬃc to version 2. In the 
following example, you increase the traﬃc to 5 percent.
aws lambda update-alias --name routing-alias --function-name my-function  \
106AWS Lambda Developer Guide
Alias routing conﬁguration
--routing-config AdditionalVersionWeights={"2"=0.05}
To route all traﬃc to version 2, use the update-alias  command to change the function-version
property to point the alias to version 2. The command also resets the routing conﬁguration.
aws lambda update-alias --name routing-alias --function-name my-function  \
--function-version 2 --routing-config AdditionalVersionWeights={}
The AWS CLI commands in the preceding steps correspond to the following Lambda API operations:
•CreateAlias (p. 1285 )
•UpdateAlias  (p. 1488 )
Determining which version has been invoked
When you conﬁgure traﬃc weights between two function versions, there are two ways to determine the 
Lambda function version that has been invoked:
•CloudWatch Logs – Lambda automatically emits a START log entry that contains the invoked version 
ID to Amazon CloudWatch Logs for every function invocation. The following is an example:
19:44:37 START RequestId: request id  Version: $ version
For alias invocations, Lambda uses the Executed Version  dimension to ﬁlter the metric data by the 
invoked version. For more information, see Working with Lambda function metrics (p. 965).
•Response payload (synchronous invocations) – Responses to synchronous function invocations 
include an x-amz-executed-version  header to indicate which function version has been invoked.
107AWS Lambda Developer Guide
Versions
Lambda function versions
You can use versions to manage the deployment of your functions. For example, you can publish a new 
version of a function for beta testing without aﬀecting users of the stable production version. Lambda 
creates a new version of your function each time that you publish the function. The new version is a copy 
of the unpublished version of the function. The unpublished version is named $LATEST.
Note
Lambda doesn't create a new version if the code in the unpublished version is the same as the 
previous published version. You need to deploy code changes in $LATEST before you can create 
a new version.
A function version includes the following information:
•The function code and all associated dependencies.
•The Lambda runtime identiﬁer and runtime version used by the function.
•All the function settings, including the environment variables.
•A unique Amazon Resource Name (ARN) to identify the speciﬁc version of the function.
When using runtime management controls with Auto  mode, the runtime version used by the function 
version is updated automatically. When using Function update or Manual  mode, the runtime version is 
not updated. For more information, see the section called “Runtime updates” (p. 45).
Sections
•Creating function versions (p. 108)
•Using versions (p. 109)
•Granting permissions  (p. 109)
Creating function versions
You can change the function code and settings only on the unpublished version of a function. When you 
publish a version, Lambda locks the code and most of the settings to maintain a consistent experience 
for users of that version. For more information about conﬁguring function settings, see Conﬁguring 
Lambda function options (p. 72).
You can create a function version using the Lambda console.
To create a new function version
1. Open the Functions page of the Lambda console.
2. Choose a function and then choose Versions.
3. On the versions conﬁguration page, choose Publish new version.
4. (Optional) Enter a version description.
5. Choose Publish .
Alternatively, you can publish a version of a function using the PublishVersion (p. 1454 ) API operation.
The following AWS CLI command publishes a new version of a function. The response returns 
conﬁguration information about the new version, including the version number and the function ARN 
with the version suﬃx.
aws lambda publish-version --function-name my-function
108AWS Lambda Developer Guide
Using versions
You should see the following output:
{ 
  "FunctionName": "my-function", 
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1", 
  "Version": "1", 
  "Role": "arn:aws:iam::123456789012:role/lambda-role", 
  "Handler": "function.handler", 
  "Runtime": "nodejs18.x", 
  ...
}
Note
Lambda assigns monotonically increasing sequence numbers for versioning. Lambda never 
reuses version numbers, even after you delete and recreate a function.
Using versions
You can reference your Lambda function using either a qualiﬁed ARN or an unqualiﬁed ARN.
•Qualiﬁed ARN  – The function ARN with a version suﬃx. The following example refers to version 42 of 
the helloworld  function.
arn:aws:lambda:aws-region:acct-id:function:helloworld:42
•Unqualiﬁed ARN  – The function ARN without a version suﬃx.
arn:aws:lambda:aws-region:acct-id:function:helloworld
You can use a qualiﬁed or an unqualiﬁed ARN in all relevant API operations. However, you can't use an 
unqualiﬁed ARN to create an alias.
If you decide not to publish function versions, you can invoke the function using either the qualiﬁed 
or unqualiﬁed ARN in your event source mapping (p. 150). When you invoke a function using an 
unqualiﬁed ARN, Lambda implicitly invokes $LATEST.
Lambda publishes a new function version only if the code has never been published or if the code has 
changed from the last published version. If there is no change, the function version remains at the last 
published version.
The qualiﬁed ARN for each Lambda function version is unique. After you publish a version, you can't 
change the ARN or the function code.
Granting permissions
You can use a resource-based policy (p. 929) or an identity-based policy (p. 920) to grant access to 
your function. The scope of the permission depends on whether you apply the policy to a function or to 
one version of a function. For more information about function resource names in policies, see Resources 
and conditions for Lambda actions (p. 935).
You can simplify the management of event sources and AWS Identity and Access Management (IAM) 
policies by using function aliases. For more information, see Lambda function aliases (p. 104).
109AWS Lambda Developer Guide
Response streaming
Conﬁguring a Lambda function to stream 
responses
You can conﬁgure your Lambda function URLs to stream response payloads back to clients. Response 
streaming can beneﬁt latency sensitive applications by improving time to ﬁrst byte (TTFB) performance. 
This is because you can send partial responses back to the client as they become available. Additionally, 
you can use response streaming to build functions that return larger payloads. Response stream 
payloads have a soft limit of 20 MB as compared to the 6 MB limit for buﬀered responses. Streaming a 
response also means that your function doesn’t need to ﬁt the entire response in memory. For very large 
responses, this can reduce the amount of memory you need to conﬁgure for your function.
The speed at which Lambda streams your responses depends on the response size. The streaming rate 
for the ﬁrst 6MB of your function’s response is uncapped. For responses larger than 6MB, the remainder 
of the response is subject to a bandwidth cap. For more information on streaming bandwidth, see
Bandwidth limits for response streaming (p. 112).
Streaming responses incurs a cost. For more information, see AWS Lambda Pricing.
Currently, Lambda supports response streaming only on Node.js 14.x , Node.js 16.x , and Node.js 
18.x managed runtimes. You can also use a custom runtime with a custom Runtime API integration to 
stream responses or use the Lambda Web Adapter. You can stream responses through Lambda Function 
URLs , the AWS SDK, or using the Lambda InvokeWithResponseStream API.
Note
When testing your function through the Lambda console, you'll always see responses as 
buﬀered.
Writing response streaming-enabled functions
Writing the handler for response streaming functions is diﬀerent than typical handler patterns. When 
writing streaming functions, be sure to do the following:
•Wrap your function with the awslambda.streamifyResponse()  decorator that the native Node.js 
runtimes provide.
•End the stream gracefully to ensure that all data processing is complete.
Conﬁguring a handler function to stream responses
To indicate to the runtime that Lambda should stream your function's responses, you must wrap your 
function with the streamifyResponse()  decorator. This tells the runtime to use the proper logic path 
for streaming responses and enables the function to stream responses.
The streamifyResponse()  decorator accepts a function that accepts the following parameters:
•event – Provides information about the function URL's invocation event, such as the HTTP method, 
query parameters, and the request body.
•responseStream  – Provides a writable stream.
•context – Provides methods and properties with information about the invocation, function, and 
execution environment.
The responseStream  object is a Node.js writableStream . As with any such stream, you should use 
the pipeline()  method.
110AWS Lambda Developer Guide
Invoking a response streaming enabled 
function using Lambda function URLs
Example response streaming-enabled handler
const pipeline = require("util").promisify(require("stream").pipeline);
const { Readable } = require('stream');
exports.echo = awslambda.streamifyResponse(async (event, responseStream, _context) => { 
  // As an example, convert event to a readable stream. 
  const requestStream = Readable.from(Buffer.from(JSON.stringify(event))); 
  await pipeline(requestStream, responseStream);
});
While responseStream  oﬀers the write() method to write to the stream, we recommend that 
you use pipeline()  wherever possible. Using pipeline()  ensures that the writable stream is not 
overwhelmed by a faster readable stream.
Ending the stream
Make sure that you properly end the stream before the handler returns. The pipeline()  method 
handles this automatically.
For other use cases, call the responseStream.end()  method to properly end a stream. This method 
signals that no more data should be written to the stream. This method isn't required if you write to the 
stream with pipeline()  or pipe() .
Example Example ending a stream with pipeline()
const pipeline = require("util").promisify(require("stream").pipeline);
exports.handler = awslambda.streamifyResponse(async (event, responseStream, _context) => { 
  await pipeline(requestStream, responseStream);
});
Example Example ending a stream without pipeline()
exports.handler = awslambda.streamifyResponse(async (event, responseStream, _context) => { 
  responseStream.write("Hello "); 
  responseStream.write("world "); 
  responseStream.write("from "); 
  responseStream.write("Lambda!"); 
  responseStream.end();
});
Invoking a response streaming enabled function 
using Lambda function URLs
Note
You must invoke your function using a function URL to stream the responses.
You can invoke response streaming enabled functions by changing the invoke mode of your function's 
URL. The invoke mode determines which API operation Lambda uses to invoke your function. The 
available invoke modes are:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API operation. 
Invocation results are available when the payload is complete. The maximum payload size is 6 MB.
111AWS Lambda Developer Guide
Bandwidth limits for response streaming
•RESPONSE_STREAM  – Enables your function to stream payload results as they become available. 
Lambda invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB. However, you can request a quota increase.
You can still invoke your function without response streaming by directly calling the Invoke  API 
operation. However, Lambda streams all response payloads for invocations that come through the 
function's URL until you change the invoke mode to BUFFERED .
To set the invoke mode of a function URL (console)
1.
Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to set the invoke mode for.
3. Choose the Conﬁguration  tab, and then choose Function URL.
4. Choose Edit, then choose Additional settings.
5. Under Invoke mode, choose your desired invoke mode.
6. Choose Save.
To set the invoke mode of a function's URL (AWS CLI)
aws lambda update-function-url-config --function-name my-function  --invoke-mode 
 RESPONSE_STREAM
To set the invoke mode of a function's URL (AWS CloudFormation)
MyFunctionUrl: 
  Type: AWS::Lambda::Url 
  Properties: 
    AuthType: AWS_IAM 
    InvokeMode: RESPONSE_STREAM
For more information about conﬁguring function URLs, see Lambda function URLs (p. 189).
Bandwidth limits for response streaming
The ﬁrst 6MB of your function’s response payload has uncapped bandwidth. After this initial burst, 
Lambda streams your response at a maximum rate of 2MBps. If your function responses never exceed 
6MB, then this bandwidth limit never applies.
Note
Bandwidth limits only apply to your function’s response payload, and not to network access by 
your function.
The rate of uncapped bandwidth varies depending on a number of factors, including your function’s 
processing speed. You can normally expect a rate higher than 2MBps for the ﬁrst 6MB of your function’s 
response. If your function is streaming a response to a destination outside of AWS, the streaming rate 
also depends on the speed of the external internet connection.
Tutorial: Creating a response streaming Lambda 
function with a function URL
In this tutorial, you create a Lambda function deﬁned as a .zip ﬁle archive with a public function URL 
endpoint that returns a response stream. For more information about conﬁguring function URLs, see
Creating and managing function URLs (p. 190).
112AWS Lambda Developer Guide
Tutorial: Creating a response streaming 
function with a function URL
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create an execution role
Create the execution role (p. 913) that gives your Lambda function permission to access AWS resources.
To create an execution role
1. Open the Roles page of the AWS Identity and Access Management (IAM) console.
2. Choose Create role.
3. Create a role with the following properties:
•Trusted entity type – AWS service
•Use case  – Lambda
•Permissions – AWSLambdaBasicExecutionRole
•Role name – response-streaming-role
The AWSLambdaBasicExecutionRole policy has the permissions that the function needs to write logs to 
Amazon CloudWatch Logs.
Create a response streaming function (AWS CLI)
Create a response streaming Lambda function with a function URL endpoint using the AWS Command 
Line Interface (AWS CLI).
To create a function that can stream responses
1. Copy the following code example into a ﬁle named index.js .
import util from 'util';
113AWS Lambda Developer Guide
Tutorial: Creating a response streaming 
function with a function URL
import stream from 'stream';
const { Readable } = stream;
const pipeline = util.promisify(stream.pipeline);
/* global awslambda */
export const handler = awslambda.streamifyResponse(async (event, responseStream, 
 _context) => { 
  const requestStream = Readable.from(Buffer.from(JSON.stringify(event))); 
  await pipeline(requestStream, responseStream);
});
2. Create a deployment package.
zip function.zip index.js
3. Create a Lambda function with the create-function  command.
aws lambda create-function \ 
  --function-name my-streaming-function \ 
  --runtime nodejs14.x \ 
  --zip-file fileb://function.zip \ 
  --handler index.handler \ 
  --role arn:aws:iam::123456789012:role/response-streaming-role
To create a function URL
1. Add a resource-based policy to your function to allow public access to your function URL.
aws lambda add-permission 
  --function-name my-streaming-function \ 
  --action lambda:InvokeFunctionUrl \ 
  --statement-id 12345 \ 
  --principal "*" \ 
  --function-url-auth-type AWS_IAM \ 
  --statement-id url
2. Create a URL endpoint for the function with the create-function-url-config  command.
aws lambda create-function-url-config \ 
  --function-name my-streaming-function \ 
  --auth-type AWS_IAM \ 
  --invoke-mode RESPONSE_STREAM 
Create a response streaming function (AWS CloudFormation)
You can also create a streaming function conﬁgured with a function URL using AWS CloudFormation.
Resources: 
  MyStreamingFunction: 
    Type: AWS::Lambda::Function 
    Properties: 
      Handler: index.handler 
      Runtime: nodejs14.x 
      Role: arn:aws:iam::123456789012:role/response-streaming-role 
      Code: 
        ZipFile: | 
            exports.handler = awslambda.streamifyResponse( 
                async (event, responseStream, _context) => { 
114AWS Lambda Developer Guide
Tutorial: Creating a response streaming 
function with a function URL
                    // Metadata is a JSON serializable JS object. Its shape is not defined 
 here. 
                    const metadata = { 
                    statusCode: 200, 
                    headers: { 
                        "Content-Type": "application/json", 
                        "CustomHeader": "outerspace" 
                    } 
                    }; 
                 
                    // Assign to the responseStream parameter to prevent accidental reuse 
 of the non-wrapped stream. 
                    responseStream = awslambda.HttpResponseStream.from(responseStream, 
 metadata); 
                 
                    responseStream.write("Streaming with Helper \n"); 
                    await new Promise(r => setTimeout(r, 1000)); 
                    responseStream.write("Hello 0 \n"); 
                    await new Promise(r => setTimeout(r, 1000)); 
                    responseStream.write("Hello 1 \n"); 
                    await new Promise(r => setTimeout(r, 1000)); 
                    responseStream.write("Hello 3 \n"); 
                    await new Promise(r => setTimeout(r, 1000)); 
                    responseStream.end(); 
                    await responseStream.finished(); 
                } 
              ); 
      Description: Create a streaming function configured with a URL. 
  MyStreamingFunctionPermissions: 
    Type: AWS::Lambda::Permission 
    Properties: 
      FunctionName: !Ref MyStreamingFunction 
      Action: lambda:InvokeFunctionUrl 
      Principal: "*" 
      FunctionUrlAuthType: AWS_IAM 
  MyStreamingFunctionUrl: 
    Type: AWS::Lambda::Url 
    Properties: 
      TargetFunctionArn: !Ref MyUrlFunction 
      AuthType: AWS_IAM 
      InvokeMode: RESPONSE_STREAM
Create a response streaming function (AWS SAM)
You can also create a streaming function conﬁgured with a function URL using AWS Serverless 
Application Model (AWS SAM).
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Resources: 
  StreamingFunction: 
    Type: AWS::Serverless::Function 
    Properties: 
      CodeUri: " <path-to-your-code> " 
      Handler: index.handler 
      Runtime: nodejs14.x 
      AutoPublishAlias: live 
  MyStreamingFunctionUrl: 
    Type: AWS::Lambda::Url 
    Properties: 
      TargetFunctionArn: !Ref StreamingFunction 
      AuthType: AWS_IAM 
      InvokeMode: RESPONSE_STREAM
115AWS Lambda Developer Guide
Tutorial: Creating a response streaming 
function with a function URL
Test the function URL endpoint
Test your integration by invoking your function. You can open your function's URL in a browser, or you 
can use curl.
curl --request GET " <your function url here> " --user " <key:token> " --aws-sigv4 "aws:amz:eu-
west-1:lambda" --no-buffer
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
116AWS Lambda Developer Guide
.zip ﬁle archives
Deploying Lambda functions
You can deploy code to your Lambda function by uploading a zip ﬁle archive, or by creating and 
uploading a container image.
.zip ﬁle archives
A .zip ﬁle archive includes your application code and its dependencies. When you author functions using 
the Lambda console or a toolkit, Lambda automatically creates a .zip ﬁle archive of your code.
When you create functions with the Lambda API, command line tools, or the AWS SDKs, you must create 
a deployment package. You also must create a deployment package if your function uses a compiled 
language, or to add dependencies to your function. To deploy your function's code, you upload the 
deployment package from Amazon Simple Storage Service (Amazon S3) or your local machine.
You can upload a .zip ﬁle as your deployment package using the Lambda console, AWS Command Line 
Interface (AWS CLI), or to an Amazon Simple Storage Service (Amazon S3) bucket.
Container images
You can package your code and dependencies as a container image using tools such as the Docker 
command line interface (CLI). You can then upload the image to your container registry hosted on 
Amazon Elastic Container Registry (Amazon ECR).
AWS provides a set of open-source base images that you can use to build the container image for 
your function code. You can also use alternative base images from other container registries. AWS 
also provides an open-source runtime client that you add to your alternative base image to make it 
compatible with the Lambda service.
Additionally, AWS provides a runtime interface emulator for you to test your functions locally using tools 
such as the Docker CLI.
Note
You create each container image to be compatible with one of the instruction set architectures 
that Lambda supports. Lambda provides base images for each of the instruction set 
architectures and Lambda also provides base images that support both architectures.
The image that you build for your function must target only one of the architectures.
There is no additional charge for packaging and deploying functions as container images. When a 
function deployed as a container image is invoked, you pay for invocation requests and execution 
duration. You do incur charges related to storing your container images in Amazon ECR. For more 
information, see Amazon ECR pricing.
Topics
•Deploying Lambda functions as .zip ﬁle archives (p. 118)
•Working with Lambda container images (p. 122)
•Testing Lambda container images locally (p. 127)
117AWS Lambda Developer Guide
.zip ﬁle archives
Deploying Lambda functions as .zip ﬁle archives
When you create a Lambda function, you package your function code into a deployment package. 
Lambda supports two types of deployment packages: container images (p. 18) and .zip ﬁle 
archives (p. 18). The workﬂow to create a function depends on the deployment package type. To 
conﬁgure a function deﬁned as a container image, see the section called “Container images” (p. 122).
You can use the Lambda console and the Lambda API to create a function deﬁned with a .zip ﬁle archive. 
You can also upload an updated .zip ﬁle to change the function code.
Note
You cannot convert an existing container image function (p. 122) to use a .zip ﬁle archive. You 
must create a new function.
Topics
•Creating the function (p. 118)
•Using the console code editor (p. 119)
•Updating function code (p. 119)
•Changing the runtime  (p. 120)
•Changing the architecture (p. 120)
•Using the Lambda API  (p. 74)
•AWS CloudFormation (p. 121)
Creating the function
When you create a function deﬁned with a .zip ﬁle archive, you choose a code template, the language 
version, and the execution role for the function. You add your function code after Lambda creates the 
function.
To create the function
1. Open the Functions page of the Lambda console.
2. Choose Create function.
3. Choose Author from scratch  or Use a blueprint  to create your function.
4. Under Basic information , do the following:
a. For Function name, enter the function name. Function names are limited to 64 characters in 
length.
b. For Runtime , choose the language version to use for your function.
c. (Optional) For Architecture, choose the instruction set architecture to use for your function. The 
default architecture is x86_64. When you build the deployment package for your function, make 
sure that it is compatible with this instruction set architecture (p. 33).
5. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing role.
6. (Optional) Expand Advanced settings. You can choose a Code signing conﬁguration for the 
function. You can also conﬁgure an (Amazon VPC) for the function to access.
7. Choose Create function.
Lambda creates the new function. You can now use the console to add the function code and conﬁgure 
other function parameters and features. For code deployment instructions, see the handler page for the 
runtime your function uses.
118AWS Lambda Developer Guide
Using the console code editor
Node.js
Deploy Node.js Lambda functions with .zip ﬁle archives (p. 281)
Python
Working with .zip ﬁle archives for Python Lambda functions (p. 352)
Ruby
Working with .zip ﬁle archives for Ruby Lambda functions (p. 406)
Java
Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446)
Go
Deploy Go Lambda functions with .zip ﬁle archives (p. 520)
C#
Deploy C# Lambda functions with .zip ﬁle archives (p. 566)
PowerShell
Deploy PowerShell Lambda functions with .zip ﬁle archives (p. 602)
Using the console code editor
The console creates a Lambda function with a single source ﬁle. For scripting languages, you can edit this 
ﬁle and add more ﬁles using the built-in code editor (p. 25). To save your changes, choose Save. Then, to 
run your code, choose Test.
Note
The Lambda console uses AWS Cloud9 to provide an integrated development environment 
in the browser. You can also use AWS Cloud9 to develop Lambda functions in your own 
environment. For more information, see Working with AWS Lambda functions using the AWS 
Toolkit in the AWS Cloud9 user guide.
When you save your function code, the Lambda console creates a .zip ﬁle archive deployment package. 
When you develop your function code outside of the console (using an IDE) you need to create a 
deployment package (p. 281) to upload your code to the Lambda function.
Updating function code
For scripting languages (Node.js, Python, and Ruby), you can edit your function code in the embedded 
code editor  (p. 25). If the code is larger than 3MB, or if you need to add libraries, or for languages that 
the editor doesn't support (Java, Go, C#), you must upload your function code as a .zip archive. If the .zip 
ﬁle archive is smaller than 50 MB, you can upload the .zip ﬁle archive from your local machine. If the ﬁle 
is larger than 50 MB, upload the ﬁle to the function from an Amazon S3 bucket.
To upload function code as a .zip archive
1. Open the Functions page of the Lambda console.
2. Choose the function to update and choose the Code  tab.
3. Under Code source, choose Upload from.
4. Choose .zip ﬁle, and then choose Upload.
• In the ﬁle chooser, select the new image version, choose Open , and then choose Save.
119AWS Lambda Developer Guide
Changing the runtime
5. (Alternative to step 4) Choose Amazon S3 location.
• In the text box, enter the S3 link URL of the .zip ﬁle archive, then choose Save.
Changing the runtime
If you update the function conﬁguration to use a new runtime, you may need to update the function 
code to be compatible with the new runtime. If you update the function conﬁguration to use a diﬀerent 
runtime, you must  provide new function code that is compatible with the runtime and architecture. For 
instructions on how to create a deployment package for the function code, see the handler page for the 
runtime that the function uses.
To change the runtime
1. Open the Functions page of the Lambda console.
2. Choose the function to update and choose the Code  tab.
3. Scroll down to the Runtime settings section, which is under the code editor.
4. Choose Edit.
a. For Runtime , select the runtime identiﬁer.
b. For Handler, specify ﬁle name and handler for your function.
c. For Architecture, choose the instruction set architecture to use for your function.
5. Choose Save.
Changing the architecture
Before you can change the instruction set architecture, you need to ensure that your function's code is 
compatible with the target architecture.
If you use Node.js, Python, or Ruby and you edit your function code in the embedded editor  (p. 25), the 
existing code may run without modiﬁcation.
However, if you provide your function code using a .zip ﬁle archive deployment package, you must 
prepare a new .zip ﬁle archive that is compiled and built correctly for the target runtime and instruction-
set architecture. For instructions, see the handler page for your function runtime.
To change the instruction set architecture
1. Open the Functions page of the Lambda console.
2. Choose the function to update and choose the Code  tab.
3. Under Runtime settings, choose Edit.
4. For Architecture, choose the instruction set architecture to use for your function.
5. Choose Save.
Using the Lambda API
To create and conﬁgure a function that uses a .zip ﬁle archive, use the following API operations:
•CreateFunction (p. 1304 )
•UpdateFunctionCode (p. 1506 )
•UpdateFunctionConﬁguration (p. 1516 )
120AWS Lambda Developer Guide
AWS CloudFormation
AWS CloudFormation
You can use AWS CloudFormation to create a Lambda function that uses a .zip ﬁle archive. In your AWS 
CloudFormation template, the AWS::Lambda::Function  resource speciﬁes the Lambda function. For 
descriptions of the properties in the AWS::Lambda::Function  resource, see AWS::Lambda::Function in 
the AWS CloudFormation User Guide.
In the AWS::Lambda::Function  resource, set the following properties to create a function deﬁned as 
a .zip ﬁle archive:
•AWS::Lambda::Function
•PackageType – Set to Zip.
•Code – Enter the Amazon S3 bucket name and .zip ﬁle name in the S3Bucket  and S3Keyﬁelds. For 
Node.js or Python, you can provide inline source code of your Lambda function.
•Runtime – Set the runtime value.
•Architecture – Set the architecture value to arm64 to use the AWS Graviton2 processor. By default, 
the architecture value is x86_64 .
121AWS Lambda Developer Guide
Container images
Working with Lambda container images
Your AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package  to deploy your function code to Lambda. Lambda supports two types of 
deployment packages: container images and .zip ﬁle archives.
There are three ways to build a container image for a Lambda function:
•Using an AWS base image for Lambda (p. 123)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, 
and code to these images. To make the image compatible with Lambda, you must include a runtime 
interface client (p. 124) for your language in the image.
•Using a non-AWS base image (p. 124)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include a runtime interface client (p. 124) for your language in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
To create a Lambda function from a container image, build your image locally and upload it to an 
Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you 
create the function.
This page explains the base image types and requirements for creating Lambda-compatible container 
images.
Topics
•Requirements (p. 122)
•Using an AWS base image for Lambda (p. 123)
•Using an AWS base image for custom runtimes (p. 123)
•Using a non-AWS base image (p. 124)
•Runtime interface clients (p. 124)
•Amazon ECR permissions (p. 124)
•Container image settings (p. 126)
Requirements
Install the AWS Command Line Interface (AWS CLI) version 2 and the Docker CLI. Additionally, note the 
following requirements:
•The container image must implement the Lambda runtime API  (p. 55). The AWS open-source runtime 
interface clients (p. 124) implement the API. You can add a runtime interface client to your preferred 
base image to make it compatible with Lambda.
122AWS Lambda Developer Guide
Using an AWS base image
•The container image must be able to run on a read-only ﬁle system. Your function code can access a 
writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.
•The default Lambda user must be able to read all the ﬁles required to run your function code. Lambda 
follows security best practices by deﬁning a default Linux user with least-privileged permissions. Verify 
that your application code does not rely on ﬁles that other Linux users are restricted from running.
•Lambda supports only Linux-based container images.
•Lambda provides multi-architecture base images. However, the image you build for your function must 
target only one of the architectures. Lambda does not support functions that use multi-architecture 
container images.
Using an AWS base image for Lambda
You can use one of the AWS base images for Lambda to build the container image for your function 
code. The base images are preloaded with a language runtime and other components required to run a 
container image on Lambda. You add your function code and dependencies to the base image and then 
package it as a container image.
AWS periodically provides updates to the AWS base images for Lambda. If your Dockerﬁle includes the 
image name in the FROM property, your Docker client pulls the latest version of the image from the
Amazon ECR repository. To use the updated base image, you must rebuild your container image and
update the function code.
To build a container image using an AWS base image, choose the instructions for your preferred 
language:
•Node.js  (p. 289)
•TypeScript (p. 324) (uses a Node.js base image)
•Python (p. 363)
•Java (p. 454)
•Go (p. 537)
•.NET  (p. 572)
•Ruby (p. 415)
Using an AWS base image for custom runtimes
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and the
runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, and 
code to these images. To make the image compatible with Lambda, you must include a runtime interface 
client  (p. 124) for your language in the image.
Tags Runtime Operating 
systemDockerﬁle Deprecation
al2 Custom 
RuntimeAmazon 
Linux 2Dockerﬁle for Custom 
Runtime on GitHub
alami Custom 
RuntimeAmazon 
LinuxDockerﬁle for Custom 
Runtime on GitHubDec 31, 2023
Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
123AWS Lambda Developer Guide
Using a non-AWS base image
Using a non-AWS base image
Lambda supports any image that conforms to one of the following image manifest formats:
•Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)
•Open Container Initiative (OCI) Speciﬁcations (v1.0.0 and up)
Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
Note
To make the image compatible with Lambda, you must include a runtime interface 
client  (p. 124) for your language in the image.
Runtime interface clients
If you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
a runtime interface client in your image. The runtime interface client must extend the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code. AWS provides 
open-source runtime interface clients for the following languages:
•Node.js  (p. 292)
•Python (p. 366)
•Java (p. 458)
•.NET  (p. 573)
•Go (p. 529)
•Ruby (p. 418)
If you're using a language that doesn't have an AWS-provided runtime interface client, you must create 
your own.
Amazon ECR permissions
Before you create a Lambda function from a container image, you must build the image locally and 
upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR 
repository URI.
Make sure that the permissions for the user or role that creates the function contain the AWS managed 
policies GetRepositoryPolicy  and SetRepositoryPolicy .
For example, use the IAM console to create a role with the following policy:
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "VisualEditor0", 
      "Effect": "Allow", 
      "Action": [ 
        "ecr:SetRepositoryPolicy", 
        "ecr:GetRepositoryPolicy" 
      ], 
      "Resource": "arn:aws:ecr: us-east-1 :111122223333 :repository/ hello-world " 
    } 
  ]
}
124AWS Lambda Developer Guide
Amazon ECR permissions
Amazon ECR repository policies
For a function in the same account as the container image in Amazon ECR, you can add
ecr:BatchGetImage  and ecr:GetDownloadUrlForLayer  permissions to your Amazon ECR 
repository policy. The following example shows the minimum policy:
{ 
        "Sid": "LambdaECRImageRetrievalPolicy", 
        "Effect": "Allow", 
        "Principal": { 
          "Service": "lambda.amazonaws.com" 
        }, 
        "Action": [ 
          "ecr:BatchGetImage", 
          "ecr:GetDownloadUrlForLayer" 
        ] 
    }    
For more information about Amazon ECR repository permissions, see Private repository policies in the
Amazon Elastic Container Registry User Guide.
If the Amazon ECR repository does not include these permissions, Lambda adds ecr:BatchGetImage
and ecr:GetDownloadUrlForLayer  to the container image repository permissions. Lambda can 
add these permissions only if the principal calling Lambda has ecr:getRepositoryPolicy  and
ecr:setRepositoryPolicy  permissions.
To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private 
repository policy statement in the Amazon Elastic Container Registry User Guide.
Amazon ECR cross-account permissions
A diﬀerent account in the same region can create a function that uses a container image owned by your 
account. In the following example, your Amazon ECR repository permissions policy needs the following 
statements to grant access to account number 123456789012.
•CrossAccountPermission – Allows account 123456789012 to create and update Lambda functions 
that use images from this ECR repository.
•LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a function's state 
to inactive if it is not invoked for an extended period. This statement is required so that Lambda 
can retrieve the container image for optimization and caching on behalf of the function owned by 
123456789012.
Example — Add cross-account permission to your repository
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "CrossAccountPermission", 
      "Effect": "Allow", 
      "Action": [ 
        "ecr:BatchGetImage", 
        "ecr:GetDownloadUrlForLayer" 
      ], 
      "Principal": { 
        "AWS": "arn:aws:iam:: 123456789012 :root" 
      } 
    }, 
    { 
125AWS Lambda Developer Guide
Container image settings
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy", 
      "Effect": "Allow", 
      "Action": [ 
        "ecr:BatchGetImage", 
        "ecr:GetDownloadUrlForLayer" 
      ], 
      "Principal": { 
        "Service": "lambda.amazonaws.com" 
      }, 
      "Condition": { 
        "StringLike": { 
          "aws:sourceARN": "arn:aws:lambda: us-east-1 :123456789012 :function:*" 
        } 
      } 
    } 
  ]
}
To give access to multiple accounts, you add the account IDs to the Principal list in 
the CrossAccountPermission  policy and to the Condition evaluation list in the
LambdaECRImageCrossAccountRetrievalPolicy .
If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate 
each account ID in the ECR permissions policy. This approach aligns with the AWS security best practice 
of setting narrow permissions in IAM policies.
Container image settings
The following are common container image settings. If you use these settings in your Dockerﬁle, note 
how Lambda interprets and processes these settings:
•ENTRYPOINT – Speciﬁes the absolute path to the entry point of the application.
•CMD – Speciﬁes parameters that you want to pass in with ENTRYPOINT.
•WORKDIR – Speciﬁes the absolute path to the working directory.
•ENV – Speciﬁes an environment variable for the Lambda function.
For more information about how Docker uses the container image settings, see ENTRYPOINT in the 
Dockerﬁle reference on the Docker Docs website. For more information about using ENTRYPOINT and 
CMD, see Demystifying ENTRYPOINT and CMD in Docker on the AWS Open Source Blog.
You can specify the container image settings in the Dockerﬁle when you build your image. You can 
also override these conﬁgurations using the Lambda console or Lambda API. This allows you to deploy 
multiple functions that deploy the same container image but with diﬀerent runtime conﬁgurations.
Warning
When you specify ENTRYPOINT or CMD in the Dockerﬁle or as an override, make sure that you 
enter the absolute path. Also, do not use symlinks as the entry point to the container.
To override the conﬁguration values in the container image
1. Open the Functions page of the Lambda console.
2. Choose the function to update.
3. Under Image conﬁguration, choose Edit.
4. Enter new values for any of the override settings, and then choose Save.
5. (Optional) To add or override environment variables, under Environment variables, choose Edit.
For more information, see the section called “Environment variables” (p. 77).
126AWS Lambda Developer Guide
Testing images
Testing Lambda container images locally
You can use the Lambda runtime interface emulator to locally test a container image function before 
uploading it to Amazon Elastic Container Registry (Amazon ECR) and deploying it to Lambda. The 
emulator is a proxy for the Lambda runtime API  (p. 55). It's a lightweight web server that converts HTTP 
requests into JSON events to pass to the Lambda function in the container image.
The AWS base images (p. 123) and base images for custom runtimes  (p. 123) include the runtime 
interface emulator. If you use an alternative base image, such as an Alpine Linux or Debian image, you 
can build the emulator into your image (p. 130) or install it on your local machine (p. 133).
The runtime interface emulator is available on the AWS GitHub repository. There are separate packages 
for the x86-64 and arm64 architectures.
Topics
•Guidelines for using the runtime interface emulator (p. 127)
•Environment variables (p. 127)
•Testing images built from AWS base images (p. 128)
•Testing images built from the provided.al2 base image (p. 128)
•Testing images built from alternative base images (p. 130)
Guidelines for using the runtime interface emulator
Note the following guidelines when using the runtime interface emulator:
•The RIE does not emulate Lambda security and authentication conﬁgurations, or Lambda 
orchestration.
•Lambda provides an emulator for each of the instruction set architectures.
•The emulator does not support AWS X-Ray tracing or other Lambda integrations.
Environment variables
The runtime interface emulator supports a subset of environment variables (p. 77) for the Lambda 
function in the local running image.
If your function uses security credentials, you can conﬁgure the credentials by setting the following 
environment variables:
•AWS_ACCESS_KEY_ID
•AWS_SECRET_ACCESS_KEY
•AWS_SESSION_TOKEN
•AWS_DEFAULT_REGION
To set the function timeout, conﬁgure AWS_LAMBDA_FUNCTION_TIMEOUT . Enter the maximum number 
of seconds that you want to allow the function to run.
The emulator does not populate the following Lambda environment variables. However, you can set 
them to match the values that you expect when the function runs in the Lambda service:
•AWS_LAMBDA_FUNCTION_VERSION
•AWS_LAMBDA_FUNCTION_NAME
127AWS Lambda Developer Guide
Testing AWS base images
•AWS_LAMBDA_FUNCTION_MEMORY_SIZE
Testing images built from AWS base images
The AWS base images for Lambda (p. 123) include the runtime interface emulator. After building your 
Docker image, follow these steps to test it locally.
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Testing images built from the provided.al2 base 
image
The base images for custom runtimes  (p. 123) include the runtime interface emulator. After building 
your Docker image, follow these steps to test it locally.
1. Start the Docker image with the docker run command.
Node.js
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
  --entrypoint /aws-lambda/aws-lambda-rie \ 
   docker-image:test  \ 
     /usr/local/bin/npx aws-lambda-ric index.handler
•/usr/local/bin/npx aws-lambda-ric : The npx command to start the Node.js runtime 
interface client
128AWS Lambda Developer Guide
Testing provided.al2 base images
•index.handler : The Lambda function handler (usually the CMD in your Dockerﬁle)
Python
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
  --entrypoint /aws-lambda/aws-lambda-rie \ 
   docker-image:test  \ 
     /usr/local/bin/python -m awslambdaric app.handler
•usr/local/bin/python -m awslambdaric : The Python interpreter command to run the 
Python runtime interface client as a script
•app.handler : The Lambda function handler (usually the CMD in your Dockerﬁle)
Java
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
  --entrypoint /aws-lambda/aws-lambda-rie \ 
   docker-image:test  \ 
     /usr/bin/java -cp './*' 
 com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
•/usr/bin/java -cp './*' 
com.amazonaws.services.lambda.runtime.api.client.AWSLambda : Sets the 
classpath to the Java runtime interface client
•app.handlerexample.App::sayHello : The Lambda function handler (usually the CMD in 
your Dockerﬁle)
Go
In the following example, /main is the binary that is compiled during the Docker build.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
  --entrypoint /aws-lambda/aws-lambda-rie \ 
   docker-image:test  \ 
     /main
Ruby
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
  --entrypoint /aws-lambda/aws-lambda-rie \ 
   docker-image:test  \ 
     aws_lambda_ric index.LambdaFunction::Handler.process
•aws_lambda_ric : The Ruby runtime interface client
•index.LambdaFunction::Handler.process : The Lambda function handler (usually the
CMD in your Dockerﬁle)
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
129AWS Lambda Developer Guide
Testing non-AWS images
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Testing images built from alternative base images
If you use an alternative base image, such as an Alpine Linux or Debian image, you can build the 
emulator into your image (p. 130) or install it on your local machine (p. 133).
Building the runtime interface emulator into an image
To build the emulator into your image
1. Create a script and save it in your project directory. Set execution permissions for the script ﬁle.
The script checks for the presence of the AWS_LAMBDA_RUNTIME_API  environment variable, which 
indicates the presence of the runtime API. If the runtime API is present, the script runs the runtime 
interface client (p. 124). Otherwise, the script runs the runtime interface emulator.
Choose your language to see an example script:
Node.js
In the following example, /usr/local/bin/npx aws-lambda-ric  is the npx command to 
start the Node.js runtime interface client.
Example entry_script.sh
#!/bin/sh
if [ -z "${AWS_LAMBDA_RUNTIME_API}" ]; then 
  exec /usr/local/bin/aws-lambda-rie /usr/local/bin/npx aws-lambda-ric  $@
else 
  exec /usr/local/bin/npx aws-lambda-ric  $@
fi
Python
In the following example, /usr/local/bin/python -m awslambdaric  is the Python 
interpreter command to run the Python runtime interface client as a script.
Example entry_script.sh
#!/bin/sh
130AWS Lambda Developer Guide
Testing non-AWS images
if [ -z "${AWS_LAMBDA_RUNTIME_API}" ]; then 
  exec /usr/local/bin/aws-lambda-rie /usr/local/bin/python -m awslambdaric  $@
else 
  exec /usr/local/bin/python -m awslambdaric  $@
fi
Java
In the following example, /usr/bin/java -cp './*' 
com.amazonaws.services.lambda.runtime.api.client.AWSLambda  sets the classpath 
to the Java runtime interface client.
Example entry_script.sh
#!/bin/sh
if [ -z "${AWS_LAMBDA_RUNTIME_API}" ]; then 
  exec /usr/local/bin/aws-lambda-rie /usr/bin/java -cp './*' 
 com.amazonaws.services.lambda.runtime.api.client.AWSLambda  $@
else 
  exec /usr/bin/java -cp './*' 
 com.amazonaws.services.lambda.runtime.api.client.AWSLambda  $@
fi
Go
In the following example, /main is the binary that is compiled during the Docker build.
Example entry_script.sh
#!/bin/sh
if [ -z "${AWS_LAMBDA_RUNTIME_API}" ]; then 
  exec /usr/local/bin/aws-lambda-rie /main $@
else 
  exec /main $@
fi
Ruby
In the following example, aws_lambda_ric  is the Ruby runtime interface client.
Example entry_script.sh
#!/bin/sh
if [ -z "${AWS_LAMBDA_RUNTIME_API}" ]; then 
  exec /usr/local/bin/aws-lambda-rie aws_lambda_ric  $@
else 
  exec aws_lambda_ric  $@
fi
2. Download the runtime interface emulator for your target architecture from GitHub into your project 
directory. Lambda provides an emulator for each of the instruction set architectures.
curl -Lo aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/
releases/latest/download/aws-lambda-rie \
&& chmod +x aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:131AWS Lambda Developer Guide
Testing non-AWS images
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
3. Copy the script, install the emulator package, and change the ENTRYPOINT  to the new script by 
adding the following lines to your Dockerﬁle.
Example — Lines to add to Dockerﬁle
COPY ./entry_script.sh  /entry_script.sh
ADD aws-lambda-rie /usr/local/bin/aws-lambda-rie
ENTRYPOINT [ "/ entry_script.sh " ]
4. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
5. Start the Docker image with the docker run command.
Node.js
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/local/bin/npx aws-lambda-ric index.handler
•/usr/local/bin/npx aws-lambda-ric : The npx command to start the Node.js runtime 
interface client
•index.handler : The Lambda function handler (usually the CMD in your Dockerﬁle)
Python
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/local/bin/python -m awslambdaric app.handler
•usr/local/bin/python -m awslambdaric : The Python interpreter command to run the 
Python runtime interface client as a script
•app.handler : The Lambda function handler (usually the CMD in your Dockerﬁle)
Java
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/bin/java -cp './*' 
 com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
•/usr/bin/java -cp './*' 
com.amazonaws.services.lambda.runtime.api.client.AWSLambda : Sets the 
classpath to the Java runtime interface client
•app.handlerexample.App::sayHello : The Lambda function handler (usually the CMD in 
your Dockerﬁle)
132AWS Lambda Developer Guide
Testing non-AWS images
Go
In the following example, /main is the binary that is compiled during the Docker build.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /main
Ruby
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         aws_lambda_ric index.LambdaFunction::Handler.process
•aws_lambda_ric : The Ruby runtime interface client
•index.LambdaFunction::Handler.process : The Lambda function handler (usually the
CMD in your Dockerﬁle)
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
6. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
7. Get the container ID.
docker ps
8. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Install the runtime interface emulator locally
To install the runtime interface emulator on your local machine, download the package for your 
preferred architecture from GitHub. Then, use the docker run command to start the container image and 
set the --entrypoint  to the emulator. For more information, choose the instructions for your preferred 
language:
•Node.js  (p. 294)
•Python (p. 368)
•Java (p. 461)
133AWS Lambda Developer Guide
Testing non-AWS images
•Go (p. 535)
•Ruby (p. 420)
134AWS Lambda Developer Guide
Invoking Lambda functions
You can invoke Lambda functions directly using the Lambda console (p. 137), a function URL (p. 189)
HTTP(S) endpoint, the Lambda API , an AWS SDK, the AWS Command Line Interface (AWS CLI), and
AWS toolkits. You can also conﬁgure other AWS services to invoke your function in response to events 
or external requests, or on a schedule. For example, Amazon Simple Storage Service (Amazon S3) can 
invoke your function when an object is created in an S3 bucket, or Amazon EventBridge (CloudWatch 
Events) can invoke your function on a schedule. You can also conﬁgure Lambda to read items from a 
stream or a queue and invoke your function to process them.
When you invoke a function, you can choose to invoke it synchronously or asynchronously. With
synchronous invocation (p. 139), you wait for the function to process the event and return a response. 
With asynchronous invocation (p. 142), Lambda queues the event for processing and returns a response 
immediately. For asynchronous invocation, Lambda handles retries and can send invocation records to a
destination  (p. 144).
For another AWS service to invoke your function directly, you need to create a trigger using the Lambda 
console. A trigger is a resource you conﬁgure to allow another AWS service to invoke your function when 
certain events or conditions occur. Your function can have multiple triggers. Each trigger acts as a client 
invoking your function independently, and each event that Lambda passes to your function has data 
from only one trigger.
To create a trigger, open the functions page of the Lambda console and choose the function you want to 
add a trigger to. In the Function overview pane, choose add trigger , select the AWS service you want to 
invoke your function, and follow the instructions to create a trigger.
Each service varies in the options you conﬁgure for the trigger and in the structure of the event that the 
service sends to your Lambda function to invoke it. For a full list of the AWS services that can invoke your 
Lambda function by using a trigger, and for more information about conﬁguring triggers for diﬀerent 
services, see Using Lambda with other services. (p. 628)
For your Lambda function to process items from a stream or a queue, such as an Amazon Kinesis 
stream or an Amazon Simple Queue Service (Amazon SQS) queue, you need to create an event source 
mapping  (p. 150). An event source mapping is a resource in Lambda that reads items from a stream 
or a queue and creates events containing batches of items to send to your Lambda function. Each event 
that your function processes can contain hundreds or thousands of items.
You can create an event source mapping for your Lambda function using the Lambda console, the 
AWS CLI, the Lambda API, or an AWS SDK. To create an event source mapping in the Lambda console, 
follow the instructions to create a trigger, and select one of the AWS services that support event source 
mappings as your source. To create an event source mapping using the AWS CLI, Lambda API, or an 
AWS SDK, and to see a list of the AWS services which event source mappings can be used with, refer to
Lambda event source mappings (p. 150).
Depending on how your function is invoked, scaling behavior and the types of errors that occur can 
vary. When you invoke a function synchronously, you receive errors in the response and can retry. When 
you invoke asynchronously, use an event source mapping, or conﬁgure another service to invoke your 
function, the retry requirements and the way that your function scales to handle large numbers of events 
will vary. For more information, see Error handling and automatic retries in AWS Lambda (p. 181).
Topics
•Testing Lambda functions in the console (p. 137)
•Synchronous invocation (p. 139)
•Asynchronous invocation (p. 142)
135AWS Lambda Developer Guide
•Lambda event source mappings (p. 150)
•Lambda event ﬁltering (p. 155)
•Lambda function states (p. 179)
•Error handling and automatic retries in AWS Lambda (p. 181)
•Invoking functions deﬁned as container images (p. 183)
•Lambda recursive loop detection (p. 184)
•Lambda function URLs (p. 189)
136AWS Lambda Developer Guide
Testing in console
Testing Lambda functions in the console
You can test your Lambda function in the console by invoking your function with a test event. A test 
event  is a JSON input to your function. If your function doesn't require input, the event can be an empty 
document ({}) .
Invoking functions with test events
When you run a test event in the console, Lambda synchronously invokes your function with the test 
event. The function runtime converts the JSON document into an object and passes it to your code's 
handler method for processing.
To test a function
1. Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to test.
3. Choose the Test tab.
4. Under Test event, choose Saved event, and then choose the saved event that you want to use.
5. Choose Test.
6. To review the test results, under Execution result, expand Details .
To invoke your function without saving your test event, choose Test before saving. This creates an 
unsaved test event that Lambda preserves for the duration of the session.
You can also access your saved and unsaved test events on the Code  tab. From there, choose Test, and 
then choose your test event.
Private test events
Private test events are available only to the event creator, and they require no additional permissions to 
use. You can create and save up to 10 private test events per function.
To create a private test event
1. Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to test.
3. Choose the Test tab.
4. Under Test event, do the following:
a. Choose a Template.
b. Enter a Name  for the test.
c. In the text entry box, enter the JSON test event.
d. Under Event sharing settings, choose Private .
5. Choose Save changes.
You can also create new test events on the Code  tab. From there, choose Test, Conﬁgure test event.
Shareable test events
Shareable test events are test events that you can share with other users in the same AWS account. You 
can edit other users' shareable test events and invoke your function with them.
137AWS Lambda Developer Guide
Deleting shareable test event schemas
Lambda saves shareable test events as schemas in an Amazon EventBridge (CloudWatch Events) schema 
registry named lambda-testevent-schemas . As Lambda utilizes this registry to store and call 
shareable test events you create, we recommend that you do not edit this registry or create a registry 
using the lambda-testevent-schemas  name.
To see, share, and edit shareable test events, you must have permissions for all of the following
EventBridge (CloudWatch Events) schema registry API operations:
•schemas.CreateRegistry
•schemas.CreateSchema
•schemas.DeleteSchema
•schemas.DeleteSchemaVersion
•schemas.DescribeRegistry
•schemas.DescribeSchema
•schemas.GetDiscoveredSchema
•schemas.ListSchemaVersions
•schemas.UpdateSchema
Note that saving edits made to a shareable test event overwrites that event.
If you cannot create, edit, or see shareable test events, check that your account has the required 
permissions for these operations. If you have the required permissions but still cannot access shareable 
test events, check for any resource-based policies (p. 929) that might limit access to the EventBridge 
(CloudWatch Events) registry.
To create a shareable test event
1. Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to test.
3. Choose the Test tab.
4. Under Test event, do the following:
a. Choose a Template.
b. Enter a Name  for the test.
c. In the text entry box, enter the JSON test event.
d. Under Event sharing settings, choose Shareable.
5. Choose Save changes.
Deleting shareable test event schemas
When you delete shareable test events, Lambda removes them from the lambda-testevent-schemas
registry. If you remove the last shareable test event from the registry, Lambda deletes the registry.
If you delete the function, Lambda does not delete any associated shareable test event schemas. You 
must clean up these resources manually from the EventBridge (CloudWatch Events) console.
138AWS Lambda Developer Guide
Synchronous invocation
Synchronous invocation
When you invoke a function synchronously, Lambda runs the function and waits for a response. When 
the function completes, Lambda returns the response from the function's code with additional data, such 
as the version of the function that was invoked. To invoke a function synchronously with the AWS CLI, 
use the invoke command.
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{ "key": "value" }' response.json
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
{ 
    "ExecutedVersion": "$LATEST", 
    "StatusCode": 200
}
The following diagram shows clients invoking a Lambda function synchronously. Lambda sends the 
events directly to the function and sends the function's response back to the invoker.
The payload is a string that contains an event in JSON format. The name of the ﬁle where the AWS CLI 
writes the response from the function is response.json . If the function returns an object or error, the 
response is the object or error in JSON format. If the function exits without error, the response is null .
The output from the command, which is displayed in the terminal, includes information from headers 
in the response from Lambda. This includes the version that processed the event (useful when you use
aliases  (p. 104)), and the status code returned by Lambda. If Lambda was able to run the function, the 
status code is 200, even if the function returned an error.
Note
For functions with a long timeout, your client might be disconnected during synchronous 
invocation while it waits for a response. Conﬁgure your HTTP client, SDK, ﬁrewall, proxy, or 
operating system to allow for long connections with timeout or keep-alive settings.
If Lambda isn't able to run the function, the error is displayed in the output.
139AWS Lambda Developer Guide
Synchronous invocation
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload value response.json
You should see the following output:
An error occurred (InvalidRequestContentException) when calling the Invoke operation: Could 
 not parse request body into json: Unrecognized token 'value': was expecting ('true', 
 'false' or 'null') 
 at [Source: (byte[])"value"; line: 1, column: 11]
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
140AWS Lambda Developer Guide
Synchronous invocation
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
For more information about the Invoke API, including a full list of parameters, headers, and errors, see
Invoke (p. 1399 ).
When you invoke a function directly, you can check the response for errors and retry. The AWS CLI 
and AWS SDK also automatically retry on client timeouts, throttling, and service errors. For more 
information, see Error handling and automatic retries in AWS Lambda (p. 181).
141AWS Lambda Developer Guide
Asynchronous invocation
Asynchronous invocation
Several AWS services, such as Amazon Simple Storage Service (Amazon S3) and Amazon Simple 
Notiﬁcation Service (Amazon SNS), invoke functions asynchronously to process events. When you invoke 
a function asynchronously, you don't wait for a response from the function code. You hand oﬀ the event 
to Lambda and Lambda handles the rest. You can conﬁgure how Lambda handles errors, and can send 
invocation records to a downstream resource such as Amazon Simple Queue Service (Amazon SQS) or 
Amazon EventBridge (EventBridge) to chain together components of your application.
Sections
•How Lambda handles asynchronous invocations (p. 142)
•Conﬁguring error handling for asynchronous invocation (p. 144)
•Conﬁguring destinations for asynchronous invocation (p. 144)
•Asynchronous invocation conﬁguration API (p. 147)
•Dead-letter queues (p. 148)
How Lambda handles asynchronous invocations
The following diagram shows clients invoking a Lambda function asynchronously. Lambda queues the 
events before sending them to the function.
For asynchronous invocation, Lambda places the event in a queue and returns a success response 
without additional information. A separate process reads events from the queue and sends them to your 
function. To invoke a function asynchronously, set the invocation type parameter to Event .
aws lambda invoke \ 
  --function-name my-function  \ 
      --invocation-type Event \ 
          --cli-binary-format raw-in-base64-out \ 
              --payload '{ "key": "value" }' response.json
  
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
{ 
    "StatusCode": 202
142AWS Lambda Developer Guide
How Lambda handles asynchronous invocations
}
The output ﬁle ( response.json ) doesn't contain any information, but is still created when you run 
this command. If Lambda isn't able to add the event to the queue, the error message appears in the 
command output.
Lambda manages the function's asynchronous event queue and attempts to retry on errors. If the 
function returns an error, Lambda attempts to run it two more times, with a one-minute wait between 
the ﬁrst two attempts, and two minutes between the second and third attempts. Function errors include 
errors returned by the function's code and errors returned by the function's runtime, such as timeouts.
If the function doesn't have enough concurrency available to process all events, additional requests 
are throttled. For throttling errors (429) and system errors (500-series), Lambda returns the event 
to the queue and attempts to run the function again for up to 6 hours. The retry interval increases 
exponentially from 1 second after the ﬁrst attempt to a maximum of 5 minutes. If the queue contains 
many entries, Lambda increases the retry interval and reduces the rate at which it reads events from the 
queue.
Even if your function doesn't return an error, it's possible for it to receive the same event from Lambda 
multiple times because the queue itself is eventually consistent. If the function can't keep up with 
incoming events, events might also be deleted from the queue without being sent to the function. 
Ensure that your function code gracefully handles duplicate events, and that you have enough 
concurrency available to handle all invocations.
When the queue is very long, new events might age out before Lambda has a chance to send them 
to your function. When an event expires or fails all processing attempts, Lambda discards it. You can
conﬁgure error handling (p. 144) for a function to reduce the number of retries that Lambda performs, 
or to discard unprocessed events more quickly.
You can also conﬁgure Lambda to send an invocation record to another service. Lambda supports the 
following destinations  (p. 144) for asynchronous invocation. Note that SQS FIFO queues and SNS FIFO 
topics are not supported.
•Amazon SQS – A standard SQS queue.
•Amazon SNS – A standard SNS topic.
•AWS Lambda – A Lambda function.
•Amazon EventBridge – An EventBridge event bus.
The invocation record contains details about the request and response in JSON format. You can conﬁgure 
separate destinations for events that are processed successfully, and events that fail all processing 
attempts. Alternatively, you can conﬁgure a standard Amazon SQS queue or standard Amazon SNS topic 
as a dead-letter queue (p. 148) for discarded events. For dead-letter queues, Lambda only sends the 
content of the event, without details about the response.
If Lambda can't send a record to a destination you have conﬁgured, it sends a
DestinationDeliveryFailures  metric to Amazon CloudWatch. This can happen if your 
conﬁguration includes an unsupported destination type, such as an Amazon SQS FIFO queue or an 
Amazon SNS FIFO topic. Delivery errors can also occur due to permissions errors and size limits. For more 
information on Lambda invocation metrics, see Invocation metrics (p. 966).
Note
To prevent a function from triggering, you can set the function's reserved concurrency to zero. 
When you set reserved concurrency to zero for an asynchronously-invoked function, Lambda 
begins sending new events to the conﬁgured dead-letter queue (p. 148) or the on-failure
event destination (p. 144), without any retries. To process events that were sent while reserved 
concurrency was set to zero, you need to consume the events from the dead-letter queue or the 
on-failure event destination.
143AWS Lambda Developer Guide
Conﬁguring error handling for asynchronous invocation
Conﬁguring error handling for asynchronous 
invocation
Use the Lambda console to conﬁgure error handling settings on a function, a version, or an alias.
To conﬁgure error handling
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Asynchronous invocation.
4. Under Asynchronous invocation, choose Edit.
5. Conﬁgure the following settings.
•Maximum age of event – The maximum amount of time Lambda retains an event in the 
asynchronous event queue, up to 6 hours.
•Retry attempts – The number of times Lambda retries when the function returns an error, 
between 0 and 2.
6. Choose Save.
When an invocation event exceeds the maximum age or fails all retry attempts, Lambda discards it. To 
retain a copy of discarded events, conﬁgure a failed-event destination.
Conﬁguring destinations for asynchronous invocation
To send records of asynchronous invocations to another service, add a destination to your function. 
You can conﬁgure separate destinations for events that fail processing and events that are successfully 
processed. Like error handling settings, you can conﬁgure destinations on a function, a version, or an 
alias.
The following example shows a function that is processing asynchronous invocations. When the function 
returns a success response or exits without throwing an error, Lambda sends a record of the invocation 
to an EventBridge event bus. When an event fails all processing attempts, Lambda sends an invocation 
record to a standard Amazon SQS queue.
144AWS Lambda Developer Guide
Conﬁguring destinations for asynchronous invocation
To send events to a destination, your function needs additional permissions. Add a policy with the 
required permissions to your function's execution role (p. 913). Each destination service requires a 
diﬀerent permission, as follows:
•Amazon SQS – sqs:SendMessage
•Amazon SNS – sns:Publish
•Lambda  – InvokeFunction (p. 1399 )
•EventBridge – events:PutEvents
Add destinations to your function in the Lambda console's function visualization.
To conﬁgure a destination for asynchronous invocation records
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Under Function overview, choose Add destination .
4. For Source, choose Asynchronous invocation.
5. For Condition , choose from the following options:
•On failure  – Send a record when the event fails all processing attempts or exceeds the maximum 
age.
•On success – Send a record when the function successfully processes an asynchronous invocation.
6. For Destination type, choose the type of resource that receives the invocation record.
7. For Destination , choose a resource.
8. Choose Save.
145AWS Lambda Developer Guide
Conﬁguring destinations for asynchronous invocation
When an invocation matches the condition, Lambda sends a JSON document with details about the 
invocation to the destination.
Destination-speciﬁc JSON format
•For Amazon SQS and Amazon SNS (SnsDestination  and SqsDestination ), the invocation record is 
passed as the Message  to the destination.
•For Lambda (LambdaDestination ), the invocation record is passed as the payload to the function.
•For EventBridge (EventBridgeDestination ), the invocation record is passed as the detail  in the
PutEvents call. The value for the source event ﬁeld is lambda . The value for the detail-type  event 
ﬁeld is either Lambda Function Invocation Result – Success or Lambda Function Invocation Result – 
Failure. The resource  event ﬁeld contains the function and destination Amazon Resource Names 
(ARNs). For other event ﬁelds, see Amazon EventBridge events.
The following example shows an invocation record for an event that failed three processing attempts 
due to a function error.
Example invocation record
{ 
    "version": "1.0", 
    "timestamp": "2019-11-14T18:16:05.568Z", 
    "requestContext": { 
        "requestId": "e4b46cbf-b738-xmpl-8880-a18cdf61200e", 
        "functionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:
$LATEST", 
        "condition": "RetriesExhausted", 
        "approximateInvokeCount": 3 
    }, 
    "requestPayload": { 
        "ORDER_IDS": [ 
            "9e07af03-ce31-4ff3-xmpl-36dce652cb4f", 
            "637de236-e7b2-464e-xmpl-baf57f86bb53", 
            "a81ddca6-2c35-45c7-xmpl-c3a03a31ed15" 
        ] 
    }, 
    "responseContext": { 
        "statusCode": 200, 
        "executedVersion": "$LATEST", 
        "functionError": "Unhandled" 
    }, 
    "responsePayload": { 
        "errorMessage": "RequestId: e4b46cbf-b738-xmpl-8880-a18cdf61200e Process exited 
 before completing request" 
    }
}
The invocation record contains details about the event, the response, and the reason that the record was 
sent.
Tracing requests to destinations
You can use X-Ray to see a connected view of each request as it's queued, processed by a Lambda 
function, and passed to the destination service. When you activate X-Ray tracing for a function or a 
service that invokes a function, Lambda adds an X-Ray header to the request and passes the header 
to the destination service. Traces from upstream services are automatically linked to traces from 
downstream Lambda functions and destination services, creating an end-to-end view of the entire 
application. For more information about tracing, see Using AWS Lambda with AWS X-Ray (p. 973).
146AWS Lambda Developer Guide
Asynchronous invocation conﬁguration API
Asynchronous invocation conﬁguration API
To manage asynchronous invocation settings with the AWS CLI or AWS SDK, use the following API 
operations.
•PutFunctionEventInvokeConﬁg
•GetFunctionEventInvokeConﬁg
•UpdateFunctionEventInvokeConﬁg
•ListFunctionEventInvokeConﬁgs
•DeleteFunctionEventInvokeConﬁg
To conﬁgure asynchronous invocation with the AWS CLI, use the put-function-event-invoke-
config command. The following example conﬁgures a function with a maximum event age of 1 hour 
and no retries.
aws lambda put-function-event-invoke-config --function-name error \
--maximum-event-age-in-seconds 3600 --maximum-retry-attempts 0
You should see the following output:
{ 
    "LastModified": 1573686021.479, 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:error:$LATEST", 
    "MaximumRetryAttempts": 0, 
    "MaximumEventAgeInSeconds": 3600, 
    "DestinationConfig": { 
        "OnSuccess": {}, 
        "OnFailure": {} 
    }
}
The put-function-event-invoke-config  command overwrites any existing conﬁguration on the 
function, version, or alias. To conﬁgure an option without resetting others, use update-function-
event-invoke-config . The following example conﬁgures Lambda to send a record to a standard SQS 
queue named destination  when an event can't be processed.
aws lambda update-function-event-invoke-config --function-name error \
--destination-config '{"OnFailure":{"Destination": "arn:aws:sqs:us-
east-2:123456789012:destination"}}'
You should see the following output:
{ 
    "LastModified": 1573687896.493, 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:error:$LATEST", 
    "MaximumRetryAttempts": 0, 
    "MaximumEventAgeInSeconds": 3600, 
    "DestinationConfig": { 
        "OnSuccess": {}, 
         "OnFailure": { 
            "Destination": "arn:aws:sqs:us-east-2:123456789012:destination" 
        }
    }
}
147AWS Lambda Developer Guide
Dead-letter queues
Dead-letter queues
As an alternative to an on-failure destination (p. 144), you can conﬁgure your function with a dead-
letter queue to save discarded events for further processing. A dead-letter queue acts the same as an 
on-failure destination in that it is used when an event fails all processing attempts or expires without 
being processed. However, a dead-letter queue is part of a function's version-speciﬁc conﬁguration, so 
it is locked in when you publish a version. On-failure destinations also support additional targets and 
include details about the function's response in the invocation record.
To reprocess events in a dead-letter queue, you can set it as an event source for your Lambda function. 
Alternatively, you can manually retrieve the events.
You can choose an Amazon SQS standard queue or Amazon SNS standard topic for your dead-letter 
queue. FIFO queues and Amazon SNS FIFO topics are not supported. If you don't have a queue or topic, 
create one. Choose the target type that matches your use case.
•Amazon SQS queue – A queue holds failed events until they're retrieved. Choose an Amazon SQS 
standard queue if you expect a single entity, such as a Lambda function or CloudWatch alarm, to 
process the failed event. For more information, see Using Lambda with Amazon SQS (p. 875).
Create a queue in the Amazon SQS console.
•Amazon SNS topic – A topic relays failed events to one or more destinations. Choose an Amazon SNS 
standard topic if you expect multiple entities to act on a failed event. For example, you can conﬁgure 
a topic to send events to an email address, a Lambda function, and/or an HTTP endpoint. For more 
information, see Using AWS Lambda with Amazon SNS (p. 863).
Create a topic in the Amazon SNS console.
To send events to a queue or topic, your function needs additional permissions. Add a policy with the 
required permissions to your function's execution role (p. 913).
•Amazon SQS – sqs:SendMessage
•Amazon SNS – sns:Publish
If the target queue or topic is encrypted with a customer managed key, the execution role must also be a 
user in the key's resource-based policy.
After creating the target and updating your function's execution role, add the dead-letter queue to your 
function. You can conﬁgure multiple functions to send events to the same target.
To conﬁgure a dead-letter queue
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Asynchronous invocation.
4. Under Asynchronous invocation, choose Edit.
5. Set DLQ resource to Amazon SQS or Amazon SNS.
6. Choose the target queue or topic.
7. Choose Save.
To conﬁgure a dead-letter queue with the AWS CLI, use the update-function-configuration
command.
aws lambda update-function-configuration --function-name my-function \
148AWS Lambda Developer Guide
Dead-letter queues
--dead-letter-config TargetArn= arn:aws:sns:us-east-2:123456789012:my-topic
Lambda sends the event to the dead-letter queue as-is, with additional information in attributes. You 
can use this information to identify the error that the function returned, or to correlate the event with 
logs or an AWS X-Ray trace.
Dead-letter queue message attributes
•RequestID (String) – The ID of the invocation request. Request IDs appear in function logs. You can 
also use the X-Ray SDK to record the request ID on an attribute in the trace. You can then search for 
traces by request ID in the X-Ray console. For an example, see the error processor sample (p. 1121 ).
•ErrorCode  (Number) – The HTTP status code.
•ErrorMessage  (String) – The ﬁrst 1 KB of the error message.
If Lambda can't send a message to the dead-letter queue, it deletes the event and emits the
DeadLetterErrors (p. 965) metric. This can happen because of lack of permissions, or if the total size of 
the message exceeds the limit for the target queue or topic. For example, if an Amazon SNS notiﬁcation 
with a body close to 256 KB triggers a function that results in an error, the additional event data added 
by Amazon SNS, combined with the attributes added by Lambda, can cause the message to exceed the 
maximum size allowed in the dead-letter queue.
If you're using Amazon SQS as an event source, conﬁgure a dead-letter queue on the Amazon SQS 
queue itself and not on the Lambda function. For more information, see Using Lambda with Amazon 
SQS (p. 875).
149AWS Lambda Developer Guide
Event source mapping
Lambda event source mappings
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
An event source mapping is a Lambda resource that reads from an event source and invokes a Lambda 
function. You can use event source mappings to process items from a stream or queue in services that 
don't invoke Lambda functions directly. This page describes the services that Lambda provides event 
source mappings and how-to ﬁne tune batching behavior.
Services that Lambda reads events from
•Amazon DynamoDB (p. 707)
•Amazon Kinesis (p. 756)
•Amazon MQ (p. 780)
•Amazon Managed Streaming for Apache Kafka (Amazon MSK) (p. 789)
•Self-managed Apache Kafka (p. 743)
•Amazon Simple Queue Service (Amazon SQS) (p. 875)
•Amazon DocumentDB (with MongoDB compatibility) (Amazon DocumentDB) (p. 682)
An event source mapping uses permissions in the function's execution role (p. 913) to read and manage 
items in the event source. Permissions, event structure, settings, and polling behavior vary by event 
source. For more information, see the linked topic for the service that you use as an event source.
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
Note
When you update, disable, or delete an event source mapping for Amazon MQ, Amazon MSK, 
self-managed Apache Kafka, or Amazon DocumentDB, it can take up to 15 minutes for your 
changes to take eﬀect. Before this period has elapsed, your event source mapping may continue 
to process events and invoke your function using your previous settings. This is true even when 
the status of the event source mapping displayed in the console indicates that your changes 
have been applied.
The following example uses the AWS CLI to map a function named my-function  to a DynamoDB 
stream that its Amazon Resource Name (ARN) speciﬁes, with a batch size of 500.
aws lambda create-event-source-mapping --function-name my-function --batch-size 500 --
maximum-batching-window-in-seconds 5 --starting-position LATEST \
--event-source-arn arn:aws:dynamodb: us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525
You should see the following output:
{ 
150AWS Lambda Developer Guide
Batching behavior
    "UUID": "14e0db71-5d35-4eb5-b481-8945cf9d10c2", 
    "BatchSize": 500, 
    "MaximumBatchingWindowInSeconds": 5, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:dynamodb:us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1560209851.963, 
    "LastProcessingResult": "No records processed", 
    "State": "Creating", 
    "StateTransitionReason": "User action", 
    "DestinationConfig": {}, 
    "MaximumRecordAgeInSeconds": 604800, 
    "BisectBatchOnFunctionError": false, 
    "MaximumRetryAttempts": 10000
}
Lambda event source mappings process events at least once due to the distributed nature of its pollers. 
As a result, your Lambda function may receive duplicate events in rare situations. Follow Best practices 
for working with AWS Lambda functions (p. 908) and build idempotent functions to avoid issues 
related to duplicate events.
Batching behavior
Event source mappings read items from a target event source. By default, an event source mapping 
batches records together into a single payload that Lambda sends to your function. To ﬁne-tune 
batching behavior, you can conﬁgure a batching window (MaximumBatchingWindowInSeconds ) and 
a batch size (BatchSize ). A batching window is the maximum amount of time to gather records into a 
single payload. A batch size is the maximum number of records in a single batch. Lambda invokes your 
function when one of the following three criteria is met:
•The batching window reaches its maximum value. Batching window behavior varies depending on 
the speciﬁc event source.
•For Kinesis, DynamoDB, and Amazon SQS event sources: The default batching window is 0 
seconds. This means that Lambda sends batches to your function as quickly as possible. If you 
conﬁgure a MaximumBatchingWindowInSeconds , the next batching window begins as soon as the 
previous function invocation completes.
•For Amazon MSK, self-managed Apache Kafka, Amazon MQ, and Amazon 
DocumentDB event sources: The default batching window is 500 ms. You can conﬁgure
MaximumBatchingWindowInSeconds  to any value from 0 seconds to 300 seconds in increments 
of seconds. A batching window begins as soon as the ﬁrst record arrives.
Note
Because you can only change MaximumBatchingWindowInSeconds  in increments of 
seconds, you cannot revert back to the 500 ms default batching window after you have 
changed it. To restore the default batching window, you must create a new event source 
mapping.
•The batch size is met. The minimum batch size is 1. The default and maximum batch size depend 
on the event source. For details about these values, see the BatchSize  speciﬁcation for the
CreateEventSourceMapping  API operation.
•The payload size reaches 6 MB . You cannot modify this limit.
The following diagram illustrates these three conditions. Suppose a batching window begins at t = 7
seconds. In the ﬁrst scenario, the batching window reaches its 40 second maximum at t = 47 seconds 
after accumulating 5 records. In the second scenario, the batch size reaches 10 before the batching 
window expires, so the batching window ends early. In the third scenario, the maximum payload size is 
reached before the batching window expires, so the batching window ends early.
151AWS Lambda Developer Guide
Batching behavior
152AWS Lambda Developer Guide
Batching behavior
The following example shows an event source mapping that reads from a Kinesis stream. If a batch of 
events fails all processing attempts, the event source mapping sends details about the batch to an SQS 
queue.
The event batch is the event that Lambda sends to the function. It is a batch of records or messages 
compiled from the items that the event source mapping reads up until the current batching window 
expires.
For Kinesis and DynamoDB streams, an event source mapping creates an iterator for each shard in the 
stream and processes items in each shard in order. You can conﬁgure the event source mapping to read 
only new items that appear in the stream, or to start with older items. Processed items aren't removed 
from the stream, and other functions or consumers can process them.
Lambda doesn't wait for any conﬁgured Lambda extensions (p. 1000 ) to complete before sending 
the next batch for processing. In other words, your extensions may continue to run as Lambda 
processes the next batch of records. This can cause throttling issues if you breach any of your account's
concurrency (p. 220) settings or limits. To detect whether this is a potential issue, monitor your 
functions and check whether you're seeing higher concurrency metrics (p. 251) than expected for your 
event source mapping.
By default, if your function returns an error, the event source mapping reprocesses the entire batch until 
the function succeeds, or the items in the batch expire. To ensure in-order processing, the event source 
mapping pauses processing for the aﬀected shard until the error is resolved. You can conﬁgure the event 
source mapping to discard old events or process multiple batches in parallel. If you process multiple 
batches in parallel, in-order processing is still guaranteed for each partition key, but the event source 
mapping simultaneously processes multiple partition keys in the same shard.
For stream sources (DynamoDB and Kinesis), you can conﬁgure the maximum number of times that 
Lambda retries when your function returns an error. Service errors or throttles where the batch does not 
reach your function do not count toward retry attempts.
153AWS Lambda Developer Guide
Batching behavior
You can also conﬁgure the event source mapping to send an invocation record to another service when it 
discards an event batch. Lambda supports the following destinations  (p. 144) for event source mappings.
•Amazon SQS – An SQS queue.
•Amazon SNS – An SNS topic.
The invocation record contains details about the failed event batch in JSON format.
The following example shows an invocation record for a Kinesis stream.
Example invocation record
{ 
    "requestContext": { 
        "requestId": "c9b8fa9f-5a7f-xmpl-af9c-0c604cde93a5", 
        "functionArn": "arn:aws:lambda:us-east-2:123456789012:function:myfunction", 
        "condition": "RetryAttemptsExhausted", 
        "approximateInvokeCount": 1 
    }, 
    "responseContext": { 
        "statusCode": 200, 
        "executedVersion": "$LATEST", 
        "functionError": "Unhandled" 
    }, 
    "version": "1.0", 
    "timestamp": "2019-11-14T00:38:06.021Z", 
    "KinesisBatchInfo": { 
        "shardId": "shardId-000000000001", 
        "startSequenceNumber": "49601189658422359378836298521827638475320189012309704722", 
        "endSequenceNumber": "49601189658422359378836298522902373528957594348623495186", 
        "approximateArrivalOfFirstRecord": "2019-11-14T00:38:04.835Z", 
        "approximateArrivalOfLastRecord": "2019-11-14T00:38:05.580Z", 
        "batchSize": 500, 
        "streamArn": "arn:aws:kinesis:us-east-2:123456789012:stream/mystream" 
    }
}
Lambda also supports in-order processing for FIFO (ﬁrst-in, ﬁrst-out) queues (p. 875), scaling up to 
the number of active message groups. For standard queues, items aren't necessarily processed in order. 
Lambda scales up to process a standard queue as quickly as possible. When an error occurs, Lambda 
returns batches to the queue as individual items and might process them in a diﬀerent grouping than 
the original batch. Occasionally, the event source mapping might receive the same item from the queue 
twice, even if no function error occurred. Lambda deletes items from the queue after they're processed 
successfully. You can conﬁgure the source queue to send items to a dead-letter queue if Lambda can't 
process them.
For information about services that invoke Lambda functions directly, see Using AWS Lambda with other 
services (p. 628).
154AWS Lambda Developer Guide
Event ﬁltering
Lambda event ﬁltering
You can use event ﬁltering to control which records from a stream or queue Lambda sends to your 
function. For example, you can add a ﬁlter so that your function only processes Amazon SQS messages 
containing certain data parameters. Event ﬁltering works with event source mappings. You can add 
ﬁlters to event source mappings for the following AWS services:
•Amazon DynamoDB
•Amazon Kinesis Data Streams
•Amazon MQ
•Amazon Managed Streaming for Apache Kafka (Amazon MSK)
•Self-managed Apache Kafka
•Amazon Simple Queue Service (Amazon SQS)
Lambda doesn't support event ﬁltering for Amazon DocumentDB.
By default, you can deﬁne up to ﬁve diﬀerent ﬁlters for a single event source mapping. Your ﬁlters are 
logically ORed together. If a record from your event source satisﬁes one or more of your ﬁlters, Lambda 
includes the record in the next event it sends to your function. If none of your ﬁlters are satisﬁed, 
Lambda discards the record.
Note
If you need to deﬁne more than ﬁve ﬁlters for an event source, you can request a quota increase 
up to 10 ﬁlters for each event source. If you attempt to add more ﬁlters than your current quota 
permits, Lambda will return an error when you try and create the event source.
Topics
•Event ﬁltering basics (p. 155)
•Handling records that don't meet ﬁlter criteria (p. 157)
•Filter rule syntax  (p. 157)
•Attaching ﬁlter criteria to an event source mapping (console) (p. 158)
•Attaching ﬁlter criteria to an event source mapping (AWS CLI) (p. 159)
•Attaching ﬁlter criteria to an event source mapping (AWS SAM) (p. 160)
•Using ﬁlters with diﬀerent AWS services (p. 160)
•Filtering with DynamoDB  (p. 161)
•Filtering with Kinesis  (p. 165)
•Filtering with Amazon MQ (p. 168)
•Filtering with Amazon MSK and self-managed Apache Kafka (p. 172)
•Filtering with Amazon SQS (p. 175)
Event ﬁltering basics
A ﬁlter criteria ( FilterCriteria ) object is a structure that consists of a list of ﬁlters (Filters ). Each 
ﬁlter is a structure that deﬁnes an event ﬁltering pattern (Pattern). A pattern is a string representation 
of a JSON ﬁlter rule. The structure of a FilterCriteria  object is as follows.
{ 
   "Filters": [ 
        { 
155AWS Lambda Developer Guide
Event ﬁltering basics
            "Pattern": "{ \"Metadata1\": [ rule1 ], \"data\": { \"Data1\": [ rule2 ] }}" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "Metadata1": [ rule1 ], 
    "data": { 
        "Data1": [ rule2 ] 
    }
}
Your ﬁlter pattern can include metadata properties, data properties, or both. The available metadata 
parameters and the format of the data parameters vary according to the AWS service which is acting as 
the event source. For example, suppose your event source mapping receives the following record from an 
Amazon SQS queue:
{ 
    "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
    "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
    "body": "{\n "City": "Seattle",\n "State": "WA",\n "Temperature": "46"\n}", 
    "attributes": { 
        "ApproximateReceiveCount": "1", 
        "SentTimestamp": "1545082649183", 
        "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
        "ApproximateFirstReceiveTimestamp": "1545082649185" 
    }, 
    "messageAttributes": {}, 
    "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
    "eventSource": "aws:sqs", 
    "eventSourceARN": "arn:aws:sqs:us-east-2:123456789012:my-queue", 
    "awsRegion": "us-east-2"
}
•Metadata properties are the ﬁelds containing information about the event that created the record. 
In the example Amazon SQS record, the metadata properties include ﬁelds such as messageID ,
eventSourceArn , and awsRegion .
•Data properties are the ﬁelds of the record containing the data from your stream or queue. In the 
Amazon SQS event example, the key for the data ﬁeld is body, and the data properties are the ﬁelds
City  State , and Temperature .
Diﬀerent types of event source use diﬀerent key values for their data ﬁelds. To ﬁlter on data properties, 
make sure that you use the correct key in your ﬁlter’s pattern. For a list of data ﬁltering keys, and to see 
examples of ﬁlter patterns for each supported AWS service, refer to Using ﬁlters with diﬀerent AWS 
services (p. 160).
Event ﬁltering can handle multi-level JSON ﬁltering. For example, consider the following fragment of a 
record from a DynamoDB stream:
"dynamodb": { 
    "Keys": { 
        "ID": { 
            "S": "ABCD" 
        } 
        "Number": { 
            "N": "1234" 
    }, 
156AWS Lambda Developer Guide
Handling records that don't meet ﬁlter criteria
    ...
}
Suppose you want to process only those records where the value of the sort key Number  is 4567. In this 
case, your FilterCriteria  object would look like this:
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"dynamodb\": { \"Keys\": { \"Number\": { \"N\": 
 [ "4567" ] } } } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "dynamodb": { 
        "Keys": { 
            "Number": { 
                "N": [ "4567" ] 
                } 
            } 
        }
}
Handling records that don't meet ﬁlter criteria
The way in which records that don’t meet your ﬁlter are handled depends on the event source.
•For Amazon SQS, if a message doesn't satisfy your ﬁlter criteria, Lambda automatically removes the 
message from the queue. You don't have to manually delete these messages in Amazon SQS.
•For Kinesis  and DynamoDB , once your ﬁlter criteria processes a record, the streams iterator advances 
past this record. If the record doesn't satisfy your ﬁlter criteria, you don't have to manually delete the 
record from your event source. After the retention period, Kinesis and DynamoDB automatically delete 
these old records. If you want records to be deleted sooner, see Changing the Data Retention Period.
•For Amazon MSK, self-managed Apache Kafka, and Amazon MQ messages, Lambda drops 
messages that don't match all ﬁelds included in the ﬁlter. For self-managed Apache Kafka, Lambda 
commits oﬀsets for matched and unmatched messages after successfully invoking the function. For 
Amazon MQ, Lambda acknowledges matched messages after successfully invoking the function and 
acknowledges unmatched messages when ﬁltering them.
Filter rule syntax
For ﬁlter rules, Lambda supports the Amazon EventBridge rules and uses the same syntax as 
EventBridge. For more information, see Amazon EventBridge event patterns in the Amazon EventBridge 
User Guide .
The following is a summary of all the comparison operators available for Lambda event ﬁltering.
Comparison operator Example Rule syntax
Null UserID is null "UserID": [ null ]
157AWS Lambda Developer Guide
Attaching ﬁlter criteria to an 
event source mapping (console)
Comparison operator Example Rule syntax
Empty LastName is empty "LastName": [""]
Equals Name is "Alice""Name": [ "Alice" ]
Equals (ignore case)Name is "Alice""Name": [ { "equals-ignore-case": 
"alice" } ]
And Location is "New York" and Day 
is "Monday""Location": [ "New York" ], "Day": 
["Monday"]
Or PaymentType is "Credit" or 
"Debit""PaymentType": [ "Credit", 
"Debit"]
Or (multiple ﬁelds) Location is "New York", or Day is 
"Monday"."$or": [ { "Location": [ "New 
York" ] }, { "Day": [ "Monday" ] } ]
Not Weather is anything but 
"Raining""Weather": [ { "anything-but": 
[ "Raining" ] } ]
Numeric (equals)Price is 100 "Price": [ { "numeric": [ "=", 
100 ] } ]
Numeric (range) Price is more than 10, and less 
than or equal to 20"Price": [ { "numeric": [ ">", 10, 
"<=", 20 ] } ]
Exists ProductName exists"ProductName": [ { "exists": 
true } ]
Does not exist ProductName does not exist"ProductName": [ { "exists": 
false } ]
Begins with Region is in the US"Region": [ {"preﬁx": "us-" } ]
Ends with FileName ends with a .png 
extension."FileName": [ { "suﬃx": ".png" } ]
Note
Like EventBridge, for strings, Lambda uses exact character-by-character matching without case-
folding or any other string normalization. For numbers, Lambda also uses string representation. 
For example, 300, 300.0, and 3.0e2 are not considered equal.
Attaching ﬁlter criteria to an event source mapping 
(console)
Follow these steps to create a new event source mapping with ﬁlter criteria using the Lambda console.
To create a new event source mapping with ﬁlter criteria (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of a function to create an event source mapping for.
3. Under Function overview, choose Add trigger .
4. For Trigger conﬁguration, choose a trigger type that supports event ﬁltering. For a list of supported 
services, refer to the list at the beginning of this page.
5. Expand Additional settings.
158AWS Lambda Developer Guide
Attaching ﬁlter criteria to an 
event source mapping (AWS CLI)
6. Under Filter criteria , choose Add, and then deﬁne and enter your ﬁlters. For example, you can enter 
the following.
{ "Metadata" : [ 1, 2 ] }
This instructs Lambda to process only the records where ﬁeld Metadata  is equal to 1 or 2. You can 
continue to select Add to add more ﬁlters up to the maximum allowed number.
7. When you have ﬁnished adding your ﬁlters, choose Save.
When you enter ﬁlter criteria using the console, you enter only the ﬁlter pattern and don't need to 
provide the Pattern key or escape quotes. In step 6 of the preceding instructions, { "Metadata" : 
[ 1, 2 ] }  corresponds to the following FilterCriteria .
{ 
   "Filters": [ 
      { 
          "Pattern": "{ \"Metadata\" : [ 1, 2 ] }" 
      } 
   ]
}
After creating your event source mapping in the console, you can see the formatted FilterCriteria
in the trigger details. For more examples of creating event ﬁlters using the console, see Using ﬁlters with 
diﬀerent AWS services (p. 160).
Attaching ﬁlter criteria to an event source mapping 
(AWS CLI)
Suppose you want an event source mapping to have the following FilterCriteria :
{ 
   "Filters": [ 
      { 
          "Pattern": "{ \"Metadata\" : [ 1, 2 ] }" 
      } 
   ]
}
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line Interface 
(AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:sqs:us-east-2:123456789012:my-queue  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"Metadata\" : [ 1, 2 ]}"}]}'
This create-event-source-mapping command creates a new Amazon SQS event source mapping for 
function my-function  with the speciﬁed FilterCriteria .
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"Metadata\" : [ 1, 2 ]}"}]}'
159AWS Lambda Developer Guide
Attaching ﬁlter criteria to an 
event source mapping (AWS SAM)
Note that to update an event source mapping, you need its UUID. You can get the UUID from a list-
event-source-mappings call. Lambda also returns the UUID in the create-event-source-mapping CLI 
response.
To remove ﬁlter criteria from an event source, you can run the following update-event-source-mapping
command with an empty FilterCriteria  object.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria "{}"
For more examples of creating event ﬁlters using the AWS CLI, see Using ﬁlters with diﬀerent AWS 
services (p. 160).
Attaching ﬁlter criteria to an event source mapping 
(AWS SAM)
Suppose you want to conﬁgure an event source in AWS SAM to use the following ﬁlter criteria:
{ 
   "Filters": [ 
      { 
          "Pattern": "{ \"Metadata\" : [ 1, 2 ] }" 
      } 
   ]
}
To add these ﬁlter criteria to your event source mapping, insert the following snippet into the YAML 
template for your event source.
FilterCriteria:  
  Filters:  
    - Pattern: '{"Metadata": [1, 2]}'
For more information on creating and conﬁguring an AWS SAM template for an event source mapping, 
see the  EventSource section of the AWS SAM Developer Guide. Fore more examples of creating event 
ﬁlters using AWS SAM templates, see Using ﬁlters with diﬀerent AWS services (p. 160).
Using ﬁlters with diﬀerent AWS services
Diﬀerent types of event source use diﬀerent key values for their data ﬁelds. To ﬁlter on data properties, 
make sure that you use the correct key in your ﬁlter’s pattern. The following table gives the ﬁltering keys 
for each supported AWS service.
AWS service Filtering key
DynamoDB dynamodb
Kinesis data
Amazon MQ data
Amazon MSK value
Self-managed Apache Kafka value
Amazon SQS body
160AWS Lambda Developer Guide
Filtering with DynamoDB
The following sections give examples of ﬁlter patterns for diﬀerent types of event source. They also 
provide deﬁnitions of supported incoming data formats and ﬁlter pattern body formats for each 
supported service.
Filtering with DynamoDB
Suppose you have a DynamoDB table with the primary key CustomerName  and attributes
AccountManager  and PaymentTerms . The following shows an example record from your DynamoDB 
table’s stream.
{ 
     "eventID": "1", 
     "eventVersion": "1.0", 
     "dynamodb": { 
         "ApproximateCreationDateTime": "1678831218.0" 
         "Keys": { 
             "CustomerName": { 
                 "S": "AnyCompany Industries" 
             }, 
         "NewImage": { 
             "AccountManager": { 
                 "S": "Pat Candella" 
             }, 
             "PaymentTerms": { 
                 "S": "60 days" 
             }, 
             "CustomerName": { 
                 "S": "AnyCompany Industries" 
     }, 
     "SequenceNumber": "111", 
     "SizeBytes": 26, 
     "StreamViewType": "NEW_AND_OLD_IMAGES" 
 }
To ﬁlter based on the key and attribute values in your DynamoDB table, use the dynamodb  key in 
the record. Suppose you want your function to process only those records where the primary key
CustomerName  is “AnyCompany Industries.” The FilterCriteria  object would be as follows.
{ 
     "Filters": [ 
          { 
              "Pattern": "{ \"dynamodb\" : { \"Keys\" : { \"CustomerName\" : { \"S\" : 
 [ \"AnyCompany Industries\" ] } } } }" 
          } 
      ] 
 }
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
     "dynamodb": { 
          "Keys": { 
              "CustomerName": { 
                  "S": [ "AnyCompany Industries" ] 
                  } 
              } 
          } 
 }
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
161AWS Lambda Developer Guide
Filtering with DynamoDB
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "dynamodb" : { "Keys" : { "CustomerName" : { "S" : [ "AnyCompany 
 Industries" ] } } } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:dynamodb:us-east-2:123456789012:table/my-table  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"Keys\" : 
 { \"CustomerName\" : { \"S\" : [ \"AnyCompany Industries\" ] } } } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"Keys\" : 
 { \"CustomerName\" : { \"S\" : [ \"AnyCompany Industries\" ] } } } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
   Filters: 
     - Pattern: '{ "dynamodb" : { "Keys" : { "CustomerName" : { "S" : [ "AnyCompany 
 Industries" ] } } } }'
With DynamoDB, you can also use the NewImage  and OldImage  keys to ﬁlter for attribute values. 
Suppose you want to ﬁlter records where the AccountManager  attribute in the latest table image is 
“Pat Candella” or "Shirley Rodriguez." The FilterCriteria  object would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"dynamodb\" : { \"NewImage\" : { \"AccountManager\" : { \"S\" : 
 [ \"Pat Candella\", \"Shirley Rodriguez\" ] } } } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "dynamodb": { 
        "NewImage": { 
            "AccountManager": { 
                "S": [ "Pat Candella", "Shirley Rodriguez" ] 
            } 
        } 
162AWS Lambda Developer Guide
Filtering with DynamoDB
    }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "dynamodb" : { "NewImage" : { "AccountManager" : { "S" : [ "Pat Candella", "Shirley 
 Rodriguez" ] } } } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:dynamodb:us-east-2:123456789012:table/my-table  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"NewImage
\" : { \"AccountManager\" : { \"S\" : [ \"Pat Candella\", \"Shirley Rodriguez
\" ] } } } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"NewImage
\" : { \"AccountManager\" : { \"S\" : [ \"Pat Candella\", \"Shirley Rodriguez
\" ] } } } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "dynamodb" : { "NewImage" : { "AccountManager" : { "S" : [ "Pat 
 Candella", "Shirley Rodriguez" ] } } } }'
You can also create ﬁlters using Boolean AND expressions. These expressions can include both your 
table's key and attribute parameters. Suppose you want to ﬁlter records where the NewImage  value of
AccountManager  is "Pat Candella" and the OldImage  value is "Terry Whitlock". The FilterCriteria
object would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"dynamodb\" : { \"NewImage\" : { \"AccountManager\" : { \"S\" : 
 [ \"Pat Candella\" ] } } } , \"dynamodb\" : { \"OldImage\" : { \"AccountManager\" : { \"S
\" : [ \"Terry Whitlock\" ] } } }" 
        } 
    ]
}
163AWS Lambda Developer Guide
Filtering with DynamoDB
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{  
    "dynamodb" : {  
        "NewImage" : {  
            "AccountManager" : {  
                "S" : [  
                    "Pat Candella"  
                ]  
            }  
        }  
    },  
    "dynamodb": {  
        "OldImage": {  
            "AccountManager": {  
                "S": [  
                    "Terry Whitlock"  
                ]  
            }  
        }  
    }  
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "dynamodb" : { "NewImage" : { "AccountManager" : { "S" : [ "Pat Candella" ] } } } , 
 "dynamodb" : { "OldImage" : { "AccountManager" : { "S" : [ "Terry Whitlock" ] } } } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:dynamodb:us-east-2:123456789012:table/my-table  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"NewImage
\" : { \"AccountManager\" : { \"S\" : [ \"Pat Candella\" ] } } } , \"dynamodb\" : 
 { \"OldImage\" : { \"AccountManager\" : { \"S\" : [ \"Terry Whitlock\" ] } } } "}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"dynamodb\" : { \"NewImage
\" : { \"AccountManager\" : { \"S\" : [ \"Pat Candella\" ] } } } , \"dynamodb\" : 
 { \"OldImage\" : { \"AccountManager\" : { \"S\" : [ \"Terry Whitlock\" ] } } } "}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
164AWS Lambda Developer Guide
Filtering with Kinesis
    - Pattern: '{ "dynamodb" : { "NewImage" : { "AccountManager" : { "S" : [ "Pat 
 Candella" ] } } } , "dynamodb" : { "OldImage" : { "AccountManager" : { "S" : [ "Terry 
 Whitlock" ] } } } }'
Note
DynamoDB event ﬁltering doesn’t support the use of numeric operators (numeric equals 
and numeric range). Even if items in your table are stored as numbers, these parameters are 
converted to strings in the JSON record object.
To properly ﬁlter events from DynamoDB sources, both the data ﬁeld and your ﬁlter criteria for the data 
ﬁeld (dynamodb ) must be in valid JSON format. If either ﬁeld isn't in a valid JSON format, Lambda drops 
the message or throws an exception. The following table summarizes the speciﬁc behavior:
Incoming data format Filter pattern format for data 
propertiesResulting action
Valid JSON Valid JSON Lambda ﬁlters based on your 
ﬁlter criteria.
Valid JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Non-JSON Lambda throws an exception 
at the time of the event source 
mapping creation or update. The 
ﬁlter pattern for data properties 
must be in a valid JSON format.
Non-JSON Valid JSON Lambda drops the record.
Non-JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Non-JSON Non-JSON Lambda throws an exception 
at the time of the event source 
mapping creation or update. The 
ﬁlter pattern for data properties 
must be in a valid JSON format.
Filtering with Kinesis
Suppose a producer is putting JSON formatted data into your Kinesis data stream. An example record 
would look like the following, with the JSON data converted to a Base64 encoded string in the data
ﬁeld.
{ 
    "kinesis": { 
        "kinesisSchemaVersion": "1.0", 
        "partitionKey": "1", 
        "sequenceNumber": "49590338271490256608559692538361571095921575989136588898", 
        "data": 
 "eyJSZWNvcmROdW1iZXIiOiAiMDAwMSIsICJUaW1lU3RhbXAiOiAieXl5eS1tbS1kZFRoaDptbTpzcyIsICJSZXF1ZXN0Q29kZSI6ICJBQUFBIn0=", 
        "approximateArrivalTimestamp": 1545084650.987 
        }, 
165AWS Lambda Developer Guide
Filtering with Kinesis
    "eventSource": "aws:kinesis", 
    "eventVersion": "1.0", 
    "eventID": 
 "shardId-000000000006:49590338271490256608559692538361571095921575989136588898", 
    "eventName": "aws:kinesis:record", 
    "invokeIdentityArn": "arn:aws:iam::123456789012:role/lambda-role", 
    "awsRegion": "us-east-2", 
    "eventSourceARN": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream"
}
As long as the data the producer puts into the stream is valid JSON, you can use event ﬁltering to 
ﬁlter records using the data key. Suppose a producer is putting records into your Kinesis stream in the 
following JSON format.
{ 
    "record": 12345, 
    "order": { 
        "type": "buy", 
        "stock": "ANYCO", 
        "quantity": 1000 
        }
}
To ﬁlter only those records where the order type is “buy,” the FilterCriteria  object would be as 
follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"data\" : { \"order\" : { \"type\" : [ \"buy\" ] } } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "data": { 
        "order": { 
            "type": [ "buy" ] 
            } 
      }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "data" : { "order" : { "type" : [ "buy" ] } } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
166AWS Lambda Developer Guide
Filtering with Kinesis
    --event-source-arn arn:aws:kinesis:us-east-2:123456789012:stream/my-stream  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : { \"order\" : { \"type
\" : [ \"buy\" ] } } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : { \"order\" : { \"type
\" : [ \"buy\" ] } } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "data" : { "order" : { "type" : [ "buy" ] } } }'
To properly ﬁlter events from Kinesis sources, both the data ﬁeld and your ﬁlter criteria for the data ﬁeld 
must be in valid JSON format. If either ﬁeld isn't in a valid JSON format, Lambda drops the message or 
throws an exception. The following table summarizes the speciﬁc behavior:
Incoming data format Filter pattern format for data 
propertiesResulting action
Valid JSON Valid JSON Lambda ﬁlters based on your 
ﬁlter criteria.
Valid JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Non-JSON Lambda throws an exception 
at the time of the event source 
mapping creation or update. The 
ﬁlter pattern for data properties 
must be in a valid JSON format.
Non-JSON Valid JSON Lambda drops the record.
Non-JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Non-JSON Non-JSON Lambda throws an exception 
at the time of the event source 
mapping creation or update. The 
ﬁlter pattern for data properties 
must be in a valid JSON format.
Filtering Kinesis aggregated records
With Kinesis, you can aggregate multiple records into a single Kinesis Data Streams record to increase 
your data throughput. Lambda can only apply ﬁlter criteria to aggregated records when you use Kinesis
167AWS Lambda Developer Guide
Filtering with Amazon MQ
enhanced fan-out. Filtering aggregated records with standard Kinesis isn't supported. When using 
enhanced fan-out, you conﬁgure a Kinesis dedicated-throughput consumer to act as the trigger for your 
Lambda function. Lambda then ﬁlters the aggregated records and passes only those records that meet 
your ﬁlter criteria.
To learn more about Kinesis record aggregation, refer to the Aggregation section on the Kinesis Producer 
Library (KPL) Key Concepts page. To Learn more about using Lambda with Kinesis enhanced fan-out, see
Increasing real-time stream processing performance with Amazon Kinesis Data Streams enhanced fan-
out and AWS Lambda on the AWS compute blog.
Filtering with Amazon MQ
Note
When you update an event source mapping for Amazon MQ with new ﬁlter criteria, it can 
take up to 15 minutes for Lambda to apply your changes. Before this period has elapsed, 
previous ﬁlter settings can still be in eﬀect. This is true even when the status of the event source 
mapping displayed in the console has changed from Enabling  to Enabled .
Suppose your Amazon MQ message queue contains messages either in valid JSON format or as plain 
strings. An example record would look like the following, with the data converted to a Base64 encoded 
string in the data  ﬁeld.
ActiveMQ
{  
    "messageID": "ID:b-9bcfa592-423a-4942-879d-eb284b418fc8-1.mq.us-
west-2.amazonaws.com-37557-1234520418293-4:1:1:1:1",  
    "messageType": "jms/text-message", 
    "deliveryMode": 1, 
    "replyTo": null, 
    "type": null, 
    "expiration": "60000", 
    "priority": 1, 
    "correlationId": "myJMSCoID", 
    "redelivered": false, 
    "destination": {  
      "physicalName": "testQueue"  
    }, 
    "data":"QUJDOkFBQUE=", 
    "timestamp": 1598827811958, 
    "brokerInTime": 1598827811958,  
    "brokerOutTime": 1598827811959,  
    "properties": { 
      "index": "1", 
      "doAlarm": "false", 
      "myCustomProperty": "value" 
    }
}
RabbitMQ
{ 
    "basicProperties": { 
        "contentType": "text/plain", 
        "contentEncoding": null, 
        "headers": { 
            "header1": { 
                "bytes": [ 
                  118, 
                  97, 
168AWS Lambda Developer Guide
Filtering with Amazon MQ
                  108, 
                  117, 
                  101, 
                  49 
                ] 
            }, 
            "header2": { 
                "bytes": [ 
                  118, 
                  97, 
                  108, 
                  117, 
                  101, 
                  50 
                ] 
            }, 
            "numberInHeader": 10 
        }, 
        "deliveryMode": 1, 
        "priority": 34, 
        "correlationId": null, 
        "replyTo": null, 
        "expiration": "60000", 
        "messageId": null, 
        "timestamp": "Jan 1, 1970, 12:33:41 AM", 
        "type": null, 
        "userId": "AIDACKCEVSQ6C2EXAMPLE", 
        "appId": null, 
        "clusterId": null, 
        "bodySize": 80 
        }, 
    "redelivered": false, 
    "data": "eyJ0aW1lb3V0IjowLCJkYXRhIjoiQ1pybWYwR3c4T3Y0YnFMUXhENEUifQ=="
} 
                 
For both Active MQ and Rabbit MQ brokers, you can use event ﬁltering to ﬁlter records using the data
key. Suppose your Amazon MQ queue contains messages in the following JSON format.
{ 
    "timeout": 0, 
    "IPAddress": "203.0.113.254"
}
To ﬁlter only those records where the timeout ﬁeld is greater than 0, the FilterCriteria  object 
would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"data\" : { \"timeout\" : [ { \"numeric\": [ \">\", 
 0] } } ] } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "data": { 
        "timeout": [ { "numeric": [ ">", 0 ] } ] 
169AWS Lambda Developer Guide
Filtering with Amazon MQ
        }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
to add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "data" : { "timeout" : [ { "numeric": [ ">", 0 ] } ] } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:mq:us-east-2:123456789012:broker:my-
broker:b-8ac7cc01-5898-482d-be2f-a6b596050ea8  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : { \"timeout\" : 
 [ { \"numeric\": [ \">\", 0 ] } ] } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : { \"timeout\" : 
 [ { \"numeric\": [ \">\", 0 ] } ] } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "data" : { "timeout" : [ { "numeric": [ ">", 0 ] } ] } }'
With Amazon MQ, you can also ﬁlter records where the message is a plain string. Suppose you want to 
process only records where the message begins with "Result: ". The FilterCriteria  object would look 
as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"data\" : [ { \"prefix\": \"Result: \" } ] }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "data": [ 
        { 
170AWS Lambda Developer Guide
Filtering with Amazon MQ
        "prefix": "Result: " 
        } 
    ]
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "data" : [ { "prefix": "Result: " } ] }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:mq:us-east-2:123456789012:broker:my-
broker:b-8ac7cc01-5898-482d-be2f-a6b596050ea8  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : [ { \"prefix\": \"Result: 
 \" } ] }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"data\" : [ { \"prefix\": \"Result: 
 \" } ] }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "data" : [ { "prefix": "Result " } ] }'
Amazon MQ messages must be UTF-8 encoded strings, either plain strings or in JSON format. That's 
because Lambda decodes Amazon MQ byte arrays into UTF-8 before applying ﬁlter criteria. If your 
messages use another encoding, such as UTF-16 or ASCII, or if the message format doesn't match the
FilterCriteria  format, Lambda processes metadata ﬁlters only. The following table summarizes the 
speciﬁc behavior:
Incoming message format Filter pattern format for 
message propertiesResulting action
Plain string Plain string Lambda ﬁlters based on your 
ﬁlter criteria.
Plain string No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
171AWS Lambda Developer Guide
Filtering with Amazon MSK and 
self-managed Apache Kafka
Incoming message formatFilter pattern format for 
message propertiesResulting action
Plain string Valid JSON Lambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Plain string Lambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Valid JSON Lambda ﬁlters based on your 
ﬁlter criteria.
Non-UTF-8 encoded stringJSON, plain string, or no patternLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Filtering with Amazon MSK and self-managed Apache 
Kafka
Note
When you update an event source mapping for Amazon MSK or self-managed Apache Kafka 
with new ﬁlter criteria, it can take up to 15 minutes for Lambda to apply your changes. Before 
this period has elapsed, previous ﬁlter settings can still be in eﬀect. This is true even when the 
status of the event source mapping displayed in the console has changed from Enabling  to
Enabled .
Suppose a producer is writing messages to a topic in your Amazon MSK or self-managed Apache Kafka 
cluster, either in valid JSON format or as plain strings. An example record would look like the following, 
with the message converted to a Base64 encoded string in the value  ﬁeld.
{ 
    "mytopic-0":[ 
        { 
            "topic":"mytopic", 
            "partition":0, 
            "offset":15, 
            "timestamp":1545084650987, 
            "timestampType":"CREATE_TIME", 
            "value":"SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
            "headers":[] 
        } 
    ]
}
Suppose your Apache Kafka producer is writing messages to your topic in the following JSON format.
{ 
    "device_ID": "AB1234", 
    "session":{ 
        "start_time": "yyyy-mm-ddThh:mm:ss", 
        "duration": 162 
172AWS Lambda Developer Guide
Filtering with Amazon MSK and 
self-managed Apache Kafka
    }
}
You can use the value key to ﬁlter records. Suppose you wanted to ﬁlter only those records where
device_ID  begins with the letters AB. The FilterCriteria  object would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"value\" : { \"device_ID\" : [ { \"prefix\": \"AB\" } ] } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "value": { 
        "device_ID": [ { "prefix": "AB" } ] 
      }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "value" : { "device_ID" : [ { "prefix":  "AB" } ] } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:kafka:us-east-2:123456789012:cluster/my-cluster/
b-8ac7cc01-5898-482d-be2f-a6b596050ea8  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"value\" : { \"device_ID\" : 
 [ { \"prefix\":  \"AB\" } ] } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"value\" : { \"device_ID\" : 
 [ { \"prefix\":  \"AB\" } ] } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "value" : { "device_ID" : [ { "prefix":  "AB" } ] } }'
173AWS Lambda Developer Guide
Filtering with Amazon MSK and 
self-managed Apache Kafka
With Amazon MSK and self-managed Apache Kafka, you can also ﬁlter records where the message 
is a plain string. Suppose you want to ignore those messages where the string is "error". The
FilterCriteria  object would look as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"value\" : [ { \"anything-but\": [ \"error\" ] } ] }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "value": [ 
        { 
        "anything-but": [ "error" ] 
        } 
    ]
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "value" : [ { "anything-but": [ "error" ] } ] }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:kafka:us-east-2:123456789012:cluster/my-cluster/
b-8ac7cc01-5898-482d-be2f-a6b596050ea8  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"value\" : [ { \"anything-but\": 
 [ \"error\" ] } ] }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"value\" : [ { \"anything-but\": 
 [ \"error\" ] } ] }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
174AWS Lambda Developer Guide
Filtering with Amazon SQS
    - Pattern: '{ "value" : [ { "anything-but": [ "error" ] } ] }'
Amazon MSK and self-managed Apache Kafka messages must be UTF-8 encoded strings, either plain 
strings or in JSON format. That's because Lambda decodes Amazon MSK byte arrays into UTF-8 before 
applying ﬁlter criteria. If your messages use another encoding, such as UTF-16 or ASCII, or if the message 
format doesn't match the FilterCriteria  format, Lambda processes metadata ﬁlters only. The 
following table summarizes the speciﬁc behavior:
Incoming message format Filter pattern format for 
message propertiesResulting action
Plain string Plain string Lambda ﬁlters based on your 
ﬁlter criteria.
Plain string No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Plain string Valid JSON Lambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Plain string Lambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Valid JSON Lambda ﬁlters based on your 
ﬁlter criteria.
Non-UTF-8 encoded string JSON, plain string, or no patternLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Filtering with Amazon SQS
Suppose your Amazon SQS queue contains messages in the following JSON format.
{ 
    "RecordNumber": 0000, 
    "TimeStamp": "yyyy-mm-ddThh:mm:ss", 
    "RequestCode": "AAAA"
}
An example record for this queue would look as follows.
{ 
    "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
    "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
    "body": "{\n "RecordNumber": 0000,\n "TimeStamp": "yyyy-mm-ddThh:mm:ss",\n 
 "RequestCode": "AAAA"\n}", 
    "attributes": { 
        "ApproximateReceiveCount": "1", 
175AWS Lambda Developer Guide
Filtering with Amazon SQS
        "SentTimestamp": "1545082649183", 
        "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
        "ApproximateFirstReceiveTimestamp": "1545082649185" 
        }, 
    "messageAttributes": {}, 
    "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
    "eventSource": "aws:sqs", 
    "eventSourceARN": "arn:aws:sqs:us-west-2:123456789012:my-queue", 
    "awsRegion": "us-west-2"
}
To ﬁlter based on the contents of your Amazon SQS messages, use the body key in the Amazon SQS 
message record. Suppose you want to process only those records where the RequestCode  in your 
Amazon SQS message is “BBBB.” The FilterCriteria  object would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"body\" : { \"RequestCode\" : [ \"BBBB\" ] } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "body": { 
        "RequestCode": [ "BBBB" ] 
        }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "body" : { "RequestCode" : [ "BBBB" ] } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:sqs:us-east-2:123456789012:my-queue  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"body\" : { \"RequestCode\" : 
 [ \"BBBB\" ] } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"body\" : { \"RequestCode\" : 
 [ \"BBBB\" ] } }"}]}'
176AWS Lambda Developer Guide
Filtering with Amazon SQS
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "body" : { "RequestCode" : [ "BBBB" ] } }'
Suppose you want your function to process only those records where RecordNumber  is greater than 
9999. The FilterCriteria  object would be as follows.
{ 
    "Filters": [ 
        { 
            "Pattern": "{ \"body\" : { \"RecordNumber\" : [ { \"numeric\": [ \">\", 
 9999 ] } ] } }" 
        } 
    ]
}
For added clarity, here is the value of the ﬁlter's Pattern expanded in plain JSON.
{ 
    "body": { 
        "RecordNumber": [ 
            { 
                "numeric": [ ">", 9999 ] 
            } 
        ] 
    }
}
You can add your ﬁlter using the console, AWS CLI or an AWS SAM template.
Console
To add this ﬁlter using the console, follow the instructions in Attaching ﬁlter criteria to an event 
source mapping (console) (p. 158) and enter the following string for the Filter criteria .
{ "body" : { "RecordNumber" : [ { "numeric": [ ">", 9999 ] } ] } }
AWS CLI
To create a new event source mapping with these ﬁlter criteria using the AWS Command Line 
Interface (AWS CLI), run the following command.
aws lambda create-event-source-mapping \ 
    --function-name my-function  \ 
    --event-source-arn arn:aws:sqs:us-east-2:123456789012:my-queue  \ 
    --filter-criteria '{"Filters": [{"Pattern": "{ \"body\" : { \"RecordNumber\" : 
 [ { \"numeric\": [ \">\", 9999 ] } ] } }"}]}'
To add these ﬁlter criteria to an existing event source mapping, run the following command.
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
177AWS Lambda Developer Guide
Filtering with Amazon SQS
    --filter-criteria '{"Filters": [{"Pattern": "{ \"body\" : { \"RecordNumber\" : 
 [ { \"numeric\": [ \">\", 9999 ] } ] } }"}]}'
AWS SAM
To add this ﬁlter using AWS SAM, add the following snippet to the YAML template for your event 
source.
FilterCriteria: 
  Filters: 
    - Pattern: '{ "body" : { "RecordNumber" : [ { "numeric": [ ">", 9999 ] } ] } }'
For Amazon SQS, the message body can be any string. However, this can be problematic if your
FilterCriteria  expect body to be in a valid JSON format. The reverse scenario is also true—if the 
incoming message body is in JSON format but your ﬁlter criteria expects body  to be a plain string, this 
can lead to unintended behavior.
To avoid this issue, ensure that the format of body in your FilterCriteria  matches the expected 
format of body in messages that you receive from your queue. Before ﬁltering your messages, Lambda 
automatically evaluates the format of the incoming message body and of your ﬁlter pattern for body . If 
there is a mismatch, Lambda drops the message. The following table summarizes this evaluation:
Incoming message body  format Filter pattern body  format Resulting action
Plain string Plain string Lambda ﬁlters based on your 
ﬁlter criteria.
Plain string No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Plain string Valid JSON Lambda drops the message.
Valid JSON Plain string Lambda drops the message.
Valid JSON No ﬁlter pattern for data 
propertiesLambda ﬁlters (on the other 
metadata properties only) based 
on your ﬁlter criteria.
Valid JSON Valid JSON Lambda ﬁlters based on your 
ﬁlter criteria.
178AWS Lambda Developer Guide
Function states
Lambda function states
Lambda includes a state ﬁeld in the function conﬁguration for all functions to indicate when your 
function is ready to invoke. State provides information about the current status of the function, 
including whether you can successfully invoke the function. Function states do not change the behavior 
of function invocations or how your function runs the code. Function states include:
•Pending – After Lambda creates the function, it sets the state to pending. While in pending state, 
Lambda attempts to create or conﬁgure resources for the function, such as VPC or EFS resources. 
Lambda does not invoke a function during pending state. Any invocations or other API actions that 
operate on the function will fail.
•Active – Your function transitions to active state after Lambda completes resource conﬁguration and 
provisioning. Functions can only be successfully invoked while active.
•Failed – Indicates that resource conﬁguration or provisioning encountered an error.
•Inactive  – A function becomes inactive when it has been idle long enough for Lambda to reclaim 
the external resources that were conﬁgured for it. When you try to invoke a function that is inactive, 
the invocation fails and Lambda sets the function to pending state until the function resources are 
recreated. If Lambda fails to recreate the resources, the function is set to the inactive state.
If you are using SDK-based automation workﬂows or calling Lambda’s service APIs directly, ensure that 
you check a function's state before invocation to verify that it is active. You can do this with the Lambda 
API action GetFunction (p. 1359 ), or by conﬁguring a waiter using the AWS SDK for Java 2.0.
aws lambda get-function --function-name my-function --query 'Configuration.[State, 
 LastUpdateStatus]'
You should see the following output:
[ 
 "Active", 
 "Successful"  
]
Functions have two other attributes, StateReason  and StateReasonCode . These provide information 
and context about the function’s state when it is not active for troubleshooting issues.
The following operations fail while function creation is pending:
•Invoke (p. 1399 )
•UpdateFunctionCode (p. 1506 )
•UpdateFunctionConﬁguration (p. 1516 )
•PublishVersion (p. 1454 )
Function states while updating
Lambda provides additional context for functions undergoing updates with the LastUpdateStatus
attribute, which can have the following statuses:
•InProgress  – An update is happening on an existing function. While a function update is in progress, 
invocations go to the function’s previous code and conﬁguration.
•Successful  – The update has completed. Once Lambda ﬁnishes the update, this stays set until a 
further update.
179AWS Lambda Developer Guide
Function states while updating
•Failed – The function update has failed. Lambda aborts the update and the function’s previous code 
and conﬁguration remain available.
Example
The following is the result of get-function-configuration  on a function undergoing an update.
{ 
    "FunctionName": "my-function", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "Runtime": "nodejs18.x", 
    "VpcConfig": { 
        "SubnetIds": [ 
            "subnet-071f712345678e7c8", 
            "subnet-07fd123456788a036", 
            "subnet-0804f77612345cacf" 
        ], 
        "SecurityGroupIds": [ 
            "sg-085912345678492fb" 
        ], 
        "VpcId": "vpc-08e1234569e011e83" 
    }, 
     "State": "Active", 
    "LastUpdateStatus": "InProgress" , 
    ...
}
FunctionConﬁguration (p. 1569 ) has two other attributes, LastUpdateStatusReason  and
LastUpdateStatusReasonCode , to help troubleshoot issues with updating.
The following operations fail while an asynchronous update is in progress:
•UpdateFunctionCode (p. 1506 )
•UpdateFunctionConﬁguration (p. 1516 )
•PublishVersion (p. 1454 )
•TagResource (p. 1484 )
180AWS Lambda Developer Guide
Error handling
Error handling and automatic retries in AWS 
Lambda
When you invoke a function, two types of error can occur. Invocation errors occur when the invocation 
request is rejected before your function receives it. Function errors occur when your function's code or
runtime  (p. 41) returns an error. Depending on the type of error, the type of invocation, and the client or 
service that invokes the function, the retry behavior and the strategy for managing errors varies.
Issues with the request, caller, or account can cause invocation errors. Invocation errors include an error 
type and status code in the response that indicate the cause of the error.
Common invocation errors
•Request – The request event is too large or isn't valid JSON, the function doesn't exist, or a parameter 
value is the wrong type.
•Caller – The user or service doesn't have permission to invoke the function.
•Account – The maximum number of function instances are already running, or requests are being 
made too quickly.
Clients such as the AWS CLI and the AWS SDK retry on client timeouts, throttling errors (429), and other 
errors that aren't caused by a bad request. For a full list of invocation errors, see Invoke (p. 1399 ).
Function errors occur when your function code or the runtime that it uses return an error.
Common function errors
•Function – Your function's code throws an exception or returns an error object.
•Runtime  – The runtime terminated your function because it ran out of time, detected a syntax error, or 
failed to marshal the response object into JSON. The function exited with an error code.
Unlike invocation errors, function errors don't cause Lambda to return a 400-series or 500-series status 
code. If the function returns an error, Lambda indicates this by including a header named X-Amz-
Function-Error , and a JSON-formatted response with the error message and other details. For 
examples of function errors in each language, see the following topics.
•AWS Lambda function errors in Node.js (p. 304)
•AWS Lambda function errors in Python (p. 388)
•AWS Lambda function errors in Ruby (p. 429)
•AWS Lambda function errors in Java (p. 488)
•AWS Lambda function errors in Go (p. 547)
•AWS Lambda function errors in C# (p. 586)
•AWS Lambda function errors in PowerShell (p. 611)
When you invoke a function directly, you determine the strategy for handling errors related to your 
function code. Lambda does not automatically retry these types of errors on your behalf. To retry, you 
can manually re-invoke your function, send the failed event to a queue for debugging, or ignore the 
error. Your function's code might have run completely, partially, or not at all. If you retry, ensure that 
your function's code can handle the same event multiple times without causing duplicate transactions or 
other unwanted side eﬀects.
When you invoke a function indirectly, you need to be aware of the retry behavior of the invoker and any 
service that the request encounters along the way. This includes the following scenarios.
181AWS Lambda Developer Guide
Error handling
•Asynchronous invocation – Lambda retries function errors twice. If the function doesn't have enough 
capacity to handle all incoming requests, events might wait in the queue for hours or days to be sent 
to the function. You can conﬁgure a dead-letter queue on the function to capture events that weren't 
successfully processed. For more information, see Asynchronous invocation (p. 142).
•Event source mappings – Event source mappings that read from streams retry the entire batch of 
items. Repeated errors block processing of the aﬀected shard until the error is resolved or the items 
expire. To detect stalled shards, you can monitor the Iterator Age (p. 965) metric.
For event source mappings that read from a queue, you determine the length of time between retries 
and destination for failed events by conﬁguring the visibility timeout and redrive policy on the source 
queue. For more information, see Lambda event source mappings (p. 150) and the service-speciﬁc 
topics under Using AWS Lambda with other services (p. 628).
•AWS services – AWS services can invoke your function synchronously (p. 139) or asynchronously. 
For synchronous invocation, the service decides whether to retry. For example, Amazon S3 batch 
operations retries the operation if the Lambda function returns a TemporaryFailure  response code. 
Services that proxy requests from an upstream user or client may have a retry strategy or may relay 
the error response back to the requestor. For example, API Gateway always relays the error response 
back to the requestor.
For asynchronous invocation, the behavior is the same as when you invoke the function synchronously. 
For more information, see the service-speciﬁc topics under Using AWS Lambda with other 
services (p. 628) and the invoking service's documentation.
•Other accounts and clients – When you grant access to other accounts, you can use resource-based 
policies  (p. 929) to restrict the services or resources they can conﬁgure to invoke your function. To 
protect your function from being overloaded, consider putting an API layer in front of your function 
with Amazon API Gateway (p. 634).
To help you deal with errors in Lambda applications, Lambda integrates with services like Amazon 
CloudWatch and AWS X-Ray. You can use a combination of logs, metrics, alarms, and tracing to quickly 
detect and identify issues in your function code, API, or other resources that support your application. 
For more information, see Monitoring and troubleshooting Lambda functions (p. 961).
For a sample application that uses a CloudWatch Logs subscription, X-Ray tracing, and a Lambda 
function to detect and process errors, see Error processor sample application for AWS Lambda (p. 1121 ).
182AWS Lambda Developer Guide
Invoking functions deﬁned as container images
Invoking functions deﬁned as container images
For a Lambda function deﬁned as a container image, function behavior during invocation is very 
similar to a function deﬁned as a .zip ﬁle archive. The following sections highlight the similarities and 
diﬀerences.
Topics
•Function lifecycle (p. 183)
•Invoking the function (p. 183)
•Image security (p. 183)
Function lifecycle
After you upload a new or updated container image, Lambda optimizes the image before the function 
can process invocations. The optimization process can take a few seconds. The function remains in the
Pending state until the process completes. The function then transitions to the Active  state. While the 
state is Pending, you can invoke the function, but other operations on the function fail. Invocations that 
occur while an image update is in progress run the code from the previous image.
If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function 
transitions to the Inactive  state. To reactivate the function, you must invoke it. Lambda rejects the 
ﬁrst invocation and the function enters the Pending state until Lambda re-optimizes the image. The 
function then returns to the Active  state.
Lambda periodically fetches the associated container image from the Amazon Elastic Container Registry 
(Amazon ECR) repository. If the corresponding container image no longer exists on Amazon ECR or 
permissions are revoked, the function enters the Failed state, and Lambda returns a failure for any 
function invocations.
You can use the Lambda API to get information about a function's state. For more information, see
Lambda function states (p. 179).
Invoking the function
When you invoke the function, Lambda deploys the container image to an execution environment. 
Lambda initializes any extensions (p. 1002 ) and then runs the function’s initialization code (the code 
outside the main handler). Note that function initialization duration is included in billed execution time.
Lambda then runs the function by calling the code entry point speciﬁed in the function conﬁguration 
(the ENTRYPOINT and CMD container image settings (p. 126)).
Image security
When Lambda ﬁrst downloads the container image from its original source (Amazon ECR), the container 
image is optimized, encrypted, and stored using authenticated convergent encryption methods. All 
keys that are required to decrypt customer data are protected using AWS KMS customer managed 
keys. To track and audit Lambda's usage of customer managed keys, you can view the AWS CloudTrail 
logs (p. 657).
183AWS Lambda Developer Guide
Recursive loop detection
Lambda recursive loop detection
When you conﬁgure a Lambda function to output to the same service or resource that invokes the 
function, it's possible to create an inﬁnite recursive loop. For example, a Lambda function might write 
a message to an Amazon Simple Queue Service (Amazon SQS) queue, which then invokes the same 
function. This invocation causes the function to write another message to the queue, which in turn 
invokes the function again.
Unintentional recursive loops can result in unexpected charges being billed to your AWS account. Loops 
can also cause Lambda to scale  (p. 220) and use all of your account's available concurrency. To help 
reduce the impact of unintentional loops, Lambda can detect certain types of recursive loops shortly 
after they occur. When Lambda detects a recursive loop, it stops your function being invoked and notiﬁes 
you.
If your design intentionally uses recursive patterns, then you can request to turn oﬀ Lambda recursive 
loop detection. To request this change, contact AWS Support.
Important
If your design intentionally uses a Lambda function to write data back to the same AWS 
resource that invokes the function, then use caution and implement suitable guard rails to 
prevent unexpected charges being billed to your AWS account. To learn more about best 
practices for using recursive invocation patterns, see Recursive patterns that cause run-away 
Lambda functions in Serverless Land.
Sections
•Understanding recursive loop detection (p. 184)
•Supported AWS services and SDKs (p. 185)
•Recursive loop notiﬁcations (p. 186)
•Responding to recursive loop detection notiﬁcations (p. 187)
Understanding recursive loop detection
Recursive loop detection in Lambda works by tracking events. Lambda is an event-driven compute 
service that runs your function code when certain events occur. For example, when an item is added 
to an Amazon SQS queue or Amazon Simple Notiﬁcation Service (Amazon SNS) topic. Lambda passes 
events to your function as JSON objects, which contain information about the change in the system 
state. When an event causes your function to run, this is called an invocation.
To detect recursive loops, Lambda uses AWS X-Ray tracing headers. When AWS services that support 
recursive loop detection (p. 185) send events to Lambda, those events are automatically annotated 
with metadata. When your Lambda function writes one of these events to another supported AWS 
service using a supported version of an AWS SDK (p. 186), it updates this metadata. The updated 
metadata includes a count of the number of times that the event has invoked the function.
Note
You don't need to enable X-Ray active tracing for this feature to work. Recursive loop detection 
is turned on by default for all AWS customers. There is no charge to use the feature.
A chain of requests  is a sequence of Lambda invocations caused by the same triggering event. For 
example, imagine that an Amazon SQS queue invokes your Lambda function. Your Lambda function then 
sends the processed event back to the same Amazon SQS queue, which invokes your function again. In 
this example, each invocation of your function falls in the same chain of requests.
If your function is invoked more than 16 times in the same chain of requests, then Lambda automatically 
stops the next function invocation in that request chain and notiﬁes you. If you have an on-failure 
destination  (p. 144) or dead-letter queue (p. 148) conﬁgured for your function, then Lambda also sends 
the event from the stopped invocation to your destination or dead-letter queue. Lambda stops only 
184AWS Lambda Developer Guide
Supported AWS services and SDKs
invocations that are part of the same chain of requests. For example, if your function is conﬁgured with 
multiple triggers, then invocations from other triggers aren't aﬀected.
Note
If you conﬁgure a destination or dead-letter queue for your function, then be sure not to use 
an Amazon SNS topic or Amazon SQS queue that your function also uses as an event trigger or 
event source mapping. If you send events to the same resource that invokes your function, then 
you can create another recursive loop.
Supported AWS services and SDKs
Lambda can detect only recursive loops that include certain supported AWS services. For recursive loops 
to be detected, your function must also use one of the supported AWS SDKs.
Supported AWS services
Lambda currently detects recursive loops between your functions, Amazon SQS, and Amazon SNS. 
Lambda also detects loops comprised only of Lambda functions, which may invoke each other 
synchronously or asynchronously. The following diagrams show some examples of loops that Lambda 
can detect:
When another AWS service such as Amazon DynamoDB or Amazon Simple Storage Service (Amazon S3) 
forms part of the loop, Lambda can't currently detect and stop it.
Because Lambda currently detects only recursive loops involving Amazon SQS and Amazon SNS, it's 
still possible that loops involving other AWS services can result in unintended usage of your Lambda 
functions.
185AWS Lambda Developer Guide
Recursive loop notiﬁcations
To guard against unexpected charges being billed to your AWS account, we recommend that you 
conﬁgure Amazon CloudWatch alarms to alert you to unusual usage patterns. For example, you can 
conﬁgure CloudWatch to notify you about spikes in Lambda function concurrency or invocations. You can 
also conﬁgure a billing alarm  to notify you when spending in your account exceeds a threshold that you 
specify. Or, you can use AWS Cost Anomaly Detection to alert you to unusual billing patterns.
Supported AWS SDKs
For Lambda to detect recursive loops, your function must use one of the following SDK versions or 
higher:
Runtime Minimum required AWS SDK version
Node.js 2.1147.0 (SDK version 2)
3.105.0 (SDK version 3)
Python 1.24.46 (boto3)
1.27.46 (botocore)
Java 8 and Java 11 1.12.200 (SDK version 1)
2.17.135 (SDK version 2)
Java 17 2.20.81
.NET 3.7.293.0
Ruby 3.134.0
Some Lambda runtimes such as Python and Node.js include a version of the AWS SDK. If the SDK version 
included in your function's runtime is lower than the minimum required, then you can add a supported 
version of the SDK to your function's deployment package (p. 18). You can also add a supported SDK 
version to your function using a Lambda layer (p. 988). For a list of the SDKs included with each 
Lambda runtime, see Lambda runtimes  (p. 41).
Lambda recursion detection is not supported for the Lambda Go runtime.
Recursive loop notiﬁcations
When Lambda stops a recursive loop, you receive notiﬁcations through the AWS Health Dashboard and 
through email. You can also use CloudWatch metrics to monitor the number of recursive invocations that 
Lambda has stopped.
AWS Health Dashboard notiﬁcations
When Lambda stops a recursive invocation, the AWS Health Dashboard displays a notiﬁcation on the
Your account health page, under Open and recent issues. Note that it can take up to three hours 
after Lambda stops a recursive invocation before this notiﬁcation is displayed. For more information 
about viewing account events in the AWS Health Dashboard, see Getting started with your AWS Health 
Dashboard – Your account health in the AWS Health User Guide.
Email alerts
When Lambda ﬁrst stops a recursive invocation of your function, it sends you an email alert. Lambda 
sends a maximum of one email every 24 hours for each function in your AWS account. After Lambda 
186AWS Lambda Developer Guide
Responding to recursive loop detection notiﬁcations
sends an email notiﬁcation, you won't receive any more emails for that function for another 24 hours, 
even if Lambda stops further recursive invocations of the function. Note that it can take up to three 
hours after Lambda stops a recursive invocation before you receive this email alert.
Lambda sends recursive loop email alerts to your AWS account's primary account contact and alternate 
operations contact. For information about viewing or updating the email addresses in your account, see
Updating contact information in the AWS General Reference.
Amazon CloudWatch metrics
The CloudWatch metric (p. 965) RecursiveInvocationsDropped  records the number of function 
invocations that Lambda has stopped because your function has been invoked more than 16 times in a 
single chain of requests. Lambda emits this metric as soon as it stops a recursive invocation. To view this 
metric, follow the instructions for Viewing metrics on the CloudWatch console and choose the metric
RecursiveInvocationsDropped .
Responding to recursive loop detection notiﬁcations
When your function is invoked more than 16 times by the same triggering event, Lambda stops the next 
function invocation for that event to break the recursive loop. To prevent a reoccurrence of a recursive 
loop that Lambda has broken, do the following:
•Reduce your function's available concurrency (p. 220) to zero, which throttles all future invocations.
•Remove or disable the trigger or event source mapping that's invoking your function.
•Identify and ﬁx code defects that write events back to the AWS resource that's invoking your function. 
A common source of defects occurs when you use variables to deﬁne a function's event source and 
target. Check that you're not using the same value for both variables.
Additionally, if the event source for your Lambda function is an Amazon SQS queue, then consider
conﬁguring a dead-letter queue on the source queue.
Note
Make sure that you conﬁgure the dead-letter queue on the source queue, not on the Lambda 
function. The dead-letter queue that you conﬁgure on a function is used for the function's
asynchronous invocation queue (p. 142), not for event source queues.
If the event source is an Amazon SNS topic, then consider adding an on-failure destination (p. 144) for 
your function.
To reduce your function's available concurrency to zero (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of your function.
3. Choose Throttle.
4. In the Throttle your function dialog box, choose Conﬁrm .
To remove a trigger or event source mapping for your function (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of your function.
3. Choose the Conﬁguration  tab, then choose Triggers.
4. Under Triggers, select the trigger or event source mapping that you want to delete, then choose
Delete.
5. In the Delete triggers dialog box, choose Delete.
187AWS Lambda Developer Guide
Responding to recursive loop detection notiﬁcations
To disable an event source mapping for your function (AWS CLI)
1. To ﬁnd the UUID for the event source mapping that you want to disable, run the AWS Command 
Line Interface (AWS CLI) list-event-source-mappings command.
aws lambda list-event-source-mappings
2. To disable the event source mapping, run the following AWS CLI update-event-source-mapping
command.
aws lambda update-event-source-mapping --function-name MyFunction  \
--uuid a1b2c3d4-5678-90ab-cdef-EXAMPLE11111  --no-enabled
188AWS Lambda Developer Guide
Function URLs
Lambda function URLs
A function URL is a dedicated HTTP(S) endpoint for your Lambda function. You can create and conﬁgure 
a function URL through the Lambda console or the Lambda API. When you create a function URL, 
Lambda automatically generates a unique URL endpoint for you. Once you create a function URL, its URL 
endpoint never changes. Function URL endpoints have the following format:
https:// <url-id> .lambda-url.<region>.on.aws
Note
Function URLs are not supported in the following regions: Asia Paciﬁc (Hyderabad) (ap-
south-2), Europe (Spain) (eu-south-2 ), and Middle East (UAE) (me-central-1 ).
Function URLs are dual stack-enabled, supporting IPv4 and IPv6. After you conﬁgure a function URL 
for your function, you can invoke your function through its HTTP(S) endpoint via a web browser, curl, 
Postman, or any HTTP client.
Note
You can access your function URL through the public Internet only. While Lambda functions do 
support AWS PrivateLink, function URLs do not.
Lambda function URLs use resource-based policies (p. 929) for security and access control. Function 
URLs also support cross-origin resource sharing (CORS) conﬁguration options.
You can apply function URLs to any function alias, or to the $LATEST unpublished function version. You 
can't add a function URL to any other function version.
Topics
•Creating and managing Lambda function URLs (p. 190)
•Security and auth model for Lambda function URLs (p. 195)
•Invoking Lambda function URLs (p. 200)
•Monitoring Lambda function URLs (p. 207)
•Tutorial: Creating a Lambda function with a function URL (p. 209)
189AWS Lambda Developer Guide
Creating and managing function URLs
Creating and managing Lambda function URLs
A function URL is a dedicated HTTP(S) endpoint for your Lambda function. You can create and conﬁgure 
a function URL through the Lambda console or the Lambda API. When you create a function URL, 
Lambda automatically generates a unique URL endpoint for you. Once you create a function URL, its URL 
endpoint never changes. Function URL endpoints have the following format:
https:// <url-id> .lambda-url.<region>.on.aws
Note
Function URLs are not supported in the following regions: Asia Paciﬁc (Hyderabad) (ap-
south-2), Europe (Spain) (eu-south-2 ), and Middle East (UAE) (me-central-1 ).
The following section show how to create and manage a function URL using the Lambda console, AWS 
CLI, and AWS CloudFormation template
Topics
•Creating a function URL (console) (p. 190)
•Creating a function URL (AWS CLI) (p. 191)
•Adding a function URL to a CloudFormation template (p. 192)
•Cross-origin resource sharing (CORS) (p. 193)
•Throttling function URLs (p. 193)
•Deactivating function URLs (p. 194)
•Deleting function URLs (p. 194)
Creating a function URL (console)
Follow these steps to create a function URL using the console.
To create a function URL for an existing function (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to create the function URL for.
3. Choose the Conﬁguration  tab, and then choose Function URL.
4. Choose Create function URL.
5. For Auth type, choose AWS_IAM or NONE . For more information about function URL 
authentication, see Security and auth model (p. 195).
6. (Optional) Select Conﬁgure cross-origin resource sharing (CORS), and then conﬁgure the CORS 
settings for your function URL. For more information about CORS, see Cross-origin resource sharing 
(CORS) (p. 193).
7. Choose Save.
This creates a function URL for the $LATEST unpublished version of your function. The function URL 
appears in the Function overview section of the console.
To create a function URL for an existing alias (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of the function with the alias that you want to create the function URL for.
3. Choose the Aliases  tab, and then choose the name of the alias that you want to create the function 
URL for.
190AWS Lambda Developer Guide
Creating and managing function URLs
4. Choose the Conﬁguration  tab, and then choose Function URL.
5. Choose Create function URL.
6. For Auth type, choose AWS_IAM or NONE . For more information about function URL 
authentication, see Security and auth model (p. 195).
7. (Optional) Select Conﬁgure cross-origin resource sharing (CORS), and then conﬁgure the CORS 
settings for your function URL. For more information about CORS, see Cross-origin resource sharing 
(CORS) (p. 193).
8. Choose Save.
This creates a function URL for your function alias. The function URL appears in the console's Function 
overview section for your alias.
To create a new function with a function URL (console)
To create a new function with a function URL (console)
1. Open the Functions page of the Lambda console.
2. Choose Create function.
3. Under Basic information , do the following:
a. For Function name, enter a name for your function, such as my-function .
b. For Runtime , choose the language runtime that you prefer, such as Node.js 18.x .
c. For Architecture, choose either x86_64  or arm64 .
d. Expand Permissions, then choose whether to create a new execution role or use an existing one.
4. Expand Advanced settings, and then select Function URL.
5. For Auth type, choose AWS_IAM or NONE . For more information about function URL 
authentication, see Security and auth model (p. 195).
6. (Optional) Select Conﬁgure cross-origin resource sharing (CORS). By selecting this option during 
function creation, your function URL allows requests from all origins by default. You can edit the 
CORS settings for your function URL after creating the function. For more information about CORS, 
see Cross-origin resource sharing (CORS) (p. 193).
7. Choose Create function.
This creates a new function with a function URL for the $LATEST unpublished version of the function. 
The function URL appears in the Function overview section of the console.
Creating a function URL (AWS CLI)
To create a function URL for an existing Lambda function using the AWS Command Line Interface (AWS 
CLI), run the following command:
aws lambda create-function-url-config \ 
    --function-name my-function  \ 
    --qualifier prod \ // optional 
    --auth-type AWS_IAM
    --cors-config {AllowOrigins="https://example.com"}  // optional
This adds a function URL to the prod qualiﬁer for the function my-function . For more information 
about these conﬁguration parameters, see CreateFunctionUrlConﬁg in the API reference.
Note
To create a function URL via the AWS CLI, the function must already exist.
191AWS Lambda Developer Guide
Creating and managing function URLs
Adding a function URL to a CloudFormation template
To add an AWS::Lambda::Url  resource to your AWS CloudFormation template, use the following 
syntax:
JSON
{ 
  "Type" : "AWS::Lambda::Url", 
  "Properties" : { 
      "AuthType" : String, 
      "Cors" : Cors, 
      "Qualifier" : String, 
      "TargetFunctionArn" : String 
    }
}
YAML
Type: AWS::Lambda::Url
Properties:  
  AuthType: String 
  Cors:  
    Cors 
  Qualifier: String 
  TargetFunctionArn: String
Parameters
•(Required) AuthType  – Deﬁnes the type of authentication for your function URL. Possible values are 
either AWS_IAM  or NONE. To restrict access to authenticated users only, set to AWS_IAM. To bypass IAM 
authentication and allow any user to make requests to your function, set to NONE .
•(Optional) Cors  – Deﬁnes the CORS settings (p. 193) for your function URL. To add Cors to your
AWS::Lambda::Url  resource in CloudFormation, use the following syntax.
Example AWS::Lambda::Url.Cors (JSON)
{ 
  "AllowCredentials" : Boolean, 
  "AllowHeaders" : [ String, ... ], 
  "AllowMethods" : [ String, ... ], 
  "AllowOrigins" : [ String, ... ], 
  "ExposeHeaders" : [ String, ... ], 
  "MaxAge" : Integer
}
Example AWS::Lambda::Url.Cors (YAML)
  AllowCredentials: Boolean 
  AllowHeaders:  
    - String 
  AllowMethods:  
    - String 
  AllowOrigins:  
    - String 
  ExposeHeaders:  
    - String 
192AWS Lambda Developer Guide
Creating and managing function URLs
  MaxAge: Integer
•(Optional) Qualifier  – The alias name.
•(Required) TargetFunctionArn  – The name or Amazon Resource Name (ARN) of the Lambda 
function. Valid name formats include the following:
•Function name – my-function
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function
•Partial ARN – 123456789012:function:my-function
Cross-origin resource sharing (CORS)
To deﬁne how diﬀerent origins can access your function URL, use cross-origin resource sharing (CORS). 
We recommend conﬁguring CORS if you intend to call your function URL from a diﬀerent domain. 
Lambda supports the following CORS headers for function URLs.
CORS header CORS conﬁguration property Example values
Access-Control-Allow-OriginAllowOrigins * (allow all origins)
https://www.example.com
http://localhost:60905
Access-Control-Allow-MethodsAllowMethods GET, POST , DELETE , *
Access-Control-Allow-HeadersAllowHeaders Date , Keep-Alive , X-Custom-
Header
Access-Control-Expose-HeadersExposeHeaders Date , Keep-Alive , X-Custom-
Header
Access-Control-Allow-
CredentialsAllowCredentials TRUE
Access-Control-Max-Age MaxAge 5 (default), 300
When you conﬁgure CORS for a function URL using the Lambda console or the AWS CLI, Lambda 
automatically adds the CORS headers to all responses through the function URL. Alternatively, you can 
manually add CORS headers to your function response. If there are conﬂicting headers, the conﬁgured 
CORS headers on the function URL take precedence.
Throttling function URLs
Throttling limits the rate at which your function processes requests. This is useful in many situations, 
such as preventing your function from overloading downstream resources, or handling a sudden surge in 
requests.
You can throttle the rate of requests that your Lambda function processes through a function URL by 
conﬁguring reserved concurrency. Reserved concurrency limits the number of maximum concurrent 
invocations for your function. Your function's maximum request rate per second (RPS) is equivalent to 10 
times the conﬁgured reserved concurrency. For example, if you conﬁgure your function with a reserved 
concurrency of 100, then the maximum RPS is 1,000.
Whenever your function concurrency exceeds the reserved concurrency, your function URL returns an 
HTTP 429 status code. If your function receives a request that exceeds the 10x RPS maximum based on 
193AWS Lambda Developer Guide
Creating and managing function URLs
your conﬁgured reserved concurrency, you also receive an HTTP 429 error. For more information about 
reserved concurrency, see Conﬁguring reserved concurrency (p. 234).
Deactivating function URLs
In an emergency, you might want to reject all traﬃc to your function URL. To deactivate your function 
URL, set the reserved concurrency to zero. This throttles all requests to your function URL, resulting 
in HTTP 429 status responses. To reactivate your function URL, delete the reserved concurrency 
conﬁguration, or set the conﬁguration to an amount greater than zero.
Deleting function URLs
When you delete a function URL, you can’t recover it. Creating a new function URL will result in a 
diﬀerent URL address.
1. Open the Functions page of the Lambda console.
2. Choose the name of the function.
3. Choose the Conﬁguration  tab, and then choose Function URL.
4. Choose Delete.
5. Enter the word delete  into the ﬁeld to conﬁrm the deletion.
6. Choose Delete.
Note
If you delete a function URL with auth type NONE , Lambda doesn't automatically delete the 
associated resource-based policy. If you want to delete this policy, you must manually do so.
194AWS Lambda Developer Guide
Security and auth model
Security and auth model for Lambda function URLs
You can control access to your Lambda function URLs using the AuthType  parameter combined with
resource-based policies (p. 929) attached to your speciﬁc function. The conﬁguration of these two 
components determines who can invoke or perform other administrative actions on your function URL.
The AuthType  parameter determines how Lambda authenticates or authorizes requests to your function 
URL. When you conﬁgure your function URL, you must specify one of the following AuthType  options:
•AWS_IAM – Lambda uses AWS Identity and Access Management (IAM) to authenticate and authorize 
requests based on the IAM principal's identity policy and the function's resource-based policy. Choose 
this option if you want only authenticated users and roles to invoke your function via the function 
URL.
•NONE – Lambda doesn't perform any authentication before invoking your function. However, your 
function's resource-based policy is always in eﬀect and must grant public access before your function 
URL can receive requests. Choose this option to allow public, unauthenticated access to your function 
URL.
In addition to AuthType , you can also use resource-based policies to grant permissions to other 
AWS accounts to invoke your function. For more information, see Using resource-based policies for 
Lambda  (p. 929).
For additional insights into security, you can use AWS Identity and Access Management Access Analyzer 
to get a comprehensive analysis of external access to your function URL. IAM Access Analyzer also 
monitors for new or updated permissions on your Lambda functions to help you identify permissions 
that grant public and cross-account access. IAM Access Analyzer is free to use for any AWS customer. To 
get started with IAM Access Analyzer, see Using AWS IAM Access Analyzer.
This page contains examples of resource-based policies for both auth types, and also how to create 
these policies using the AddPermission (p. 1280 ) API operation or the Lambda console. For information 
on how to invoke your function URL after you've set up permissions, see Invoking Lambda function 
URLs  (p. 200).
Topics
•Using the AWS_IAM auth type (p. 195)
•Using the NONE auth type (p. 197)
•Governance and access control (p. 197)
Using the AWS_IAM auth type
If you choose the AWS_IAM auth type, users who need to invoke your Lambda function URL must have 
the lambda:InvokeFunctionUrl  permission. Depending on who makes the invocation request, you 
may have to grant this permission using a resource-based policy.
If the principal making the request is in the same AWS account as the function URL, then the principal 
must either  have lambda:InvokeFunctionUrl  permissions in their identity-based policy, or have 
permissions granted to them in the function's resource-based policy. In other words, a resource-based 
policy is optional if the user already has lambda:InvokeFunctionUrl  permissions in their identity-
based policy. Policy evaluation follows the rules outlined in Determining whether a request is allowed or 
denied within an account.
If the principal making the request is in a diﬀerent account, then the principal must have both  an 
identity-based policy that gives them lambda:InvokeFunctionUrl  permissions and permissions 
195AWS Lambda Developer Guide
Security and auth model
granted to them in a resource-based policy on the function that they are trying to invoke. In these cross-
account cases, policy evaluation follows the rules outlined in Determining whether a cross-account 
request is allowed.
For an example cross-account interaction, the following resource-based policy allows the example role 
in AWS account 444455556666  to invoke the function URL associated with function my-function :
Example function URL cross-account invoke policy
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Principal": { 
                "AWS": "arn:aws:iam::444455556666:role/ example" 
            }, 
            "Action": "lambda:InvokeFunctionUrl", 
            "Resource": "arn:aws:lambda:us-east-1:123456789012:function: my-function ", 
            "Condition": { 
                "StringEquals": { 
                    "lambda:FunctionUrlAuthType": "AWS_IAM" 
                } 
            } 
        } 
    ]
}
You can create this policy statement through the console by following these steps:
To grant URL invocation permissions to another account (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of the function that you want to grant URL invocation permissions for.
3. Choose the Conﬁguration  tab, and then choose Permissions.
4. Under Resource-based policy, choose Add permissions .
5. Choose Function URL.
6. For Auth type, choose AWS_IAM.
7. (Optional) For Statement ID , enter a statement ID for your policy statement.
8. For Principal , enter account ID or the Amazon Resource Name (ARN) of the user or role that you 
want to grant permissions to. For example: 444455556666 .
9. Choose Save.
Alternatively, you can create this policy statement using the following add-permission  AWS Command 
Line Interface (AWS CLI) command:
aws lambda add-permission --function-name my-function \ 
    --statement-id example0-cross-account-statement \ 
    --action lambda:InvokeFunctionUrl \ 
    --principal 444455556666 \ 
    --function-url-auth-type AWS_IAM
In the previous example, the lambda:FunctionUrlAuthType  condition key value is AWS_IAM . This 
policy only allows access when your function URL's auth type is also AWS_IAM .
196AWS Lambda Developer Guide
Security and auth model
Using the NONE auth type
Important
When your function URL auth type is NONE and you have a resource-based policy that grants 
public access, any unauthenticated user with your function URL can invoke your function.
In some cases, you may want your function URL to be public. For example, you might want to serve 
requests made directly from a web browser. To allow public access to your function URL, choose the
NONE auth type.
If you choose the NONE auth type, Lambda doesn't use IAM to authenticate requests to your function 
URL. However, users must still have lambda:InvokeFunctionUrl  permissions in order to successfully 
invoke your function URL. You can grant lambda:InvokeFunctionUrl  permissions using the following 
resource-based policy:
Example function URL invoke policy for all unauthenticated principals
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Principal": "*", 
            "Action": "lambda:InvokeFunctionUrl", 
            "Resource": "arn:aws:lambda:us-east-1:123456789012:function: my-function ", 
            "Condition": { 
                "StringEquals": { 
                    "lambda:FunctionUrlAuthType": "NONE" 
                } 
            } 
        } 
    ]
}
Note
When you create a function URL with auth type NONE via the console or AWS Serverless 
Application Model (AWS SAM), Lambda automatically creates the preceding resource-
based policy statement for you. If the policy already exists, or the user or role creating the 
application doesn't have the appropriate permissions, then Lambda won't create it for you. 
If you're using the AWS CLI, AWS CloudFormation, or the Lambda API directly, you must add
lambda:InvokeFunctionUrl  permissions yourself. This makes your function public.
In addition, if you delete your function URL with auth type NONE , Lambda doesn't automatically 
delete the associated resource-based policy. If you want to delete this policy, you must manually 
do so.
In this statement, the lambda:FunctionUrlAuthType  condition key value is NONE. This policy 
statement allows access only when your function URL's auth type is also NONE .
If a function's resource-based policy doesn't grant lambda:invokeFunctionUrl  permissions, then 
users will get a 403 Forbidden error code when they try to invoke your function URL, even if the function 
URL uses the NONE auth type.
Governance and access control
In addition to function URL invocation permissions, you can also control access on actions used to 
conﬁgure function URLs. Lambda supports the following IAM policy actions for function URLs:
•lambda:InvokeFunctionUrl  – Invoke a Lambda function using the function URL.
•lambda:CreateFunctionUrlConfig  – Create a function URL and set its AuthType .
197AWS Lambda Developer Guide
Security and auth model
•lambda:UpdateFunctionUrlConfig  – Update a function URL conﬁguration and its AuthType .
•lambda:GetFunctionUrlConfig  – View the details of a function URL.
•lambda:ListFunctionUrlConfigs  – List function URL conﬁgurations.
•lambda:DeleteFunctionUrlConfig  – Delete a function URL.
Note
The Lambda console supports adding permissions only for lambda:InvokeFunctionUrl . For 
all other actions, you must add permissions using the Lambda API or AWS CLI.
To allow or deny function URL access to other AWS entities, include these actions in IAM policies. For 
example, the following policy grants the example role in AWS account 444455556666  permissions to 
update the function URL for function my-function  in account 123456789012 .
Example cross-account function URL policy
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Principal": {  
                "AWS": "arn:aws:iam::444455556666:role/example" 
            }, 
            "Action": "lambda:UpdateFunctionUrlConfig", 
            "Resource": "arn:aws:lambda:us-east-2:123456789012:function: my-function " 
        } 
    ]
}
Condition keys
For ﬁne-grained access control over your function URLs, use a condition key. Lambda supports one 
additional condition key for function URLs: FunctionUrlAuthType . The FunctionUrlAuthType  key 
deﬁnes an enum value describing the auth type that your function URL uses. The value can be either
AWS_IAM  or NONE .
You can use this condition key in policies associated with your function. For example, you 
might want to restrict who can make conﬁguration changes to your function URLs. To deny all
UpdateFunctionUrlConfig  requests to any function with URL auth type NONE, you can deﬁne the 
following policy:
Example function URL policy with explicit deny
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Deny", 
            "Principal": "*", 
            "Action":[ 
                "lambda:UpdateFunctionUrlConfig" 
            ], 
            "Resource": "arn:aws:lambda:us-east-1:123456789012:function:*", 
            "Condition": { 
                "StringEquals": { 
                    "lambda:FunctionUrlAuthType": "NONE" 
                } 
            } 
        } 
198AWS Lambda Developer Guide
Security and auth model
    ]
}
To grant the example role in AWS account 444455556666  permissions to make
CreateFunctionUrlConfig  and UpdateFunctionUrlConfig  requests on functions with URL auth 
type AWS_IAM, you can deﬁne the following policy:
Example function URL policy with explicit allow
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Principal": {  
                "AWS": "arn:aws:iam::444455556666:role/example" 
            }, 
            "Action":[ 
                "lambda:CreateFunctionUrlConfig", 
                "lambda:UpdateFunctionUrlConfig" 
            ], 
            "Resource": "arn:aws:lambda:us-east-1:123456789012:function:*", 
            "Condition": { 
                "StringEquals": { 
                    "lambda:FunctionUrlAuthType": "AWS_IAM" 
                } 
            } 
        } 
    ]
}
You can also use this condition key in a service control policy (SCP). Use SCPs to manage permissions 
across an entire organization in AWS Organizations. For example, to deny users from creating or 
updating function URLs that use anything other than the AWS_IAM auth type, use the following service 
control policy:
Example function URL SCP with explicit deny
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Deny", 
            "Action":[ 
                "lambda:CreateFunctionUrlConfig", 
                "lambda:UpdateFunctionUrlConfig" 
            ], 
            "Resource": "arn:aws:lambda:*:123456789012:function:*", 
            "Condition": { 
                "StringNotEquals": { 
                    "lambda:FunctionUrlAuthType": "AWS_IAM" 
                } 
            } 
        } 
    ]
}
199AWS Lambda Developer Guide
Invoking function URLs
Invoking Lambda function URLs
A function URL is a dedicated HTTP(S) endpoint for your Lambda function. You can create and conﬁgure 
a function URL through the Lambda console or the Lambda API. When you create a function URL, 
Lambda automatically generates a unique URL endpoint for you. Once you create a function URL, its URL 
endpoint never changes. Function URL endpoints have the following format:
https:// <url-id> .lambda-url.<region>.on.aws
Note
Function URLs are not supported in the following regions: Asia Paciﬁc (Hyderabad) (ap-
south-2), Europe (Spain) (eu-south-2 ), and Middle East (UAE) (me-central-1 ).
Function URLs are dual stack-enabled, supporting IPv4 and IPv6. After conﬁguring your function URL, 
you can invoke your function through its HTTP(S) endpoint via a web browser, curl, Postman, or any 
HTTP client. To invoke a function URL, you must have lambda:InvokeFunctionUrl  permissions. For 
more information, see Security and auth model (p. 195).
Topics
•Function URL invocation basics (p. 200)
•Request and response payloads (p. 201)
Function URL invocation basics
If your function URL uses the AWS_IAM auth type, you must sign each HTTP request using AWS Signature 
Version 4 (SigV4). Tools such as awscurl, Postman, and AWS SigV4 Proxy oﬀer built-in ways to sign your 
requests with SigV4.
If you don't use a tool to sign HTTP requests to your function URL, you must manually sign each request 
using SigV4. When your function URL receives a request, Lambda also calculates the SigV4 signature. 
Lambda processes the request only if the signatures match. For instructions on how to manually sign 
your requests with SigV4, see Signing AWS requests with Signature Version 4 in the Amazon Web Services 
General Reference Guide.
If your function URL uses the NONE auth type, you don't have to sign your requests using SigV4. You can 
invoke your function using a web browser, curl, Postman, or any HTTP client.
To test simple GET requests to your function, use a web browser. For example, if your function URL is
https://abcdefg.lambda-url.us-east-1.on.aws , and it takes in a string parameter message , 
your request URL could look like this:
https://abcdefg.lambda-url.us-east-1.on.aws/?message=HelloWorld
To test other HTTP requests, such as a POST request, you can use a tool such as curl. For example, if you 
want to include some JSON data in a POST request to your function URL, you could use the following 
curl command:
curl -v 'https://abcdefg.lambda-url.us-east-1.on.aws/?message=HelloWorld' \
-H 'content-type: application/json' \
-d '{ "example": "test" }'
200AWS Lambda Developer Guide
Invoking function URLs
Request and response payloads
When a client calls your function URL, Lambda maps the request to an event object before passing it to 
your function. Your function's response is then mapped to an HTTP response that Lambda sends back to 
the client through the function URL.
The request and response event formats follow the same schema as the Amazon API Gateway payload 
format version 2.0.
Request payload format
A request payload has the following structure:
{ 
  "version": "2.0", 
  "routeKey": "$default", 
  "rawPath": "/my/path", 
  "rawQueryString": "parameter1=value1&parameter1=value2&parameter2=value", 
  "cookies": [ 
    "cookie1", 
    "cookie2" 
  ], 
  "headers": { 
    "header1": "value1", 
    "header2": "value1,value2" 
  }, 
  "queryStringParameters": { 
    "parameter1": "value1,value2", 
    "parameter2": "value" 
  }, 
  "requestContext": { 
    "accountId": "123456789012", 
    "apiId": "<urlid>", 
    "authentication": null, 
    "authorizer": { 
        "iam": { 
                "accessKey": "AKIA...", 
                "accountId": "111122223333", 
                "callerId": "AIDA...", 
                "cognitoIdentity": null, 
                "principalOrgId": null, 
                "userArn": "arn:aws:iam::111122223333:user/example-user", 
                "userId": "AIDA..." 
        } 
    }, 
    "domainName": "<url-id>.lambda-url.us-west-2.on.aws", 
    "domainPrefix": "<url-id>", 
    "http": { 
      "method": "POST", 
      "path": "/my/path", 
      "protocol": "HTTP/1.1", 
      "sourceIp": "123.123.123.123", 
      "userAgent": "agent" 
    }, 
    "requestId": "id", 
    "routeKey": "$default", 
    "stage": "$default", 
    "time": "12/Mar/2020:19:03:58 +0000", 
    "timeEpoch": 1583348638390 
  }, 
  "body": "Hello from client!", 
  "pathParameters": null, 
  "isBase64Encoded": false, 
201AWS Lambda Developer Guide
Invoking function URLs
  "stageVariables": null
}
Parameter Description Example
version The payload format version for 
this event. Lambda function 
URLs currently support payload 
format version 2.0.2.0
routeKey Function URLs don't use this 
parameter. Lambda sets this to
$default  as a placeholder.$default
rawPath The request path. For example, 
if the request URL is https://
{url-id}.lambda-url.
{region}.on.aws/example/
test/demo , then the raw path 
value is /example/test/demo ./example/test/demo
rawQueryString The raw string containing 
the request's query string 
parameters."?
parameter1=value1&parameter2=value2"
cookies An array containing all cookies 
sent as part of the request.["Cookie_1=Value_1", 
"Cookie_2=Value_2"]
headers The list of request headers, 
presented as key-value pairs.{"header1": "value1", 
"header2": "value2"}
queryStringParameters The query parameters for 
the request. For example, if 
the request URL is https://
{url-id}.lambda-url.
{region}.on.aws/example?
name=Jane , then the
queryStringParameters
value is a JSON object with a key 
of name  and a value of Jane .{"name": "Jane"}
requestContext An object that contains 
additional information about the 
request, such as the requestId , 
the time of the request, and 
the identity of the caller if 
authorized via AWS Identity and 
Access Management (IAM).
requestContext.accountId The AWS account ID of the 
function owner."123456789012"
requestContext.apiId The ID of the function URL."33anwqw8fj"
requestContext.authentication Function URLs don't use this 
parameter. Lambda sets this to
null .null
202AWS Lambda Developer Guide
Invoking function URLs
Parameter Description Example
requestContext.authorizer An object that contains 
information about the caller 
identity, if the function URL 
uses the AWS_IAM auth type. 
Otherwise, Lambda sets this to
null .
requestContext.authorizer.iam.accessKey The access key of the caller 
identity."AKIAIOSFODNN7EXAMPLE"
requestContext.authorizer.iam.accountId The AWS account ID of the caller 
identity."111122223333"
requestContext.authorizer.iam.callerId The ID (user ID) of the caller."AIDACKCEVSQ6C2EXAMPLE"
requestContext.authorizer.iam.cognitoIdentity Function URLs don't use this 
parameter. Lambda sets this to
null or excludes this from the 
JSON.null
requestContext.authorizer.iam.principalOrgId The principal org ID associated 
with the caller identity."AIDACKCEVSQORGEXAMPLE"
requestContext.authorizer.iam.userArn The user Amazon Resource 
Name (ARN) of the caller 
identity."arn:aws:iam::111122223333:user/
example-user"
requestContext.authorizer.iam.userId The user ID of the caller identity."AIDACOSFODNN7EXAMPLE2"
requestContext.domainName The domain name of the 
function URL."<url-id>.lambda-url.us-
west-2.on.aws"
requestContext.domainPrefix The domain preﬁx of the 
function URL."<url-id>"
requestContext.http An object that contains details 
about the HTTP request.
requestContext.http.method The HTTP method used in this 
request. Valid values include
GET, POST , PUT, HEAD , OPTIONS ,
PATCH , and DELETE .GET
requestContext.http.path The request path. For example, 
if the request URL is https://
{url-id}.lambda-url.
{region}.on.aws/example/
test/demo , then the path value 
is /example/test/demo ./example/test/demo
requestContext.http.protocol The protocol of the request.HTTP/1.1
requestContext.http.sourceIp The source IP address of the 
immediate TCP connection 
making the request.123.123.123.123
203AWS Lambda Developer Guide
Invoking function URLs
Parameter Description Example
requestContext.http.userAgent The User-Agent request header 
value.Mozilla/5.0 (Macintosh; 
Intel Mac OS X 10_15_7) 
Gecko/20100101 
Firefox/42.0
requestContext.requestId The ID of the invocation request. 
You can use this ID to trace 
invocation logs related to your 
function.e1506fd5-9e7b-434f-
bd42-4f8fa224b599
requestContext.routeKey Function URLs don't use this 
parameter. Lambda sets this to
$default  as a placeholder.$default
requestContext.stage Function URLs don't use this 
parameter. Lambda sets this to
$default  as a placeholder.$default
requestContext.time The timestamp of the request."07/Sep/2021:22:50:22 
+0000"
requestContext.timeEpoch The timestamp of the request, in 
Unix epoch time."1631055022677"
body The body of the request. If the 
content type of the request 
is binary, the body is base64-
encoded.{"key1": "value1", 
"key2": "value2"}
pathParameters Function URLs don't use this 
parameter. Lambda sets this to
null or excludes this from the 
JSON.null
isBase64Encoded TRUE if the body is a binary 
payload and base64-encoded.
FALSE otherwise.FALSE
stageVariables Function URLs don't use this 
parameter. Lambda sets this to
null or excludes this from the 
JSON.null
Response payload format
When your function returns a response, Lambda parses the response and converts it into an HTTP 
response. Function response payloads have the following format:
{ 
   "statusCode": 201, 
    "headers": { 
        "Content-Type": "application/json", 
        "My-Custom-Header": "Custom Value" 
    }, 
    "body": "{ \"message\": \"Hello, world!\" }", 
    "cookies": [ 
        "Cookie_1=Value1; Expires=21 Oct 2021 07:48 GMT", 
204AWS Lambda Developer Guide
Invoking function URLs
        "Cookie_2=Value2; Max-Age=78000" 
    ], 
    "isBase64Encoded": false
}
Lambda infers the response format for you. If your function returns valid JSON and doesn't return a
statusCode , Lambda assumes the following:
•statusCode  is 200.
•content-type  is application/json .
•body is the function response.
•isBase64Encoded  is false .
The following examples show how the output of your Lambda function maps to the response payload, 
and how the response payload maps to the ﬁnal HTTP response. When the client invokes your function 
URL, they see the HTTP response.
Example output for a string response
Lambda function output Interpreted response output HTTP response (what the client 
sees)
"Hello, world!" { 
  "statusCode": 200, 
  "body": "Hello, world!", 
  "headers": { 
    "content-type": 
 "application/json" 
  }, 
  "isBase64Encoded": false
}HTTP/2 200
date: Wed, 08 Sep 2021 
 18:02:24 GMT
content-type: application/
json
content-length: 15
"Hello, world!"
Example output for a JSON response
Lambda function output Interpreted response output HTTP response (what the client 
sees)
{ 
  "message": "Hello, world!"
}{ 
  "statusCode": 200, 
  "body": { 
    "message": "Hello, 
 world!" 
  }, 
  "headers": { 
    "content-type": 
 "application/json" 
  }, 
  "isBase64Encoded": false
}HTTP/2 200
date: Wed, 08 Sep 2021 
 18:02:24 GMT
content-type: application/
json
content-length: 34
{ 
  "message": "Hello, world!"
}
205AWS Lambda Developer Guide
Invoking function URLs
Example output for a custom response
Lambda function output Interpreted response output HTTP response (what the client 
sees)
{ 
   "statusCode": 201, 
    "headers": { 
        "Content-Type": 
 "application/json", 
        "My-Custom-Header": 
 "Custom Value" 
    }, 
    "body": JSON.stringify({ 
        "message": "Hello, 
 world!" 
    }), 
    "isBase64Encoded": false
}{ 
   "statusCode": 201, 
    "headers": { 
        "Content-Type": 
 "application/json", 
        "My-Custom-Header": 
 "Custom Value" 
    }, 
    "body": JSON.stringify({ 
        "message": "Hello, 
 world!" 
    }), 
    "isBase64Encoded": false
}HTTP/2 201
date: Wed, 08 Sep 2021 
 18:02:24 GMT
content-type: application/
json
content-length: 27
my-custom-header: Custom 
 Value
{ 
  "message": "Hello, world!"
}
Cookies
To return cookies from your function, don't manually add set-cookie  headers. Instead, include the 
cookies in your response payload object. Lambda automatically interprets this and adds them as set-
cookie headers in your HTTP response, as in the following example.
Example output for a response returning cookies
Lambda function output HTTP response (what the client sees)
{ 
   "statusCode": 201, 
    "headers": { 
        "Content-Type": "application/json", 
        "My-Custom-Header": "Custom Value" 
    }, 
    "body": JSON.stringify({ 
        "message": "Hello, world!" 
    }), 
    "cookies": [ 
        "Cookie_1=Value1; Expires=21 Oct 
 2021 07:48 GMT", 
        "Cookie_2=Value2; Max-Age=78000" 
    ], 
    "isBase64Encoded": false
}HTTP/2 201
date: Wed, 08 Sep 2021 18:02:24 GMT
content-type: application/json
content-length: 27
my-custom-header: Custom Value
set-cookie: Cookie_1=Value2; Expires=21 Oct 
 2021 07:48 GMT
set-cookie: Cookie_2=Value2; Max-Age=78000
{ 
  "message": "Hello, world!"
}
206AWS Lambda Developer Guide
Monitoring function URLs
Monitoring Lambda function URLs
You can use AWS CloudTrail and Amazon CloudWatch to monitor your function URLs.
Topics
•Monitoring function URLs with CloudTrail (p. 207)
•CloudWatch metrics for function URLs (p. 207)
Monitoring function URLs with CloudTrail
For function URLs, Lambda automatically supports logging the following API operations as events in 
CloudTrail log ﬁles:
•CreateFunctionUrlConﬁg
•UpdateFunctionUrlConﬁg
•DeleteFunctionUrlConﬁg
•GetFunctionUrlConﬁg
•ListFunctionUrlConﬁgs
Each log entry contains information about the caller identity, when the request was made, and other 
details. You can see all events within the last 90 days by viewing your CloudTrail Event history. To retain 
records past 90 days, you can create a trail. For more information, see Using AWS Lambda with AWS 
CloudTrail (p. 655).
By default, CloudTrail doesn't log InvokeFunctionUrl  requests, which are considered data events. 
However, you can turn on data event logging in CloudTrail. For more information, see Logging data 
events for trails in the AWS CloudTrail User Guide.
CloudWatch metrics for function URLs
Lambda sends aggregated metrics about function URL requests to CloudWatch. With these metrics, you 
can monitor your function URLs, build dashboards, and conﬁgure alarms in the CloudWatch console.
Function URLs support the following invocation metrics. We recommend viewing these metrics with the
Sum statistic.
•UrlRequestCount  – The number of requests made to this function URL.
•Url4xxCount  – The number of requests that returned a 4XX HTTP status code. 4XX series codes 
indicate client-side errors, such as bad requests.
•Url5xxCount  – The number of requests that returned a 5XX HTTP status code. 5XX series codes 
indicate server-side errors, such as function errors and timeouts.
Function URLs also support the following performance metric. We recommend viewing this metric with 
the Average  or Max statistics.
•UrlRequestLatency  – The time between when the function URL receives a request and when the 
function URL returns a response.
Each of these invocation and performance metrics supports the following dimensions:
•FunctionName  – View aggregate metrics for function URLs assigned to a function's $LATEST
unpublished version, or to any of the function's aliases. For example, hello-world-function .
207AWS Lambda Developer Guide
Monitoring function URLs
•Resource  – View metrics for a speciﬁc function URL. This is deﬁned by a function name, along with 
either the function's $LATEST unpublished version or one of the function's aliases. For example,
hello-world-function:$LATEST .
•ExecutedVersion  – View metrics for a speciﬁc function URL based on the executed version. You can 
use this dimension primarily to track the function URL assigned to the $LATEST unpublished version.
208AWS Lambda Developer Guide
Tutorial: Creating a function with a function URL
Tutorial: Creating a Lambda function with a function 
URL
In this tutorial, you create a Lambda function deﬁned as a .zip ﬁle archive with a public  function URL 
endpoint that returns the product of two numbers. For more information about conﬁguring function 
URLs, see Creating and managing function URLs (p. 190).
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create an execution role
Create the execution role (p. 913) that gives your Lambda function permission to access AWS resources.
To create an execution role
1. Open the Roles page of the AWS Identity and Access Management (IAM) console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – AWS Lambda.
•Permissions – AWSLambdaBasicExecutionRole.
•Role name – lambda-url-role .
The AWSLambdaBasicExecutionRole policy has the permissions that the function needs to write logs to 
Amazon CloudWatch Logs.
Create a Lambda function with a function URL (.zip ﬁle archive)
Create a Lambda function with a function URL endpoint using a .zip ﬁle archive.
209AWS Lambda Developer Guide
Tutorial: Creating a function with a function URL
To create the function
1. Copy the following code example into a ﬁle named index.js .
Example index.js
exports.handler = async (event) => { 
    let body = JSON.parse(event.body) 
    const product = body.num1 * body.num2; 
    const response = { 
        statusCode: 200, 
        body: "The product of " + body.num1 + " and " + body.num2 + " is " + product, 
    }; 
    return response;
};
2. Create a deployment package.
zip function.zip index.js
3. Create a Lambda function with the create-function  command.
aws lambda create-function \ 
    --function-name my-url-function \ 
    --runtime nodejs14.x \ 
    --zip-file fileb://function.zip \ 
    --handler index.handler \ 
    --role arn:aws:iam::123456789012:role/lambda-url-role
4. Add a resource-based policy to your function granting permissions to allow public access to your 
function URL.
aws lambda add-permission \ 
    --function-name my-url-function \ 
    --action lambda:InvokeFunctionUrl \ 
    --principal "*" \ 
    --function-url-auth-type "NONE" \ 
    --statement-id url
5. Create a URL endpoint for the function with the create-function-url-config  command.
aws lambda create-function-url-config \ 
    --function-name my-url-function \ 
    --auth-type NONE
Test the function URL endpoint
Invoke your Lambda function by calling your function URL endpoint using an HTTP client such as curl or 
Postman.
curl 'https://abcdefg.lambda-url.us-east-1.on.aws/'  \
-H 'Content-Type: application/json' \
-d '{"num1": "10", "num2": "10"}'
You should see the following output:
The product of 10 and 10 is 100
210AWS Lambda Developer Guide
Tutorial: Creating a function with a function URL
Create a Lambda function with a function URL (CloudFormation)
You can also create a Lambda function with a function URL endpoint using the AWS CloudFormation 
type AWS::Lambda::Url .
Resources: 
  MyUrlFunction: 
    Type: AWS::Lambda::Function 
    Properties: 
      Handler: index.handler 
      Runtime: nodejs14.x 
      Role: arn:aws:iam::123456789012:role/lambda-url-role 
      Code: 
        ZipFile: | 
          exports.handler = async (event) => { 
              let body = JSON.parse(event.body) 
              const product = body.num1 * body.num2; 
              const response = { 
                  statusCode: 200, 
                  body: "The product of " + body.num1 + " and " + body.num2 + " is " + 
 product, 
              }; 
              return response; 
          }; 
      Description: Create a function with a URL. 
  MyUrlFunctionPermissions: 
    Type: AWS::Lambda::Permission 
    Properties: 
      FunctionName: !Ref MyUrlFunction 
      Action: lambda:InvokeFunctionUrl 
      Principal: "*" 
      FunctionUrlAuthType: NONE 
  MyFunctionUrl: 
    Type: AWS::Lambda::Url 
    Properties: 
      TargetFunctionArn: !Ref MyUrlFunction 
      AuthType: NONE
Create a Lambda function with a function URL (AWS SAM)
You can also create a Lambda function conﬁgured with a function URL using AWS Serverless Application 
Model (AWS SAM).
ProductFunction: 
  Type: AWS::Serverless::Function 
  Properties: 
    CodeUri: function/. 
    Handler: index.handler 
    Runtime: nodejs14.x 
    AutoPublishAlias: live 
    FunctionUrlConfig: 
      AuthType: NONE
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
211AWS Lambda Developer Guide
Tutorial: Creating a function with a function URL
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
212AWS Lambda Developer Guide
Managing AWS Lambda functions
Learn how to adjust and secure the resources associated with your Lambda function using the Lambda 
API or console.
Using Lambda with the AWS CLI (p. 214)
You can use the AWS Command Line Interface to manage functions and other AWS Lambda 
resources. The AWS CLI uses the AWS SDK for Python (Boto) to interact with the Lambda API. In this 
tutorial, you manage and invoke Lambda functions with the AWS CLI.
Function Scaling (p. 220)
You can conﬁgure two function-level concurrency controls: reserved concurrency and provisioned 
concurrency. Concurrency is the number of instances of your function that are active and can be 
conﬁgured to ensure critical functions avoid throttling.
Code signing  (p. 253)
Code signing for Lambda provides trust and integrity controls that let you verify that only unaltered 
code that approved developers have published is deployed in your Lambda functions.
Organize with tags (p. 257)
You can tag Lambda functions to activate attribute-based access control (ABAC) (p. 925) and to 
organize them by owner, project, or department.
Using layers (p. 988)
You can apply previously created layers to reduce deployment package size and promote code 
sharing and separation of responsibilities so that you can iterate faster on writing business logic.
213AWS Lambda Developer Guide
Tutorial - Lambda with CLI
Using Lambda with the AWS CLI
You can use the AWS Command Line Interface to manage functions and other AWS Lambda resources. 
The AWS CLI uses the AWS SDK for Python (Boto) to interact with the Lambda API. You can use it to 
learn about the API, and apply that knowledge in building applications that use Lambda with the AWS 
SDK.
In this tutorial, you manage and invoke Lambda functions with the AWS CLI. For more information, see
What is the AWS CLI? in the AWS Command Line Interface User Guide.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in the section called “Create a function” (p. 4).
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role
Create the execution role (p. 913) that gives your function permission to access AWS resources. To 
create an execution role with the AWS CLI, use the create-role  command.
In the following example, you specify the trust policy inline. Requirements for escaping quotes in the 
JSON string vary depending on your shell.
aws iam create-role --role-name lambda-ex --assume-role-policy-document '{"Version": 
 "2012-10-17","Statement": [{ "Effect": "Allow", "Principal": {"Service": 
 "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}'
You can also deﬁne the trust policy for the role using a JSON ﬁle. In the following example, trust-
policy.json  is a ﬁle in the current directory. This trust policy allows Lambda to use the role's 
permissions by giving the service principal lambda.amazonaws.com  permission to call the AWS 
Security Token Service (AWS STS) AssumeRole  action.
Example trust-policy.json
{ 
214AWS Lambda Developer Guide
Create the function
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Principal": { 
        "Service": "lambda.amazonaws.com" 
      }, 
      "Action": "sts:AssumeRole" 
    } 
  ]
}
aws iam create-role --role-name lambda-ex --assume-role-policy-document file://trust-
policy.json
You should see the following output:
{ 
    "Role": { 
        "Path": "/", 
        "RoleName": "lambda-ex", 
        "RoleId": "AROAQFOXMPL6TZ6ITKWND", 
        "Arn": "arn:aws:iam::123456789012:role/lambda-ex", 
        "CreateDate": "2020-01-17T23:19:12Z", 
        "AssumeRolePolicyDocument": { 
            "Version": "2012-10-17", 
            "Statement": [ 
                { 
                    "Effect": "Allow", 
                    "Principal": { 
                        "Service": "lambda.amazonaws.com" 
                    }, 
                    "Action": "sts:AssumeRole" 
                } 
            ] 
        } 
    }
}
To add permissions to the role, use the attach-policy-to-role command. Start by adding the
AWSLambdaBasicExecutionRole  managed policy.
aws iam attach-role-policy --role-name lambda-ex --policy-arn arn:aws:iam::aws:policy/
service-role/AWSLambdaBasicExecutionRole
The AWSLambdaBasicExecutionRole policy has the permissions that the function needs to write logs to 
CloudWatch Logs.
Create the function
The following example logs the values of environment variables and the event object.
Example index.js
exports.handler = async function(event, context) { 
  console.log("ENVIRONMENT VARIABLES\n" + JSON.stringify(process.env, null, 2)) 
  console.log("EVENT\n" + JSON.stringify(event, null, 2)) 
  return context.logStreamName
}
215AWS Lambda Developer Guide
Create the function
To create the function
1. Copy the sample code into a ﬁle named index.js .
2. Create a deployment package.
zip function.zip index.js
3. Create a Lambda function with the create-function  command. Replace the highlighted text in 
the role ARN with your account ID.
aws lambda create-function --function-name my-function \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: 123456789012 :role/lambda-ex
You should see the following output:
{ 
    "FunctionName": "my-function", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "Runtime": "nodejs18.x", 
    "Role": "arn:aws:iam::123456789012:role/lambda-ex", 
    "Handler": "index.handler", 
    "CodeSha256": "FpFMvUhayLkOoVBpNuNiIVML/tuGv2iJQ7t0yWVTU8c=", 
    "Version": "$LATEST", 
    "TracingConfig": { 
        "Mode": "PassThrough" 
    }, 
    "RevisionId": "88ebe1e1-bfdf-4dc3-84de-3017268fa1ff", 
    ...
}
To get logs for an invocation from the command line, use the --log-type  option. The response 
includes a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the invocation.
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
You can use the base64 utility to decode the logs.
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text |  base64 -d
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST 
  "AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
216AWS Lambda Developer Guide
Create the function
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. For macOS, the command is
base64 -D .
To get full log events from the command line, you can include the log stream name in the output of your 
function, as shown in the preceding example. The following example script invokes a function named
my-function  and downloads the last ﬁve log events.
Example get-logs.sh Script
This example requires that my-function  returns a log stream ID.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/my-function --log-stream-name $(cat 
 out) --limit 5
The script uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for 
the logs to be available. The output includes the response from Lambda and the output from the get-
log-events  command.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
217AWS Lambda Developer Guide
Update the function
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Update the function
After you create a function, you can conﬁgure additional capabilities for the function, such as triggers, 
network access, and ﬁle system access. You can also adjust resources associated with the function, such 
as memory and concurrency. These conﬁgurations apply to functions deﬁned as .zip ﬁle archives and to 
functions deﬁned as container images.
Use the update-function-conﬁguration command to conﬁgure functions. The following example sets the 
function memory to 256 MB.
Example update-function-conﬁguration command
aws lambda update-function-configuration \
--function-name my-function \
--memory-size 256
List the Lambda functions in your account
Run the following AWS CLI list-functions  command to retrieve a list of functions that you have 
created.
aws lambda list-functions --max-items 10
You should see the following output:
{ 
    "Functions": [ 
        { 
            "FunctionName": "cli", 
            "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
            "Runtime": "nodejs18.x", 
            "Role": "arn:aws:iam::123456789012:role/lambda-ex", 
            "Handler": "index.handler", 
            ... 
        }, 
        { 
            "FunctionName": "random-error", 
            "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:random-error", 
            "Runtime": "nodejs18.x", 
            "Role": "arn:aws:iam::123456789012:role/lambda-role", 
            "Handler": "index.handler", 
            ... 
        }, 
        ... 
      ], 
      "NextToken": "eyJNYXJrZXIiOiBudWxsLCAiYm90b190cnVuY2F0ZV9hbW91bnQiOiAxMH0="
} 
218AWS Lambda Developer Guide
Retrieve a Lambda function
In response, Lambda returns a list of up to 10 functions. If there are more functions you can retrieve,
NextToken  provides a marker you can use in the next list-functions  request. The following list-
functions  AWS CLI command is an example that shows the --starting-token  parameter.
aws lambda list-functions --max-items 10 --starting-
token eyJNYXJrZXIiOiBudWxsLCAiYm90b190cnVuY2F0ZV9hbW91bnQiOiAxMH0=
Retrieve a Lambda function
The Lambda CLI get-function  command returns Lambda function metadata and a presigned URL that 
you can use to download the function's deployment package.
aws lambda get-function --function-name my-function
You should see the following output:
{ 
    "Configuration": { 
        "FunctionName": "my-function", 
        "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
        "Runtime": "nodejs18.x", 
        "Role": "arn:aws:iam::123456789012:role/lambda-ex", 
        "CodeSha256": "FpFMvUhayLkOoVBpNuNiIVML/tuGv2iJQ7t0yWVTU8c=", 
        "Version": "$LATEST", 
        "TracingConfig": { 
            "Mode": "PassThrough" 
        }, 
        "RevisionId": "88ebe1e1-bfdf-4dc3-84de-3017268fa1ff", 
        ... 
    }, 
    "Code": { 
        "RepositoryType": "S3", 
        "Location": "https://awslambda-us-east-2-tasks.s3.us-east-2.amazonaws.com/
snapshots/123456789012/my-function-4203078a-b7c9-4f35-..." 
    }
}
For more information, see GetFunction (p. 1359 ).
Clean up
Run the following delete-function  command to delete the my-function  function.
aws lambda delete-function --function-name my-function
Delete the IAM role you created in the IAM console. For information about deleting a role, see Deleting 
roles or instance proﬁles in the IAM User Guide .
219AWS Lambda Developer Guide
Function scaling
Lambda function scaling
Concurrency is the number of in-ﬂight requests your AWS Lambda function is handling at the same 
time. For each concurrent request, Lambda provisions a separate instance of your execution environment. 
As your functions receive more requests, Lambda automatically handles scaling the number of execution 
environments until you reach your account's concurrency limit. By default, Lambda provides your account 
with a total concurrency limit of 1,000 across all functions in a region. To support your speciﬁc account 
needs, you can  request a quota increase and conﬁgure function-level concurrency controls so that your 
critical functions don't experience throttling.
This topic explains concurrency and function scaling in Lambda. By the end of this topic, you'll be able to 
understand how to calculate concurrency, visualize the two main concurrency control options (reserved 
and provisioned), estimate appropriate concurrency control settings, and view metrics for further 
optimization.
Sections
•Understanding and visualizing concurrency (p. 220)
•How to calculate concurrency (p. 223)
•Concurrency vs. requests per second (p. 224)
•Reserved concurrency and provisioned concurrency (p. 225)
•Concurrency quotas (p. 232)
•Conﬁguring reserved concurrency (p. 234)
•Conﬁguring provisioned concurrency (p. 237)
•Burst concurrency (p. 243)
•Monitoring concurrency (p. 251)
Understanding and visualizing concurrency
Lambda invokes your function in a secure and isolated execution environment. To handle a request, 
Lambda must ﬁrst initialize an execution environment (the Init phase ), before using it to invoke your 
function (the Invoke phase):
Note
Actual Init and Invoke durations can vary depending on many factors, such as the runtime you 
choose and the Lambda function code. The previous diagram isn't meant to represent the exact 
proportions of Init and Invoke phase durations.
The previous diagram uses a rectangle to represent a single execution environment. When your function 
receives its very ﬁrst request (represented by the yellow circle with label 1), Lambda creates a new 
220AWS Lambda Developer Guide
Understanding and visualizing concurrency
execution environment and runs the code outside your main handler during the Init phase. Then, Lambda 
runs your function's main handler code during the Invoke phase. During this entire process, this execution 
environment is busy and cannot process other requests.
When Lambda ﬁnishes processing the ﬁrst request, this execution environment can then process 
additional requests for the same function. For subsequent requests, Lambda doesn't need to re-initialize 
the environment.
In the previous diagram, Lambda reuses the execution environment to handle the second request 
(represented by the yellow circle with label 2).
So far, we've focused on just a single instance of your execution environment (i.e. a concurrency of 1). In 
practice, Lambda may need to provision multiple execution environment instances in parallel to handle 
all incoming requests. When your function receives a new request, one of two things can happen:
•If a pre-initialized execution environment instance is available, Lambda uses it to process the request.
•Otherwise, Lambda creates a new execution environment instance to process the request.
For example, let's explore what happens when your function receives 10 requests:
In the previous diagram, each horizontal plane represents a single execution environment instance 
(labeled from A through F. Here's how Lambda handles each request:
Lambda behavior for requests 1 through 10
Request Lambda behavior Reasoning
1 Provisions new environment A This is the ﬁrst request; no 
execution environment instances 
available
221AWS Lambda Developer Guide
Understanding and visualizing concurrency
Request Lambda behaviorReasoning
2 Provisions new environment BExisting execution environment 
instance A is busy
3 Provisions new environment CExisting execution environment 
instances A and B are both busy
4 Provisions new environment DExisting execution environment 
instances A, B, and C are all busy
5 Provisions new environment EExisting execution environment 
instances A, B, C, and D are all 
busy
6 Reuses environment AExecution environment instance
A has ﬁnished processing 
request 1 and is now available
7 Reuses environment BExecution environment instance
B has ﬁnished processing 
request 2 and is now available
8 Reuses environment CExecution environment instance
C has ﬁnished processing 
request 3 and is now available
9 Provisions new environment FExisting execution environment 
instances A, B, C, D, and E are all 
busy
10 Reuses environment DExecution environment instance
D has ﬁnished processing 
request 4 and is now available
As your function receives more concurrent requests, Lambda scales up the number of execution 
environment instances in response. The following animation tracks the number of concurrent requests 
over time:
222AWS Lambda Developer Guide
How to calculate concurrency
By freezing the previous animation at six distinct points in time, we get the following diagram:
In the previous diagram, we can draw a vertical line at any point in time and count the number of 
environments that intersect this line. This gives us the number of concurrent requests at that point 
in time. For example, at time t1, there are 3 active environments serving 3 concurrent requests. The 
maximum number of concurrent requests in this simulation occurs at time t4, when there are 6 active 
environments serving 6 concurrent requests.
To summarize, your function's concurrency is the number of concurrent requests that it's handling at the 
same time. In response to an increase in your function's concurrency, Lambda provisions more execution 
environment instances to meet request demand.
How to calculate concurrency
In general, concurrency of a system is the ability to process more than one task simultaneously. In 
Lambda, concurrency is the number of in-ﬂight requests that your function is handling at the same 
223AWS Lambda Developer Guide
Concurrency vs. requests per second
time. A quick and practical way of measuring concurrency of a Lambda function is to use the following 
formula:
Concurrency = (average requests per second) * (average request duration in seconds)
Concurrency diﬀers from requests per second. For example, suppose your function receives 100 
requests per second on average. If the average request duration is 1 second, then it's true that the 
concurrency is also 100:
Concurrency = (100 requests/second) * (1 second/request) = 100
However, if the average request duration is 500 ms, the concurrency is 50:
Concurrency = (100 requests/second) * (0.5 second/request) = 50
What does a concurrency of 50 mean in practice? If the average request duration is 500 ms, you can 
think of an instance of your function as being able to handle 2 requests per second. Then, it takes 50 
instances of your function to handle a load of 100 requests per second. A concurrency of 50 means that 
Lambda must provision 50 execution environment instances to eﬃciently handle this workload without 
any throttling. Here's how to express this in equation form:
Concurrency = (100 requests/second) / (2 requests/second) = 50
If your function receives double the number of requests (200 requests per second), but only requires half 
the time to process each request (250 ms), the concurrency is still 50:
Concurrency = (200 requests/second) * (0.25 second/request) = 50
Test your understanding of concurrency
Suppose you have a function that takes, on average, 200 ms to run. During peak load, you observe 5,000 
requests per second. What is the concurrency of your function during peak load?
Answer
The average function duration is 200 ms, or 0.2 seconds. Using the concurrency formula, you can plug in 
the numbers to get a concurrency of 1000:
Concurrency = (5,000 requests/second) * (0.2 seconds/request) = 1,000
Alternatively, an average function duration of 200 ms means that your function can process 5 requests 
per second. To handle the 5,000 request per second workload, you need 1,000 execution environment 
instances. Thus, the concurrency is 1,000:
Concurrency = (5,000 requests/second) / (5 requests/second) = 1,000
Concurrency vs. requests per second
As mentioned in the previous section, concurrency diﬀers from requests per second. This is an especially 
important distinction to make when working with functions that have an average request duration of 
less than 100 ms.
224AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
In general, each instance of your execution environment can handle at most 10 requests per second. This 
limit applies to synchronous on-demand functions, as well as functions that use provisioned concurrency. 
In you're unfamiliar with this limit, you may be confused as to why such functions could experience 
throttling in certain scenarios.
For example, consider a function with an average request duration of 50 ms. At 200 requests per second, 
here's the concurrency of this function:
Concurrency = (200 requests/second) * (0.05 second/request) = 10
Based on this result, you might expect that you only need 10 execution environment instances to handle 
this load. However, each execution environment can handle only 10 executions per second. This means 
that with 10 execution environments, you can only handle 100 requests per second out of the 200 total 
requests. This function experiences throttling.
The lesson is that you need to consider both concurrency and requests per second when conﬁguring 
concurrency settings for your functions. In this case, you need 20 execution environments for your 
function, even though it only has a concurrency of 10.
Test your understanding of concurrency (sub-100 ms functions)
Suppose you have a function that takes, on average, 20 ms to run. During peak load, you observe 3,000 
requests per second. What is the concurrency of your function during peak load?
Answer
The average function duration is 20 ms, or 0.02 seconds. Using the concurrency formula, you can plug in 
the numbers to get a concurrency of 60:
Concurrency = (3,000 requests/second) * (0.02 seconds/request) = 60
However, each execution environment can handle only 10 requests per second. With 60 execution 
environments, your function can handle a maximum of 600 requests per second. In order to fully 
accommodate the 3,000 requests, you'll need at least 300 execution environment instances.
Reserved concurrency and provisioned concurrency
By default, your account has a concurrency limit of 1,000 across all functions in a region. Your functions 
share this pool of 1,000 concurrency on an on-demand basis. Your function experiences throttling (i.e. it 
starts to drop requests) if you run out of available concurrency.
Some of your functions might be more critical than others. As a result, you might want to conﬁgure 
concurrency settings to ensure that critical functions get the concurrency they need. There are two types 
of concurrency controls available: reserved concurrency and provisioned concurrency.
•Use reserved concurrency to reserve a portion of your account's concurrency for a function. This is 
useful if you don't want other functions taking up all the available unreserved concurrency.
•Use provisioned concurrency to pre-initialize a number of environment instances for a function. This 
is useful for reducing cold start latencies.
Reserved concurrency
If you want to guarantee that a certain amount of concurrency is available for your function at any time, 
use reserved concurrency.
225AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
Reserved concurrency is the maximum number of concurrent instances you want to allocate to your 
function. When you dedicate reserved concurrency to a function, no other function can use that 
concurrency. In other words, setting reserved concurrency can impact the concurrency pool that's 
available to other functions. Functions that don't have reserved concurrency share the remaining pool of 
unreserved concurrency.
Conﬁguring reserved concurrency counts towards your overall account concurrency limit. There is no 
charge for conﬁguring reserved concurrency for a function.
To better understand reserved concurrency, consider the following diagram:
In this diagram, your account concurrency limit for all the functions in this region is at the default limit 
of 1,000. Suppose you have two critical functions, function-blue  and function-orange , that 
routinely expect to get high invocation volumes. You decide to give 400 units of reserved concurrency 
to function-blue , and 400 units of reserved concurrency to function-orange . In this example, all 
other functions in your account must share the remaining 200 units of unreserved concurrency.
The diagram has 5 points of interest:
•At t1, both function-orange  and function-blue  begin receiving requests. Each function begins 
to use up their allocated portion of reserved concurrency units.
•At t2, function-orange  and function-blue  are steadily receiving more requests. At the 
same time, you deploy some other Lambda functions, which begin receiving requests. You do not 
allocate reserved concurrency to these other functions. They begin using the remaining 200 units of 
unreserved concurrency.
•At t3, function-orange  hits the max concurrency of 400. Although there is unused concurrency 
elsewhere in your account, function-orange  cannot access it. The red line indicates that function-
orange is experiencing throttling, and Lambda may drop requests.
•At t4, function-orange  starts to receive fewer requests and is no longer throttling. However, your 
other functions experience a spike in traﬃc and begin throttling. Although there is unused concurrency 
elsewhere in your account, these other functions cannot access it. The red line indicates that your other 
functions are experiencing throttling.
•At t5, other functions start to receive fewer requests and are no longer throttling.
226AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
From this example, notice that reserving concurrency has the following eﬀects:
•Your function can scale independently of other functions in your account. All of your account's 
functions in the same region that don't have reserved concurrency share the pool of unreserved 
concurrency. Without reserved concurrency, other functions can potentially use up all of your available 
concurrency. This prevents critical functions from scaling up if needed.
•Your function can't scale out of control. Reserved concurrency puts a cap on your function's 
maximum concurrency. This means that your function can't use concurrency reserved for other 
functions, or concurrency from the unreserved pool. You can reserve concurrency to prevent your 
function from using all the available concurrency in your account, or from overloading downstream 
resources.
•You may not be able to use all of your account's available concurrency. Reserving concurrency 
counts towards your account concurrency limit, but this also means that other functions cannot use 
that chunk of reserved concurrency. If your function doesn't use up all of the concurrency that you 
reserve for it, you're eﬀectively wasting that concurrency. This isn't an issue unless other functions in 
your account could beneﬁt from the wasted concurrency.
To manage reserved concurrency settings for your functions, see Conﬁguring reserved 
concurrency (p. 234).
Provisioned concurrency
You use reserved concurrency to deﬁne the maximum number of execution environments reserved for a 
Lambda function. However, none of these environments come pre-initialized. As a result, your function 
invocations may take longer because Lambda must ﬁrst initialize the new environment before being able 
to use it to invoke your function. When Lambda has to initialize a new environment in order to carry out 
an invocation, this is known as a cold start. To mitigate cold starts, you can use provisioned concurrency.
Provisioned concurrency is the number of pre-initialized execution environments you want to allocate 
to your function. If you set provisioned concurrency on a function, Lambda initializes that number of 
execution environments so that they are prepared to respond immediately to function requests.
Note
Using provisioned concurrency incurs additional charges to your account. If you're working 
with the Java 11 or Java 17 runtimes, you can also use Lambda SnapStart to mitigate 
cold start issues at no additional cost. SnapStart uses cached snapshots of your execution 
environment to signiﬁcantly improve start-up performance. You cannot use both SnapStart and 
provisioned concurrency on the same function version. For more information about SnapStart 
features, limitations, and supported regions, see Improving startup performance with Lambda 
SnapStart (p. 1098 ).
When using provisioned concurrency, Lambda still recycles execution environments in the background. 
However, at any given time, Lambda always ensures that the number of pre-initialized environments is 
equal to the value of your function's provisioned concurrency setting. This behavior diﬀers from reserved 
concurrency, where Lambda may completely terminate an environment after a period of inactivity. The 
following diagram illustrates this by comparing the lifecycle of a single execution environment when you 
conﬁgure your function using reserved concurrency compared to provisioned concurrency.
227AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
The diagram has four points of interest:
Time Reserved concurrency Provisioned concurrency
t1 Nothing happens. Lambda pre-initializes an 
execution environment instance.
t2 Request 1 comes in. Lambda 
must initialize a new execution 
environment instance.Request 1 comes in. Lambda 
uses the pre-initialized 
environment instance.
t3 After some inactivity, 
Lambda terminates the active 
environment instance.Nothing happens.
t4 Request 2 comes in. Lambda 
must initialize a new execution 
environment instance.Request 2 comes in. Lambda 
uses the pre-initialized 
environment instance.
To better understand provisioned concurrency, consider the following diagram:
228AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
In this diagram, you have an account concurrency limit of 1,000. You decide to give 400 units of 
provisioned concurrency to function-orange . All functions in your account, including  function-
orange, can use the remaining 600 units of unreserved concurrency.
The diagram has 5 points of interest:
•At t1, function-orange  begins receiving requests. Since Lambda has pre-initialized 400 execution 
environment instances, function-orange  is ready for immediate invocation.
•At t2, function-orange  reaches 400 concurrent requests. As a result, function-orange  runs out 
of provisioned concurrency. However, since there's still unreserved concurrency available, Lambda can 
use this to handle additional requests to function-orange  (there's no throttling). Lambda must 
create new instances to serve these requests, and your function may experience cold start latencies.
•At t3, function-orange  returns to 400 concurrent requests after a brief spike in traﬃc. Lambda is 
again able to handle all requests without cold start latencies.
•At t4, functions in your account experience a burst in traﬃc. This burst can come from function-
orange or any other function in your account. Lambda uses unreserved concurrency to handle these 
requests.
•At t5, functions in your account reach the maximum concurrency limit of 1,000, and experience 
throttling.
The previous example only considered provisioned concurrency. In practice, you can set both provisioned 
concurrency and reserved concurrency on a function. You might do this if you had a function that 
handles a consistent load of invocations, but routinely sees spikes of traﬃc during the weekends. In this 
case, you could use provisioned concurrency to set a baseline amount of environments to handle request 
during weekdays, and use reserved concurrency to handle the weekend spikes. Consider the following 
diagram:
229AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
In this diagram, suppose that you conﬁgure 200 units of provisioned concurrency and 400 units of 
reserved concurrency for function-orange . Because you conﬁgured reserved concurrency, function-
orange cannot use any of the 600 units of unreserved concurrency.
This diagram has 5 points of interest:
•At t1, function-orange  begins receiving requests. Since Lambda has pre-initialized 200 execution 
environment instances, function-orange  is ready for immediate invocation.
•At t2, function-orange  uses up all its provisioned concurrency. function-orange  can continue 
serving requests using reserved concurrency, but these requests may experience cold start latencies.
•At t3, function-orange  reaches 400 concurrent requests. As a result, function-orange  uses up 
all its reserved concurrency. Since function-orange  cannot use unreserved concurrency, requests 
begin to throttle.
•At t4, function-orange  starts to receive fewer requests, and no longer throttles.
•At t5, function-orange  drops down to 200 concurrent requests, so all requests are again able to 
use provisioned concurrency (i.e. no cold start latencies).
Both reserved concurrency and provisioned concurrency count towards your account concurrency limit 
and Regional quotas. In other words, allocating reserved and provisioned concurrency can impact the 
concurrency pool that's available to other functions. Conﬁguring provisioned concurrency incurs charges 
to your AWS account.
Note
If the amount of provisioned concurrency on a function's versions and aliases adds up to 
the function's reserved concurrency, all invocations run on provisioned concurrency. This 
conﬁguration also has the eﬀect of throttling the unpublished version of the function 
($LATEST), which prevents it from executing. You can't allocate more provisioned concurrency 
than reserved concurrency for a function.
To manage provisioned concurrency settings for your functions, see conﬁguring provisioned concurrency. 
To automate provisioned concurrency scaling based on a schedule or application utilization, see 
managing provisioned concurrency with Application Auto Scaling.
230AWS Lambda Developer Guide
Reserved concurrency and provisioned concurrency
How Lambda allocates provisioned concurrency
Provisioned concurrency doesn't come online immediately after you conﬁgure it. Lambda starts 
allocating provisioned concurrency after a minute or two of preparation. In particular, Lambda can 
provision between 500 to 3,000 execution environments at once, depending on the region. After this 
initial burst, Lambda allocates 500 additional environments per minute, regardless of the region, until 
the request is fulﬁlled.
For example, suppose your account concurrency limit is 10,000. Also, suppose that at 10:00 in US East 
(N. Virginia), you conﬁgure 5,000 units of provisioned concurrency for one function. Here's how Lambda 
might allocate provisioned concurrency units:
In the previous diagram:
•Initially, Lambda can provision at max 3,000 execution environments, since the initial burst 
concurrency limit in US East (N. Virginia) is 3,000.
•At 10:00 : You request 5,000 units of provisioned concurrency for this function. Lambda doesn't begin 
provisioning execution environments instantaneously.
•At 10:01 : Lambda starts by provisioning 3,000 environments.
•From 10:02 to 10:05: Lambda provisions 500 additional environments each minute. By 10:05, Lambda 
ﬁnishes allocating 5,000 environments to your function.
When you submit a request to allocate provisioned concurrency, you can't access any of those 
environments until Lambda completely ﬁnishes allocating them. For example, in the previous scenario, 
none of your requests can use provisioned concurrency until 10:05, since that's when Lambda completely 
ﬁnishes allocating your request of 5,000 execution environments.
Comparing reserved concurrency and provisioned concurrency
The following is a table summarizing and comparing reserved and provisioned concurrency.
231AWS Lambda Developer Guide
Concurrency quotas
Topic Reserved concurrencyProvisioned concurrency
Deﬁnition Maximum number of execution 
environment instances for your 
function.Set number of pre-provisioned 
execution environment instances 
for your function.
Provisioning behaviorLambda provisions new 
instances on an on-demand 
basis.Lambda pre-provisions instances 
(i.e. before your function starts 
receiving requests).
Cold start behaviorCold start latency possible, 
since Lambda must create new 
instances on-demand.Cold start latency eliminated, 
since Lambda doesn't have to 
create instances on-demand.
Throttling behaviorFunction throttled when 
reserved concurrency limit 
reached.If reserved concurrency not 
set: function uses unreserved 
concurrency when provisioned 
concurrency limit reached.
If reserved concurrency set: 
function throttled when 
reserved concurrency limit 
reached.
Default behavior if not setFunction uses unreserved 
concurrency available in your 
account.Lambda doesn't pre-provision 
any instances. Instead, if 
reserved concurrency not 
set: function uses unreserved 
concurrency available in your 
account.
If reserved concurrency 
set: function uses reserved 
concurrency.
Pricing No additional charge.Incurs additional charges.
Concurrency quotas
Lambda sets quotas for the total amount of concurrency you can use across all functions in a region. 
These quotas exist on two levels:
•At the account level, your functions can have up to 1,000 units of concurrency by default. To increase 
this limit, see Requesting a quota increase in the Service Quotas User Guide.
•At the function level, you can reserve up to 900 units of concurrency across all your functions by 
default. 100 units of concurrency are always reserved for functions that don't explicitly reserve 
concurrency. For example, if you increased your account concurrency limit to 2,000, you can reserve up 
to 1,900 units of concurrency at the function level.
To check your current account level concurrency quota, use the AWS Command Line Interface (CLI) to run 
the following command:
aws lambda get-account-settings
You should see output that looks like the following:
232AWS Lambda Developer Guide
Concurrency quotas
{ 
    "AccountLimit": { 
        "TotalCodeSize": 80530636800, 
        "CodeSizeUnzipped": 262144000, 
        "CodeSizeZipped": 52428800, 
        "ConcurrentExecutions": 1000, 
        "UnreservedConcurrentExecutions": 900 
    }, 
    "AccountUsage": { 
        "TotalCodeSize": 410759889, 
        "FunctionCount": 8 
    }
}
ConcurrentExecutions  is your total account level concurrency quota.
UnreservedConcurrentExecutions  is the amount of reserved concurrency you can still allocate to 
your functions.
For initial bursts of traﬃc, your cumulative concurrency can reach a level of between 500 and 3,000 
depending on the region:
Regions Burst concurrency limit
US West (Oregon), US East (N. Virginia), Europe 
(Ireland)3,000
Asia Paciﬁc (Tokyo), Europe (Frankfurt), US East 
(Ohio)1,000
All other Regions 500
After the initial burst increase, Lambda continues to scale up your function based on the following rules:
•If your function needs additional scaling, Lambda can scale up by a maximum of 500 additional 
execution environment instances (burst quota units) per minute, regardless of the Region.
•Each minute, you continue to accrue 500 burst quota units. If your function doesn’t require this level 
of scaling, Lambda saves up any unused units in an imaginary “bucket”, up until the bucket reaches the 
maximum burst concurrency limit in your Region. For instance, your bucket can continue to accrue 500 
units per minute until it reaches 3,000 units in US East (N. Virginia). When your function encounters 
future bursts, Lambda draws from your bucket to scale up your function.
For more information, see the section called “Burst concurrency” (p. 243). If you need a burst 
concurrency limit increase, please inquire further through AWS Support. Service Quotas do not support 
changes in burst limits at this time.
233AWS Lambda Developer Guide
Conﬁguring reserved concurrency
Conﬁguring reserved concurrency
In Lambda, concurrency (p. 220) is the number of in-ﬂight requests your function is handling at the same 
time. There are two types of concurrency controls available:
•Reserved concurrency – Reserved concurrency is the maximum number of concurrent instances you 
want to allocate to your function. When a function has reserved concurrency, no other function can 
use that concurrency. There is no charge for conﬁguring reserved concurrency for a function.
•Provisioned concurrency – Provisioned concurrency is the number of pre-initialized execution 
environments you want to allocate to your function. These execution environments are prepared 
to respond immediately to incoming function requests. Conﬁguring provisioned concurrency incurs 
charges to your AWS account.
This topic details how to manage and conﬁgure reserved concurrency. For a conceptual overview of 
these two types of concurrency controls, see Reserved concurrency and provisioned concurrency. For 
information on conﬁguring provisioned concurrency, see the section called “Conﬁguring provisioned 
concurrency” (p. 237).
Sections
•Conﬁguring reserved concurrency (p. 234)
•Conﬁguring concurrency with the Lambda API (p. 235)
Conﬁguring reserved concurrency
You can conﬁgure reserved concurrency settings for a function using the Lambda console or the Lambda 
API.
To reserve concurrency for a function (console)
1. Open the Functions page of the Lambda console.
2. Choose the function you want to reserve concurrency for.
3. Choose Conﬁguration  and then choose Concurrency.
4. Under Concurrency, choose Edit.
5. Choose Reserve concurrency. Enter the amount of concurrency to reserve for the function.
6. Choose Save.
You can reserve up to the Unreserved account concurrency value minus 100. The remaining 100 units of 
concurrency are for functions that aren't using reserved concurrency. For example, if your account has a 
concurrency limit of 1,000, you cannot reserve all 1,000 units of concurrency to a single function.
234AWS Lambda Developer Guide
Conﬁguring reserved concurrency
Reserving concurrency for a function impacts the concurrency pool that's available to other functions. 
For example, if you reserve 100 units of concurrency for function-a , other functions in your account 
must share the remaining 900 units of concurrency, even if function-a  doesn't use all 100 reserved 
concurrency units.
To intentionally throttle a function, set its reserved concurrency to 0. This stops your function from 
processing any events until you remove the limit.
To conﬁgure reserved concurrency with the Lambda API, use the following API operations.
•PutFunctionConcurrency (p. 1466 )
•GetFunctionConcurrency
•DeleteFunctionConcurrency (p. 1336 )
For example, to conﬁgure reserved concurrency with the AWS Command Line Interface (CLI), use the
put-function-concurrency  command. The following command reserves 100 concurrency units for a 
function named my-function :
aws lambda put-function-concurrency --function-name my-function \ 
    --reserved-concurrent-executions 100
You should see output that looks like the following:
{ 
    "ReservedConcurrentExecutions": 100
}
Conﬁguring concurrency with the Lambda API
If your function is currently serving traﬃc, you can easily view its concurrency metrics using CloudWatch 
metrics . Speciﬁcally, the ConcurrentExecutions  metric shows you the number of concurrent 
invocations for each function in your account.
235AWS Lambda Developer Guide
Conﬁguring reserved concurrency
The previous graph suggests that this function serves an average of 5 to 10 concurrent requests at any 
given time, and peaks at 20 requests on a typical day. Suppose that there are many other functions in 
your account.  If this function is critical to your application and you don't want to drop any requests, 
use a number greater than or equal to 20 as your reserved concurrency setting.
Alternatively, recall that you can also  calculate concurrency using the following formula:
Concurrency = (average requests per second) * (average request duration in seconds)
Multiplying average requests per second with the average request duration in seconds gives you a rough 
estimate of how much concurrency you need to reserve. You can estimate average requests per second 
using the Invocation  metric, and the average request duration in seconds using the Duration  metric. 
See Working with Lambda function metrics (p. 965) for more details.
236AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
Conﬁguring provisioned concurrency
In Lambda, concurrency (p. 220) is the number of in-ﬂight requests your function is handling at the same 
time. There are two types of concurrency controls available:
•Reserved concurrency – Reserved concurrency is the maximum number of concurrent instances you 
want to allocate to your function. When a function has reserved concurrency, no other function can 
use that concurrency. There is no charge for conﬁguring reserved concurrency for a function.
•Provisioned concurrency – Provisioned concurrency is the number of pre-initialized execution 
environments you want to allocate to your function. These execution environments are prepared 
to respond immediately to incoming function requests. Conﬁguring provisioned concurrency incurs 
charges to your AWS account.
This topic details how to manage and conﬁgure provisioned concurrency. For a conceptual overview of 
these two types of concurrency controls, see  Reserved concurrency and provisioned concurrency. For 
more information on conﬁguring reserved concurrency, see the section called “Conﬁguring reserved 
concurrency” (p. 234).
Sections
•Conﬁguring provisioned concurrency (p. 237)
•Accurately estimating required provisioned concurrency (p. 239)
•Optimizing latency with provisioned concurrency (p. 239)
•Managing provisioned concurrency with Application Auto Scaling  (p. 240)
Conﬁguring provisioned concurrency
You can conﬁgure provisioned concurrency settings for a function using the Lambda console or the 
Lambda API.
To allocate provisioned concurrency for a function (console)
1. Open the Functions page of the Lambda console.
2. Choose the function you want to allocate provisioned concurrency for.
3. Choose Conﬁguration  and then choose Concurrency.
4. Under Provisioned concurrency conﬁgurations, choose Add conﬁguration.
5. Choose Reserve concurrency. Enter the amount of concurrency to reserve for the function.
6. Choose the qualiﬁer type, and alias or version.
Note
You cannot use provisioned concurrency with the $LATEST version of any function.
In addition, if you're using an event source with your Lambda function, make sure that event 
source points to the correct alias or version. Otherwise, your function won't use provisioned 
concurrency environments.
7. Enter a number under Provisioned concurrency. Lambda provides an estimate of monthly costs.
8. Choose Save.
You can conﬁgure up to the Unreserved account concurrency in your account, minus 100. The 
remaining 100 units of concurrency are for functions that aren't using reserved concurrency. For 
example, if your account has a concurrency limit of 1,000, and you haven't assigned any reserved 
or provisioned concurrency to any of your other functions, you can conﬁgure a maximum of 900 
provisioned concurrency units for a single function.
237AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
Conﬁguring provisioned concurrency for a function impacts the concurrency pool that's available to 
other functions. For example, if you conﬁgure 100 units of provisioned concurrency for function-a , 
other functions in your account must share the remaining 900 units of concurrency, even if function-a
doesn't use all 100 provisioned concurrency units.
You can allocate both reserved concurrency and provisioned concurrency for the same function. If you do 
so, the amount of provisioned concurrency cannot exceed the amount of reserved concurrency.
This limit also applies to function versions. The maximum amount of provisioned concurrency you 
can allocate to a speciﬁc function version is equal to the function's reserved concurrency minus the 
provisioned concurrency on other function versions.
To conﬁgure provisioned concurrency with the Lambda API, use the following API operations.
•PutProvisionedConcurrencyConﬁg
•GetProvisionedConcurrencyConﬁg
•ListProvisionedConcurrencyConﬁgs
•DeleteProvisionedConcurrencyConﬁg
For example, to conﬁgure provisioned concurrency with the AWS Command Line Interface (CLI), use the
put-provisioned-function-concurrency  command. The following command allocates 100 units 
of provisioned concurrency for the BLUE alias of a function named my-function :
aws lambda put-provisioned-function-concurrency --function-name my-function \ 
  --qualifier BLUE \ 
  --provisioned-concurrent-executions 100 
     
You should see output that looks like the following:
{ 
  "Requested ProvisionedConcurrentExecutions": 100, 
  "Allocated ProvisionedConcurrentExecutions": 0, 
  "Status": "IN_PROGRESS", 
  "LastModified": "2023-01-21T11:30:00+0000"
}
238AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
Accurately estimating required provisioned concurrency
If your function is currently serving traﬃc, you can easily view its concurrency metrics using CloudWatch 
metrics . Speciﬁcally, the ConcurrentExecutions  metric shows you the number of concurrent 
invocations for each function in your account.
The previous graph suggests that this function serves an average of 5 to 10 concurrent requests at any 
given time, and peaks at 20 requests on a typical day. Suppose that there are many other functions in 
your account.  If this function is critical to your application and you need a low-latency response on 
every invocation, use a number greater than or equal to 20 as your provisioned concurrency setting.
Alternatively, recall that you can also  calculate concurrency using the following formula:
Concurrency = (average requests per second) * (average request duration in seconds)
Multiplying average requests per second with the average request duration in seconds gives you a rough 
estimate of how much concurrency you need to reserve. You can estimate average requests per second 
using the Invocation  metric, and the average request duration in seconds using the Duration  metric. 
See Working with Lambda function metrics (p. 965) for more details.
When working with provisioned concurrency, Lambda suggests including a 10% buﬀer on top of the 
amount of concurrency your function typically needs. For example, if your function usually peaks at 200 
concurrent requests, set your provisioned concurrency at 220 instead (200 concurrent requests + 10% = 
220 provisioned concurrency).
Optimizing latency with provisioned concurrency
The way you structure your function code to optimize for latency can depend on whether you choose 
provisioned concurrency or on-demand environments. For functions running on provisioned concurrency, 
Lambda runs any initialization code (i.e. loading libraries and instantiating clients) at allocation time. So, 
putting as much initialization outside of the main function handler is a good idea, since doing so won't 
impact latency during actual function invocations. In contrast, if you initialize libraries or instantiate 
clients within your main handler code, your function has to run this each time you invoke it, regardless of 
whether or not you're using provisioned concurrency.
If you're using on-demand instances, Lambda may have to re-run your initialization code every time 
your function receives a request (cold start). Depending on what your function needs to achieve, you 
may choose to defer initialization for a speciﬁc capability until the function needs that capability. For 
example, consider the following control ﬂow for a Lambda handler:
def handler(event, context): 
    ... 
    if ( some_condition ): 
        // Initialize CLIENT_A to perform a task 
239AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
    else: 
        // Do nothing
In the previous example, instead of initializing CLIENT_A  outside of the main handler, the function 
author chose to initialize it within the if statement. By doing this, Lambda only runs this code if
some_condition  is satisﬁed. If the author initializes CLIENT_A  outside the main handler, Lambda runs 
that code on every cold start, increasing overall latency.
It's possible for your function to use up all of its provisioned concurrency. To handle excess traﬃc, your 
function has to use on-demand instances. To help you determine what type of initialization Lambda 
used for a particular environment, check the value of the AWS_LAMBDA_INITIALIZATION_TYPE
environment variable. This variable can have two possible values: provisioned-concurrency  or on-
demand . the value of AWS_LAMBDA_INITIALIZATION_TYPE  is immutable and does not change over 
the lifetime of the execution environment.
If you use the .NET 6 or .NET 7 runtimes, you can conﬁgure the AWS_LAMBDA_DOTNET_PREJIT
environment variable to improve the latency for functions, even if they don't use provisioned 
concurrency. The .NET runtime lazily compiles and initializes each library that your code calls for the ﬁrst 
time. As a result, the ﬁrst invocation of a Lambda function can take longer than subsequent invocations. 
To mitigate this, you can choose one of three values for AWS_LAMBDA_DOTNET_PREJIT :
•ProvisionedConcurrency : Lambda performs ahead-of-time JIT compilation for all environments 
using provisioned concurrency. This is the default value.
•Always: Lambda performs ahead-of-time JIT compilation for every environment, even if the function 
doesn't use provisioned concurrency.
•Never: Lambda disables ahead-of-time JIT compilation for all environments.
For provisioned concurrency environments, your function's initialization code runs during allocation, and 
every few hours as Lambda recycles active instances of your environment. You can see the initialization 
time in logs and traces (p. 973) after an environment instance processes a request. However, Lambda 
bills you for initialization even if the environment instance never processes a request. Provisioned 
concurrency runs continually and is billed separately from initialization and invocation costs. For details, 
see AWS Lambda Pricing.
For additional guidance on optimizing functions using provisioned concurrency, see  Lambda execution 
environments in Serverless Land.
Managing provisioned concurrency with Application Auto 
Scaling
You can use Application Auto Scaling to manage provisioned concurrency on a schedule or based on 
utilization. If you observe predictable patterns of traﬃc to your function, use scheduled scaling. If you 
want your function to maintain a speciﬁc utilization percentage, use a target tracking scaling policy.
Scheduled scaling
With Application Auto Scaling, you can set your own scaling schedule according to predictable load 
changes. For more information and examples, see  Scheduled scaling for Application Auto Scaling  in 
the Application Auto Scaling User Guide, and  Scheduling AWS Lambda Provisioned Concurrency for 
recurring peak usage on the AWS Compute Blog.
Target tracking
With target tracking, Application Auto Scaling creates and manages a set of CloudWatch alarms based on 
how you deﬁne your scaling policy. When these alarms activate, Application Auto Scaling automatically 
240AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
adjusts the amount of environments allocated using provisioned concurrency. Target tracking is ideal for 
applications that don't have predictable traﬃc patterns.
To scale provisioned concurrency using target tracking, use the RegisterScalableTarget  and
PutScalingPolicy  Application Auto Scaling API operations. For example, if you're using the AWS 
Command Line Interface (CLI), follow these steps:
1. Register a function's alias as a scaling target. The following example registers the BLUE alias of a 
function named my-function :
aws application-autoscaling register-scalable-target --service-namespace lambda \ 
    --resource-id function:my-function:BLUE --min-capacity 1 --max-capacity 100 \ 
    --scalable-dimension lambda:function:ProvisionedConcurrency
2. Apply a scaling policy to the target. The following example conﬁgures Application Auto Scaling to 
adjust the provisioned concurrency conﬁguration for an alias to keep utilization near 70 percent.
aws application-autoscaling put-scaling-policy \ 
    --service-namespace lambda \ 
    --scalable-dimension lambda:function:ProvisionedConcurrency \ 
    --resource-id function:my-function:BLUE \ 
    --policy-name my-policy \ 
    --policy-type TargetTrackingScaling \ 
    --target-tracking-scaling-policy-configuration '{ "TargetValue": 
 0.7, "PredefinedMetricSpecification": { "PredefinedMetricType": 
 "LambdaProvisionedConcurrencyUtilization" }}'
You should see output that looks like this:
{ 
    "PolicyARN": "arn:aws:autoscaling:us-east-2:123456789012:scalingPolicy:12266dbb-1524-
xmpl-a64e-9a0a34b996fa:resource/lambda/function:my-function:BLUE:policyName/my-policy", 
    "Alarms": [ 
        { 
            "AlarmName": "TargetTracking-function:my-function:BLUE-AlarmHigh-aed0e274-
xmpl-40fe-8cba-2e78f000c0a7", 
            "AlarmARN": "arn:aws:cloudwatch:us-east-2:123456789012:alarm:TargetTracking-
function:my-function:BLUE-AlarmHigh-aed0e274-xmpl-40fe-8cba-2e78f000c0a7" 
        }, 
        { 
            "AlarmName": "TargetTracking-function:my-function:BLUE-AlarmLow-7e1a928e-
xmpl-4d2b-8c01-782321bc6f66", 
            "AlarmARN": "arn:aws:cloudwatch:us-east-2:123456789012:alarm:TargetTracking-
function:my-function:BLUE-AlarmLow-7e1a928e-xmpl-4d2b-8c01-782321bc6f66" 
        } 
    ]
}
Application Auto Scaling creates two alarms in CloudWatch. The ﬁrst alarm triggers when the utilization 
of provisioned concurrency consistently exceeds 70%. When this happens, Application Auto Scaling 
allocates more provisioned concurrency to reduce utilization. The second alarm triggers when utilization 
is consistently less than 63% (90 percent of the 70% target). When this happens, Application Auto 
Scaling reduces the alias's provisioned concurrency.
In the following example, a function scales between a minimum and maximum amount of provisioned 
concurrency based on utilization.
241AWS Lambda Developer Guide
Conﬁguring provisioned concurrency
Legend
•
Function instances
•
Open requests
•
Provisioned concurrency
•
Standard concurrency
When the number of open requests increase, Application Auto Scaling increases provisioned concurrency 
in large steps until it reaches the conﬁgured maximum. Once it reaches the maximum, the function 
can continue to scale on standard, unreserved concurrency if your account hasn't reached its account 
concurrency limit. When utilization drops and stays consistently low, Application Auto Scaling decreases 
provisioned concurrency in smaller periodic steps.
Both of the alarms that Application Auto Scaling manages use the average statistic by default. Functions 
that have traﬃc patterns that come in quick bursts may not trigger these alarms. For example, suppose 
your Lambda function executes quickly (i.e. 20-100 ms) and your traﬃc pattern comes in quick bursts. 
In this case, the number of requests may exceed allocated provisioned concurrency during the burst, but 
the burst load must sustain for at least 3 minutes for Application Auto Scaling to provision additional 
environments. Additionally, both CloudWatch alarms require 3 data points that hit the target average 
before activating the auto scaling policy.
For more information on target tracking scaling policies, see  Target tracking scaling policies for 
Application Auto Scaling .
242AWS Lambda Developer Guide
Burst concurrency
Burst concurrency
As your function receives more requests, Lambda automatically scales up the number of execution 
environments to handle these requests until you reach your account concurrency limit. However, there’s 
a limit to how fast Lambda can scale. In most cases, you don’t need to worry about this limitation, but 
there are a few special cases where you should take this into account:
•When you deploy a new function and expect a large initial  burst of traﬃc
•When you expect existing  functions to experience a sudden  burst of traﬃc
In response to sudden bursts of traﬃc, Lambda might not scale up immediately to handle all incoming 
requests. This is to protect against over-scaling. Your burst concurrency quota is the maximum rate at 
which functions in your account can scale in response to bursts (i.e. how quickly Lambda can create new 
execution environments). Burst concurrency quota is an account-level limit. This section discusses how 
Lambda determines your burst concurrency quota, and details burst concurrency scaling behavior for 
speciﬁc burst scenarios.
Sections
•Burst concurrency rate limits (p. 243)
•Understanding and visualizing burst concurrency (p. 244)
Burst concurrency rate limits
When you deploy new functions, Lambda can immediately scale those functions up to between 500 and 
3,000 execution environment instances to handle an initial burst of traﬃc. The exact maximum depends 
on the AWS Region:
Regions Burst concurrency limit
US West (Oregon), US East (N. Virginia), Europe 
(Ireland)3,000
Asia Paciﬁc (Tokyo), Europe (Frankfurt), US East 
(Ohio)1,000
All other Regions 500
If you need a burst concurrency limit increase, please inquire further through AWS Support. Service 
Quotas do not support changes in burst limits at this time.
Note
Your burst concurrency limit cannot exceed your account concurrency limit. For example, the 
initial burst concurrency limit of 3,000 in US West (Oregon), US East (N. Virginia), and Europe 
(Ireland) is higher than the default account concurrency limit of 1,000. So, by default, initial 
bursts in these three Regions can scale only up to 1,000. To take advantage of the full 3,000 
units of burst concurrency available to your functions in these three Regions, request an account 
concurrency limit increase.
After the initial burst increase, Lambda continues to scale up your function based on the following rules:
•If your function needs additional scaling, Lambda can scale up by a maximum of 500 additional 
execution environment instances (burst quota units) per minute, regardless of the Region.
•Each minute, you continue to accrue 500 burst quota units. If your function doesn’t require this level 
of scaling, Lambda saves up any unused units in an imaginary “bucket”, up until the bucket reaches the 
243AWS Lambda Developer Guide
Burst concurrency
maximum burst concurrency limit in your Region. For instance, your bucket can continue to accrue 500 
units per minute until it reaches 3,000 units in US East (N. Virginia). When your function encounters 
future bursts, Lambda draws from your bucket to scale up your function.
In all cases, Lambda can continue to scale at the fastest rate available to you as long as you haven’t 
reached your account concurrency limit. If requests come in faster than your function can scale, or if your 
function is at maximum concurrency, additional requests fail with a throttling error (429 status code).
Understanding and visualizing burst concurrency
This section contains animations of a scaling example to help you understand Lambda burst concurrency 
behavior. In this scenario, assume that you have active Lambda functions in the US East (N. Virginia) 
region, and you have an account concurrency limit of 10,000. Suppose that over the span of several 
minutes, your functions encounter the following traﬃc pattern:
In the following animations, we'll break down how Lambda scales in response to each of the three bursts. 
In order to fully understand the animations, here is an explanation of the various components of the 
graph:
Component Signiﬁcance Examples
x-axis Time
y-axis Concurrent requests
Solid black line The actual number of concurrent 
requests that your functions are 
handling.•At 8:59, your functions 
are handling 0 concurrent 
requests.
•At 9:00, your functions are 
handling 2,000 concurrent 
requests.
244AWS Lambda Developer Guide
Burst concurrency
Component Signiﬁcance Examples
Shaded blue regionThe number of active execution 
environments that Lambda has 
provisioned for your functions.•At 8:59, Lambda has 
provisioned 0 execution 
environments.
•At 9:00, Lambda has 
provisioned 2,000 execution 
environments.
Shaded green regionThe theoretical maximum 
scaling capacity of your 
functions, given your current 
burst concurrency quota.•At 8:59, your functions can 
scale to 3,000 execution 
environments at maximum.
•At 9:00, your functions 
can still scale to just 3,000 
execution environments at 
maximum.
Orange "bucket" on the right 
side of the graphThe burst quota that's currently 
available to you.•At 9:07, the end of this 
scenario, the maximum burst 
quota available to you is 
1,000.
Part 1: Handling burst #1 (8:58 - 9:00)
The ﬁrst animation depicts how Lambda handles an initial burst of 2,000 concurrent requests.
Here's an explanation of this animation:
•At 8:58, you have the entire burst quota of 3,000 available to you. Though your functions receive 
0 requests until 9:00, Lambda can scale your functions to up to 3,000 execution environments 
immediately, if need be.
•At 9:00, your functions suddenly experience a burst of 2,000 concurrent requests. Lambda uses 2,000 
out of the 3,000 burst quota available to provision 2,000 execution environments. Lambda then 
245AWS Lambda Developer Guide
Burst concurrency
handles all 2,000 incoming requests. You have a remaining burst quota of 1,000, which Lambda saves 
for potential use later.
Part 2: Accumulating unused burst quota (9:00 - 9:02)
The second animation depicts how Lambda accumulates burst quota units if they go unused.
Here's an explanation of this animation:
•From 9:00 to 9:01, actual concurrent requests stay under 2,000, so there's no need for Lambda to 
continue to scale up.
•At 9:01, you get 500 additional burst quota units. Since you don't need to use any right now, Lambda 
saves all 500 units, bringing your total available burst quota to 1,500. Notice how this increases the 
theoretical maximum scaling capacity up to 3,500.
•The same thing occurs from 9:01 to 9:02. At 9:02, you get an additional 500 units, bringing your total 
available burst quota to 2,000. This increases the theoretical maximum scaling capacity to 4,000.
Part 3: Handling burst #2 (9:02 - 9:03)
The third animation depicts how Lambda uses your accumulated burst quota to handle a second burst.
246AWS Lambda Developer Guide
Burst concurrency
Here's an explanation of this animation:
•Shortly after 9:02, your functions suddenly experience a burst of 2,000 additional concurrent requests, 
or 4,000 total. Lambda uses all 2,000 of your available burst quota units to provision 2,000 more 
execution environments. Lambda then handles all 4,000 incoming requests. Your remaining burst 
quota is 0.
•At 9:03, you again accumulate 500 units.
Part 4: Handling burst #3 and throttling (9:03 - 9:04)
The fourth animation depicts a scenario in which your functions experience temporary throttling in 
response to a burst.
247AWS Lambda Developer Guide
Burst concurrency
Here's an explanation of this animation:
•At 9:04, you again accumulate 500 units. Your available burst quota is 1,000.
•Shortly after 9:04, your functions suddenly experience a burst of 1,500 additional concurrent requests, 
or 5,500 total. Lambda uses all 1,000 of your available quota to provision 1,000 more execution 
environments. Lambda can then handle 5,000 incoming requests, but 500 requests experience 
throttling.
Part 5: Recovery (9:04 - 9:05)
The ﬁfth animation depicts how Lambda quickly uses new burst quota units to recover from temporary 
throttling.
248AWS Lambda Developer Guide
Burst concurrency
Here's an explanation of this animation:
•At 9:05, you again accumulate 500 units. Your available burst quota is now 500.
•Immediately, Lambda uses these 500 units to provision 500 execution environments. This ends 
throttling, since Lambda can handle all 5,500 incoming requests. Your available burst quota is 0.
Part 6: Conclusion (9:05 - 9:07)
The sixth and ﬁnal animation depicts how Lambda continues to accumulate burst quota units, even if 
they aren't needed.
249AWS Lambda Developer Guide
Burst concurrency
Here's an explanation of this animation:
•At 9:06, you again accumulate 500 units. Your available burst quota is now 500.
•At 9:07, you again accumulate 500 units. Your available burst quota is now 1,000.
Note
Unused execution environments are frozen while they're waiting for requests and don't incur any 
charges. If they sit idle for a prolonged period of time, Lambda automatically shuts then down.
250AWS Lambda Developer Guide
Monitoring concurrency
Monitoring concurrency
Lambda emits Amazon CloudWatch metrics to help you monitor concurrency for your functions. This 
topic explains these metrics and how to interpret them.
Sections
•General concurrency metrics (p. 251)
•Provisioned concurrency metrics (p. 251)
General concurrency metrics
Use the following metrics to monitor concurrency for your Lambda functions. The granularity for each 
metric is 1 minute.
•ConcurrentExecutions  – The number of active concurrent invocations at a given point in time. 
Lambda emits this metric for all functions, versions, and aliases. For any function in the Lambda 
console, Lambda displays the graph for ConcurrentExecutions  natively in the Monitoring  tab, 
under Metrics . View this metric using MAX.
•UnreservedConcurrentExecutions  – The number of active concurrent invocations that are using 
unreserved concurrency. Lambda emits this metric across all functions in a region. View this metric 
using MAX.
Provisioned concurrency metrics
Use the following metrics to monitor Lambda functions using provisioned concurrency. The granularity 
for each metric is 1 minute.
•ProvisionedConcurrentExecutions  – The number of execution environment instances that 
are actively processing an invocation on provisioned concurrency. Lambda emits this metric for each 
function version and alias with provisioned concurrency conﬁgured. View this metric using MAX.
ProvisionedConcurrentExecutions  is not the same as the total number of provisioned concurrency 
that you allocate. For example, suppose you allocate 100 units of provisioned concurrency to a function 
version. During any given minute, if at most 50 out of those 100 execution environments were handling 
invocations simultaneously, then the value of MAX(ProvisionedConcurrentExecutions ) is 50.
•ProvisionedConcurrentInvocations  – The number of times Lambda invokes your function code 
using provisioned concurrency. Lambda emits this metric for each function version and alias with 
provisioned concurrency conﬁgured. View this metric using SUM.
ProvisionedConcurrentInvocations  diﬀers from ProvisionedConcurrentExecutions
in that ProvisionedConcurrentInvocations  counts total number of invocations, while
ProvisionedConcurrentExecutions  counts number of active environments. To understand this 
distinction, consider the following scenario:
251AWS Lambda Developer Guide
Monitoring concurrency
In this example, suppose that you receive 1 invocation per minute, and each invocation takes 2 minutes 
to complete. Each orange horizontal bar represents a single request. Suppose that you allocate 10 units 
of provisioned concurrency to this function, such that each request runs on provisioned concurrency.
In between minutes 0 and 1, Request 1  comes in. At minute 1 , the value for
MAX(ProvisionedConcurrentExecutions ) is 1, since at most 1 execution environment was active 
during the past minute. The value for SUM(ProvisionedConcurrentInvocations ) is also 1, since 1 
new request came in during the past minute.
In between minutes 1 and 2, Request 2  comes in, and Request 1  continues to run. At 
minute 2 , the value for MAX(ProvisionedConcurrentExecutions ) is 2, since at most 
2 execution environments were active during the past minute. However, the value for
SUM(ProvisionedConcurrentInvocations ) is 1, since only 1 new request came in during the past 
minute. This metric behavior continues until the end of the example.
•ProvisionedConcurrencySpilloverInvocations  – The number of times Lambda invokes 
your function on standard (reserved or unreserved) concurrency when all provisioned concurrency 
is in use. Lambda emits this metric for each function version and alias with provisioned concurrency 
conﬁgured. View this metric using SUM. The value of ProvisionedConcurrentInvocations
+ ProvisionedConcurrencySpilloverInvocations  should be equal to the total number of 
function invocations (i.e. the Invocations  metric).
ProvisionedConcurrencyUtilization  – The percentage of provisioned concurrency in use (i.e. 
the value of ProvisionedConcurrentExecutions  divided by the total amount of provisioned 
concurrency allocated). Lambda emits this metric for each function version and alias with provisioned 
concurrency conﬁgured. View this metric using MAX.
For example, suppose you provision 100 units of provisioned concurrency to a function version. During 
any given minute, if at most 60 out of those 100 execution environments were handling invocations 
simultaneously, then the value of MAX(ProvisionedConcurrentExecutions ) is 60, and the value of
MAX(ProvisionedConcurrentUtilization ) is 0.6.
A high value for ProvisionedConcurrencySpilloverInvocations  may indicate that you need 
to allocate additional provisioned concurrency for your function. Alternatively, you can  conﬁgure 
Application Auto Scaling to handle automatic scaling of provisioned concurrency based on pre-deﬁned 
thresholds.
Conversely, consistently low values for ProvisionedConcurrencyUtilization  may indicate that you 
over-allocated provisioned concurrency for your function.
252AWS Lambda Developer Guide
Code signing
Conﬁguring code signing for AWS Lambda
Code signing for AWS Lambda helps to ensure that only trusted code runs in your Lambda functions. 
When you enable code signing for a function, Lambda checks every code deployment and veriﬁes that 
the code package is signed by a trusted source.
Note
Functions deﬁned as container images do not support code signing.
To verify code integrity, use AWS Signer to create digitally signed code packages for functions and 
layers. When a user attempts to deploy a code package, Lambda performs validation checks on the code 
package before accepting the deployment. Because code signing validation checks run at deployment 
time, there is no performance impact on function execution.
You also use AWS Signer to create signing proﬁles . You use a signing proﬁle to create the signed code 
package. Use AWS Identity and Access Management (IAM) to control who can sign code packages and 
create signing proﬁles. For more information, see Authentication and Access Control in the AWS Signer 
Developer Guide .
To enable code signing for a function, you create a code signing conﬁguration  and attach it to the 
function. A code signing conﬁguration deﬁnes a list of allowed signing proﬁles and the policy action to 
take if any of the validation checks fail.
Lambda layers follow the same signed code package format as function code packages. When you add a 
layer to a function that has code signing enabled, Lambda checks that the layer is signed by an allowed 
signing proﬁle. When you enable code signing for a function, all layers that are added to the function 
must also be signed by one of the allowed signing proﬁles.
Use IAM to control who can create code signing conﬁgurations. Typically, you allow only speciﬁc 
administrative users to have this ability. Additionally, you can set up IAM policies to enforce that 
developers only create functions that have code signing enabled.
You can conﬁgure code signing to log changes to AWS CloudTrail. Successful and blocked deployments 
to functions are logged to CloudTrail with information about the signature and validation checks.
You can conﬁgure code signing for your functions using the Lambda console, the AWS Command Line 
Interface (AWS CLI), AWS CloudFormation, and the AWS Serverless Application Model (AWS SAM).
There is no additional charge for using AWS Signer or code signing for AWS Lambda.
Sections
•Signature validation (p. 253)
•Conﬁguration prerequisites (p. 254)
•Creating code signing conﬁgurations (p. 254)
•Updating a code signing conﬁguration (p. 254)
•Deleting a code signing conﬁguration (p. 255)
•Enabling code signing for a function (p. 255)
•Conﬁguring IAM policies  (p. 255)
•Conﬁguring code signing with the Lambda API (p. 256)
Signature validation
Lambda performs the following validation checks when you deploy a signed code package to your 
function:
253AWS Lambda Developer Guide
Conﬁguration prerequisites
1.Integrity – Validates that the code package has not been modiﬁed since it was signed. Lambda 
compares the hash of the package with the hash from the signature.
2.Expiry – Validates that the signature of the code package has not expired.
3.Mismatch – Validates that the code package is signed with one of the allowed signing proﬁles for the 
Lambda function. A mismatch also occurs if a signature is not present.
4.Revocation – Validates that the signature of the code package has not been revoked.
The signature validation policy deﬁned in the code signing conﬁguration determines which of the 
following actions Lambda takes if any of the validation checks fail:
•Warn – Lambda allows the deployment of the code package, but issues a warning. Lambda issues a 
new Amazon CloudWatch metric and also stores the warning in the CloudTrail log.
•Enforce – Lambda issues a warning (the same as for the Warn action) and blocks the deployment of 
the code package.
You can conﬁgure the policy for the expiry, mismatch, and revocation validation checks. Note that you 
cannot conﬁgure a policy for the integrity check. If the integrity check fails, Lambda blocks deployment.
Conﬁguration prerequisites
Before you can conﬁgure code signing for a Lambda function, use AWS Signer to do the following:
•Create one or more signing proﬁles.
•Use a signing proﬁle to create a signed code package for your function.
For more information, see Creating Signing Proﬁles (Console) in the AWS Signer Developer Guide.
Creating code signing conﬁgurations
A code signing conﬁguration deﬁnes a list of allowed signing proﬁles and the signature validation policy.
To create a code signing conﬁguration (console)
1. Open the Code signing conﬁgurations page of the Lambda console.
2. Choose Create conﬁguration.
3. For Description , enter a descriptive name for the conﬁguration.
4. Under Signing proﬁles, add up to 20 signing proﬁles to the conﬁguration.
a. For Signing proﬁle version ARN, choose a proﬁle version's Amazon Resource Name (ARN), or 
enter the ARN.
b. To add an additional signing proﬁle, choose Add signing proﬁles.
5. Under Signature validation policy, choose Warn or Enforce.
6. Choose Create conﬁguration.
Updating a code signing conﬁguration
When you update a code signing conﬁguration, the changes impact the future deployments of functions 
that have the code signing conﬁguration attached.
254AWS Lambda Developer Guide
Deleting a code signing conﬁguration
To update a code signing conﬁguration (console)
1. Open the Code signing conﬁgurations page of the Lambda console.
2. Select a code signing conﬁguration to update, and then choose Edit.
3. For Description , enter a descriptive name for the conﬁguration.
4. Under Signing proﬁles, add up to 20 signing proﬁles to the conﬁguration.
a. For Signing proﬁle version ARN, choose a proﬁle version's Amazon Resource Name (ARN), or 
enter the ARN.
b. To add an additional signing proﬁle, choose Add signing proﬁles.
5. Under Signature validation policy, choose Warn or Enforce.
6. Choose Save changes.
Deleting a code signing conﬁguration
You can delete a code signing conﬁguration only if no functions are using it.
To delete a code signing conﬁguration (console)
1. Open the Code signing conﬁgurations page of the Lambda console.
2. Select a code signing conﬁguration to delete, and then choose Delete.
3. To conﬁrm, choose Delete again.
Enabling code signing for a function
To enable code signing for a function, you associate a code signing conﬁguration with the function.
To associate a code signing conﬁguration with a function (console)
1. Open the Functions page of the Lambda console.
2. Choose the function for which you want to enable code signing.
3. Under Code signing conﬁguration, choose Edit.
4. In Edit code signing, choose a code signing conﬁguration for this function.
5. Choose Save.
Conﬁguring IAM policies
To grant permission for a user to access the code signing API operations (p. 256), attach one or more 
policy statements to the user policy. For more information about user policies, see Identity-based IAM 
policies for Lambda  (p. 920).
The following example policy statement grants permission to create, update, and retrieve code signing 
conﬁgurations.
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Action": [ 
          "lambda:CreateCodeSigningConfig", 
255AWS Lambda Developer Guide
Conﬁguring code signing with the Lambda API
          "lambda:UpdateCodeSigningConfig", 
          "lambda:GetCodeSigningConfig" 
        ], 
      "Resource": "*"  
    } 
  ]
} 
Administrators can use the CodeSigningConfigArn  condition key to specify the code signing 
conﬁgurations that developers must use to create or update your functions.
The following example policy statement grants permission to create a function. The policy statement 
includes a lambda:CodeSigningConfigArn  condition to specify the allowed code signing 
conﬁguration. Lambda blocks any CreateFunction  API request if its CodeSigningConfigArn
parameter is missing or does not match the value in the condition.
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "AllowReferencingCodeSigningConfig", 
      "Effect": "Allow", 
      "Action": [ 
          "lambda:CreateFunction", 
        ], 
      "Resource": "*", 
      "Condition": { 
          "StringEquals": { 
              "lambda:CodeSigningConfigArn":   
                  “arn:aws:lambda:us-west-2:123456789012:code-signing-
config:csc-0d4518bd353a0a7c6” 
          } 
      } 
    } 
  ]
} 
Conﬁguring code signing with the Lambda API
To manage code signing conﬁgurations with the AWS CLI or AWS SDK, use the following API operations:
•ListCodeSigningConﬁgs
•CreateCodeSigningConﬁg
•GetCodeSigningConﬁg
•UpdateCodeSigningConﬁg
•DeleteCodeSigningConﬁg
To manage the code signing conﬁguration for a function, use the following API operations:
•CreateFunction (p. 1304 )
•GetFunctionCodeSigningConﬁg
•PutFunctionCodeSigningConﬁg
•DeleteFunctionCodeSigningConﬁg
•ListFunctionsByCodeSigningConﬁg
256AWS Lambda Developer Guide
Tags
Using tags on Lambda functions
You can tag AWS Lambda functions to activate attribute-based access control (ABAC) (p. 925) and to 
organize them by owner, project, or department. Tags are free-form key-value pairs that are supported 
across AWS services for use in ABAC, ﬁltering resources, and adding detail to billing reports.
Tags apply at the function level, not to versions or aliases. Tags are not part of the version-speciﬁc 
conﬁguration that Lambda creates a snapshot of when you publish a version.
Sections
•Permissions required for working with tags (p. 257)
•Using tags with the Lambda console (p. 257)
•Using tags with the AWS CLI (p. 259)
•Requirements for tags (p. 260)
Permissions required for working with tags
Grant appropriate permissions to the AWS Identity and Access Management (IAM) identity (user, group, 
or role) for the person working with the function:
•lambda:ListTags – When a function has tags, grant this permission to anyone who needs to call
GetFunction  or ListTags  on it.
•lambda:TagResource – Grant this permission to anyone who needs to call CreateFunction  or
TagResource .
For more information, see Identity-based IAM policies for Lambda (p. 920).
Using tags with the Lambda console
You can use the Lambda console to create functions that have tags, add tags to existing functions, and 
ﬁlter functions by tags that you add.
To add tags when you create a function
1. Open the Functions page of the Lambda console.
2. Choose Create function.
3. Choose Author from scratch  or Container image .
4. Under Basic information , do the following:
a. For Function name, enter the function name. Function names are limited to 64 characters in 
length.
b. For Runtime , choose the language version to use for your function.
c. (Optional) For Architecture, choose the instruction set architecture (p. 33) to use for your 
function. The default architecture is x86_64. When you build the deployment package for your 
function, make sure that it is compatible with the instruction set architecture that you choose.
5. Expand Advanced settings, and then select Enable tags.
6. Choose Add new tag , and then enter a Key and an optional Value. To add more tags, repeat this 
step.
7. Choose Create function.
257AWS Lambda Developer Guide
Using tags with the console
To add tags to an existing function
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Choose Conﬁguration , and then choose Tags.
4. Under Tags, choose Manage tags .
5. Choose Add new tag , and then enter a Key and an optional Value. To add more tags, repeat this 
step.
6. Choose Save.
To ﬁlter functions with tags
1. Open the Functions page of the Lambda console.
2. Choose the search bar to see a list of function attributes and tag keys.
3. Choose a tag key to see a list of values that are in use in the current AWS Region.
4. Choose a value to see functions with that value, or choose (all values)  to see all functions that have 
a tag with that key.
258AWS Lambda Developer Guide
Using tags with the AWS CLI
The search bar also supports searching for tag keys. Enter tag to see only a list of tag keys, or enter the 
name of a key to ﬁnd it in the list.
Using tags with the AWS CLI
Adding and removing tags
To create a new Lambda function with tags, use the create-function command with the --tags option.
aws lambda create-function --function-name my-function
--handler index.js --runtime nodejs18.x \
--role arn:aws:iam:: 123456789012 :role/lambda-role  \
--tags Department=Marketing,CostCenter=1234ABCD
To add tags to an existing function, use the tag-resource command.
aws lambda tag-resource \
--resource arn:aws:lambda: us-east-2:123456789012:function:my-function  \
--tags Department=Marketing,CostCenter=1234ABCD
To remove tags, use the untag-resource command.
aws lambda untag-resource --resource arn:aws:lambda:us-east-1:123456789012:function:my-
function  \
--tag-keys Department
Viewing tags on a function
If you want to view the tags that are applied to a speciﬁc Lambda function, you can use either of the 
following AWS CLI commands:
•ListTags (p. 1443 ) – To view a list of the tags associated with this function, include your Lambda 
function ARN (Amazon Resource Name):
aws lambda list-tags --resource arn:aws:lambda:us-east-1:123456789012:function:my-
function
•GetFunction (p. 1359 ) – To view a list of the tags associated with this function, include your Lambda 
function name:
259AWS Lambda Developer Guide
Requirements for tags
aws lambda get-function --function-name my-function
Filtering functions by tag
You can use the AWS Resource Groups Tagging API GetResources API operation to ﬁlter your resources by 
tags. The GetResources  operation receives up to 10 ﬁlters, with each ﬁlter containing a tag key and up 
to 10 tag values. You provide GetResources  with a ResourceType  to ﬁlter by speciﬁc resource types.
For more information about AWS Resource Groups, see What are resource groups? in the AWS Resource 
Groups and Tags User Guide.
Requirements for tags
The following requirements apply to tags:
•Maximum number of tags per resource: 50
•Maximum key length: 128 Unicode characters in UTF-8
•Maximum value length: 256 Unicode characters in UTF-8
•Tag keys and values are case sensitive.
•Do not use the aws: preﬁx in your tag names or values because it is reserved for AWS use. You can't 
edit or delete tag names or values with this preﬁx. Tags with this preﬁx do not count against your tags 
per resource limit.
•If you plan to use your tagging schema across multiple services and resources, remember that other 
services may have restrictions on allowed characters. Generally allowed characters are: letters, spaces, 
and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.
260AWS Lambda Developer Guide
Targeted business outcomes
Testing serverless functions and 
applications
Testing serverless functions uses traditional test types and techniques, but you must also consider 
testing serverless applications as a whole. Cloud-based tests will provide the most accurate measure of 
quality of both your functions and serverless applications.
A serverless application architecture includes managed services that provide critical application 
functionality through API calls. For this reason, your development cycle should include automated tests 
that verify functionality when your function and services interact.
If you do not create cloud-based tests, you could encounter issues due to diﬀerences between your 
local environment and the deployed environment. Your continuous integration process should run tests 
against a suite of resources provisioned in the cloud before promoting your code to the next deployment 
environment, such as QA, Staging, or Production.
Continue reading this short guide to learn about testing strategies for serverless applications, or visit the
Serverless Test Samples repository to dive in with practical examples, speciﬁc to your chosen language 
and runtime.
For serverless testing, you will still write unit, integration  and end-to-end  tests.
•Unit tests  - Tests that run against an isolated block of code. For example, verifying the business logic 
to calculate the delivery charge given a particular item and destination.
•Integration tests  - Tests involving two or more components or services that interact, typically in a 
cloud environment. For example, verifying a function processes events from a queue.
•End-to-end tests  - Tests that verify behavior across an entire application. For example, ensuring 
infrastructure is set up correctly and that events ﬂow between services as expected to record a 
customer's order.
Targeted business outcomes
Testing serverless solutions may require slightly more time to set up tests that verify event-driven 
interactions between services. Keep the following practical business reasons in mind as you read this 
guide:
261AWS Lambda Developer Guide
What to test
•Increase the quality of your application
•Decrease time to build features and ﬁx bugs
The quality of an application depends on testing a variety of scenarios to verify functionality. Carefully 
considering the business scenarios and automating those tests to run against cloud services will raise the 
quality of your application.
Software bugs and conﬁguration problems have the least impact on cost and schedule when caught 
during an iterative development cycle. If issues remain undetected during development, ﬁnding and 
ﬁxing in production requires more eﬀort by more people.
A well planned serverless testing strategy will increase software quality and improve iteration time by 
verifying your Lambda functions and applications perform as expected in a cloud environment.
What to test
We recommend adopting a testing strategy that tests managed service behaviors , cloud conﬁguration, 
security policies, and the integration with your code to improve software quality. Behavior testing , also 
known as black box testing, veriﬁes a system works as expected without knowing all the internals.
•Run unit tests to check business logic inside Lambda functions.
•Verify integrated services are actually invoked, and input parameters are correct.
•Check that an event goes through all expected services end-to-end in a workﬂow.
In traditional server-based architecture, teams often deﬁne a scope for testing to only include code 
that runs on the application server. Other components, services, or dependencies are often considered 
external and out of scope for testing.
Serverless applications often consist of small units of work, such as Lambda functions that retrieve 
products from a database, or process items from a queue, or resize an image in storage. Each component 
runs in their own environment. Teams will likely be responsible for many of these small units within a 
single application.
Some application functionality can be delegated entirely to managed services such as Amazon S3, or 
created without using any internally developed code. There is no need to test these managed services, 
but you do need to test the integration with these services.
How to test serverless
You are probably familiar with how to test applications deployed locally: You write tests that run against 
code running entirely on your desktop operating system, or inside containers. For example, you might 
invoke a local web service component with a request and then make assertions about the response.
Serverless solutions are built from your function code and cloud-based managed services, such as 
queues, databases, event buses, and messaging systems. These components are all connected through 
an event-driven architecture , where messages, called events , ﬂow from one resource to another. 
These interactions can be synchronous, such as when a web service returns results immediately, or 
an asynchronous action which complete at a later time, such as placing items in a queue or starting a 
workﬂow step. Your testing strategy must include both scenarios and test the interactions between 
services. For asynchronous interactions, you may need detect side eﬀects in downstream components 
that may not be immediately observable.
Replicating an entire cloud environment, including queues, database tables, event buses, security 
policies, and more, is not practical. You will inevitably encounter issues due to diﬀerences between 
262AWS Lambda Developer Guide
Testing techniques
your local environment and your deployed environments in the cloud. The variations between your 
environments will increase the time to reproduce and ﬁx bugs.
In serverless applications, architecture components commonly exist entirely in the cloud, so testing 
against code and services in the cloud is necessary to develop features and ﬁx bugs.
Testing techniques
In reality, your testing strategy will likely include a mix of techniques to increase quality of your 
solutions. You will use quick interactive tests to debug functions in the console, automated unit tests to 
check isolated business logic, veriﬁcation of calls to external services with mocks, and occasional testing 
against emulators that mimic a service.
•Testing in the cloud - you deploy infrastructure and code to test with actual services, security policies, 
conﬁgurations and infrastructure speciﬁc parameters. Cloud-based tests provide the most accurate
measure of quality of your code.
Debugging a function in the console is a quick way to test in the cloud. You can choose from a library 
of sample test events or create a custom event to test a function in isolation. You can also share test 
events through the console with your team.
To automate  testing in the development and build lifecycle, you will need to test outside of the 
console. See the language speciﬁc testing sections in this guide for automation strategies and 
resources.
•Testing with mocks (also called fakes ) - Mocks are objects within your code that simulate and stand-
in for an external service. Mocks provide pre-deﬁned behavior to verify service calls and parameters. 
A fake is a mock implementation that takes shortcuts to simplify or improve performance. For 
example, a fake data access object might return data from an in-memory datastore. Mocks can mimic 
and simplify complex dependencies, but can also lead to more mocks in order to replace nested 
dependencies.
•Testing with emulators - You can setup applications (sometimes from a third party) to mimic a 
cloud service in your local environment. Speed is their strength, but setup and parity with production 
services is their weakness. Use emulators sparingly.
Testing in the cloud
Testing in the cloud is valuable for all phases of testing, including unit tests, integration tests, and end-
to-end tests. When you run tests against cloud-based code that also interacts with cloud-based services, 
you get the most accurate measure of quality of your code.
A convenient way to run a Lambda function in the cloud is with a test event in the AWS Management 
Console. A test event  is a JSON input to your function. If your function does not require input, the event 
can be an empty JSON document ({}). The console provides sample events for a variety of service 
integrations. After creating an event in the console, you can also share it with your team to make testing 
easier and consistent.
Learn how to debug a sample function in the console (p. 137).
Note
Although running functions in the console is a quick way to debug, automating  your test cycles 
is essential to increase application quality and development speed.
Test automation samples are available in the Serverless Test Samples repository. The following 
command line runs an automated Python integration test example:
python -m pytest -s tests/integration -v
263AWS Lambda Developer Guide
Testing in the cloud
Although the test runs locally, it interacts with cloud-based resources. These resources have been 
deployed using the AWS Serverless Application Model and AWS SAM command line tool. The test code 
ﬁrst retrieves the deployed stack outputs, which includes the API endpoint, function ARN, and security 
role. Next, the test sends a request to the API endpoint, which responds with a list of Amazon S3 buckets. 
This test runs entirely against cloud-based resources to verify those resources are deployed, secured, and 
work as expected.
========================= test session starts ========================= 
      platform darwin -- Python 3.10.10, pytest-7.3.1, pluggy-1.0.0 
      -- /Users/t/code/aws/serverless-test-samples/python-test-samples/apigw-lambda/venv/
bin/python 
      cachedir: .pytest_cache 
      rootdir: /Users/t/code/aws/serverless-test-samples/python-test-samples/apigw-lambda 
      plugins: mock-3.10.0 
      collected 1 item                                                                      
                                    
      tests/integration/test_api_gateway.py::TestApiGateway::test_api_gateway  
      --> Stack outputs: 
        HelloWorldApi 
        = https://p7teqs3162.execute-api.us-west-2.amazonaws.com/Prod/hello/ 
        > API Gateway endpoint URL for Prod stage for Hello World function 
        PythonTestDemo 
        = arn:aws:lambda:us-west-2:1234567890:function:testing-apigw-lambda-PythonTestDemo-
iSij8evaTdxl 
        > Hello World Lambda Function ARN 
        PythonTestDemoIamRole 
        = arn:aws:iam::1234567890:role/testing-apigw-lambda-PythonTestDemoRole-IZELQQ9MG4HQ 
        > Implicit IAM Role created for Hello World function 
      --> Found API endpoint for "testing-apigw-lambda" stack... 
      --> https://p7teqs3162.execute-api.us-west-2.amazonaws.com/Prod/hello/ 
      API Gateway response: 
      amplify-dev-123456789-deployment|myapp-prod-p-loggingbucket-123456|s3-java-
bucket-123456789 
      PASSED 
      ========================= 1 passed in 1.53s =========================  
       
For cloud-native application development, testing in the cloud provides the following beneﬁts:
•You can test every available service.
•You are always using the most recent service APIs and return values.
•A cloud test environment closely resembles your production environment.
•Tests can cover security policies, service quotas, conﬁgurations and infrastructure speciﬁc parameters.
•Every developer can quickly create one or more testing environments in the cloud.
•Cloud tests increase conﬁdence your code will run correctly in production.
Testing in the cloud does have some disadvantages. The most obvious negative of testing in the cloud 
is that deployments to cloud environments typically take longer than deployments to a local desktop 
environments.
Fortunately, tools such as AWS Serverless Application Model (AWS SAM) Accelerate, AWS Cloud 
Development Kit (AWS CDK) watch mode, and SST (3rd party) reduce the latency involved with cloud 
deployment iterations. These tools can monitor your infrastructure and code and automatically deploy 
incremental updates into your cloud environment.
264AWS Lambda Developer Guide
Testing with mocks
Note
See how to create infrastructure as code in the Serverless Developer Guide to learn more about 
AWS Serverless Application Model, AWS CloudFormation, and AWS Cloud Development Kit (AWS 
CDK).
Unlike local testing, testing in the cloud requires additional resources which may incur service costs. 
Creating isolated testing environments may increase the burden on your DevOps teams, especially 
in organizations with strict controls around accounts and infrastructure. Even so, when working with 
complex infrastructure scenarios, the cost in developer time to set up and maintain an intricate local 
environment could be similar (or more costly) than using disposable testing environments created with 
Infrastructure as Code automation tools.
Testing in the cloud, even with these considerations, is still the best way to guarantee the quality of your 
serverless solutions.
Testing with mocks
Testing with mocks is a technique where you create replacement objects in your code to simulate the 
behavior of a cloud service.
For example, you could write a test that uses a mock of the Amazon S3 service that returns a speciﬁc 
response whenever the CreateObject method is called. When a test runs, the mock returns that 
programmed response without calling Amazon S3, or any other service endpoints.
Mock objects are often generated by a mock framework to reduce development eﬀort. Some mock 
frameworks are generic and others are designed speciﬁcally for AWS SDKs, such as Moto , a Python 
library for mocking AWS services and resources.
Note that mock objects diﬀer from emulators in that mocks are typically created or conﬁgured by 
a developer as part of the test code, whereas emulators are standalone applications that expose 
functionality in the same manner as the systems they emulate.
The advantages of using mocks include the following:
•Mocks can simulate third-party services that are beyond the control of your application, such as APIs 
and software as a service (SaaS) providers, without needing direct access to those services.
•Mocks are useful for testing failure conditions, especially when such conditions are hard to simulate, 
like a service outage.
•Mock can provide fast local testing once conﬁgured.
•Mocks can provide substitute behavior for virtually any kind of object, so mocking strategies can create 
coverage for a wider variety of services than emulators.
•When new features or behaviors become available, mock testing can react more quickly. By using a 
generic mock framework, you can simulate new features as soon as the updated AWS SDK become 
available.
Mock testing has these disadvantages:
•Mocks generally require a non-trivial amount of setup and conﬁguration eﬀort, speciﬁcally when 
trying to determine return values from diﬀerent services in order to properly mock responses.
•Mocks are written, conﬁgured, and must be maintained by developers, increasing their responsibilities.
•You might need to have access to the cloud in order to understand the APIs and return values of 
services.
•Mocks can be diﬃcult to maintain. When mocked cloud API signatures change, or return value 
schemas evolve, you need to update your mocks. Mocks also require updates if you extend your 
application logic to make calls to new APIs.
•Tests that use mocks might pass in desktop environments but fail in the cloud. Results may not match 
the current API. Service conﬁguration and quotas cannot be tested.
265AWS Lambda Developer Guide
Testing with emulation
•Mock frameworks are limited in testing or detecting AWS Identity and Access Management (IAM) policy 
or quota limitations. Although mocks are better at simulating when authorization fails or a quota is 
exceeded, testing cannot determine which outcome will actually occur in a production environment.
Testing with emulation
Emulators are typically a locally running application which mimics a production AWS service.
Emulators have APIs that are similar to their cloud counterparts and provide similar return values. They 
can also simulate state changes that are initiated by API calls. For example, you might use AWS SAM 
to run a function with AWS SAM local to emulate the Lambda service so that you can quickly invoke a 
function. See AWS SAM local in the AWS Serverless Application Model Developer Guide for details.
The advantages of test with emulators include the following:
•Emulators can facilitate fast local development iterations and testing.
•Emulators provide a familiar environment for developers used to developing code in a local 
environment. For example, if you’re familiar with the development of an n-tier application, you might 
have a database engine and web server, similar to those running in production, running on your local 
machine to provide quick, local, isolated test capability.
•Emulators do not require any changes to cloud infrastructure (such as developer cloud accounts), so it’s 
easy to implement with existing testing patterns.
Testing with emulators has these disadvantages:
•Emulators can be diﬃcult to set up and replicate, especially when used in CI/CD pipelines. This can 
increase the workload of IT staﬀ or developers who manage their own software.
•Emulated features and APIs typically lag behind service updates. This can lead to errors because tested 
code does not match the actual API, and impede the adoption of new features.
•Emulators require support, updates, bug ﬁxes, and feature parity enhancements. These are the 
responsibility of the emulator author, which could be a third-party company.
•Tests that rely on emulators may provide successful results locally, but fail in the cloud due to 
production security policies, inter-service conﬁgurations, or exceeding Lambda quotas.
•Many AWS services do not have emulators available. If you rely on emulation, you may not have a 
satisfactory testing option for portions of your application.
Best practices
The following sections provide recommendations for successful serverless application testing.
You can ﬁnd practical examples of tests and test automation in the Serverless Test Samples repository.
Prioritize testing in the cloud
Testing in the cloud provides the most reliable, accurate, and complete test coverage. Performing tests 
in the context of the cloud will comprehensively test not only business logic but also security policies, 
service conﬁgurations, quotas, and the most up to date API signatures and return values.
Structure your code for testability
Simplify your tests and Lambda functions by separating Lambda-speciﬁc code from your core business 
logic.
266AWS Lambda Developer Guide
Accelerate development feedback loops
Your Lambda function handler  should be a slim adapter that takes in event data and passes only the 
details that matter to your business logic method(s). With this strategy, you can wrap comprehensive 
tests around your business logic without worrying about Lambda-speciﬁc details. Your AWS Lambda 
functions should not require setting up a complex environment or large amount of dependencies to 
create and initialize the component under test.
Generally speaking, you should write a handler that extracts and validates data from the incoming event
and context objects, then sends that input to methods that perform your business logic.
Accelerate development feedback loops
There are tools and techniques to accelerate development feedback loops. For example, AWS SAM 
Accelerate and AWS CDK watch mode both decrease the time required to update cloud environments.
The samples in the GitHub Serverless Test Samples repository explore some of these techniques.
We also recommend that you create and test cloud resources as early as possible during development—
not only after a check-in to source control. This practice enables quicker exploration and experimentation 
when developing solutions. In addition, automating deployment from a development machine helps 
you discover cloud conﬁguration problems more quickly and reduces wasted eﬀort for updates and code 
review processes.
Focus on integration tests
When building applications with Lambda, testing components together is a best practice.
Tests that run against two or more architectural components are called integration tests . The goal of 
integration tests is to understand not only how your code will execute across components, but how the 
environment hosting your code will behave. End-to-end tests  are special types of integration tests that 
verify behaviors across an entire application.
To build integration tests, deploy your application to a cloud environment. This can be done from a local 
environment or through a CI/CD pipeline. Then, write tests to exercise the system under test (SUT) and 
validate expected behavior.
For example, the system under test could be an application that uses API Gateway, Lambda and 
DynamoDB. A test could make a synthetic HTTP call to an API Gateway endpoint and validate that the 
response included the expected payload. This test validates that the AWS Lambda code is correct, and 
that each service is correctly conﬁgured to handle the request, including the IAM permissions between 
them. Further, you could design the test to write records of various sizes to verify your service quotas, 
such as max record size in DynamoDB, are set up correctly.
Create isolated test environments
Testing in the cloud typically requires isolated developer environments, so that tests, data, and events do 
not overlap.
267AWS Lambda Developer Guide
Use mocks for isolated business logic
One approach is to provide each developer a dedicated AWS account. This will avoid conﬂicts with 
resource naming that can occur when multiple developers working in a shared code base, attempt to 
deploy resources or invoke an API.
Automated test processes should create uniquely named resources for each stack. For example, you can 
set up scripts or TOML conﬁguration ﬁles so that AWS SAM CLI sam deploy or sam sync  commands will 
automatically specify a stack with a unique preﬁx.
In some cases, developers share an AWS account. This may be due to having resources in your stack that 
are expensive to operate, or to provision and conﬁgure. For example, a database may be shared to make 
it easier to set up and seed the data properly
If developers share an account, you should set boundaries to identify ownership and eliminate overlap. 
One way to do this is by preﬁxing stack names with developer user IDs. Another popular approach 
is to set up stacks based on code branches. With branch boundaries, environments are isolated, but 
developers can still share resources, such as a relational database. This approach is a best practice when 
developers work on more than one branch at a time.
Testing in the cloud is valuable for all phases of testing, including unit tests, integration tests, and 
end-to-end tests. Maintaining proper isolation is essential; but you still want your QA environment to 
resemble your production environment as closely as possible. For this reason, teams add change control 
processes for QA environments.
For pre-production and production environments, boundaries are typically drawn at the account level 
to insulate workloads from noisy neighbor problems and implement least privilege security controls to 
protect sensitive data. Workloads have quotas. You don't want your testing to consume quotas allocated 
for production (noisy neighbor) or have access to customer data. Load testing is another activity you 
should isolate from your production stack.
In all cases, environments should be conﬁgured with alerts and controls to avoid unnecessary spending. 
For example, you can limit the type, tier, or size of resources that can be created, and set up email alerts 
when estimated costs exceed a given threshold.
Use mocks for isolated business logic
Mock frameworks are a valuable tool for writing fast unit tests. They are especially beneﬁcial when tests 
cover complex internal business logic, such as mathematical or ﬁnancial calculations or simulations. 
Look for unit tests that have a large number of test cases or input variations, where those inputs do not 
change the pattern or the content of calls to other cloud services.
Code that is covered by unit tests with mocks should also be covered by testing in the cloud. This is 
recommended because a developer laptop or build machine environment could be conﬁgured diﬀerently 
than a production environment in the cloud. For example, your Lambda functions could use more 
memory or time than allocated when run with certain input parameters. Or your code might include 
environment variables that are not conﬁgured in the same way (or at all), and the diﬀerences could cause 
the code to behave diﬀerently or fail.
The beneﬁt of mocks is less for integration tests, because the level of eﬀort to implement the necessary 
mocks increases with the number of connection points. End-to-end testing should not use mocks, 
because these tests generally deal with states and complex logic that cannot be easily simulated with 
mock frameworks.
Lastly, avoid using mocked cloud services to validate the proper implementation of service calls. Instead, 
make cloud service calls in the cloud to validate behavior, conﬁguration, and functional implementation.
Use emulators sparingly
Emulators can be convenient for some use cases, for example, for a development team with limited, 
unreliable, or slow internet access. But, in most circumstances, choose to use emulators sparingly.
268AWS Lambda Developer Guide
Challenges testing locally
By avoiding emulators, you will be able to build and innovate with the latest service features and up 
to date APIs. You will not be stuck waiting on vendor releases to achieve feature parity. You will reduce 
your upfront and ongoing expenses for purchasing and conﬁguration on multiple development systems 
and build machines. Moreover, you will avoid the problem that many cloud services simply do not have 
emulators available. A testing strategy that depends on emulation will make it impossible to use those 
services (leading to potentially more expensive workarounds) or produce code and conﬁgurations that 
aren’t well tested.
When you do use emulation for testing, you must still test in the cloud to verify conﬁguration and to test 
interactions with cloud services that can only be simulated or mocked in an emulated environment.
Challenges testing locally
When you use emulators and mocked calls to test on your local desktop you might experience testing 
inconsistencies as your code progresses from environment to environment in your CI/CD pipeline. Unit 
tests to validate your application’s business logic on your desktop may not accurately test critical aspects 
of the cloud services.
The following examples provide cases to watch out for when testing locally with mocks and emulators:
Example: Lambda function creates an S3 bucket
If a Lambda function’s logic depends on creating an S3 bucket, a complete test should conﬁrm that 
Amazon S3 was called and the bucket was successfully created.
•In a mock testing setup, you might mock a success response and potentially add a test case to handle a 
failure response.
•In an emulation testing scenario, the CreateBucket API might be called, but you need to be aware 
that the identity making the local call will not originate from the Lambda service. The calling identity 
will not assume a security role as it would in the cloud, so a placeholder authentication will be used 
instead, possibly with a more permissive role or user identity that will be diﬀerent when run in the 
cloud.
The mock and emulation setups will test what the Lambda function will do if it calls Amazon S3; 
however, those tests will not verify that the Lambda function, as conﬁgured, is capable of successfully 
creating the Amazon S3 bucket. You must make sure the role assigned to the function has an attached 
security policy that allows the function to perform the s3:CreateBucket  action. If not, the function 
will likely fail when deployed to a cloud environment.
Example: Lambda function processes messages from 
an Amazon SQS queue
If an Amazon SQS queue is the source of a Lambda function, a complete test should verify that the 
Lambda function is successfully invoked when a message is put in a queue.
Emulation testing and mock testing are generally set up to run the Lambda function code directly, and to 
simulate the Amazon SQS integration by passing a JSON event payload (or a deserialized object) as the 
function handler’s input.
Local testing that simulates the Amazon SQS integration will test what the Lambda function will do 
when it’s called by Amazon SQS with a given payload, but the test will not verify that Amazon SQS will 
successfully invoke the Lambda function when it is deployed to a cloud environment.
269AWS Lambda Developer Guide
FAQ
Some examples of conﬁguration problems you might encounter with Amazon SQS and Lambda include 
the following:
•Amazon SQS visibility timeout is too low, resulting in multiple invocations when only one was 
intended.
•The Lambda function’s execution role doesn’t allow reading messages from the queue (through
sqs:ReceiveMessage , sqs:DeleteMessage , orsqs:GetQueueAttributes ).
•The sample event that is passed to the Lambda function exceeds the Amazon SQS message size quota. 
Therefore, the test is invalid because Amazon SQS would never be able to send a message of that size.
As these examples show, tests that cover business logic but not the conﬁgurations between cloud 
services are likely to provide unreliable results.
FAQ
I have a Lambda function that performs calculations and returns a result without calling any other 
services. Do I really need to test it in the cloud?
Yes. Lambda functions have conﬁguration parameters that could change the outcome of the test. All 
Lambda function code has a dependency on timeout and memory settings, which could cause the 
function to fail if those settings are not set properly. Lambda policies also enable standard output 
logging to Amazon CloudWatch. Even if your code does not call CloudWatch directly, permission is 
needed to enable logging. This required permission cannot be accurately mocked or emulated.
How can testing in the cloud help with unit testing? If it’s in the cloud and connects to other 
resources, isn’t that an integration test?
We deﬁne unit tests  as tests that operate on architectural components in isolation, but this does 
not prevent tests from including components that may call other services or use some network 
communication.
Many serverless applications have architectural components that can be tested in isolation, even in the 
cloud. One example is a Lambda function that takes input, processes the data, and sends a message to 
an Amazon SQS queue. A unit test of this function would likely test whether input values result in certain 
values being present in the queued message.
Consider a test that is written by using the Arrange, Act, Assert pattern:
•Arrange : Allocate resources (a queue to receive messages, and the function under test).
•Act: Call the function under test.
•Assert: Retrieve the message sent by the function, and validate the output.
A mock testing approach would involve mocking the queue with an in-process mock object, and creating 
an in-process instance of the class or module that contains the Lambda function code. During the Assert 
phase, the queued message would be retrieved from the mocked object.
In a cloud-based approach, the test would create an Amazon SQS queue for the purposes of the test, and 
would deploy the Lambda function with environment variables that are conﬁgured to use the isolated 
Amazon SQS queue as the output destination. After running the Lambda function, the test would 
retrieve the message from the Amazon SQS queue.
The cloud-based test would run the same code, assert the same behavior, and validate the application’s 
functional correctness. However, it would have the added advantage of being able to validate the 
settings of the Lambda function: the IAM role, IAM policies, and the function’s timeout and memory 
settings.
270AWS Lambda Developer Guide
Next steps and resources
Next steps and resources
Use the following resources to learn more and explore practical examples of testing.
Sample implementations
The Serverless Test Samples repository on GitHub contains concrete examples of tests that follow the 
patterns and best practices described in this guide. The repository contains sample code and guided 
walkthroughs of the mock, emulation, and cloud testing processes described in previous sections. Use 
this repository to get up to speed on the latest serverless testing guidance from AWS.
Further reading
Visit Serverless Land to access the latest blogs, videos, and training for AWS serverless technologies.
The following AWS blog posts are also recommended reading:
•Accelerating serverless development with AWS SAM Accelerate (AWS blog post)
•Increasing development speed with CDK Watch (AWS blog post)
•Mocking service integrations with AWS Step Functions Local (AWS blog post)
•Getting started with testing serverless applications (AWS blog post)
Tools
•AWS SAM – Testing and debugging serverless applications
•AWS SAM – Integrating with automated tests
•Lambda – Testing Lambda functions in the Lambda console (p. 137)
271AWS Lambda Developer Guide
Building Lambda functions with 
Node.js
You can run JavaScript code with Node.js in AWS Lambda. Lambda provides runtimes  (p. 41) for Node.js 
that run your code to process events. Your code runs in an environment that includes the AWS SDK for 
JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage.
Lambda supports the following Node.js runtimes.
Node.js
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Node.js 18 nodejs18.x 3.188.0 Amazon Linux 
2x86_64, arm64
Node.js 16 nodejs16.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Mar 11, 2024
Node.js 14 nodejs14.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Nov 27, 2023
Note
The Node 18 runtime uses AWS SDK for JavaScript v3. To migrate a function to Node 18 from 
an earlier runtime, follow the migration workshop on GitHub. For more information about AWS 
SDK for JavaScript version 3, see the Modular AWS SDK for JavaScript is now generally available
blog post.
To create a Node.js function
1. Open the Lambda console.
2. Choose Create function.
3. Conﬁgure the following settings:
•Function name: Enter a name for the function.
•Runtime : Choose Node.js 18.x .
4. Choose Create function.
5. To conﬁgure a test event, choose Test.
6. For Event name, enter test .
7. Choose Save changes.
8. To invoke the function, choose Test.
The console creates a Lambda function with a single source ﬁle named index.js  or index.mjs . You 
can edit this ﬁle and add more ﬁles in the built-in code editor (p. 25). To save your changes, choose Save. 
Then, to run your code, choose Test.
272AWS Lambda Developer Guide
Node.js initialization
Note
The Lambda console uses AWS Cloud9 to provide an integrated development environment 
in the browser. You can also use AWS Cloud9 to develop Lambda functions in your own 
environment. For more information, see Working with AWS Lambda functions using the AWS 
Toolkit in the AWS Cloud9 user guide.
The index.js  or index.mjs  ﬁle exports a function named handler that takes an event object and a 
context object. This is the handler function (p. 276) that Lambda calls when the function is invoked. 
The Node.js function runtime gets invocation events from Lambda and passes them to the handler. In 
the function conﬁguration, the handler value is index.handler .
When you save your function code, the Lambda console creates a .zip ﬁle archive deployment package. 
When you develop your function code outside of the console (using an IDE) you need to create a 
deployment package (p. 281) to upload your code to the Lambda function.
Note
To get started with application development in your local environment, deploy one of the 
sample applications available in this guide's GitHub repository.
Sample Lambda applications in Node.js
•blank-nodejs – A Node.js function that shows the use of logging, environment variables, AWS 
X-Ray tracing, layers, unit tests and the AWS SDK.
•nodejs-apig  – A function with a public API endpoint that processes an event from API Gateway 
and returns an HTTP response.
•rds-mysql – A function that relays queries to a MySQL for RDS Database. This sample includes 
a private VPC and database instance conﬁgured with a password in AWS Secrets Manager.
•efs-nodejs  – A function that uses an Amazon EFS ﬁle system in a Amazon VPC. This sample 
includes a VPC, ﬁle system, mount targets, and access point conﬁgured for use with Lambda.
•list-manager – A function processes events from an Amazon Kinesis data stream and update 
aggregate lists in Amazon DynamoDB. The function stores a record of each event in a MySQL 
for RDS Database in a private VPC. This sample includes a private VPC with a VPC endpoint for 
DynamoDB and a database instance.
•error-processor – A Node.js function generates errors for a speciﬁed percentage of requests. 
A CloudWatch Logs subscription invokes a second function when an error is recorded. The 
processor function uses the AWS SDK to gather details about the request and stores them in 
an Amazon S3 bucket.
The function runtime passes a context object to the handler, in addition to the invocation event. The
context object (p. 297) contains additional information about the invocation, the function, and the 
execution environment. More information is available from environment variables.
Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details 
about each invocation to CloudWatch Logs. It relays any logs that your function outputs (p. 299) during 
invocation. If your function returns an error (p. 304), Lambda formats the error and returns it to the 
invoker.
Node.js initialization
Node.js has a unique event loop model that causes its initialization behavior to be diﬀerent from other 
runtimes. Speciﬁcally, Node.js uses a non-blocking I/O model that supports asynchronous operations. 
This model allows Node.js to perform eﬃciently for most workloads. For example, if a Node.js function 
makes a network call, that request may be designated as an asynchronous operation and placed into 
a callback queue. The function may continue to process other operations within the main call stack 
273AWS Lambda Developer Guide
Designating a function handler as an ES module
without getting blocked by waiting for the network call to return. Once the network call is completed, its 
callback is executed and then removed from the callback queue.
Some initialization tasks may run asynchronously. These asynchronous tasks are not guaranteed to 
complete execution prior to an invocation. For example, code that makes a network call to fetch a 
parameter from AWS Parameter Store may not be complete by the time Lambda executes the handler 
function. As a result, the variable may be null during an invocation. To avoid this, ensure that variables 
and other asynchronous code are fully initialized before continuing with the rest of the function's core 
business logic.
Alternatively, you can designate your function code as an ES module, allowing you to use await  at the 
top level of the ﬁle, outside the scope of your function handler. When you await every Promise , the 
asynchronous initialization code completes before handler invocations, maximizing the eﬀectiveness of
provisioned concurrency (p. 237) in reducing cold start latency. For more information and an example, 
see Using Node.js ES modules and top-level await in AWS Lambda.
Designating a function handler as an ES module
By default, Lambda treats ﬁles with the .js suﬃx as CommonJS modules. Optionally, you can designate 
your code as an ES module. You can do this in two ways: specifying the type  as module in the function's
package.json  ﬁle, or by using the .mjs ﬁle name extension. In the ﬁrst approach, your function code 
treats all .js ﬁles as ES modules, while in the second scenario, only the ﬁle you specify with .mjs
is an ES module. You can mix ES modules and CommonJS modules by naming them .mjs  and .cjs
respectively, as .mjs ﬁles are always ES modules and .cjs ﬁles are always CommonJS modules.
In Node.js 14 and Node.js 16, the Lambda runtime loads ES modules from the same folder as your 
function handler, or a subfolder. Starting with Node.js 18, Lambda searches folders in the NODE_PATH
environment variable when loading ES modules. With Node.js 18, you can load the AWS SDK that's 
included in the runtime using ES module import statements. You can also load ES modules from
layers (p. 11).
Using keep-alive for TCP connections
The default Node.js HTTP/HTTPS agent creates a new TCP connection for every new request. To avoid 
the cost of establishing new connections, you can use keepAlive: true  to reuse connections that 
your function makes using the AWS SDK for JavaScript. Keep-alive can reduce request times for Lambda 
functions that make multiple API calls using the SDK. Keep-alive behavior diﬀers depending on which 
version of the SDK you're using:
•In the AWS SDK for JavaScript 3.x, which is included in the Lambda runtime for nodejs18.x , keep-
alive is enabled by default. To disable keep-alive, see Reusing connections with keep-alive in Node.js in 
the AWS SDK for JavaScript 3.x Developer Guide.
•In the AWS SDK for JavaScript 2.x, which is included in the Lambda runtimes for nodejs14.x  and
nodejs16.x , keep-alive is disabled by default. To enable keep-alive, see Reusing Connections with 
Keep-Alive in Node.js in the AWS SDK for JavaScript 2.x Developer Guide.
For more information about using keep-alive, see HTTP keep-alive is on by default in modular AWS SDK 
for JavaScript on the AWS Developer Tools Blog.
Topics
•AWS Lambda function handler in Node.js (p. 276)
•Deploy Node.js Lambda functions with .zip ﬁle archives (p. 281)
•Deploy Node.js Lambda functions with container images (p. 288)
274AWS Lambda Developer Guide
Using keep-alive
•AWS Lambda context object in Node.js (p. 297)
•AWS Lambda function logging in Node.js (p. 299)
•AWS Lambda function errors in Node.js (p. 304)
•Instrumenting Node.js code in AWS Lambda (p. 308)
275AWS Lambda Developer Guide
Handler
AWS Lambda function handler in Node.js
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
The following example function logs the contents of the event object and returns the location of the 
logs.
Note
This page shows examples of both CommonJS and ES module handlers. To learn about the 
diﬀerence between these two handler types, see Designating a function handler as an ES 
module  (p. 274).
CommonJS module handler
Example
exports.handler = async function (event, context) { 
  console.log("EVENT: \n" + JSON.stringify(event, null, 2)); 
  return context.logStreamName;
};
ES module handler
Example
export const handler = async (event, context) => { 
  console.log("EVENT: \n" + JSON.stringify(event, null, 2)); 
  return context.logStreamName;
};
When you conﬁgure a function, the value of the handler setting is the ﬁle name and the name of the 
exported handler method, separated by a dot. The default in the console and for examples in this guide 
is index.handler . This indicates the handler method that's exported from the index.js  ﬁle.
The runtime passes arguments to the handler method. The ﬁrst argument is the event object, which 
contains information from the invoker. The invoker passes this information as a JSON-formatted string 
when it calls Invoke (p. 1399 ), and the runtime converts it to an object. When an AWS service invokes 
your function, the event structure varies by service (p. 628).
The second argument is the context object (p. 297), which contains information about the invocation, 
function, and execution environment. In the preceding example, the function gets the name of the log 
stream (p. 299) from the context object and returns it to the invoker.
You can also use a callback argument, which is a function that you can call in non-async handlers to 
send a response. We recommend that you use async/await instead of callbacks. Async/await provides 
improved readability, error handling, and eﬃciency. For more information about the diﬀerences between 
async/await and callbacks, see Using callbacks  (p. 278).
Using async/await
If your code performs an asynchronous task, use the async/await pattern to make sure that the handler 
ﬁnishes running. Async/await is a concise and readable way to write asynchronous code in Node.js, 
276AWS Lambda Developer Guide
Using async/await
without the need for nested callbacks or chaining promises. With async/await, you can write code that 
reads like synchronous code, while still being asynchronous and non-blocking.
The async keyword marks a function as asynchronous, and the await keyword pauses the execution of 
the function until a Promise is resolved.
Note
Make sure to wait for asynchronous events to complete. If the function returns before 
async events are complete, the function might fail or cause unexpected behavior in your 
application. This can happen when a forEach loop contains an async event. forEach  loops 
expect a synchronous call. For more information, see Array.prototype.forEach() in the Mozilla 
documentation.
CommonJS module handler
Example – HTTP request with async/await
const https = require("https");
let url = "https://aws.amazon.com/";
exports.handler = async function (event) { 
  let statusCode; 
  await new Promise(function (resolve, reject) { 
    https.get(url, (res) => { 
        statusCode = res.statusCode; 
        resolve(statusCode); 
      }).on("error", (e) => { 
        reject(Error(e)); 
      }); 
  }); 
  console.log(statusCode); 
  return statusCode;
};
ES module handler
Example – HTTP request with async/await
This example uses fetch, which is available in the nodejs18.x  runtime.
const url = "https://aws.amazon.com/";
export const handler = async(event) => { 
    try { 
        // fetch is available with Node.js 18 
        const res = await fetch(url); 
        console.info("status", res.status); 
        return res.status; 
    } 
    catch (e) { 
        console.error(e); 
        return 500; 
    }
};
The next example uses async/await to list your Amazon Simple Storage Service buckets.
Note
Before using this example, make sure that your function's execution role has Amazon S3 read 
permissions.
277AWS Lambda Developer Guide
Using callbacks
CommonJS module handler
Example – AWS SDK v2 with async/await
This example uses the AWS SDK for JavaScript v2, which is available in the Node.js 14 and 16 
runtimes.
const AWS = require('aws-sdk')
const s3 = new AWS.S3() 
    
exports.handler = async function(event) { 
  const buckets = await s3.listBuckets().promise() 
  return buckets
}
ES module handler
Example – AWS SDK v3 with async/await
This example uses the AWS SDK for JavaScript v3, which is available in the nodejs18.x  runtime.
import {S3Client, ListBucketsCommand} from '@aws-sdk/client-s3';
const s3 = new S3Client({region: 'us-east-1'}); 
    
export const handler = async(event) => { 
  const data = await s3.send(new ListBucketsCommand({})); 
  return data.Buckets; 
         
};
Using callbacks
We recommend that you use async/await (p. 276) to declare the function handler instead of using 
callbacks. Async/await is a better choice for several reasons:
•Readability: Async/await code is easier to read and understand than callback code, which can quickly 
become diﬃcult to follow and result in callback hell.
•Debugging and error handling:  Debugging callback-based code can be diﬃcult. The call stack can 
become hard to follow and errors can easily be swallowed. With async/await, you can use try/catch 
blocks to handle errors.
•Eﬃciency: Callbacks often require switching between diﬀerent parts of the code. Async/await can 
reduce the number of context switches, resulting in more eﬃcient code.
When you use callbacks in your handler, the function continues to execute until the event loop is empty 
or the function times out. The response isn't sent to the invoker until all event loop tasks are ﬁnished. If 
the function times out, an error is returned instead. You can conﬁgure the runtime to send the response 
immediately by setting context.callbackWaitsForEmptyEventLoop (p. 297) to false.
The callback function takes two arguments: an Error and a response. The response object must be 
compatible with JSON.stringify .
The following example function checks a URL and returns the status code to the invoker.
CommonJS module handler
Example – HTTP request with callback
const https = require("https");
278AWS Lambda Developer Guide
Using callbacks
let url = "https://aws.amazon.com/";
exports.handler = function (event, context, callback) { 
  https.get(url, (res) => { 
       callback(null, res.statusCode) ; 
    }).on("error", (e) => { 
       callback(Error(e)) ; 
    });
};
ES module handler
Example – HTTP request with callback
import https from "https";
let url = "https://aws.amazon.com/";
export function handler(event, context, callback) { 
  https.get(url, (res) => { 
       callback(null, res.statusCode) ; 
    }).on("error", (e) => { 
       callback(Error(e)) ; 
    });
}
In the next example, the response from Amazon S3 is returned to the invoker as soon as it's available. 
The timeout running on the event loop is frozen, and it continues running the next time the function is 
invoked.
Note
Before using this example, make sure that your function's execution role has Amazon S3 read 
permissions.
CommonJS module handler
Example – AWS SDK v2 with callbackWaitsForEmptyEventLoop
This example uses the AWS SDK for JavaScript v2, which is available in the Node.js 14 and 16 
runtimes.
const AWS = require("aws-sdk");
const s3 = new AWS.S3();
exports.handler = function (event, context, callback) { 
  context. callbackWaitsForEmptyEventLoop  = false; 
  s3.listBuckets(null, callback); 
  setTimeout(function () { 
    console.log("Timeout complete."); 
  }, 5000);
};
ES module handler
Example – AWS SDK v3 with callbackWaitsForEmptyEventLoop
This example uses the AWS SDK for JavaScript v3, which is available in the nodejs18.x  runtime.
import AWS from "@aws-sdk/client-s3";
const s3 = new AWS.S3({});
279AWS Lambda Developer Guide
Using callbacks
export const handler = function (event, context, callback) { 
  context. callbackWaitsForEmptyEventLoop  = false; 
  s3.listBuckets({}, callback); 
  setTimeout(function () { 
    console.log("Timeout complete."); 
  }, 5000);
};
280AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Deploy Node.js Lambda functions with .zip ﬁle 
archives
Your AWS Lambda function’s code comprises a .js or .mjs ﬁle containing your function’s handler code, 
together with any additional packages and modules your code depends on. To deploy this function code 
to Lambda, you use a deployment package . This package may either be a .zip ﬁle archive or a container 
image. For more information about using container images with Node.js, see Deploy Node.js Lambda 
functions with container images.
To create your deployment package as .zip ﬁle archive, you can use your command-line tool’s built-
in .zip ﬁle archive utility, or any other .zip ﬁle utility such as 7zip. The examples shown in the following 
sections assume you’re using a command-line zip tool in a Linux or MacOS environment. To use the 
same commands in Windows, you can install the Windows Subsystem for Linux to get a Windows-
integrated version of Ubuntu and Bash.
Note that Lambda uses POSIX ﬁle permissions, so you may need to set permissions for the deployment 
package folder  before you create the .zip ﬁle archive.
Topics
•Runtime dependencies in Node.js  (p. 281)
•Creating a .zip deployment package with no dependencies (p. 281)
•Creating a .zip deployment package with dependencies (p. 282)
•Dependency search path and runtime-included libraries (p. 283)
•Creating and updating Node.js Lambda functions using .zip ﬁles (p. 283)
Runtime dependencies in Node.js
For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The 
Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for 
JavaScript. Runtime versions up to nodejs16.x include version 2.x of the SDK. Runtime versions starting 
from nodejs18.x include version 3 of the SDK. If your chosen runtime includes the version of the SDK you 
are using, you don't need to include the SDK library in your .zip ﬁle.
Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and 
security upgrades. Lambda also applies security patches and updates to the other libraries included 
in the runtime. To have full control of the dependencies in your package, you can add your preferred 
version of any runtime-included dependency to your deployment package. For example, if you want to 
use a particular version of the SDK for JavaScript, you can include it in your .zip ﬁle as a dependency. For 
more information on adding runtime-included dependencies to your .zip ﬁle, see Dependency search 
path and runtime-included libraries  (p. 283).
Under the AWS shared responsibility model, you are responsible for the management of any 
dependencies in your functions' deployment packages. This includes applying updates and security 
patches. To update dependencies in your function's deployment package, ﬁrst create a new .zip ﬁle and 
then upload it to Lambda. See Creating a .zip deployment package with dependencies (p. 282) and
Creating and updating Node.js Lambda functions using .zip ﬁles (p. 283) for more information.
Creating a .zip deployment package with no 
dependencies
If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip 
ﬁle contains only the index.js  or index.mjs  ﬁle with your function’s handler code. Use your preferred 
281AWS Lambda Developer Guide
Creating a .zip deployment package with dependencies
zip utility to create a .zip ﬁle with your index.js  or index.mjs  ﬁle at the root. If the ﬁle containing 
your handler code isn't at the root of your .zip ﬁle, Lambda won’t be able to run your code.
To learn how to deploy your .zip ﬁle to create a new Lambda function or update an existing one, see
Creating and updating Python Lambda functions using .zip ﬁles (p. 283).
Creating a .zip deployment package with 
dependencies
If your function code depends on packages or modules that are not included in the Lambda Node.js 
runtime, you can either add these dependencies to your .zip ﬁle with your function code or use a Lambda 
layer. A layer is a separate .zip ﬁle that can contain additional code and other content. To learn more 
about using Lambda layers, see Lambda layers  (p. 988). The instructions in this section show you how 
to include your dependencies in your .zip deployment package.
The following example CLI commands create a .zip ﬁle named my_deployment_package.zip
containing the index.js  or index.mjs  ﬁle with your function's handler code and its dependencies. In 
the example, you install dependencies using the npm package manager.
To create the deployment package
1. Navigate to the project directory containing your index.js  or index.mjs  source code ﬁle. In this 
example, the directory is named my_function .
cd my_function
2. Install your function's required libraries in the node_modules  directory using the npm install
command. In this example you install the AWS X-Ray SDK for Node.js.
npm install aws-xray-sdk
This creates a folder structure similar to the following:
~/my_function
### index.mjs
### node_modules 
    ### async 
    ### async-listener 
    ### atomic-batcher 
    ### aws-sdk 
    ### aws-xray-sdk 
    ### aws-xray-sdk-core
You can also add custom modules that you create yourself to your deployment package. Create 
a directory under node_modules  with the name of your module and save your custom written 
packages there.
3. Create a .zip ﬁle that contains the contents of your project folder at the root. Use the r (recursive) 
option to ensure that zip compresses the subfolders.
zip -r my_deployment_package.zip .
282AWS Lambda Developer Guide
Dependency search path and runtime-included libraries
Dependency search path and runtime-included 
libraries
The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK 
for JavaScript. If you want to use a diﬀerent version of a runtime-included library, you can do this 
by bundling it with your function or by adding it as a dependency in your deployment package. For 
example, you can use a diﬀerent version of the SDK by adding it to your .zip deployment package. You 
can also include it in a Lambda layer (p. 988) for your function.
When you use an import  or require statement in your code, the Node.js runtime searches the 
directories in the NODE_PATH  path until it ﬁnds the module. By default, the ﬁrst location the runtime 
searches is the directory into which your .zip deployment package is decompressed and mounted (/var/
task). If you include a version of a runtime-included library in your deployment package, this version 
will take precedence over the version included in the runtime. Dependencies in your deployment package 
also have precedence over dependencies in layers.
When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules
where nodexx represents the version of the runtime you are using. In the search path, this directory 
has precedence over the directory containing the runtime-included libraries (/var/lang/lib/
node_modules ). Libraries in function layers therefore have precedence over versions included in the 
runtime.
You can see the full search path for your Lambda function by adding the following line of code.
console.log(process.env.NODE_PATH)
You can also add dependencies in a separate folder inside your .zip package. For example, you might 
add a custom module to a folder in your .zip package called common. When your .zip package is 
decompressed and mounted, this folder is placed inside the /var/task  directory. To use a dependency 
from a folder in your .zip deployment package in your code, use an import { } from  or const { } = 
require()  statement, depending on whether you are using CJS or ESM module resolution. For example:
import { myModule } from './common'
If you bundle your code with esbuild , rollup, or similar, the dependencies used by your function 
are bundled together in one or more ﬁles. We recommend using this method to vend dependencies 
whenever possible. Compared to adding dependencies to your deployment package, bundling your code 
results in improved performance due to the reduction in I/O operations.
Creating and updating Node.js Lambda functions 
using .zip ﬁles
Once you have created your .zip deployment package, you can use it to create a new Lambda function or 
update an existing one. You can deploy your .zip package using the Lambda console, the AWS Command 
Line Interface, and the Lambda API. You can also create and update Lambda functions using AWS 
Serverless Application Model (AWS SAM) and AWS CloudFormation.
The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit 
applies to the combined size of all the ﬁles you upload, including any Lambda layers.
Creating and updating functions with .zip ﬁles using the console
To create a new function, you must ﬁrst create the function in the console, then upload your .zip archive. 
To update an existing function, open the page for your function, then follow the same procedure to add 
your updated .zip ﬁle.
283AWS Lambda Developer Guide
Creating and updating Node.js 
Lambda functions using .zip ﬁles
If your .zip ﬁle is less than 50MB, you can create or update a function by uploading the ﬁle directly 
from your local machine. For .zip ﬁles greater than 50MB, you must upload your package to an Amazon 
S3 bucket ﬁrst. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
Management Console, see Getting started with Amazon S3. To upload ﬁles using the AWS CLI, see Move 
objects in the AWS CLI User Guide.
Note
You cannot convert an existing container image function to use a .zip archive. You must create a 
new function.
To create a new function (console)
1. Open the Functions page of the Lambda console and choose Create Function.
2. Choose Author from scratch .
3. Under Basic information , do the following:
a. For Function name, enter the name for your function.
b. For Runtime , select the runtime you want to use.
c. (Optional) For Architecture, choose the instruction set architecture for your function. The 
default architecture is x86_64. Ensure that the .zip deployment package for your function is 
compatible with the instruction set architecture you select.
4. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing one.
5. Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
To upload a .zip archive from your local machine (console)
1. In the Functions page of the Lambda console, choose the function you want to upload the .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose .zip ﬁle.
5. To upload the .zip ﬁle, do the following:
a. Select Upload, then select your .zip ﬁle in the ﬁle chooser.
b. Choose Open .
c. Choose Save.
To upload a .zip archive from an Amazon S3 bucket (console)
1. In the Functions page of the Lambda console, choose the function you want to upload a new .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose Amazon S3 location.
5. Paste the Amazon S3 link URL of your .zip ﬁle and choose Save.
Updating .zip ﬁle functions using the console code editor
For some functions with .zip deployment packages, you can use the Lambda console’s built-in code 
editor to update your function code directly. To use this feature, your function must meet the following 
criteria:
284AWS Lambda Developer Guide
Creating and updating Node.js 
Lambda functions using .zip ﬁles
•Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
•Your function’s deployment package must be smaller than 3MB.
Function code for functions with container image deployment packages cannot be edited directly in the 
console.
To update function code using the console code editor
1. Open the Functions page of the Lambda console and select your function.
2. Select the Code  tab.
3. In the Code source pane, select your source code ﬁle and edit it in the integrated code editor.
4. When you have ﬁnished editing your code, choose Deploy to save your changes and update your 
function.
Creating and updating functions with .zip ﬁles using the AWS 
CLI
You can can use the AWS CLI to create a new function or to update an existing one using a .zip ﬁle. Use 
the create-function and update-function-code commands to deploy your .zip package. If your .zip ﬁle is 
smaller than 50MB, you can upload the .zip package from a ﬁle location on your local build machine. For 
larger ﬁles, you must upload your .zip package from an Amazon S3 bucket. For instructions on how to 
upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
Note
If you upload your .zip ﬁle from an Amazon S3 bucket using the AWS CLI, the bucket must be 
located in the same AWS Region as your function.
To create a new function using a .zip ﬁle with the AWS CLI, you must specify the following:
•The name of your function (--function-name )
•Your function’s runtime (--runtime )
•The Amazon Resource Name (ARN) of your function’s execution role (--role )
•The name of the handler method in your function code (--handler )
You must also specify the location of your .zip ﬁle. If your .zip ﬁle is located in a folder on your local 
build machine, use the --zip-file  option to specify the ﬁle path, as shown in the following example 
command.
aws lambda create-function --function-name myFunction \
--runtime nodejs18.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --code option as shown in the 
following example command. You only need to use the S3ObjectVersion  parameter for versioned 
objects.
aws lambda create-function --function-name myFunction \
--runtime nodejs18.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=myBucketName,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
To update an existing function using the CLI, you specify the the name of your function using the --
function-name  parameter. You must also specify the location of the .zip ﬁle you want to use to update 
285AWS Lambda Developer Guide
Creating and updating Node.js 
Lambda functions using .zip ﬁles
your function code. If your .zip ﬁle is located in a folder on your local build machine, use the --zip-
file option to specify the ﬁle path, as shown in the following example command.
aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --s3-bucket  and --s3-key  options 
as shown in the following example command. You only need to use the --s3-object-version
parameter for versioned objects.
aws lambda update-function-code --function-name myFunction \
--s3-bucket myBucketName --s3-key myFileName.zip --s3-object-version myObject Version
Creating and updating functions with .zip ﬁles using the 
Lambda API
To create and update functions using a .zip ﬁle archive, use the following API operations:
•CreateFunction
•UpdateFunctionCode
Creating and updating functions with .zip ﬁles using AWS SAM
The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of 
building and running serverless applications on AWS. You deﬁne the resources for your application in a 
YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, 
and deploy your applications. When you build a Lambda function from an AWS SAM template, AWS SAM 
automatically creates a .zip deployment package or container image with your function code and any 
dependencies you specify. To learn more about using AWS SAM to build and deploy Lambda functions, 
see Getting started with AWS SAM in the AWS Serverless Application Model Developer Guide.
You can also use AWS SAM to create a Lambda function using an existing .zip ﬁle archive. To create a 
Lambda function using AWS SAM, you can save your .zip ﬁle in an Amazon S3 bucket or in a local folder 
on your build machine. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
CLI, see Move objects in the AWS CLI User Guide.
In your AWS SAM template, the AWS::Serverless::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - set to Zip
•CodeUri - set to the function code's Amazon S3 URI, path to local folder, or FunctionCode object
•Runtime - Set to your chosen runtime
With AWS SAM, if your .zip ﬁle is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket 
ﬁrst. AWS SAM can upload .zip packages up to the maximum allowed size of 250MB (unzipped) from a 
location on your local build machine.
To learn more about deploying functions using .zip ﬁle in AWS SAM, see AWS::Serverless::Function in the
AWS SAM Developer Guide.
Creating and updating functions with .zip ﬁles using AWS 
CloudFormation
You can use AWS CloudFormation to create a Lambda function using a .zip ﬁle archive. To create a 
Lambda function from a .zip ﬁle, you must ﬁrst upload your ﬁle to an Amazon S3 bucket. For instructions 
286AWS Lambda Developer Guide
Creating and updating Node.js 
Lambda functions using .zip ﬁles
on how to upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User 
Guide.
In your AWS CloudFormation template, the AWS::Lambda::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - Set to Zip
•Code - Enter the Amazon S3 bucket name and the .zip ﬁle name in the S3Bucket  and S3Key  ﬁelds
•Runtime - Set to your chosen runtime
The .zip ﬁle that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying 
functions using .zip ﬁle in AWS CloudFormation, see AWS::Lambda::Function in the AWS CloudFormation 
User Guide .
287AWS Lambda Developer Guide
Deploy container images
Deploy Node.js Lambda functions with container 
images
There are three ways to build a container image for a Node.js Lambda function:
•Using an AWS base image for Node.js (p. 289)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, 
and code to these images. To make the image compatible with Lambda, you must include the runtime 
interface client for Node.js (p. 292) in the image.
•Using a non-AWS base image (p. 292)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the runtime interface client for Node.js (p. 292) in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
Topics
•AWS base images for Node.js (p. 288)
•Using an AWS base image for Node.js (p. 289)
•Using an alternative base image with the runtime interface client (p. 292)
AWS base images for Node.js
AWS provides the following base images for Node.js:
Tags Runtime Operating 
systemDockerﬁle Deprecation
18 Node.js 18 Amazon 
Linux 2Dockerﬁle for Node.js 18 on 
GitHub
16 Node.js 16 Amazon 
Linux 2Dockerﬁle for Node.js 16 on 
GitHubMar 11, 2024
14 Node.js 14 Amazon 
Linux 2Dockerﬁle for Node.js 14 on 
GitHubNov 27, 2023
Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
288AWS Lambda Developer Guide
Using an AWS base image
Using an AWS base image for Node.js
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Node.js
Creating an image from a base image
To create a container image from an AWS base image for Node.js
1. Create a directory for the project, and then switch to that directory.
mkdir example
cd example
2. Create a new Node.js project with npm. To accept the default options provided in the interactive 
experience, press Enter .
npm init
3. Create a new ﬁle called index.js . You can add the following sample function code to the ﬁle for 
testing, or use your own.
Example CommonJS handler
exports.handler = async (event) => { 
    const response = { 
        statusCode: 200, 
        body: JSON.stringify('Hello from Lambda!'), 
    }; 
    return response;
};
4. If your function depends on libraries other than the AWS SDK for JavaScript, use npm  to add them 
to your package.
5. Create a new Dockerﬁle with the following conﬁguration:
•Set the FROM property to the URI of the base image .
•Use the COPY command to copy the function code and runtime dependencies to
{LAMBDA_TASK_ROOT} .
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM public.ecr.aws/lambda/nodejs:16
# Copy function code
COPY index.js  ${LAMBDA_TASK_ROOT} 
   
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
289AWS Lambda Developer Guide
Using an AWS base image
CMD [ "index.handler " ]
6. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
290AWS Lambda Developer Guide
Using an AWS base image
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
291AWS Lambda Developer Guide
Using a non-AWS base image
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using an alternative base image with the runtime 
interface clientIf you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
the runtime interface client in your image. The runtime interface client extends the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code.
Install the Node.js runtime interface client using the npm package manager:
npm install aws-lambda-ric
You can also download the Node.js runtime interface client from GitHub. The runtime interface client 
supports the following Node.js versions:
•14.x
•16.x
•18.x
The following example demonstrates how to build a container image for Node.js using a non-AWS base 
image. The example Dockerﬁle uses a buster base image. The Dockerﬁle includes the runtime interface 
client.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Node.js
Creating an image from an alternative base image
To create a container image from a non-AWS base image
1. Create a directory for the project, and then switch to that directory.
mkdir example
cd example
2. Create a new Node.js project with npm. To accept the default options provided in the interactive 
experience, press Enter .
npm init
292AWS Lambda Developer Guide
Using a non-AWS base image
3. Create a new ﬁle called index.js . You can add the following sample function code to the ﬁle for 
testing, or use your own.
Example CommonJS handler
exports.handler = async (event) => { 
    const response = { 
        statusCode: 200, 
        body: JSON.stringify('Hello from Lambda!'), 
    }; 
    return response;
};
4. Create a new Dockerﬁle. The following Dockerﬁle uses a buster  base image instead of an AWS 
base image  (p. 123). The Dockerﬁle includes the runtime interface client, which makes the image 
compatible with Lambda. The Dockerﬁle uses a multi-stage build . The ﬁrst stage creates a build 
image, which is a standard Node.js environment where the function's dependencies are installed. The 
second stage creates a slimmer image which includes the function code and its dependencies. This 
reduces the ﬁnal image size.
•Set the FROM property to the base image identiﬁer.
•Use the COPY command to copy the function code and runtime dependencies.
•Set the ENTRYPOINT  to the module that you want the Docker container to run when it starts. In 
this case, the module is the runtime interface client.
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
# Define custom function directory
ARG FUNCTION_DIR="/function"
FROM node:18-buster  as build-image
# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Install build dependencies
RUN apt-get update && \ 
    apt-get install -y \ 
    g++ \ 
    make \ 
    cmake \ 
    unzip \ 
    libcurl4-openssl-dev
# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}
WORKDIR ${FUNCTION_DIR}
# Install Node.js dependencies
RUN npm install
# Install the runtime interface client
RUN npm install aws-lambda-ric
# Grab a fresh slim copy of the image to reduce the final size
FROM node:18-buster-slim
293AWS Lambda Developer Guide
Using a non-AWS base image
# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm
# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}
# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}
# Set runtime interface client as default command for the container runtime
ENTRYPOINT [" /usr/local/bin/npx", "aws-lambda-ric" ]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler "]
5. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test the image. You can build the emulator into 
your image (p. 130) or install it on your local machine.
To install and run the runtime interface emulator on your local machine
1. From your project directory, run the following command to download the runtime interface 
emulator (x86-64 architecture) from GitHub and install it on your local machine.
mkdir -p ~/.aws-lambda-rie && \ 
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-
runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \ 
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
2. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•/usr/local/bin/npx aws-lambda-ric index.handler  is the ENTRYPOINT  followed by the
CMD from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/local/bin/npx aws-lambda-ric index.handler
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
294AWS Lambda Developer Guide
Using a non-AWS base image
3. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
4. Get the container ID.
docker ps
5. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
295AWS Lambda Developer Guide
Using a non-AWS base image
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
296AWS Lambda Developer Guide
Context
AWS Lambda context object in Node.js
When Lambda runs your function, it passes a context object to the handler  (p. 276). This object provides 
methods and properties that provide information about the invocation, function, and execution 
environment.
Context methods
•getRemainingTimeInMillis()  – Returns the number of milliseconds left before the execution 
times out.
Context properties
•functionName  – The name of the Lambda function.
•functionVersion  – The version (p. 108) of the function.
•invokedFunctionArn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•memoryLimitInMB  – The amount of memory that's allocated for the function.
•awsRequestId  – The identiﬁer of the invocation request.
•logGroupName  – The log group for the function.
•logStreamName  – The log stream for the function instance.
•identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•cognitoIdentityId  – The authenticated Amazon Cognito identity.
•cognitoIdentityPoolId  – The Amazon Cognito identity pool that authorized the invocation.
•clientContext  – (mobile apps) Client context that's provided to Lambda by the client application.
•client.installation_id
•client.app_title
•client.app_version_name
•client.app_version_code
•client.app_package_name
•env.platform_version
•env.platform
•env.make
•env.model
•env.locale
•Custom – Custom values that are set by the client application.
•callbackWaitsForEmptyEventLoop  – Set to false to send the response right away when the
callback  (p. 278) runs, instead of waiting for the Node.js event loop to be empty. If this is false, any 
outstanding events continue to run during the next invocation.
The following example function logs context information and returns the location of the logs.
Example index.js ﬁle
exports.handler = async function(event, context) { 
  console.log('Remaining time: ', context.getRemainingTimeInMillis()) 
  console.log('Function name: ', context.functionName) 
  return context.logStreamName
297AWS Lambda Developer Guide
Context
}
298AWS Lambda Developer Guide
Logging
AWS Lambda function logging in Node.js
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, or the CloudWatch console.
Sections
•Creating a function that returns logs (p. 299)
•Using the Lambda console (p. 300)
•Using the CloudWatch console (p. 300)
•Using the AWS Command Line Interface (AWS CLI) (p. 300)
•Deleting logs  (p. 303)
Creating a function that returns logs
To output logs from your function code, you can use methods on the console object, or any logging 
library that writes to stdout  or stderr. The following example logs the values of environment 
variables and the event object.
Example index.js ﬁle – Logging
exports.handler = async function(event, context) { 
  console.log("ENVIRONMENT VARIABLES\n" + JSON.stringify(process.env, null, 2)) 
  console.info("EVENT\n" + JSON.stringify(event, null, 2)) 
  console.warn("Event not processed.") 
  return context.logStreamName
}
Example log format
START RequestId: c793869b-ee49-115b-a5b6-4fd21e8dedac Version: $LATEST
2019-06-07T19:11:20.562Z c793869b-ee49-115b-a5b6-4fd21e8dedac INFO ENVIRONMENT VARIABLES
{ 
  "AWS_LAMBDA_FUNCTION_VERSION": "$LATEST", 
  "AWS_LAMBDA_LOG_GROUP_NAME": "/aws/lambda/my-function", 
  "AWS_LAMBDA_LOG_STREAM_NAME": "2019/06/07/[$LATEST]e6f4a0c4241adcd70c262d34c0bbc85c", 
  "AWS_EXECUTION_ENV": "AWS_Lambda_nodejs12.x", 
  "AWS_LAMBDA_FUNCTION_NAME": "my-function", 
  "PATH": "/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin", 
  "NODE_PATH": "/opt/nodejs/node10/node_modules:/opt/nodejs/node_modules:/var/runtime/
node_modules", 
  ...
}
2019-06-07T19:11:20.563Z c793869b-ee49-115b-a5b6-4fd21e8dedac INFO EVENT
{ 
  "key": "value"
}
2019-06-07T19:11:20.564Z c793869b-ee49-115b-a5b6-4fd21e8dedac WARN Event not processed.
END RequestId: c793869b-ee49-115b-a5b6-4fd21e8dedac
299AWS Lambda Developer Guide
Using the Lambda console
REPORT RequestId: c793869b-ee49-115b-a5b6-4fd21e8dedac Duration: 128.83 ms Billed Duration: 
 200 ms Memory Size: 128 MB Max Memory Used: 74 MB Init Duration: 166.62 ms XRAY TraceId: 
 1-5d9d007f-0a8c7fd02xmpl480aed55ef0 SegmentId: 3d752xmpl1bbe37e Sampled: true
The Node.js runtime logs the START , END, and REPORT lines for each invocation. It adds a timestamp, 
request ID, and log level to each entry logged by the function. The report line provides the following 
details.
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
You can view logs in the Lambda console, in the CloudWatch Logs console, or from the command line.
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
300AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
301AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
302AWS Lambda Developer Guide
Deleting logs
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
303AWS Lambda Developer Guide
Errors
AWS Lambda function errors in Node.js
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the Node.js runtime using the 
Lambda console and the AWS CLI.
Sections
•Syntax (p. 304)
•How it works (p. 304)
•Using the Lambda console (p. 305)
•Using the AWS Command Line Interface (AWS CLI) (p. 305)
•Error handling in other AWS services (p. 306)
•What's next? (p. 307)
Syntax
Example index.js ﬁle – Reference error
exports.handler = async function() { 
    return x + 10 
  }
This code results in a reference error. Lambda catches the error and generates a JSON document with 
ﬁelds for the error message, the type, and the stack trace.
{ 
    "errorType": "ReferenceError", 
    "errorMessage": "x is not defined", 
    "trace": [ 
      "ReferenceError: x is not defined", 
      "    at Runtime.exports.handler (/var/task/index.js:2:3)", 
      "    at Runtime.handleOnce (/var/runtime/Runtime.js:63:25)", 
      "    at process._tickCallback (internal/process/next_tick.js:68:7)" 
    ] 
  }
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
304AWS Lambda Developer Guide
Using the Lambda console
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
305AWS Lambda Developer Guide
Error handling in other AWS services
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
{"errorType":"ReferenceError","errorMessage":"x is not defined","trace":["ReferenceError: 
 x is not defined"," at Runtime.exports.handler (/var/task/index.js:2:3)"," at 
 Runtime.handleOnce (/var/runtime/Runtime.js:63:25)"," at process._tickCallback (internal/
process/next_tick.js:68:7)"]}
Lambda also records up to 256 KB of the error object in the function's logs. For more information, see
AWS Lambda function logging in Node.js (p. 299).
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
306AWS Lambda Developer Guide
What's next?
For more information, see Instrumenting Node.js code in AWS Lambda (p. 308).
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 299) page.
307AWS Lambda Developer Guide
Tracing
Instrumenting Node.js code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of two SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for Node.js – An SDK for generating and sending trace data to X-Ray.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using ADOT to instrument your Node.js functions (p. 308)
•Using the X-Ray SDK to instrument your Node.js functions (p. 308)
•Activating tracing with the Lambda console (p. 309)
•Activating tracing with the Lambda API (p. 310)
•Activating tracing with AWS CloudFormation (p. 310)
•Interpreting an X-Ray trace (p. 310)
•Storing runtime dependencies in a layer (X-Ray SDK) (p. 312)
Using ADOT to instrument your Node.js functions
ADOT provides fully managed Lambda layers (p. 11) that package everything you need to collect 
telemetry data using the OTel SDK. By consuming this layer, you can instrument your Lambda functions 
without having to modify any function code. You can also conﬁgure your layer to do custom initialization 
of OTel. For more information, see Custom conﬁguration for the ADOT Collector on Lambda in the ADOT 
documentation.
For Node.js runtimes, you can add the AWS managed Lambda layer for ADOT Javascript to 
automatically instrument your functions. For detailed instructions on how to add this layer, see AWS 
Distro for OpenTelemetry Lambda Support for JavaScript in the ADOT documentation.
Using the X-Ray SDK to instrument your Node.js 
functions
To record details about calls that your Lambda function makes to other resources in your application, you 
can also use the AWS X-Ray SDK for Node.js. To get the SDK, add the aws-xray-sdk-core  package to 
your application's dependencies.
308AWS Lambda Developer Guide
Activating tracing with the Lambda console
Example blank-nodejs/package.json
{ 
  "name": "blank-nodejs", 
  "version": "1.0.0", 
  "private": true, 
  "devDependencies": { 
    "aws-sdk": "2.631.0", 
    "jest": "25.4.0" 
  }, 
  "dependencies": { 
     "aws-xray-sdk-core": "1.1.2"
  }, 
  "scripts": { 
    "test": "jest" 
  }
}
To instrument AWS SDK clients, wrap the aws-sdk library with the captureAWS  method.
Example blank-nodejs/function/index.js – Tracing an AWS SDK client
const AWSXRay = require('aws-xray-sdk-core')
const AWS = AWSXRay.captureAWS(require('aws-sdk'))
// Create client outside of handler to reuse
const lambda = new AWS.Lambda()
// Handler
exports.handler = async function(event, context) { 
  event.Records.forEach(record => { 
  ...
The Lambda runtime sets some environment variables to conﬁgure the X-Ray SDK. For example, Lambda 
sets AWS_XRAY_CONTEXT_MISSING  to LOG_ERROR  to avoid throwing runtime errors from the X-Ray 
SDK. To set a custom context missing strategy, override the environment variable in your function 
conﬁguration to have no value, and then you can set the context missing strategy programmatically.
Example Example initialization code
const AWSXRay = require('aws-xray-sdk-core');
// Configure the context missing strategy to do nothing
AWSXRay.setContextMissingStrategy(() => {});
For more information, see the section called “Environment variables” (p. 77).
After you add the correct dependencies and make the necessary code changes, activate tracing in your 
function's conﬁguration via the Lambda console or the API.
Activating tracing with the Lambda console
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
309AWS Lambda Developer Guide
Activating tracing with the Lambda API
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Activating tracing with the Lambda API
Conﬁgure tracing on your Lambda function with the AWS CLI or AWS SDK, use the following API 
operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Activating tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
Interpreting an X-Ray trace
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
310AWS Lambda Developer Guide
Interpreting an X-Ray trace
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
311AWS Lambda Developer Guide
Storing runtime dependencies in a layer (X-Ray SDK)
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see the AWS X-Ray SDK for Node.js in the AWS X-Ray 
Developer Guide .
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
Storing runtime dependencies in a layer (X-Ray SDK)
If you use the X-Ray SDK to instrument AWS SDK clients your function code, your deployment package 
can become quite large. To avoid uploading runtime dependencies every time you update your function 
code, package the X-Ray SDK in a Lambda layer (p. 988).
The following example shows an AWS::Serverless::LayerVersion  resource that stores the AWS X-
Ray SDK for Node.js.
Example template.yml – Dependencies layer
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: function/. 
      Tracing: Active 
       Layers: 
        - !Ref libs
      ... 
   libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-nodejs-lib 
      Description: Dependencies for the blank sample app. 
      ContentUri: lib/. 
      CompatibleRuntimes: 
        - nodejs16.x
312AWS Lambda Developer Guide
Storing runtime dependencies in a layer (X-Ray SDK)
With this conﬁguration, you update the library layer only if you change your runtime dependencies. Since 
the function deployment package contains only your code, this can help reduce upload times.
Creating a layer for dependencies requires build changes to generate the layer archive prior to 
deployment. For a working example, see the blank-nodejs sample application.
313AWS Lambda Developer Guide
Development environment
Building Lambda functions with 
TypeScript
You can use the Node.js runtime to run TypeScript code in AWS Lambda. Because Node.js doesn't run 
TypeScript code natively, you must ﬁrst transpile your TypeScript code into JavaScript. Then, use the 
JavaScript ﬁles to deploy your function code to Lambda. Your code runs in an environment that includes 
the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role 
that you manage.
Lambda supports the following Node.js runtimes.
Node.js
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Node.js 18 nodejs18.x 3.188.0 Amazon Linux 
2x86_64, arm64
Node.js 16 nodejs16.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Mar 11, 2024
Node.js 14 nodejs14.x 2.1374.0 Amazon Linux 
2x86_64, arm64 Nov 27, 2023
Setting up a TypeScript development environment
Use a local integrated development environment (IDE), text editor, or AWS Cloud9 to write your 
TypeScript function code. You can’t create TypeScript code on the Lambda console.
To transpile your TypeScript code, set up a compiler such as esbuild  or Microsoft's TypeScript compiler 
(tsc) , which is bundled with the TypeScript distribution. You can use the AWS Serverless Application 
Model (AWS SAM) or the AWS Cloud Development Kit (AWS CDK) to simplify building and deploying 
TypeScript code. Both tools use esbuild to transpile TypeScript code into JavaScript.
When using esbuild, consider the following:
•There are several TypeScript caveats.
•You must conﬁgure your TypeScript transpilation settings to match the Node.js runtime that you 
plan to use. For more information, see Target in the esbuild documentation. For an example of a
tsconﬁg.json ﬁle that demonstrates how to target a speciﬁc Node.js version supported by Lambda, 
refer to the TypeScript GitHub repository.
•esbuild doesn’t perform type checks. To check types, use the tsc compiler. Run tsc -noEmit  or add 
a "noEmit"  parameter to your tsconﬁg.json ﬁle, as shown in the following example. This conﬁgures
tsc to not emit JavaScript ﬁles. After checking types, use esbuild to convert the TypeScript ﬁles into 
JavaScript.
Example tsconﬁg.json
 { 
314AWS Lambda Developer Guide
Development environment
  "compilerOptions": { 
    "target": "es2020", 
    "strict": true, 
    "preserveConstEnums": true, 
    "noEmit": true, 
    "sourceMap": false, 
    "module":"commonjs", 
    "moduleResolution":"node", 
    "esModuleInterop": true,  
    "skipLibCheck": true, 
    "forceConsistentCasingInFileNames": true,  
    "isolatedModules": true,  
  }, 
  "exclude": ["node_modules", "**/*.test.ts"]
}
Topics
•AWS Lambda function handler in TypeScript (p. 316)
•Deploy transpiled TypeScript code in Lambda with .zip ﬁle archives (p. 319)
•Deploy transpiled TypeScript code in Lambda with container images (p. 324)
•AWS Lambda context object in TypeScript (p. 328)
•AWS Lambda function logging in TypeScript (p. 330)
•AWS Lambda function testing in TypeScript (p. 336)
•AWS Lambda function errors in TypeScript (p. 338)
•Tracing TypeScript code in AWS Lambda (p. 340)
315AWS Lambda Developer Guide
Handler
AWS Lambda function handler in TypeScript
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
Example TypeScript handler
•The following example function logs the contents of the event object and returns the location of the 
logs.
•The handler in this example is an ES module and must be designated as such in your package.json
ﬁle or by using the .mjs ﬁle extension. For more information, see see Designating a function handler 
as an ES module  (p. 274).
import { Handler } from 'aws-lambda';
export const handler: Handler = async (event, context) => { 
    console.log('EVENT: \n' + JSON.stringify(event, null, 2)); 
    return context.logStreamName;
};
The runtime passes arguments to the handler method. The ﬁrst argument is the event object, which 
contains information from the invoker. The invoker passes this information as a JSON-formatted string 
when it calls Invoke (p. 1399 ), and the runtime converts it to an object. When an AWS service invokes 
your function, the event structure varies by service (p. 628). With TypeScript, we recommend using type 
annotations for the event object. For more information, see Using types for the event object (p. 318).
The second argument is the context object (p. 328), which contains information about the invocation, 
function, and execution environment. In the preceding example, the function gets the name of the log 
stream (p. 330) from the context object and returns it to the invoker.
You can also use a callback argument, which is a function that you can call in non-async handlers to 
send a response. We recommend that you use async/await instead of callbacks. Async/await provides 
improved readability, error handling, and eﬃciency. For more information about the diﬀerences between 
async/await and callbacks, see Using callbacks  (p. 317).
Using async/await
If your code performs an asynchronous task, use the async/await pattern to make sure that the handler 
ﬁnishes running. Async/await is a concise and readable way to write asynchronous code in Node.js, 
without the need for nested callbacks or chaining promises. With async/await, you can write code that 
reads like synchronous code, while still being asynchronous and non-blocking.
The async keyword marks a function as asynchronous, and the await keyword pauses the execution of 
the function until a Promise is resolved.
Example TypeScript function – asynchronous
•This example uses fetch, which is available in the nodejs18.x  runtime.
•The handler in this example is an ES module and must be designated as such in your package.json
ﬁle or by using the .mjs ﬁle extension. For more information, see see Designating a function handler 
as an ES module  (p. 274).
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
316AWS Lambda Developer Guide
Using callbacks
const url = 'https://aws.amazon.com/';
export const lambdaHandler = async (event: APIGatewayProxyEvent): 
 Promise<APIGatewayProxyResult> => { 
    try { 
        // fetch is available with Node.js 18 
        const res = await fetch(url); 
        return { 
            statusCode: res.status, 
            body: JSON.stringify({ 
                message: await res.text(), 
            }), 
        }; 
    } catch (err) { 
        console.log(err); 
        return { 
            statusCode: 500, 
            body: JSON.stringify({ 
                message: 'some error happened', 
            }), 
        }; 
    }
};
Using callbacks
We recommend that you use async/await (p. 316) to declare the function handler instead of using 
callbacks. Async/await is a better choice for several reasons:
•Readability: Async/await code is easier to read and understand than callback code, which can quickly 
become diﬃcult to follow and result in callback hell.
•Debugging and error handling:  Debugging callback-based code can be diﬃcult. The call stack can 
become hard to follow and errors can easily be swallowed. With async/await, you can use try/catch 
blocks to handle errors.
•Eﬃciency: Callbacks often require switching between diﬀerent parts of the code. Async/await can 
reduce the number of context switches, resulting in more eﬃcient code.
When you use callbacks in your handler, the function continues to execute until the event loop is empty 
or the function times out. The response isn't sent to the invoker until all event loop tasks are ﬁnished. If 
the function times out, an error is returned instead. You can conﬁgure the runtime to send the response 
immediately by setting context.callbackWaitsForEmptyEventLoop (p. 328) to false.
The callback function takes two arguments: an Error and a response. The response object must be 
compatible with JSON.stringify .
Example TypeScript function with callback
•This sample function receives an event from Amazon API Gateway, logs the event and context objects, 
and then returns a response to API Gateway.
•The handler in this example is an ES module and must be designated as such in your package.json
ﬁle or by using the .mjs ﬁle extension. For more information, see see Designating a function handler 
as an ES module  (p. 274).
import { Context, APIGatewayProxyCallback, APIGatewayEvent } from 'aws-lambda';
export const lambdaHandler = (event: APIGatewayEvent, context: Context, callback: 
 APIGatewayProxyCallback): void => { 
    console.log(`Event: ${JSON.stringify(event, null, 2)}`); 
317AWS Lambda Developer Guide
Using types for the event object
    console.log(`Context: ${JSON.stringify(context, null, 2)}`); 
    callback(null, { 
        statusCode: 200, 
        body: JSON.stringify({ 
            message: 'hello world', 
        }), 
    });
};
Using types for the event object
We recommend that you don’t use the any type for the handler arguments and return type because 
you lose the ability to check types. Instead, generate an event using the sam local generate-event AWS 
Serverless Application Model CLI command, or use an open-source deﬁnition from the @types/aws-
lambda package .
Generating an event using the sam local generate-event command
1. Generate an Amazon Simple Storage Service (Amazon S3) proxy event.
sam local generate-event s3 put >> S3PutEvent.json
2. Use the quicktype utility to generate type deﬁnitions from the S3PutEvent.json ﬁle.
npm install -g quicktype
quicktype S3PutEvent.json -o S3PutEvent.ts
3. Use the generated types in your code.
import { S3PutEvent } from './S3PutEvent';
export const lambdaHandler = async (event: S3PutEvent): Promise<void> => { 
  event.Records.map((record) => console.log(record.s3.object.key));
};
Generating an event using an open-source deﬁnition from the @types/aws-lambda package
1. Add the @types/aws-lambda package as a development dependency.
npm install -D @types/aws-lambda
2. Use the types in your code.
import { S3Event } from "aws-lambda";
export const lambdaHandler = async (event: S3Event): Promise<void> => { 
  event.Records.map((record) => console.log(record.s3.object.key));
};
318AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Deploy transpiled TypeScript code in Lambda 
with .zip ﬁle archives
Before you can deploy TypeScript code to AWS Lambda, you need to transpile it into JavaScript. This 
page explains three ways to build and deploy TypeScript code to Lambda with .zip ﬁle archives:
•Using AWS Serverless Application Model (AWS SAM) (p. 319)
•Using the AWS Cloud Development Kit (AWS CDK) (p. 320)
•Using the AWS Command Line Interface (AWS CLI) and esbuild (p. 322)
AWS SAM and AWS CDK simplify building and deploying TypeScript functions. The AWS SAM template 
speciﬁcation  provides a simple and clean syntax to describe the Lambda functions, APIs, permissions, 
conﬁgurations, and events that make up your serverless application. The AWS CDK lets you build 
reliable, scalable, cost-eﬀective applications in the cloud with the considerable expressive power of a 
programming language. The AWS CDK is intended for moderately to highly experienced AWS users. Both 
the AWS CDK and the AWS SAM use esbuild to transpile TypeScript code into JavaScript.
Using AWS SAM to deploy TypeScript code to 
Lambda
Follow the steps below to download, build, and deploy a sample Hello World TypeScript application 
using the AWS SAM. This application implements a basic API backend. It consists of an Amazon API 
Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway endpoint, 
the Lambda function is invoked. The function returns a hello world  message.
Note
AWS SAM uses esbuild to create Node.js Lambda functions from TypeScript code. esbuild 
support is currently in public preview. During public preview, esbuild support may be subject to 
backwards incompatible changes.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS CLI version 2
•AWS SAM CLI version 1.39 or later
•Node.js 14.x or later
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World TypeScript template.
sam init --app-template hello-world-typescript --name sam-app --package-type Zip --
runtime nodejs16.x
2. (Optional) The sample application includes conﬁgurations for commonly used tools, such as ESLlint
for code linting and Jest for unit testing. To run lint and test commands:
cd sam-app/hello-world
npm install
npm run lint
319AWS Lambda Developer Guide
Using the AWS CDK
npm run test
3. Build the app.
cd sam-app
sam build
4. Deploy the app.
sam deploy --guided
5. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
respond with Enter .
6. The output shows the endpoint for the REST API. Open the endpoint in a browser to test the 
function. You should see this response:
{"message":"hello world"}
7. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Using the AWS CDK to deploy TypeScript code to 
Lambda
Follow the steps below to build and deploy a sample TypeScript application using the AWS CDK. This 
application implements a basic API backend. It consists of an API Gateway endpoint and a Lambda 
function. When you send a GET request to the API Gateway endpoint, the Lambda function is invoked. 
The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS CLI version 2
•AWS CDK version 2
•Node.js 14.x or later
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language typescript
3. Add the @types/aws-lambda package as a development dependency.
npm install -D @types/aws-lambda
320AWS Lambda Developer Guide
Using the AWS CDK
4. Open the lib directory. You should see a ﬁle called hello-world-stack.ts. Create two new ﬁles in this 
directory: hello-world.function.ts and hello-world.ts.
5. Open hello-world.function.ts and add the following code to the ﬁle. This is the code for the 
Lambda function.
import { Context, APIGatewayProxyResult, APIGatewayEvent } from 'aws-lambda';
export const handler = async (event: APIGatewayEvent, context: Context): 
 Promise<APIGatewayProxyResult> => { 
    console.log(`Event: ${JSON.stringify(event, null, 2)}`); 
    console.log(`Context: ${JSON.stringify(context, null, 2)}`); 
    return { 
        statusCode: 200, 
        body: JSON.stringify({ 
            message: 'hello world', 
        }), 
    };
};
6. Open hello-world.ts and add the following code to the ﬁle. This contains the NodejsFunction 
construct, which creates the Lambda function, and the LambdaRestApi construct, which creates the 
REST API.
import { Construct } from 'constructs';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';
import { LambdaRestApi } from 'aws-cdk-lib/aws-apigateway'; 
   
export class HelloWorld extends Construct { 
  constructor(scope: Construct, id: string) { 
    super(scope, id); 
    const helloFunction = new NodejsFunction(this, 'function'); 
    new LambdaRestApi(this, 'apigw', { 
      handler: helloFunction, 
    }); 
  }
}
The NodejsFunction  construct assumes the following by default:
•Your function handler is called handler .
•The .ts ﬁle that contains the function code (hello-world.function.ts) is in the same directory 
as the .ts ﬁle that contains the construct (hello-world.ts). The construct uses the construct's ID 
("hello-world") and the name of the Lambda handler ﬁle ("function") to ﬁnd the function code. For 
example, if your function code is in a ﬁle called hello-world.my-function.ts, the hello-world.ts
ﬁle must reference the function code like this:
const helloFunction = new NodejsFunction(this, 'my-function' );
You can change this behavior and conﬁgure other esbuild parameters. For more information, see
Conﬁguring esbuild  in the AWS CDK API reference.
7. Open hello-world-stack.ts. This is the code that deﬁnes your AWS CDK stack. Replace the code with 
the following:
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { HelloWorld } from './hello-world'; 
   
export class HelloWorldStack extends Stack { 
321AWS Lambda Developer Guide
Using the AWS CLI and esbuild
  constructor(scope: Construct, id: string, props?: StackProps) { 
    super(scope, id, props); 
    new HelloWorld(this, 'hello-world'); 
  }
}
8. Deploy your application.
cdk deploy
9. The AWS CDK builds and packages the Lambda function using esbuild, and then deploys the 
function to the Lambda runtime. The output shows the endpoint for the REST API. Open the 
endpoint in a browser to test the function. You should see this response:
{"message":"hello world"}
This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
Using the AWS CLI and esbuild to deploy TypeScript 
code to Lambda
The following example demonstrates how to transpile and deploy TypeScript code to Lambda using 
esbuild and the AWS CLI. esbuild produces one JavaScript ﬁle with all dependencies. This is the only ﬁle 
that you need to add to the .zip archive.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS CLI version 2
•Node.js 14.x or later
•An execution role (p. 913) for the Lambda function
Deploy a sample function
1. On your local machine, create a project directory for your new function.
2. Create a new Node.js project with npm or a package manager of your choice.
npm init
3. Add the @types/aws-lambda and esbuild  packages as development dependencies.
npm install -D @types/aws-lambda esbuild
4. Create a new ﬁle called index.ts . Add the following code to the new ﬁle. This is the code for the 
Lambda function. The function returns a hello world  message. The function doesn’t create any 
API Gateway resources.
import { Context, APIGatewayProxyResult, APIGatewayEvent } from 'aws-lambda';
export const handler = async (event: APIGatewayEvent, context: Context): 
 Promise<APIGatewayProxyResult> => { 
  console.log(`Event: ${JSON.stringify(event, null, 2)}`); 
322AWS Lambda Developer Guide
Using the AWS CLI and esbuild
  console.log(`Context: ${JSON.stringify(context, null, 2)}`); 
  return { 
      statusCode: 200, 
      body: JSON.stringify({ 
          message: 'hello world', 
      }), 
   };
};
5. Add a build script to the package.json  ﬁle. This conﬁgures esbuild to automatically create the .zip 
deployment package. For more information, see Build scripts  in the esbuild documentation.
  "scripts": { 
  "prebuild": "rm -rf dist", 
  "build": "esbuild index.ts --bundle --minify --sourcemap --platform=node --
target=es2020 --outfile=dist/index.js", 
  "postbuild": "cd dist && zip -r index.zip index.js*"
},
6. Build the package.
npm run build
7. Create a Lambda function using the .zip deployment package. Replace the highlighted text with the 
Amazon Resource Name (ARN) of your execution role (p. 913).
aws lambda create-function --function-name hello-world --runtime "nodejs16.x" --
role arn:aws:iam::123456789012:role/lambda-ex  --zip-file "fileb://dist/index.zip" --
handler index.handler
8. Run a test event (p. 137) to conﬁrm that the function returns the following response. If you want to 
invoke this function using API Gateway, create and conﬁgure a REST API.
{ 
  "statusCode": 200, 
  "body": "{\"message\":\"hello world\"}"
}
323AWS Lambda Developer Guide
Deploy container images
Deploy transpiled TypeScript code in Lambda with 
container images
You can deploy your TypeScript code to an AWS Lambda function as a Node.js container image (p. 122). 
AWS provides base images  (p. 288) for Node.js to help you build the container image. These base images 
are preloaded with a language runtime and other components that are required to run the image on 
Lambda. AWS provides a Dockerﬁle for each of the base images to help with building your container 
image.
If you use a community or private enterprise base image, you must add the Node.js runtime interface 
client (RIC) (p. 292) to the base image to make it compatible with Lambda.
Lambda provides a runtime interface emulator for local testing. The AWS base images for Node.js 
include the runtime interface emulator. If you use an alternative base image, such as an Alpine 
Linux or Debian image, you can build the emulator into your image (p. 130) or install it on your local 
machine  (p. 133).
Using a Node.js base image to build and package 
TypeScript function code
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Node.js 14.x or later
Creating an image from a base image
To create an image from an AWS base image for Lambda
1. On your local machine, create a project directory for your new function.
2. Create a new Node.js project with npm or a package manager of your choice.
npm init
3. Add the @types/aws-lambda and esbuild  packages as development dependencies.
npm install -D @types/aws-lambda esbuild
4. Add a build script  to the package.json  ﬁle.
  "scripts": { 
  "build": "esbuild index.ts --bundle --minify --sourcemap --platform=node --
target=es2020 --outfile=dist/index.js"
}
5. Create a new ﬁle called index.ts . Add the following sample code to the new ﬁle. This is the code 
for the Lambda function. The function returns a hello world  message.
import { Context, APIGatewayProxyResult, APIGatewayEvent } from 'aws-lambda';
324AWS Lambda Developer Guide
Using a Node.js base image to build 
and package TypeScript function code
export const handler = async (event: APIGatewayEvent, context: Context): 
 Promise<APIGatewayProxyResult> => { 
    console.log(`Event: ${JSON.stringify(event, null, 2)}`); 
    console.log(`Context: ${JSON.stringify(context, null, 2)}`); 
    return { 
        statusCode: 200, 
        body: JSON.stringify({ 
            message: 'hello world', 
        }), 
    };
};
6. Create a new Dockerﬁle with the following conﬁguration:
•Set the FROM property to the URI of the base image.
•Set the CMD argument to specify the Lambda function handler.
Example Dockerﬁle
The following Dockerﬁle uses a multi-stage build. The ﬁrst step transpiles the TypeScript code into 
JavaScript. The second step produces a container image that contains only JavaScript ﬁles and 
production dependencies.
FROM public.ecr.aws/lambda/nodejs:16 as builder
WORKDIR /usr/app
COPY package.json index.ts  ./
RUN npm install
RUN npm run build 
     
FROM public.ecr.aws/lambda/nodejs:16
WORKDIR ${LAMBDA_TASK_ROOT}
COPY --from=builder /usr/app/dist/* ./
CMD ["index.handler"]
7. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
325AWS Lambda Developer Guide
Using a Node.js base image to build 
and package TypeScript function code
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
326AWS Lambda Developer Guide
Using a Node.js base image to build 
and package TypeScript function code
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
327AWS Lambda Developer Guide
Context
AWS Lambda context object in TypeScript
When Lambda runs your function, it passes a context object to the handler  (p. 316). This object provides 
methods and properties that provide information about the invocation, function, and execution 
environment.
Context methods
•getRemainingTimeInMillis()  – Returns the number of milliseconds left before the execution 
times out.
Context properties
•functionName  – The name of the Lambda function.
•functionVersion  – The version (p. 108) of the function.
•invokedFunctionArn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•memoryLimitInMB  – The amount of memory that's allocated for the function.
•awsRequestId  – The identiﬁer of the invocation request.
•logGroupName  – The log group for the function.
•logStreamName  – The log stream for the function instance.
•identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•cognitoIdentityId  – The authenticated Amazon Cognito identity.
•cognitoIdentityPoolId  – The Amazon Cognito identity pool that authorized the invocation.
•clientContext  – (mobile apps) Client context that's provided to Lambda by the client application.
•client.installation_id
•client.app_title
•client.app_version_name
•client.app_version_code
•client.app_package_name
•env.platform_version
•env.platform
•env.make
•env.model
•env.locale
•Custom – Custom values that are set by the client application.
•callbackWaitsForEmptyEventLoop  – Set to false to send the response right away when the
callback  (p. 317) runs, instead of waiting for the Node.js event loop to be empty. If this is false, any 
outstanding events continue to run during the next invocation.
You can use the @types/aws-lambda npm package to work with the context object.
Example index.ts ﬁle
The following example function logs context information and returns the location of the logs.
import { Context } from 'aws-lambda';
export const lambdaHandler = async (event: string, context: Context): Promise<string> => { 
328AWS Lambda Developer Guide
Context
  console.log('Remaining time: ', context.getRemainingTimeInMillis()); 
  console.log('Function name: ', context.functionName); 
  return context.logStreamName;
};
329AWS Lambda Developer Guide
Logging
AWS Lambda function logging in TypeScript
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
To output logs from your function code, you can use methods on the console object, or any logging 
library that writes to stdout  or stderr. For simple use cases, this approach might be suﬃcient.
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, the CloudWatch console, or Infrastructure as 
code tools such as the AWS Serverless Application Model(AWS SAM).
Sections
•Tools and libraries (p. 330)
•Using Powertools for AWS Lambda (TypeScript) and AWS SAM for structured logging (p. 330)
•Using Powertools for AWS Lambda (TypeScript) and the AWS CDK for structured logging (p. 332)
•Using the Lambda console (p. 335)
•Using the CloudWatch console (p. 335)
Tools and libraries
Powertools for AWS Lambda (TypeScript) is a developer toolkit to implement Serverless best practices 
and increase developer velocity. The Logger utility provides a Lambda optimized logger which includes 
additional information about function context across all your functions with output structured as JSON. 
Use this utility to do the following:
•Capture key ﬁelds from the Lambda context, cold start and structures logging output as JSON
•Log Lambda invocation events when instructed (disabled by default)
•Print all the logs only for a percentage of invocations via log sampling (disabled by default)
•Append additional keys to structured log at any point in time
•Use a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with 
your organization’s Logging RFC
Using Powertools for AWS Lambda (TypeScript) and 
AWS SAM for structured logging
Follow the steps below to download, build, and deploy a sample Hello World TypeScript application 
with integrated Powertools for AWS Lambda (TypeScript) modules using the AWS SAM. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Node.js 18.x or later
330AWS Lambda Developer Guide
Using Powertools for AWS Lambda (TypeScript) 
and AWS SAM for structured logging
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World TypeScript template.
sam init --app-template hello-world-powertools-typescript --name sam-app --package-type 
 Zip --runtime nodejs18.x
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name sam-app
The log output looks like this:
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.552000 START 
 RequestId: 70693159-7e94-4102-a2af-98a6343fb8fb Version: $LATEST
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.594000 
 2022-08-31T09:33:10.557Z 70693159-7e94-4102-a2af-98a6343fb8fb 
 INFO {"_aws":{"Timestamp":1661938390556,"CloudWatchMetrics":
[{"Namespace":"sam-app","Dimensions":[["service"]],"Metrics":
[{"Name":"ColdStart","Unit":"Count"}]}]},"service":"helloWorld","ColdStart":1}
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.595000 
 2022-08-31T09:33:10.595Z 70693159-7e94-4102-a2af-98a6343fb8fb INFO 
 {"level":"INFO","message":"This is an INFO log - sending HTTP 200 - hello world 
 response","service":"helloWorld","timestamp":"2022-08-31T09:33:10.594Z"}
331AWS Lambda Developer Guide
Using Powertools for AWS Lambda (TypeScript) 
and the AWS CDK for structured logging
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.655000 
 2022-08-31T09:33:10.655Z 70693159-7e94-4102-a2af-98a6343fb8fb INFO {"_aws":
{"Timestamp":1661938390655,"CloudWatchMetrics":[{"Namespace":"sam-app","Dimensions":
[["service"]],"Metrics":[]}]},"service":"helloWorld"}
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.754000 END 
 RequestId: 70693159-7e94-4102-a2af-98a6343fb8fb
2023/01/31/[$LATEST]4d53e8d279824834a1ccd35511a4949c 2022-08-31T09:33:10.754000 REPORT 
 RequestId: 70693159-7e94-4102-a2af-98a6343fb8fb Duration: 201.55 ms Billed Duration: 
 202 ms Memory Size: 128 MB Max Memory Used: 66 MB Init Duration: 252.42 ms
XRAY TraceId: 1-630f2ad5-1de22b6d29a658a466e7ecf5 SegmentId: 567c116658fbf11a Sampled: 
 true
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Managing log retention
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which CloudWatch automatically deletes the 
logs. To set up log retention, add the following to your AWS SAM template:
Resources: 
  HelloWorldFunction: 
    Type: AWS::Serverless::Function 
    Properties: 
    # Omitting other properties 
   
  LogGroup: 
    Type: AWS::Logs::LogGroup 
    Properties: 
      LogGroupName: !Sub "/aws/lambda/${HelloWorldFunction}" 
      RetentionInDays: 7
Using Powertools for AWS Lambda (TypeScript) and 
the AWS CDK for structured logging
Follow the steps below to download, build, and deploy a sample Hello World TypeScript application 
with integrated Powertools for AWS Lambda (TypeScript) modules using the AWS CDK. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Node.js 18.x or later
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
332AWS Lambda Developer Guide
Using Powertools for AWS Lambda (TypeScript) 
and the AWS CDK for structured logging
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language typescript
3. Add the @types/aws-lambda package as a development dependency.
npm install -D @types/aws-lambda
4. Install the Powertools Logger utility.
npm install @aws-lambda-powertools/logger
5. Open the lib directory. You should see a ﬁle called hello-world-stack.ts. Create new two new ﬁles in 
this directory: hello-world.function.ts and hello-world.ts.
6. Open hello-world.function.ts and add the following code to the ﬁle. This is the code for the 
Lambda function.
import { APIGatewayEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { Logger } from '@aws-lambda-powertools/logger';
const logger = new Logger(); 
   
export const handler = async (event: APIGatewayEvent, context: Context): 
 Promise<APIGatewayProxyResult> => { 
  logger.info('This is an INFO log - sending HTTP 200 - hello world response'); 
  return { 
    statusCode: 200, 
    body: JSON.stringify({ 
      message: 'hello world', 
    }), 
  };
};
7. Open hello-world.ts and add the following code to the ﬁle. This contains the NodejsFunction 
construct, which creates the Lambda function, conﬁgures environment variables for Powertools, and 
sets log retention to one week. It also includes the LambdaRestApi construct, which creates the REST 
API.
import { Construct } from 'constructs';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';
import { LambdaRestApi } from 'aws-cdk-lib/aws-apigateway';
import { RetentionDays } from 'aws-cdk-lib/aws-logs';
import { CfnOutput } from 'aws-cdk-lib'; 
   
export class HelloWorld extends Construct { 
  constructor(scope: Construct, id: string) { 
    super(scope, id); 
    const helloFunction = new NodejsFunction(this, 'function', { 
      environment: { 
        Powertools_SERVICE_NAME: 'helloWorld', 
        LOG_LEVEL: 'INFO', 
      }, 
      logRetention: RetentionDays.ONE_WEEK, 
    }); 
333AWS Lambda Developer Guide
Using Powertools for AWS Lambda (TypeScript) 
and the AWS CDK for structured logging
    const api = new LambdaRestApi(this, 'apigw', { 
      handler: helloFunction, 
    }); 
    new CfnOutput(this, 'apiUrl', { 
      exportName: 'apiUrl', 
      value: api.url, 
    }); 
  }
}
8. Open hello-world-stack.ts. This is the code that deﬁnes your AWS CDK stack. Replace the code with 
the following:
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { HelloWorld } from './hello-world'; 
     
export class HelloWorldStack extends Stack { 
  constructor(scope: Construct, id: string, props?: StackProps) { 
    super(scope, id, props); 
    new HelloWorld(this, 'hello-world'); 
  }
}
9. Go back to the project directory.
cd hello-world
10. Deploy your application.
cdk deploy
11. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?ExportName==`apiUrl`].OutputValue' --output text
12. Invoke the API endpoint:
curl <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
13. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name HelloWorldStack
The log output looks like this:
2023/01/31/[$LATEST]2ca67f180dcd4d3e88b5d68576740c8e 2022-08-31T14:48:37.047000 START 
 RequestId: 19ad1007-ff67-40ce-9afe-0af0a9eb512c Version: $LATEST
2023/01/31/[$LATEST]2ca67f180dcd4d3e88b5d68576740c8e 2022-08-31T14:48:37.050000 {
"level": "INFO",
"message": "This is an INFO log - sending HTTP 200 - hello world response",
"service": "helloWorld",
"timestamp": "2022-08-31T14:48:37.048Z",
334AWS Lambda Developer Guide
Using the Lambda console
"xray_trace_id": "1-630f74c4-2b080cf77680a04f2362bcf2"
}
2023/01/31/[$LATEST]2ca67f180dcd4d3e88b5d68576740c8e 2022-08-31T14:48:37.082000 END 
 RequestId: 19ad1007-ff67-40ce-9afe-0af0a9eb512c
2023/01/31/[$LATEST]2ca67f180dcd4d3e88b5d68576740c8e 2022-08-31T14:48:37.082000 REPORT 
 RequestId: 19ad1007-ff67-40ce-9afe-0af0a9eb512c Duration: 34.60 ms Billed Duration: 35 
 ms Memory Size: 128 MB Max Memory Used: 57 MB Init Duration: 173.48 ms
14. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
335AWS Lambda Developer Guide
Testing
AWS Lambda function testing in TypeScript
Note
See the Testing functions (p. 261) chapter for a complete introduction to techniques and best 
practices for testing serverless solutions.
Testing serverless functions uses traditional test types and techniques, but you must also consider 
testing serverless applications as a whole. Cloud-based tests will provide the most accurate measure of 
quality of both your functions and serverless applications.
A serverless application architecture includes managed services that provide critical application 
functionality through API calls. For this reason, your development cycle should include automated tests 
that verify functionality when your function and services interact.
If you do not create cloud-based tests, you could encounter issues due to diﬀerences between your 
local environment and the deployed environment. Your continuous integration process should run tests 
against a suite of resources provisioned in the cloud before promoting your code to the next deployment 
environment, such as QA, Staging, or Production.
Continue reading this short guide to learn about testing strategies for serverless applications, or visit the
Serverless Test Samples repository to dive in with practical examples, speciﬁc to your chosen language 
and runtime.
For serverless testing, you will still write unit, integration  and end-to-end  tests.
•Unit tests  - Tests that run against an isolated block of code. For example, verifying the business logic 
to calculate the delivery charge given a particular item and destination.
•Integration tests  - Tests involving two or more components or services that interact, typically in a 
cloud environment. For example, verifying a function processes events from a queue.
•End-to-end tests  - Tests that verify behavior across an entire application. For example, ensuring 
infrastructure is set up correctly and that events ﬂow between services as expected to record a 
customer's order.
Testing your serverless applications
You will generally use a mix of approaches to test your serverless application code, including testing in 
the cloud, testing with mocks, and occasionally testing with emulators.
336AWS Lambda Developer Guide
Testing your serverless applications
Testing in the cloud
Testing in the cloud is valuable for all phases of testing, including unit tests, integration tests, and end-
to-end tests. You run tests against code deployed in the cloud and interacting with cloud-based services. 
This approach provides the most accurate measure of quality of your code.
A convenient way to debug your Lambda function in the cloud is through the console with a test event. 
A test event  is a JSON input to your function. If your function does not require input, the event can be an 
empty JSON document ({}). The console provides sample events for a variety of service integrations. 
After creating an event in the console, you can share it with your team to make testing easier and 
consistent.
Note
Testing a function in the console (p. 137) is a quick way to get started, but automating your test 
cycles ensures application quality and development speed.
Testing tools
Tools and techniques exist to accelerate development feedback loops. For example, AWS SAM Accelerate
and AWS CDK watch mode both decrease the time required to update cloud environments.
TypeScript code uses import  or require statements to import dependencies. You can use the module 
loading behavior of the Node.js runtime to replace or wrap dependencies before they are imported by 
the System Under Test (SUT).
The AWS SDK V3 Client Mock is a TypeScript library for mocking AWS services and resources. This library 
provides a way to mock the sending of Commands  and a way to deﬁne the returned results depending on 
the Command type and payload.
Another commonly used framework for testing, Jest, provides a custom resolver for imports so you can 
create mock objects that are outside of your test’s scope.
For more information on mocking, read the blog post: Unit Testing Lambda with TypeScript and Mock 
AWS Services.
To reduce the latency involved with cloud deployment iterations, see AWS Serverless Application Model 
(AWS SAM) Accelerate, AWS Cloud Development Kit (AWS CDK) watch mode. These tools monitor your 
infrastructure and code for changes. They react to these changes by creating and deploying incremental 
updates automatically into your cloud environment.
Examples that use these tools are available in the TypeScript Test Samples code repository.
337AWS Lambda Developer Guide
Errors
AWS Lambda function errors in TypeScript
If an exception occurs in TypeScript code that's transpiled into JavaScript, use source map ﬁles to 
determine where the error occurred. Source map ﬁles allow debuggers to map compiled JavaScript ﬁles 
to the TypeScript source code.
For example, the following code results in an error:
export const handler = async (event: unknown): Promise<unknown> => { 
    throw new Error('Some exception');
};
AWS Lambda catches the error and generates a JSON document. However, this JSON document refers to 
the compiled JavaScript ﬁle (app.js ), not the TypeScript source ﬁle.
{ 
  "errorType": "Error", 
  "errorMessage": "Some exception", 
  "stack": [ 
      "Error: Some exception", 
      "    at Runtime.p [as handler] (/var/task/app.js:1:491)", 
      "    at Runtime.handleOnce (/var/runtime/Runtime.js:66:25)" 
  ]
}
To get an error response that maps to your TypeScript source ﬁle
Note
The following steps aren't valid for Lambda@Edge functions because Lambda@Edge doesn't 
support environment variables.
1. Generate a source map ﬁle with esbuild or another TypeScript compiler. Example:
esbuild app.ts —sourcemap —outfile=output.js
2. Add the source map to your deployment.
3. Turn on source maps for the Node.js runtime by adding --enable-source-maps  to your
NODE_OPTIONS .
Example for the AWS Serverless Application Model (AWS SAM)
Globals: 
    Function: 
      Environment: 
        Variables: 
          NODE_OPTIONS: '--enable-source-maps'
Make sure that the esbuild properties in your template.yaml ﬁle include Sourcemap: true . Example:
Metadata: # Manage esbuild properties 
  BuildMethod: esbuild 
  BuildProperties: 
    Minify: true 
    Target: "es2020" 
     Sourcemap: true
    EntryPoints:  
338AWS Lambda Developer Guide
Errors
    - app.ts
Example Example for the AWS Cloud Development Kit (AWS CDK)
To use a source map with an AWS CDK application, add the following code to the ﬁle that contains the
NodejsFunction construct.
const helloFunction = new NodejsFunction(this, 'function',{ 
  bundling: { 
    minify: true, 
   sourceMap: true
  }, 
  environment:{ 
    NODE_OPTIONS: '--enable-source-maps' , 
  }
});
When you use a source map in your code, you get an error response similar to the following. This 
response shows that the error happened at line 2, column 11 in the app.ts  ﬁle.
{ 
  "errorType": "Error", 
  "errorMessage": "Some exception", 
  "stack": [ 
      "Error: Some exception", 
      "    at Runtime.p (/private/var/folders/3c/0d4wz7dn2y75bw_hxdwc0h6w0000gr/T/
tmpfmxb4ziy/app.ts:2:11)", 
      "    at Runtime.handleOnce (/var/runtime/Runtime.js:66:25)" 
  ]
}
339AWS Lambda Developer Guide
Tracing
Tracing TypeScript code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of three SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for Node.js – An SDK for generating and sending trace data to X-Ray.
•Powertools for AWS Lambda (TypeScript) – A developer toolkit to implement Serverless best practices 
and increase developer velocity.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using Powertools for AWS Lambda (TypeScript) and AWS SAM for tracing (p. 340)
•Using Powertools for AWS Lambda (TypeScript) and the AWS CDK for tracing (p. 342)
•Interpreting an X-Ray trace (p. 345)
Using Powertools for AWS Lambda (TypeScript) and 
AWS SAM for tracing
Follow the steps below to download, build, and deploy a sample Hello World TypeScript application 
with integrated Powertools for AWS Lambda (TypeScript) modules using the AWS SAM. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Node.js 18.x or later
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World TypeScript template.
340AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(TypeScript) and AWS SAM for tracing
sam init --app-template hello-world-powertools-typescript --name sam-app --package-type 
 Zip --runtime nodejs18.x --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
XRay Event [revision 1] at (2023-01-31T11:29:40.527000) with id 
 (1-11a2222-111a222222cb33de3b95daf9) and duration (0.483s) 
  - 0.425s - sam-app/Prod [HTTP: 200] 
    - 0.422s - Lambda [HTTP: 200] 
  - 0.406s - sam-app-HelloWorldFunction-Xyzv11a1bcde [HTTP: 200] 
  - 0.172s - sam-app-HelloWorldFunction-Xyzv11a1bcde 
    - 0.179s - Initialization 
    - 0.112s - Invocation 
      - 0.052s - ## app.lambdaHandler 
        - 0.001s - ### MySubSegment 
    - 0.059s - Overhead
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
341AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(TypeScript) and the AWS CDK for tracing
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
Using Powertools for AWS Lambda (TypeScript) and 
the AWS CDK for tracing
Follow the steps below to download, build, and deploy a sample Hello World TypeScript application 
with integrated Powertools for AWS Lambda (TypeScript) modules using the AWS CDK. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Node.js 18.x or later
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS Cloud Development Kit (AWS CDK) application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language typescript
3. Add the @types/aws-lambda package as a development dependency.
npm install -D @types/aws-lambda
4. Install the Powertools Tracer utility.
npm install @aws-lambda-powertools/tracer
5. Open the lib directory. You should see a ﬁle called hello-world-stack.ts. Create new two new ﬁles in 
this directory: hello-world.function.ts and hello-world.ts.
6. Open hello-world.function.ts and add the following code to the ﬁle. This is the code for the 
Lambda function.
import { APIGatewayEvent, APIGatewayProxyResult, Context } from 'aws-lambda';
import { Tracer } from '@aws-lambda-powertools/tracer';
const tracer = new Tracer();
342AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(TypeScript) and the AWS CDK for tracing
export const handler = async (event: APIGatewayEvent, context: Context): 
 Promise<APIGatewayProxyResult> => { 
  // Get facade segment created by Lambda 
  const segment = tracer.getSegment(); 
  // Create subsegment for the function and set it as active 
  const handlerSegment = segment.addNewSubsegment(`## ${process.env._HANDLER}`); 
  tracer.setSegment(handlerSegment); 
  // Annotate the subsegment with the cold start and serviceName 
  tracer.annotateColdStart(); 
  tracer.addServiceNameAnnotation(); 
  // Add annotation for the awsRequestId 
  tracer.putAnnotation('awsRequestId', context.awsRequestId); 
  // Create another subsegment and set it as active 
  const subsegment = handlerSegment.addNewSubsegment('### MySubSegment'); 
  tracer.setSegment(subsegment); 
  let response: APIGatewayProxyResult = { 
    statusCode: 200, 
    body: JSON.stringify({ 
      message: 'hello world', 
    }), 
  }; 
  // Close subsegments (the Lambda one is closed automatically) 
  subsegment.close(); // (### MySubSegment) 
  handlerSegment.close(); // (## index.handler) 
  // Set the facade segment as active again (the one created by Lambda) 
  tracer.setSegment(segment); 
  return response;
};
7. Open hello-world.ts and add the following code to the ﬁle. This contains the NodejsFunction 
construct, which creates the Lambda function, conﬁgures environment variables for Powertools, and 
sets log retention to one week. It also includes the LambdaRestApi construct, which creates the REST 
API.
import { Construct } from 'constructs';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';
import { LambdaRestApi } from 'aws-cdk-lib/aws-apigateway';
import { CfnOutput } from 'aws-cdk-lib';
import { Tracing } from 'aws-cdk-lib/aws-lambda';
export class HelloWorld extends Construct { 
  constructor(scope: Construct, id: string) { 
    super(scope, id); 
    const helloFunction = new NodejsFunction(this, 'function', { 
      environment: { 
        POWERTOOLS_SERVICE_NAME: 'helloWorld', 
      }, 
      tracing: Tracing.ACTIVE, 
    }); 
    const api = new LambdaRestApi(this, 'apigw', { 
      handler: helloFunction, 
    }); 
    new CfnOutput(this, 'apiUrl', { 
      exportName: 'apiUrl', 
      value: api.url, 
    }); 
  }
}
343AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(TypeScript) and the AWS CDK for tracing
8. Open hello-world-stack.ts. This is the code that deﬁnes your AWS CDK stack. Replace the code with 
the following:
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { HelloWorld } from './hello-world'; 
   
export class HelloWorldStack extends Stack { 
  constructor(scope: Construct, id: string, props?: StackProps) { 
    super(scope, id, props); 
    new HelloWorld(this, 'hello-world'); 
  }
}
9. Deploy your application.
cd ..
cdk deploy
10. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?ExportName==`apiUrl`].OutputValue' --output text
11. Invoke the API endpoint:
curl <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
12. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
XRay Event [revision 1] at (2023-01-31T11:50:06.997000) with id 
 (1-11a2222-111a222222cb33de3b95daf9) and duration (0.449s) 
  - 0.350s - HelloWorldStack-helloworldfunction111A2BCD-Xyzv11a1bcde [HTTP: 200] 
  - 0.157s - HelloWorldStack-helloworldfunction111A2BCD-Xyzv11a1bcde 
    - 0.169s - Initialization 
    - 0.058s - Invocation 
      - 0.055s - ## index.handler 
        - 0.000s - ### MySubSegment 
    - 0.099s - Overhead
13. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
344AWS Lambda Developer Guide
Interpreting an X-Ray trace
Interpreting an X-Ray trace
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. 
CloudWatch ServiceLens provides information about your application and all its components. The 
following example shows a trace from the sample application:
345AWS Lambda Developer Guide
Building Lambda functions with 
Python
You can run Python code in AWS Lambda. Lambda provides runtimes  (p. 41) for Python that run your 
code to process events. Your code runs in an environment that includes the SDK for Python (Boto3), with 
credentials from an AWS Identity and Access Management (IAM) role that you manage.
Lambda supports the following Python runtimes.
Python
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Python 3.11python3.11 boto3-1.27.1 
botocore-1.30.1Amazon Linux 
2x86_64, arm64
Python 3.10python3.10 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.9python3.9 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.8python3.8 boto3-1.26.90 
botocore-1.29.90Amazon Linux 
2x86_64, arm64
Python 3.7python3.7 boto3-1.26.90 
botocore-1.29.90Amazon Linux x86_64 Nov 27, 2023
The runtime information in this table undergoes continuous updates. For more information on using 
AWS SDKs in Lambda, see Managing AWS SDKs in Lambda functions in Serverless Land.
To create a Python function
1. Open the Lambda console.
2. Choose Create function.
3. Conﬁgure the following settings:
•Function name: Enter a name for the function.
•Runtime : Choose Python 3.11.
4. Choose Create function.
5. To conﬁgure a test event, choose Test.
6. For Event name, enter test .
7. Choose Save changes.
8. To invoke the function, choose Test.
The console creates a Lambda function with a single source ﬁle named lambda_function . You can edit 
this ﬁle and add more ﬁles in the built-in code editor (p. 25). To save your changes, choose Save. Then, to 
run your code, choose Test.
346AWS Lambda Developer Guide
Note
The Lambda console uses AWS Cloud9 to provide an integrated development environment 
in the browser. You can also use AWS Cloud9 to develop Lambda functions in your own 
environment. For more information, see Working with AWS Lambda functions using the AWS 
Toolkit in the AWS Cloud9 user guide.
Note
To get started with application development in your local environment, deploy one of the 
sample applications available in this guide's GitHub repository.
Sample Lambda applications in Python
•blank-python – A Python function that shows the use of logging, environment variables, AWS 
X-Ray tracing, layers, unit tests and the AWS SDK.
Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details 
about each invocation to CloudWatch Logs. It relays any logs that your function outputs (p. 374) during 
invocation. If your function returns an error (p. 388), Lambda formats the error and returns it to the 
invoker.
Topics
•Lambda function handler in Python (p. 348)
•Working with .zip ﬁle archives for Python Lambda functions (p. 352)
•Deploy Python Lambda functions with container images (p. 362)
•AWS Lambda context object in Python (p. 372)
•AWS Lambda function logging in Python (p. 374)
•AWS Lambda function testing in Python (p. 386)
•AWS Lambda function errors in Python (p. 388)
•Instrumenting Python code in AWS Lambda (p. 392)
347AWS Lambda Developer Guide
Handler
Lambda function handler in Python
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
You can use the following general syntax when creating a function handler in Python:
def handler_name (event, context):  
    ... 
    return some_value
Naming
The Lambda function handler name speciﬁed at the time that you create a Lambda function is derived 
from:
•The name of the ﬁle in which the Lambda handler function is located.
•The name of the Python handler function.
A function handler can be any name; however, the default name in the Lambda console is
lambda_function.lambda_handler . This function handler name reﬂects the function name 
(lambda_handler ) and the ﬁle where the handler code is stored (lambda_function.py ).
If you create a function in the console using a diﬀerent ﬁle name or function handler name, you must 
edit the default handler name.
To change the function handler name (console)
1. Open the Functions page of the Lambda console and choose your function.
2. Choose the Code  tab.
3. Scroll down to the Runtime settings pane and choose Edit.
4. In Handler, enter the new name for your function handler.
5. Choose Save.
How it works
When Lambda invokes your function handler, the Lambda runtime  (p. 41) passes two arguments to the 
function handler:
•The ﬁrst argument is the event object. An event is a JSON-formatted document that contains data for 
a Lambda function to process. The Lambda runtime  (p. 41) converts the event to an object and passes 
it to your function code. It is usually of the Python dict type. It can also be list , str, int, float , or 
the NoneType  type.
The event object contains information from the invoking service. When you invoke a function, you 
determine the structure and contents of the event. When an AWS service invokes your function, the 
service deﬁnes the event structure. For more information about events from AWS services, see Using 
AWS Lambda with other services (p. 628).
•The second argument is the context object (p. 372). A context object is passed to your function by 
Lambda at runtime. This object provides methods and properties that provide information about the 
invocation, function, and runtime environment.
348AWS Lambda Developer Guide
Returning a value
Returning a value
Optionally, a handler can return a value. What happens to the returned value depends on the invocation 
type (p. 135) and the service (p. 628) that invoked the function. For example:
•If you use the RequestResponse  invocation type, such as Synchronous invocation (p. 139), AWS 
Lambda returns the result of the Python function call to the client invoking the Lambda function (in 
the HTTP response to the invocation request, serialized into JSON). For example, AWS Lambda console 
uses the RequestResponse  invocation type, so when you invoke the function on the console, the 
console will display the returned value.
•If the handler returns objects that can't be serialized by json.dumps , the runtime returns an error.
•If the handler returns None, as Python functions without a return  statement implicitly do, the 
runtime returns null .
•If you use the Event invocation type (an asynchronous invocation (p. 142)), the value is discarded.
Note
In Python 3.9 and later releases, Lambda includes the requestId of the invocation in the error 
response.
Examples
The following section shows examples of Python functions you can use with Lambda. If you use the 
Lambda console to author your function, you do not need to attach a .zip archive ﬁle (p. 352) to run 
the functions in this section. These functions use standard Python libraries which are included with the 
Lambda runtime you selected. For more information, see Lambda deployment packages (p. 18).
Returning a message
The following example shows a function called lambda_handler . The function accepts user input of a 
ﬁrst and last name, and returns a message that contains data from the event it received as input.
def lambda_handler(event, context): 
    message = 'Hello {} {}!'.format(event['first_name'], event['last_name'])   
    return {  
        'message' : message 
    }
You can use the following event data to invoke the function:
{ 
    "first_name": "John", 
    "last_name": "Smith"
}
The response shows the event data passed as input:
{ 
    "message": "Hello John Smith!"
}
Parsing a response
The following example shows a function called lambda_handler . The function uses event data passed 
by Lambda at runtime. It parses the environment variable (p. 77) in AWS_REGION  returned in the JSON 
response.
349AWS Lambda Developer Guide
Examples
import os
import json 
         
def lambda_handler(event, context): 
    json_region = os.environ['AWS_REGION'] 
    return { 
        "statusCode": 200, 
        "headers": { 
            "Content-Type": "application/json" 
        }, 
        "body": json.dumps({ 
            "Region ": json_region 
        }) 
    }
You can use any event data to invoke the function:
{ 
  "key1": "value1", 
  "key2": "value2", 
  "key3": "value3"
}
Lambda runtimes set several environment variables during initialization. For more information on 
the environment variables returned in the response at runtime, see Using Lambda environment 
variables  (p. 77).
The function in this example depends on a successful response (in 200) from the Invoke API. For more 
information on the Invoke API status, see the Invoke (p. 1399 ) Response Syntax.
Returning a calculation
The following example shows a function called lambda_handler . The function accepts user input 
and returns a calculation to the user. For more information about this example, see the aws-doc-sdk-
examples GitHub repository.
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
def lambda_handler(event, context): 
    ... 
    result = None 
    action = event.get('action') 
    if action == 'increment': 
        result = event.get('number', 0) + 1 
        logger.info('Calculated result of %s', result) 
    else: 
        logger.error("%s is not a valid action.", action) 
    response = {'result': result} 
    return response
You can use the following event data to invoke the function:
{ 
    "action": "increment", 
    "number": 3
350AWS Lambda Developer Guide
Examples
}
351AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Working with .zip ﬁle archives for Python Lambda 
functions
Your AWS Lambda function’s code comprises a .py ﬁle containing your function’s handler code, together 
with any additional packages and modules your code depends on. To deploy this function code to 
Lambda, you use a deployment package . This package may either be a .zip ﬁle archive or a container 
image. For more information about using container images with Python, see Deploy Python Lambda 
functions with container images.
To create your deployment package as .zip ﬁle archive, you can use your command-line tool’s built-
in .zip ﬁle archive utility, or any other .zip ﬁle utility such as 7zip. The examples shown in the following 
sections assume you’re using a command-line zip tool in a Linux or MacOS environment. To use the 
same commands in Windows, you can install the Windows Subsystem for Linux to get a Windows-
integrated version of Ubuntu and Bash.
Note that Lambda uses POSIX ﬁle permissions, so you may need to set permissions for the deployment 
package folder  before you create the .zip ﬁle archive.
Topics
•Runtime dependencies in Python (p. 352)
•Creating a .zip deployment package with no dependencies (p. 353)
•Creating a .zip deployment package with dependencies (p. 353)
•Dependency search path and runtime-included libraries (p. 355)
•Using __pycache__ folders (p. 356)
•Creating .zip deployment packages with native libraries (p. 356)
•Creating and updating Python Lambda functions using .zip ﬁles (p. 357)
Runtime dependencies in Python
For Lambda functions that use the Python runtime, a dependency can be any Python package or 
module. When you deploy your function using a .zip archive, you can either add these dependencies 
to your .zip ﬁle with your function code or use a Lambda layer. A layer is a separate .zip ﬁle that can 
contain additional code and other content. To learn more about using Lambda layers, see Lambda 
layers  (p. 988).
The Lambda Python runtimes includes the AWS SDK for Python (Boto3) and its dependencies. Lambda 
provides the SDK in the runtime for deployment scenarios where you are unable to add your own 
dependencies. These scenarios include creating functions in the console using the built-in code editor 
or using inline functions in AWS Serverless Application Model (AWS SAM) or AWS CloudFormation 
templates.
Lambda periodically updates the libraries in the Python runtime to include the latest updates and 
security patches. If your function uses the version of the Boto3 SDK included in the runtime but your 
deployment package includes SDK dependencies, this can cause version misalignment issues. For 
example, your deployment package could include the SDK dependency urllib3. When Lambda updates 
the SDK in the runtime, compatibility issues between the new version of the runtime and the version of 
urllib3 in your deployment package can cause your function to fail.
Important
To maintain full control over your dependencies and to avoid possible version misalignment 
issues, we recommend you add all of your function’s dependencies to your deployment package, 
even if versions of them are included in the Lambda runtime. This includes the Boto3 SDK.
352AWS Lambda Developer Guide
Creating a .zip deployment package with no dependencies
Under the AWS shared responsibility model, you are responsible for the management of any 
dependencies in your functions' deployment packages. This includes applying updates and security 
patches. To update dependencies in your function's deployment package, ﬁrst create a new .zip ﬁle and 
then upload it to Lambda. See Creating a .zip deployment package with dependencies (p. 353) and
Creating and updating Python Lambda functions using .zip ﬁles (p. 357) for more information.
Creating a .zip deployment package with no 
dependencies
If your function code has no dependencies, your .zip ﬁle contains only the .py ﬁle with your function’s 
handler code. Use your preferred zip utility to create a .zip ﬁle with your .py ﬁle at the root. If the .py ﬁle 
is not at the root of your .zip ﬁle, Lambda won’t be able to run your code.
To learn how to deploy your .zip ﬁle to create a new Lambda function or update an existing one, see
Creating and updating Python Lambda functions using .zip ﬁles (p. 357).
Creating a .zip deployment package with 
dependencies
If your function code depends on additional packages or modules, you can either add these 
dependencies to your .zip ﬁle with your function code or use a Lambda layer. The instructions in this 
section show you how to include your dependencies in your .zip deployment package. For Lambda to 
run your code, the .py ﬁle containing your handler code and all of your function's dependencies must be 
installed at the root of the .zip ﬁle.
Suppose your function code is saved in a ﬁle named lambda_function.py . The following example CLI 
commands create a .zip ﬁle named my_deployment_package.zip  containing your function code and 
its dependencies. You can either install your dependencies directly to a folder in your project directory or 
use a Python virtual environment.
To create the deployment package (project directory)
1. Navigate to the project directory containing your lambda_function.py  source code ﬁle. In this 
example, the directory is named my_function .
cd my_function
2. Create a new directory named package into which you will install your dependencies.
mkdir package
Note that for a .zip deployment package, Lambda expects your source code and its dependencies all 
to be at the root of the .zip ﬁle. However, installing dependencies directly in your project directory 
can introduce a large number of new ﬁles and folders and make navigating around your IDE diﬃcult. 
You create a separate package directory here to keep your dependencies separate from your source 
code.
3. Install your dependencies in the package directory. The example below installs the Boto3 SDK from 
the Python Package Index using pip. If your function code uses Python packages you have created 
yourself, save them in the package directory.
pip install --target ./package boto3
4. Create a .zip ﬁle with the installed libraries at the root.
353AWS Lambda Developer Guide
Creating a .zip deployment package with dependencies
cd package
zip -r ../my_deployment_package.zip .
This generates a my_deployment_package.zip  ﬁle in your project directory.
5. Add the lambda_function.py ﬁle to the root of the .zip ﬁle
cd ..
zip my_deployment_package.zip lambda_function.py
Your .zip ﬁle should have a ﬂat directory structure, with your function's handler code and all your 
dependency folders installed at the root as follows.
my_deployment_package.zip
|- bin
|  |-jp.py
|- boto3
|  |-compat.py
|  |-data
|  |-docs
...
|- lambda_function.py
If the .py ﬁle containing your function’s handler code is not at the root of your .zip ﬁle, Lambda will 
not be able to run your code.
To create the deployment package (virtual environment)
1. Create and activate a virtual environment in your project directory. In this example the project 
directory is named my_function .
~$ cd my_function
~/my_function$ python3.11 -m venv my_virtual_env
~/my_function$ source ./my_virtual_env/bin/activate
2. Install your required libraries using pip. The following example installs the Boto3 SDK
(my_virtual_env) ~/my_function$ pip install boto3
3. Use pip show  to ﬁnd the location in your virtual environment where pip has installed your 
dependencies.
(my_virtual_env) ~/my_function$ pip show <package_name>
The folder in which pip installs your libraries may be named site-packages  or dist-packages . 
This folder may be located in either the lib/python3.x  or lib64/python3.x  directory (where 
python3.x represents the version of Python you are using).
4. Deactivate the virtual environment
(my_virtual_env) ~/my_function$ deactivate
5. Navigate into the directory containing the dependencies you installed with pip and create a .zip 
ﬁle in your project directory with the installed dependencies at the root. In this example, pip 
has installed your dependencies in the my_virtual_env/lib/python3.11/site-packages
directory.
354AWS Lambda Developer Guide
Dependency search path and runtime-included libraries
~/my_function$ cd my_virtual_env/lib/python3.11/site-packages
~/my_function/my_virtual_env/lib/python3.11/site-packages$ zip -r ../../../../
my_deployment_package.zip .
6. Navigate to the root of your project directory where the .py ﬁle containing your handler code is 
located and add that ﬁle to the root of your .zip package. In this example, your function code ﬁle is 
named lambda_function.py .
~/my_function/my_virtual_env/lib/python3.11/site-packages$ cd ../../../../
~/my_function$ zip my_deployment_package.zip lambda_function.py
Dependency search path and runtime-included 
libraries
When you use an import statement in your code, the Python runtime searches the directories in its 
search path until it ﬁnds the module or package. By default, the ﬁrst location the runtime searches is 
the directory into which your .zip deployment package is decompressed and mounted (/var/task ). If 
you include a version of a runtime-included library in your deployment package, your version will take 
precedence over the version that's included in the runtime. Dependencies in your deployment package 
also have precedence over dependencies in layers.
When you add a dependency to a layer, Lambda extracts this to /opt/python/lib/python3.x/site-
packages  (where python3.x  represents the version of the runtime you're using) or /opt/python . 
In the search path, these directories have precedence over the directories containing the runtime-
included libraries and pip-installed libraries ( /var/runtime  and /var/lang/lib/python3.x/site-
packages ). Libraries in function layers therefore have precedence over versions included in the runtime.
Note
In the Python 3.11 managed runtime and base image, the AWS SDK and its dependencies are 
installed in the /var/lang/lib/python3.11/site-packages  directory.
You can see the full search path for your Lambda function by adding the following code snippet.
import sys 
       
search_path = sys.path
print(search_path)
Note
Because dependencies in your deployment package or layers take precedence over runtime-
included libraries, this can cause version misalignment problems if you include an SDK 
dependency such as urllib3 in your package without including the SDK as well. If you deploy 
your own version of a Boto3 dependency, you must also deploy Boto3 as a dependency in your 
deployment package. We recommend that you package all of your function’s dependencies, 
even if versions of them are included in the runtime.
You can also add dependencies in a separate folder inside your .zip package. For example, you might add 
a version of the Boto3 SDK to a folder in your .zip package called common. When your .zip package is 
decompressed and mounted, this folder is placed inside the /var/task  directory. To use a dependency 
from a folder in your .zip deployment package in your code, use an import from  statement. For 
example, to use a version of Boto3 from a folder named common in your .zip package, use the following 
statement.
from common import boto3
355AWS Lambda Developer Guide
Using __pycache__ folders
Using __pycache__ folders
We recommend that you don't include __pycache__  folders in your function's deployment package. 
Python bytecode that's compiled on a build machine with a diﬀerent architecture or operating system 
might not be compatible with the Lambda execution environment.
Creating .zip deployment packages with native 
libraries
If your function uses only pure Python packages and modules, you can use the pip install  command 
to install your dependencies on any local build machine and create your .zip ﬁle. Many popular Python 
libraries, including NumPy and Pandas, are not pure Python and contain code written in C or C++. When 
you add libraries containing C/C++ code to your deployment package, you must build your package 
correctly to ensure that it’s compatible with the Lambda execution environment.
Most packages available on the Python Package Index (PyPI ) are available as “wheels” (.whl ﬁles). A .whl 
ﬁle is a type of ZIP ﬁle which contains a built distribution with pre-compiled binaries for a particular 
operating system and instruction set architecture. To make your deployment package compatible 
with Lambda, you install the wheel for Linux operating systems and your function’s instruction set 
architecture.
Some packages may only be available as source distributions. For these packages, you need to compile 
and build the C/C++ components yourself.
To see what distributions are available for your required package, do the following:
1. Search for the name of the package on the Python Package Index main page.
2. Choose the version of the package you want to use.
3. Choose Download ﬁles.
Working with built distributions (wheels)
To download a wheel that’s compatible with Lambda, you use the pip --platform  option.
If your Lambda function uses the x86_64  instruction set architecture, run the following pip install
command to install a compatible wheel in your package directory. Replace --python 3.x  with the 
version of the Python runtime you are using.
pip install \
--platform manylinux2014_x86_64 \
--target=package \
--implementation cp \
--python-version 3.x \
--only-binary=:all: --upgrade \
<package_name>
If your function uses the arm64  instruction set architecture, run the following command. Replace --
python 3.x  with the version of the Python runtime you are using.
pip install \
--platform manylinux2014_aarch64 \
--target=package \
--implementation cp \
356AWS Lambda Developer Guide
Creating and updating Python 
Lambda functions using .zip ﬁles
--python-version 3.x \
--only-binary=:all: --upgrade \
<package_name>
Working with source distributions
If your package is only available as a source distribution, you need to build the C/C++ libraries yourself. 
To make your package compatible with the Lambda execution environment, you need to build it in an 
environment that uses the same Amazon Linux 2 operating system. You can do this by building your 
package in an Amazon EC2 Linux instance.
To learn how to launch and connect to an Amazon EC2 Linux instance, see Tutorial: Get started with 
Amazon EC2 Linux instances in the Amazon EC2 User Guide for Linux Instances.
Creating and updating Python Lambda functions 
using .zip ﬁles
Once you have created your .zip deployment package, you can use it to create a new Lambda function or 
update an existing one. You can deploy your .zip package using the Lambda console, the AWS Command 
Line Interface, and the Lambda API. You can also create and update Lambda functions using AWS 
Serverless Application Model (AWS SAM) and AWS CloudFormation.
The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit 
applies to the combined size of all the ﬁles you upload, including any Lambda layers.
Creating and updating functions with .zip ﬁles using the console
To create a new function, you must ﬁrst create the function in the console, then upload your .zip archive. 
To update an existing function, open the page for your function, then follow the same procedure to add 
your updated .zip ﬁle.
If your .zip ﬁle is less than 50MB, you can create or update a function by uploading the ﬁle directly 
from your local machine. For .zip ﬁles greater than 50MB, you must upload your package to an Amazon 
S3 bucket ﬁrst. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
Management Console, see Getting started with Amazon S3. To upload ﬁles using the AWS CLI, see Move 
objects in the AWS CLI User Guide.
Note
You cannot convert an existing container image function to use a .zip archive. You must create a 
new function.
To create a new function (console)
1. Open the Functions page of the Lambda console and choose Create Function.
2. Choose Author from scratch .
3. Under Basic information , do the following:
a. For Function name, enter the name for your function.
b. For Runtime , select the runtime you want to use.
c. (Optional) For Architecture, choose the instruction set architecture for your function. The 
default architecture is x86_64. Ensure that the .zip deployment package for your function is 
compatible with the instruction set architecture you select.
4. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing one.
357AWS Lambda Developer Guide
Creating and updating Python 
Lambda functions using .zip ﬁles
5. Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
To upload a .zip archive from your local machine (console)
1. In the Functions page of the Lambda console, choose the function you want to upload the .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose .zip ﬁle.
5. To upload the .zip ﬁle, do the following:
a. Select Upload, then select your .zip ﬁle in the ﬁle chooser.
b. Choose Open .
c. Choose Save.
To upload a .zip archive from an Amazon S3 bucket (console)
1. In the Functions page of the Lambda console, choose the function you want to upload a new .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose Amazon S3 location.
5. Paste the Amazon S3 link URL of your .zip ﬁle and choose Save.
Updating .zip ﬁle functions using the console code editor
For some functions with .zip deployment packages, you can use the Lambda console’s built-in code 
editor to update your function code directly. To use this feature, your function must meet the following 
criteria:
•Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
•Your function’s deployment package must be smaller than 3MB.
Function code for functions with container image deployment packages cannot be edited directly in the 
console.
To update function code using the console code editor
1. Open the Functions page of the Lambda console and select your function.
2. Select the Code  tab.
3. In the Code source pane, select your source code ﬁle and edit it in the integrated code editor.
4. When you have ﬁnished editing your code, choose Deploy to save your changes and update your 
function.
Creating and updating functions with .zip ﬁles using the AWS 
CLI
You can can use the AWS CLI to create a new function or to update an existing one using a .zip ﬁle. Use 
the create-function and update-function-code commands to deploy your .zip package. If your .zip ﬁle is 
358AWS Lambda Developer Guide
Creating and updating Python 
Lambda functions using .zip ﬁles
smaller than 50MB, you can upload the .zip package from a ﬁle location on your local build machine. For 
larger ﬁles, you must upload your .zip package from an Amazon S3 bucket. For instructions on how to 
upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
Note
If you upload your .zip ﬁle from an Amazon S3 bucket using the AWS CLI, the bucket must be 
located in the same AWS Region as your function.
To create a new function using a .zip ﬁle with the AWS CLI, you must specify the following:
•The name of your function (--function-name )
•Your function’s runtime (--runtime )
•The Amazon Resource Name (ARN) of your function’s execution role (--role )
•The name of the handler method in your function code (--handler )
You must also specify the location of your .zip ﬁle. If your .zip ﬁle is located in a folder on your local 
build machine, use the --zip-file  option to specify the ﬁle path, as shown in the following example 
command.
aws lambda create-function --function-name myFunction \
--runtime python3.11 --handler lambda_function.lambda_handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --code option as shown in the 
following example command. You only need to use the S3ObjectVersion  parameter for versioned 
objects.
aws lambda create-function --function-name myFunction \
--runtime python3.11 --handler lambda_function.lambda_handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=myBucketName,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
To update an existing function using the CLI, you specify the the name of your function using the --
function-name  parameter. You must also specify the location of the .zip ﬁle you want to use to update 
your function code. If your .zip ﬁle is located in a folder on your local build machine, use the --zip-
file option to specify the ﬁle path, as shown in the following example command.
aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --s3-bucket  and --s3-key  options 
as shown in the following example command. You only need to use the --s3-object-version
parameter for versioned objects.
aws lambda update-function-code --function-name myFunction \
--s3-bucket myBucketName --s3-key myFileName.zip --s3-object-version myObject Version
Creating and updating functions with .zip ﬁles using the 
Lambda API
To create and update functions using a .zip ﬁle archive, use the following API operations:
•CreateFunction
•UpdateFunctionCode
359AWS Lambda Developer Guide
Creating and updating Python 
Lambda functions using .zip ﬁles
Creating and updating functions with .zip ﬁles using AWS SAM
The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of 
building and running serverless applications on AWS. You deﬁne the resources for your application in a 
YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, 
and deploy your applications. When you build a Lambda function from an AWS SAM template, AWS SAM 
automatically creates a .zip deployment package or container image with your function code and any 
dependencies you specify. To learn more about using AWS SAM to build and deploy Lambda functions, 
see Getting started with AWS SAM in the AWS Serverless Application Model Developer Guide.
You can also use AWS SAM to create a Lambda function using an existing .zip ﬁle archive. To create a 
Lambda function using AWS SAM, you can save your .zip ﬁle in an Amazon S3 bucket or in a local folder 
on your build machine. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
CLI, see Move objects in the AWS CLI User Guide.
In your AWS SAM template, the AWS::Serverless::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - set to Zip
•CodeUri - set to the function code's Amazon S3 URI, path to local folder, or FunctionCode object
•Runtime - Set to your chosen runtime
With AWS SAM, if your .zip ﬁle is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket 
ﬁrst. AWS SAM can upload .zip packages up to the maximum allowed size of 250MB (unzipped) from a 
location on your local build machine.
To learn more about deploying functions using .zip ﬁle in AWS SAM, see AWS::Serverless::Function in the
AWS SAM Developer Guide.
Creating and updating functions with .zip ﬁles using AWS 
CloudFormation
You can use AWS CloudFormation to create a Lambda function using a .zip ﬁle archive. To create a 
Lambda function from a .zip ﬁle, you must ﬁrst upload your ﬁle to an Amazon S3 bucket. For instructions 
on how to upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User 
Guide.
For Node.js and Python runtimes, you can also provide inline source code in your AWS CloudFormation 
template. AWS CloudFormation then creates a .zip ﬁle containing your code when you build your 
function.
Using an existing .zip ﬁle
In your AWS CloudFormation template, the AWS::Lambda::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - Set to Zip
•Code - Enter the Amazon S3 bucket name and the .zip ﬁle name in the S3Bucket  and S3Key  ﬁelds
•Runtime - Set to your chosen runtime
Creating a .zip ﬁle from inline code
You can declare simple functions written in Python or Node.js inline in an AWS CloudFormation 
template. Because the code is embedded in YAML or JSON, you can't add any external dependenices 
to your deployment package. This means your function has to use the version of the AWS SDK that's 
included in the runtime. The requirements of the template, such as having to escape certain characters, 
360AWS Lambda Developer Guide
Creating and updating Python 
Lambda functions using .zip ﬁles
also make it harder to use your IDE's syntax checking and code completion features. This means that your 
template might require additional testing. Beacuse of these limitations, declaring functions inline is best 
suited for very simple code that does not change frequently.
To create a .zip ﬁle from inline code for Node.js and Python runtimes, set the following properties in your 
template’s AWS::Lambda::Function  resource:
•PackageType  - Set to Zip
•Code - Enter your function code in the ZipFile  ﬁeld
•Runtime - Set to your chosen runtime
The .zip ﬁle that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying 
functions using .zip ﬁle in AWS CloudFormation, see AWS::Lambda::Function in the AWS CloudFormation 
User Guide .
361AWS Lambda Developer Guide
Deploy container images
Deploy Python Lambda functions with container 
images
There are three ways to build a container image for a Python Lambda function:
•Using an AWS base image for Python (p. 363)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, 
and code to these images. To make the image compatible with Lambda, you must include the runtime 
interface client for Python (p. 366) in the image.
•Using a non-AWS base image (p. 366)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the runtime interface client for Python (p. 366) in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
Topics
•AWS base images for Python (p. 362)
•Using an AWS base image for Python (p. 363)
•Using an alternative base image with the runtime interface client (p. 366)
AWS base images for Python
AWS provides the following base images for Python:
Tags Runtime Operating 
systemDockerﬁle Deprecation
3.11 Python 3.11 Amazon 
Linux 2Dockerﬁle for Python 3.11 on 
GitHub
3.10 Python 3.10 Amazon 
Linux 2Dockerﬁle for Python 3.10 on 
GitHub
3.9 Python 3.9 Amazon 
Linux 2Dockerﬁle for Python 3.9 on 
GitHub
3.8 Python 3.8 Amazon 
Linux 2Dockerﬁle for Python 3.8 on 
GitHub
362AWS Lambda Developer Guide
Using an AWS base image
Tags Runtime Operating 
systemDockerﬁle Deprecation
3.7Python 3.7Amazon 
LinuxDockerﬁle for Python 3.7 on 
GitHubNov 27, 2023
Amazon ECR repository: gallery.ecr.aws/lambda/python
Dependency search path in the base images
When you use an import statement in your code, the Python runtime searches the directories 
in its search path until it ﬁnds the module or package. By default, the runtime searches the
{LAMBDA_TASK_ROOT}  directory ﬁrst. If you include a version of a runtime-included library in your 
image, your version will take precedence over the version that's included in the runtime.
Other steps in the search path depend on which version of the Lambda base image for Python you're 
using:
•Python 3.11: Runtime-included libraries and pip-installed libraries are installed in the /var/lang/
lib/python3.11/site-packages  directory. This directory has precedence over /var/runtime  in 
the search path. You can override the SDK by using pip to install a newer version. You can use pip to 
verify that the runtime-included SDK and its dependencies are compatible with any packages that you 
install.
•Python 3.7-3.10: Runtime-included libraries are installed in the /var/runtime  directory. Pip-
installed libraries are installed in the /var/lang/lib/python3.x/site-packages  directory. The /
var/runtime  directory has precedence over /var/lang/lib/python3.x/site-packages  in the 
search path.
You can see the full search path for your Lambda function by adding the following code snippet.
import sys 
       
search_path = sys.path
print(search_path)
Using an AWS base image for Python
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Python
Creating an image from a base image
To create a container image from an AWS base image for Python
1. Create a directory for the project, and then switch to that directory.
mkdir example
363AWS Lambda Developer Guide
Using an AWS base image
cd example
2. Create a new ﬁle called lambda_function.py . You can add the following sample function code to 
the ﬁle for testing, or use your own.
Example Python function
import sys
def handler(event, context): 
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
3. Create a new ﬁle called requirements.txt . If you're using the sample function code from the 
previous step, you can leave the ﬁle empty because there are no dependencies. Otherwise, list each 
required library. For example, here's what your requirements.txt  should look like if your function 
uses the AWS SDK for Python (Boto3):
Example requirements.txt
boto3
4. Create a new Dockerﬁle with the following conﬁguration:
•Set the FROM property to the URI of the base image .
•Use the COPY command to copy the function code and runtime dependencies to
{LAMBDA_TASK_ROOT} .
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM public.ecr.aws/lambda/python:3.11
# Copy requirements.txt
COPY requirements.txt ${LAMBDA_TASK_ROOT}
# Copy function code
COPY lambda_function.py ${LAMBDA_TASK_ROOT}
# Install the specified packages
RUN pip install -r requirements.txt
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
CMD [ "lambda_function.handler" ]
5. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
364AWS Lambda Developer Guide
Using an AWS base image
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
365AWS Lambda Developer Guide
Using a non-AWS base image
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using an alternative base image with the runtime 
interface clientIf you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
the runtime interface client in your image. The runtime interface client extends the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code.
366AWS Lambda Developer Guide
Using a non-AWS base image
Install the the runtime interface client for Python using the pip package manager:
pip install awslambdaric
You can also download the Python runtime interface client from GitHub.
The following example demonstrates how to build a container image for Python using a non-AWS base 
image. The example Dockerﬁle uses an oﬃcial Python base image. The Dockerﬁle includes the runtime 
interface client for Python.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Python
Creating an image from an alternative base image
To create a container image from a non-AWS base image
1. Create a directory for the project, and then switch to that directory.
mkdir example
cd example
2. Create a new ﬁle called lambda_function.py . You can add the following sample function code to 
the ﬁle for testing, or use your own.
Example Python function
import sys
def handler(event, context): 
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
3. Create a new ﬁle called requirements.txt . If you're using the sample function code from the 
previous step, you can leave the ﬁle empty because there are no dependencies. Otherwise, list each 
required library. For example, here's what your requirements.txt  should look like if your function 
uses the AWS SDK for Python (Boto3):
Example requirements.txt
boto3
4. Create a new Dockerﬁle. The following Dockerﬁle uses an oﬃcial Python base image instead of an
AWS base image (p. 123). The Dockerﬁle includes the runtime interface client, which makes the 
image compatible with Lambda. The following example Dockerﬁle uses a multi-stage build .
•Set the FROM property to the base image.
•Set the ENTRYPOINT  to the module that you want the Docker container to run when it starts. In 
this case, the module is the runtime interface client.
•Set the CMD to the Lambda function handler.
367AWS Lambda Developer Guide
Using a non-AWS base image
Example Dockerﬁle
# Define custom function directory
ARG FUNCTION_DIR="/function"
FROM python:3.11  as build-image
# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}
# Install the function's dependencies
RUN pip install \ 
    --target ${FUNCTION_DIR} \ 
        awslambdaric
# Use a slim version of the base Python image to reduce the final image size
FROM python:3.11-slim
# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}
# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}
# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ " /usr/local/bin/python", "-m", "awslambdaric " ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "lambda_function.handler " ]
5. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test the image. You can build the emulator into 
your image (p. 130) or install it on your local machine.
To install and run the runtime interface emulator on your local machine
1. From your project directory, run the following command to download the runtime interface 
emulator (x86-64 architecture) from GitHub and install it on your local machine.
mkdir -p ~/.aws-lambda-rie && \ 
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-
runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \ 
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:
368AWS Lambda Developer Guide
Using a non-AWS base image
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
2. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•/usr/local/bin/python -m awslambdaric lambda_function.handler  is the
ENTRYPOINT  followed by the CMD from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/local/bin/python -m awslambdaric lambda_function.handler
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
3. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
4. Get the container ID.
docker ps
5. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
369AWS Lambda Developer Guide
Using a non-AWS base image
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
370AWS Lambda Developer Guide
Using a non-AWS base image
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
For an example of how to create a Python image from an Alpine base image, see Container image 
support for Lambda on the AWS Blog.
371AWS Lambda Developer Guide
Context
AWS Lambda context object in Python
When Lambda runs your function, it passes a context object to the handler  (p. 348). This object provides 
methods and properties that provide information about the invocation, function, and execution 
environment. For more information on how the context object is passed to the function handler, see
Lambda function handler in Python (p. 348).
Context methods
•get_remaining_time_in_millis  – Returns the number of milliseconds left before the execution 
times out.
Context properties
•function_name  – The name of the Lambda function.
•function_version  – The version (p. 108) of the function.
•invoked_function_arn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•memory_limit_in_mb  – The amount of memory that's allocated for the function.
•aws_request_id  – The identiﬁer of the invocation request.
•log_group_name  – The log group for the function.
•log_stream_name  – The log stream for the function instance.
•identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•cognito_identity_id  – The authenticated Amazon Cognito identity.
•cognito_identity_pool_id  – The Amazon Cognito identity pool that authorized the invocation.
•client_context  – (mobile apps) Client context that's provided to Lambda by the client application.
•client.installation_id
•client.app_title
•client.app_version_name
•client.app_version_code
•client.app_package_name
•custom  – A dict of custom values set by the mobile client application.
•env – A dict of environment information provided by the AWS SDK.
The following example shows a handler function that logs context information.
Example handler.py
import time
def lambda_handler(event, context):    
    print("Lambda function ARN:", context.invoked_function_arn) 
    print("CloudWatch log stream name:", context.log_stream_name) 
    print("CloudWatch log group name:",  context.log_group_name) 
    print("Lambda Request ID:", context.aws_request_id) 
    print("Lambda function memory limits in MB:", context.memory_limit_in_mb) 
    # We have added a 1 second delay so you can see the time remaining in 
 get_remaining_time_in_millis. 
    time.sleep(1)  
    print("Lambda time remaining in MS:", context.get_remaining_time_in_millis())
372AWS Lambda Developer Guide
Context
In addition to the options listed above, you can also use the AWS X-Ray SDK for Instrumenting Python 
code in AWS Lambda (p. 392) to identify critical code paths, trace their performance and capture the 
data for analysis.
373AWS Lambda Developer Guide
Logging
AWS Lambda function logging in Python
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
To output logs from your function code, you can use logging library that writes to stdout or stderr. For 
simple use cases, this approach might be suﬃcient.
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, the CloudWatch console, or Infrastructure as 
code tools such as the AWS Serverless Application Model(AWS SAM).
Sections
•Tools and libraries (p. 374)
•Creating a function that returns logs (p. 374)
•Using Powertools for AWS Lambda (Python) and AWS SAM for structured logging (p. 375)
•Using Powertools for AWS Lambda (Python) and the AWS CDK for structured logging (p. 378)
•Using the Lambda console (p. 382)
•Using the CloudWatch console (p. 382)
•Using the AWS Command Line Interface (AWS CLI) (p. 383)
•Deleting logs  (p. 385)
•Logging library (p. 385)
Tools and libraries
Powertools for AWS Lambda (Python) is a developer toolkit to implement Serverless best practices 
and increase developer velocity. The Logger utility provides a Lambda optimized logger which includes 
additional information about function context across all your functions with output structured as JSON. 
Use this utility to do the following:
•Capture key ﬁelds from the Lambda context, cold start and structures logging output as JSON
•Log Lambda invocation events when instructed (disabled by default)
•Print all the logs only for a percentage of invocations via log sampling (disabled by default)
•Append additional keys to structured log at any point in time
•Use a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with 
your organization’s Logging RFC
Creating a function that returns logs
To output logs from your function code, you can use the print  method , or any logging library that 
writes to stdout  or stderr. The following example logs the values of the Amazon CloudWatch Logs 
group and stream for the function and the event object.
Example lambda_function.py
import os
def lambda_handler(event, context): 
    print('## ENVIRONMENT VARIABLES') 
374AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and AWS SAM for structured logging
    print(os.environ['AWS_LAMBDA_LOG_GROUP_NAME']) 
    print(os.environ['AWS_LAMBDA_LOG_STREAM_NAME']) 
    print('## EVENT') 
    print(event)
Example log format
START RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95 Version: $LATEST
## ENVIRONMENT VARIABLES
/aws/lambda/my-function
2020/01/31/[$LATEST]3893xmpl7fac4485b47bb75b671a283c
## EVENT
{'key': 'value'}
END RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95
REPORT RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95  Duration: 15.74 ms  Billed 
 Duration: 16 ms Memory Size: 128 MB Max Memory Used: 56 MB  Init Duration: 130.49 ms
XRAY TraceId: 1-5e34a614-10bdxmplf1fb44f07bc535a1   SegmentId: 07f5xmpl2d1f6f85 Sampled: 
 true    
The Python runtime logs the START , END, and REPORT lines for each invocation. The report line provides 
the following details.
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
Using Powertools for AWS Lambda (Python) and AWS 
SAM for structured logging
Follow the steps below to download, build, and deploy a sample Hello World Python application with 
integrated Powertools for Python modules using the AWS SAM. This application implements a basic 
API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon API 
Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway endpoint, 
the Lambda function invokes, sends logs and metrics using Embedded Metric Format to CloudWatch, and 
sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Python 3.9
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
375AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and AWS SAM for structured logging
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World Python template.
sam init --app-template hello-world-powertools-python --name sam-app --package-type Zip 
 --runtime python3.9 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name sam-app
The log output looks like this:
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:50.371000 
 INIT_START Runtime Version: python:3.9.v16    Runtime Version ARN: arn:aws:lambda:us-
east-1::runtime:07a48df201798d627f2b950f03bb227aab4a655a1d019c3296406f95937e2525
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.112000 START 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be Version: $LATEST
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.114000 { 
  "level": "INFO", 
  "location": "hello:23", 
  "message": "Hello world API - HTTP 200", 
  "timestamp": "2023-02-03 14:59:51,113+0000", 
  "service": "PowertoolsHelloWorld", 
  "cold_start": true, 
  "function_name": "sam-app-HelloWorldFunction-YBg8yfYtOc9j", 
  "function_memory_size": "128", 
  "function_arn": "arn:aws:lambda:us-east-1:111122223333:function:sam-app-
HelloWorldFunction-YBg8yfYtOc9j", 
  "function_request_id": "d455cfc4-7704-46df-901b-2a5cce9405be", 
376AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and AWS SAM for structured logging
  "correlation_id": "e73f8aef-5e07-436e-a30b-63e4b23f0047", 
  "xray_trace_id": "1-63dd2166-434a12c22e1307ff2114f299"
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.126000 { 
  "_aws": { 
    "Timestamp": 1675436391126, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "Powertools", 
        "Dimensions": [ 
          [ 
            "function_name", 
            "service" 
          ] 
        ], 
        "Metrics": [ 
          { 
            "Name": "ColdStart", 
            "Unit": "Count" 
          } 
        ] 
      } 
    ] 
  }, 
  "function_name": "sam-app-HelloWorldFunction-YBg8yfYtOc9j", 
  "service": "PowertoolsHelloWorld", 
  "ColdStart": [ 
    1.0 
  ]
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.126000 { 
  "_aws": { 
    "Timestamp": 1675436391126, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "Powertools", 
        "Dimensions": [ 
          [ 
            "service" 
          ] 
        ], 
        "Metrics": [ 
          { 
            "Name": "HelloWorldInvocations", 
            "Unit": "Count" 
          } 
        ] 
      } 
    ] 
  }, 
  "service": "PowertoolsHelloWorld", 
  "HelloWorldInvocations": [ 
    1.0 
  ]
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.128000 END 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.128000 REPORT 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be    Duration: 16.33 ms    Billed 
 Duration: 17 ms    Memory Size: 128 MB    Max Memory Used: 64 MB    Init Duration: 
 739.46 ms     
XRAY TraceId: 1-63dd2166-434a12c22e1307ff2114f299    SegmentId: 3c5d18d735a1ced0    
 Sampled: true
377AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and the AWS CDK for structured logging
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Managing log retention
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which CloudWatch automatically deletes the 
logs. To set up log retention, add the following to your AWS SAM template:
Resources: 
  HelloWorldFunction: 
    Type: AWS::Serverless::Function 
    Properties: 
      # Omitting other properties 
  LogGroup: 
    Type: AWS::Logs::LogGroup 
    Properties: 
      LogGroupName: !Sub "/aws/lambda/${HelloWorldFunction}" 
      RetentionInDays: 7
Using Powertools for AWS Lambda (Python) and the 
AWS CDK for structured logging
Follow the steps below to download, build, and deploy a sample Hello World Python application 
with integrated Powertools for AWS Lambda (Python) modules using the AWS CDK. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
•Python 3.9
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language python
378AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and the AWS CDK for structured logging
3. Install the Python dependencies.
pip install -r requirements.txt
4. Create a directory lambda_function under the root folder.
mkdir lambda_function
cd lambda_function
5. Create a ﬁle app.py and add the following code to the ﬁle. This is the code for the Lambda function.
from aws_lambda_powertools.event_handler import APIGatewayRestResolver
from aws_lambda_powertools.utilities.typing import LambdaContext
from aws_lambda_powertools.logging import correlation_paths
from aws_lambda_powertools import Logger
from aws_lambda_powertools import Tracer
from aws_lambda_powertools import Metrics
from aws_lambda_powertools.metrics import MetricUnit
app = APIGatewayRestResolver()
tracer = Tracer()
logger = Logger()
metrics = Metrics(namespace="PowertoolsSample")
@app.get("/hello")
@tracer.capture_method
def hello(): 
    # adding custom metrics 
    # See: https://docs.powertools.aws.dev/lambda-python/latest/core/metrics/ 
    metrics.add_metric(name="HelloWorldInvocations", unit=MetricUnit.Count, value=1) 
    # structured log 
    # See: https://docs.powertools.aws.dev/lambda-python/latest/core/logger/ 
    logger.info("Hello world API - HTTP 200") 
    return {"message": "hello world"}
# Enrich logging with contextual information from Lambda
@logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
# Adding tracer
# See: https://docs.powertools.aws.dev/lambda-python/latest/core/tracer/
@tracer.capture_lambda_handler
# ensures metrics are flushed upon request completion/failure and capturing ColdStart 
 metric
@metrics.log_metrics(capture_cold_start_metric=True)
def lambda_handler(event: dict, context: LambdaContext) -> dict: 
    return app.resolve(event, context)
6. Open the hello_world directory. You should see a ﬁle called hello_world_stack.py.
cd ..
cd hello_world
7. Open hello_world_stack.py and add the following code to the ﬁle. This contains the Lambda 
Constructor, which creates the Lambda function, conﬁgures environment variables for Powertools 
and sets log retention to one week, and the  ApiGatewayv1 Constructor, which creates the REST API.
from aws_cdk import ( 
    Stack, 
    aws_apigateway as apigwv1, 
    aws_lambda as lambda_, 
    CfnOutput, 
    Duration
379AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and the AWS CDK for structured logging
)
from constructs import Construct
class HelloWorldStack(Stack): 
    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None: 
        super().__init__(scope, construct_id, **kwargs) 
        # Powertools Lambda Layer 
        powertools_layer = lambda_.LayerVersion.from_layer_version_arn( 
            self, 
            id="lambda-powertools", 
            # At the moment we wrote this example, the aws_lambda_python_alpha CDK 
 constructor is in Alpha, o we use layer to make the example simpler 
            # See https://docs.aws.amazon.com/cdk/api/v2/python/
aws_cdk.aws_lambda_python_alpha/README.html 
            # Check all Powertools layers versions here: https://
docs.powertools.aws.dev/lambda-python/latest/#lambda-layer 
            layer_version_arn=f"arn:aws:lambda:
{self.region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:21" 
        ) 
        function = lambda_.Function(self, 
            'sample-app-lambda', 
            runtime=lambda_.Runtime.PYTHON_3_9, 
            layers=[powertools_layer], 
            code = lambda_.Code.from_asset("./lambda_function/"), 
            handler="app.lambda_handler", 
            memory_size=128, 
            timeout=Duration.seconds(3), 
            architecture=lambda_.Architecture.X86_64, 
            environment={ 
                "POWERTOOLS_SERVICE_NAME": "PowertoolsHelloWorld", 
                "POWERTOOLS_METRICS_NAMESPACE": "PowertoolsSample", 
                "LOG_LEVEL": "INFO" 
            } 
        ) 
        apigw = apigwv1.RestApi(self, "PowertoolsAPI", 
 deploy_options=apigwv1.StageOptions(stage_name="dev")) 
        hello_api = apigw.root.add_resource("hello") 
        hello_api.add_method("GET", apigwv1.LambdaIntegration(function, proxy=True)) 
        CfnOutput(self, "apiUrl", value=f"{apigw.url}hello")
8. Deploy your application.
cd ..
cdk deploy
9. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?OutputKey==`apiUrl`].OutputValue' --output text
10. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
380AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Python) 
and the AWS CDK for structured logging
{"message":"hello world"}
11. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name HelloWorldStack
The log output looks like this:
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:50.371000 
 INIT_START Runtime Version: python:3.9.v16    Runtime Version ARN: arn:aws:lambda:us-
east-1::runtime:07a48df201798d627f2b950f03bb227aab4a655a1d019c3296406f95937e2525
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.112000 START 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be Version: $LATEST
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.114000 { 
  "level": "INFO", 
  "location": "hello:23", 
  "message": "Hello world API - HTTP 200", 
  "timestamp": "2023-02-03 14:59:51,113+0000", 
  "service": "PowertoolsHelloWorld", 
  "cold_start": true, 
  "function_name": "sam-app-HelloWorldFunction-YBg8yfYtOc9j", 
  "function_memory_size": "128", 
  "function_arn": "arn:aws:lambda:us-east-1:111122223333:function:sam-app-
HelloWorldFunction-YBg8yfYtOc9j", 
  "function_request_id": "d455cfc4-7704-46df-901b-2a5cce9405be", 
  "correlation_id": "e73f8aef-5e07-436e-a30b-63e4b23f0047", 
  "xray_trace_id": "1-63dd2166-434a12c22e1307ff2114f299"
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.126000 { 
  "_aws": { 
    "Timestamp": 1675436391126, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "Powertools", 
        "Dimensions": [ 
          [ 
            "function_name", 
            "service" 
          ] 
        ], 
        "Metrics": [ 
          { 
            "Name": "ColdStart", 
            "Unit": "Count" 
          } 
        ] 
      } 
    ] 
  }, 
  "function_name": "sam-app-HelloWorldFunction-YBg8yfYtOc9j", 
  "service": "PowertoolsHelloWorld", 
  "ColdStart": [ 
    1.0 
  ]
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.126000 { 
  "_aws": { 
    "Timestamp": 1675436391126, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "Powertools", 
381AWS Lambda Developer Guide
Using the Lambda console
        "Dimensions": [ 
          [ 
            "service" 
          ] 
        ], 
        "Metrics": [ 
          { 
            "Name": "HelloWorldInvocations", 
            "Unit": "Count" 
          } 
        ] 
      } 
    ] 
  }, 
  "service": "PowertoolsHelloWorld", 
  "HelloWorldInvocations": [ 
    1.0 
  ]
}
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.128000 END 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be
2023/02/03/[$LATEST]ea9a64ec87294bf6bbc9026c05a01e04 2023-02-03T14:59:51.128000 REPORT 
 RequestId: d455cfc4-7704-46df-901b-2a5cce9405be    Duration: 16.33 ms    Billed 
 Duration: 17 ms    Memory Size: 128 MB    Max Memory Used: 64 MB    Init Duration: 
 739.46 ms     
XRAY TraceId: 1-63dd2166-434a12c22e1307ff2114f299    SegmentId: 3c5d18d735a1ced0    
 Sampled: true
12. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
382AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
383AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
384AWS Lambda Developer Guide
Deleting logs
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
Logging library
For more detailed logs, use the logging library.
import os
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
def lambda_handler(event, context): 
    logger.info('## ENVIRONMENT VARIABLES') 
    logger.info(os.environ['AWS_LAMBDA_LOG_GROUP_NAME']) 
    logger.info(os.environ['AWS_LAMBDA_LOG_STREAM_NAME']) 
    logger.info('## EVENT') 
    logger.info(event)
The output from logger includes the log level, timestamp, and request ID.
START RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125 Version: $LATEST
[INFO]  2020-01-31T22:12:58.534Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    ## ENVIRONMENT 
 VARIABLES
[INFO]  2020-01-31T22:12:58.534Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    /aws/lambda/my-
function
[INFO]  2020-01-31T22:12:58.534Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    2020/01/31/
[$LATEST]1bbe51xmplb34a2788dbaa7433b0aa4d
[INFO]  2020-01-31T22:12:58.535Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    ## EVENT
[INFO]  2020-01-31T22:12:58.535Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    {'key': 
 'value'}
END RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125
REPORT RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125  Duration: 2.75 ms   Billed 
 Duration: 3 ms Memory Size: 128 MB Max Memory Used: 56 MB  Init Duration: 113.51 ms
XRAY TraceId: 1-5e34a66a-474xmpl7c2534a87870b4370   SegmentId: 073cxmpl3e442861 Sampled: 
 true
385AWS Lambda Developer Guide
Testing
AWS Lambda function testing in Python
Note
See the Testing functions (p. 261) chapter for a complete introduction to techniques and best 
practices for testing serverless solutions.
Testing serverless functions uses traditional test types and techniques, but you must also consider 
testing serverless applications as a whole. Cloud-based tests will provide the most accurate measure of 
quality of both your functions and serverless applications.
A serverless application architecture includes managed services that provide critical application 
functionality through API calls. For this reason, your development cycle should include automated tests 
that verify functionality when your function and services interact.
If you do not create cloud-based tests, you could encounter issues due to diﬀerences between your 
local environment and the deployed environment. Your continuous integration process should run tests 
against a suite of resources provisioned in the cloud before promoting your code to the next deployment 
environment, such as QA, Staging, or Production.
Continue reading this short guide to learn about testing strategies for serverless applications, or visit the
Serverless Test Samples repository to dive in with practical examples, speciﬁc to your chosen language 
and runtime.
For serverless testing, you will still write unit, integration  and end-to-end  tests.
•Unit tests  - Tests that run against an isolated block of code. For example, verifying the business logic 
to calculate the delivery charge given a particular item and destination.
•Integration tests  - Tests involving two or more components or services that interact, typically in a 
cloud environment. For example, verifying a function processes events from a queue.
•End-to-end tests  - Tests that verify behavior across an entire application. For example, ensuring 
infrastructure is set up correctly and that events ﬂow between services as expected to record a 
customer's order.
Testing your serverless applications
You will generally use a mix of approaches to test your serverless application code, including testing in 
the cloud, testing with mocks, and occasionally testing with emulators.
386AWS Lambda Developer Guide
Testing your serverless applications
Testing in the cloud
Testing in the cloud is valuable for all phases of testing, including unit tests, integration tests, and end-
to-end tests. You run tests against code deployed in the cloud and interacting with cloud-based services. 
This approach provides the most accurate measure of quality of your code.
A convenient way to debug your Lambda function in the cloud is through the console with a test event. 
A test event  is a JSON input to your function. If your function does not require input, the event can be an 
empty JSON document ({}). The console provides sample events for a variety of service integrations. 
After creating an event in the console, you can share it with your team to make testing easier and 
consistent.
Note
Testing a function in the console (p. 137) is a quick way to get started, but automating your test 
cycles ensures application quality and development speed.
Testing tools
Tools and techniques exist to accelerate development feedback loops. For example, AWS SAM Accelerate
and AWS CDK watch mode both decrease the time required to update cloud environments.
Moto  is a Python library for mocking AWS services and resources, so that you can test your functions 
with little or no modiﬁcation using decorators to intercept and simulate responses.
The validation feature of the Powertools for AWS Lambda (Python) provides decorators so you can 
validate input events and output responses from your Python functions.
For more information, read the blog post Unit Testing Lambda with Python and Mock AWS Services.
To reduce the latency involved with cloud deployment iterations, see AWS Serverless Application Model 
(AWS SAM) Accelerate, AWS Cloud Development Kit (AWS CDK) watch mode. These tools monitor your 
infrastructure and code for changes. They react to these changes by creating and deploying incremental 
updates automatically into your cloud environment.
Examples that use these tools are available in the Python Test Samples code repository.
387AWS Lambda Developer Guide
Errors
AWS Lambda function errors in Python
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the Python runtime using the 
Lambda console and the AWS CLI.
Sections
•How it works (p. 388)
•Using the Lambda console (p. 389)
•Using the AWS Command Line Interface (AWS CLI) (p. 389)
•Error handling in other AWS services (p. 390)
•Error examples (p. 390)
•Sample applications  (p. 391)
•What's next? (p. 307)
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
388AWS Lambda Developer Guide
Using the Lambda console
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
389AWS Lambda Developer Guide
Error handling in other AWS services
cat output.txt
You should see the invocation response in your command prompt.
{"errorMessage": "'action'", "errorType": "KeyError", "stackTrace": ["  File \"/var/task/
lambda_function.py\", line 36, in lambda_handler\n    result = ACTIONS[event['action']]
(event['number'])\n"]}
Lambda also records up to 256 KB of the error object in the function's logs. For more information, see
AWS Lambda function logging in Python (p. 374).
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
For more information, see Instrumenting Python code in AWS Lambda (p. 392).
Error examples
The following section shows common errors you may receive when creating, updating, or invoking your 
function using the Python Lambda runtimes  (p. 41).
Example Runtime exception – ImportError
{ 
  "errorMessage": "Unable to import module 'lambda_function': Cannot import name '_imaging' 
 from 'PIL' (/var/task/PIL/__init__.py)", 
  "errorType": "Runtime.ImportModuleError"
}
This error is a result of using the AWS Command Line Interface (AWS CLI) to upload a deployment 
package that contains a C or C++ library. For example, the Pillow (PIL), numpy, or pandas  library.
We recommend using the AWS SAM CLI sam build  command with the --use-container  option to 
create your deployment package. Using the AWS SAM CLI with this option creates a Docker container 
with a Lambda-like environment that is compatible with Lambda.
390AWS Lambda Developer Guide
Sample applications
Example JSON serialization error – Runtime.MarshalError
{ 
  "errorMessage": "Unable to marshal response: Object of type AttributeError is not JSON 
 serializable", 
  "errorType": "Runtime.MarshalError"
}
This error can be the result of the base64-encoding mechanism you are using in your function code. For 
example:
import base64
encrypted_data = base64.b64encode(payload_enc).decode("utf-8")
This error can also be the result of not specifying your .zip ﬁle as a binary ﬁle when you created or 
updated your function. We recommend using the ﬁleb://  command option to upload your deployment 
package (.zip ﬁle).
aws lambda create-function --function-name my-function --zip-file fileb://my-deployment-
package.zip --handler lambda_function.lambda_handler --runtime python3.8 --role 
 arn:aws:iam::your-account-id:role/lambda-ex
Sample applications
The GitHub repository for this guide includes sample applications that demonstrate the use of the 
errors. Each sample application includes scripts for easy deployment and cleanup, an AWS Serverless 
Application Model (AWS SAM) template, and supporting resources.
Sample Lambda applications in Python
•blank-python – A Python function that shows the use of logging, environment variables, AWS X-Ray 
tracing, layers, unit tests and the AWS SDK.
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 374) page.
391AWS Lambda Developer Guide
Tracing
Instrumenting Python code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of three SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for Python – An SDK for generating and sending trace data to X-Ray.
•Powertools for AWS Lambda (Python) – A developer toolkit to implement Serverless best practices and 
increase developer velocity.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using Powertools for AWS Lambda (Python) and AWS SAM for tracing (p. 392)
•Using Powertools for AWS Lambda (Python) and the AWS CDK for tracing (p. 378)
•Using ADOT to instrument your Python functions (p. 398)
•Using the X-Ray SDK to instrument your Python functions (p. 398)
•Activating tracing with the Lambda console (p. 398)
•Activating tracing with the Lambda API (p. 399)
•Activating tracing with AWS CloudFormation (p. 399)
•Interpreting an X-Ray trace (p. 399)
•Storing runtime dependencies in a layer (X-Ray SDK) (p. 401)
Using Powertools for AWS Lambda (Python) and AWS 
SAM for tracing
Follow the steps below to download, build, and deploy a sample Hello World Python application 
with integrated Powertools for AWS Lambda (Python) modules using the AWS SAM. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
392AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Python) and AWS SAM for tracing
•Python 3.9
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World Python template.
sam init --app-template hello-world-powertools-python --name sam-app --package-type Zip 
 --runtime python3.9 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
New XRay Service Graph 
  Start time: 2023-02-03 14:59:50+00:00 
  End time: 2023-02-03 14:59:50+00:00 
  Reference Id: 0 - (Root) AWS::Lambda - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [1] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.924 
393AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Python) and the AWS CDK for tracing
  Reference Id: 1 - AWS::Lambda::Function - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.016 
  Reference Id: 2 - client - sam-app-HelloWorldFunction-YBg8yfYtOc9j - Edges: [0] 
   Summary_statistics: 
     - total requests: 0 
     - ok count(2XX): 0 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0
XRay Event [revision 1] at (2023-02-03T14:59:50.204000) with id 
 (1-63dd2166-434a12c22e1307ff2114f299) and duration (0.924s) 
 - 0.924s - sam-app-HelloWorldFunction-YBg8yfYtOc9j [HTTP: 200] 
 - 0.016s - sam-app-HelloWorldFunction-YBg8yfYtOc9j 
   - 0.739s - Initialization 
   - 0.016s - Invocation 
     - 0.013s - ## lambda_handler 
       - 0.000s - ## app.hello 
   - 0.000s - Overhead
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
Using Powertools for AWS Lambda (Python) and the 
AWS CDK for tracing
Follow the steps below to download, build, and deploy a sample Hello World Python application 
with integrated Powertools for AWS Lambda (Python) modules using the AWS CDK. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
•Python 3.9
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
394AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Python) and the AWS CDK for tracing
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language python
3. Install the Python dependencies.
pip install -r requirements.txt
4. Create a directory lambda_function under the root folder.
mkdir lambda_function
cd lambda_function
5. Create a ﬁle app.py and add the following code to the ﬁle. This is the code for the Lambda function.
from aws_lambda_powertools.event_handler import APIGatewayRestResolver
from aws_lambda_powertools.utilities.typing import LambdaContext
from aws_lambda_powertools.logging import correlation_paths
from aws_lambda_powertools import Logger
from aws_lambda_powertools import Tracer
from aws_lambda_powertools import Metrics
from aws_lambda_powertools.metrics import MetricUnit
app = APIGatewayRestResolver()
tracer = Tracer()
logger = Logger()
metrics = Metrics(namespace="PowertoolsSample")
@app.get("/hello")
@tracer.capture_method
def hello(): 
    # adding custom metrics 
    # See: https://docs.powertools.aws.dev/lambda-python/latest/core/metrics/ 
    metrics.add_metric(name="HelloWorldInvocations", unit=MetricUnit.Count, value=1) 
    # structured log 
    # See: https://docs.powertools.aws.dev/lambda-python/latest/core/logger/ 
    logger.info("Hello world API - HTTP 200") 
    return {"message": "hello world"}
# Enrich logging with contextual information from Lambda
@logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
# Adding tracer
# See: https://docs.powertools.aws.dev/lambda-python/latest/core/tracer/
@tracer.capture_lambda_handler
# ensures metrics are flushed upon request completion/failure and capturing ColdStart 
 metric
@metrics.log_metrics(capture_cold_start_metric=True)
def lambda_handler(event: dict, context: LambdaContext) -> dict: 
    return app.resolve(event, context)
6. Open the hello_world directory. You should see a ﬁle called hello_world_stack.py.
cd ..
395AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Python) and the AWS CDK for tracing
cd hello_world
7. Open hello_world_stack.py and add the following code to the ﬁle. This contains the Lambda 
Constructor, which creates the Lambda function, conﬁgures environment variables for Powertools 
and sets log retention to one week, and the  ApiGatewayv1 Constructor, which creates the REST API.
from aws_cdk import ( 
    Stack, 
    aws_apigateway as apigwv1, 
    aws_lambda as lambda_, 
    CfnOutput, 
    Duration
)
from constructs import Construct
class HelloWorldStack(Stack): 
    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None: 
        super().__init__(scope, construct_id, **kwargs) 
        # Powertools Lambda Layer 
        powertools_layer = lambda_.LayerVersion.from_layer_version_arn( 
            self, 
            id="lambda-powertools", 
            # At the moment we wrote this example, the aws_lambda_python_alpha CDK 
 constructor is in Alpha, o we use layer to make the example simpler 
            # See https://docs.aws.amazon.com/cdk/api/v2/python/
aws_cdk.aws_lambda_python_alpha/README.html 
            # Check all Powertools layers versions here: https://
docs.powertools.aws.dev/lambda-python/latest/#lambda-layer 
            layer_version_arn=f"arn:aws:lambda:
{self.region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:21" 
        ) 
        function = lambda_.Function(self, 
            'sample-app-lambda', 
            runtime=lambda_.Runtime.PYTHON_3_9, 
            layers=[powertools_layer], 
            code = lambda_.Code.from_asset("./lambda_function/"), 
            handler="app.lambda_handler", 
            memory_size=128, 
            timeout=Duration.seconds(3), 
            architecture=lambda_.Architecture.X86_64, 
            environment={ 
                "POWERTOOLS_SERVICE_NAME": "PowertoolsHelloWorld", 
                "POWERTOOLS_METRICS_NAMESPACE": "PowertoolsSample", 
                "LOG_LEVEL": "INFO" 
            } 
        ) 
        apigw = apigwv1.RestApi(self, "PowertoolsAPI", 
 deploy_options=apigwv1.StageOptions(stage_name="dev")) 
        hello_api = apigw.root.add_resource("hello") 
        hello_api.add_method("GET", apigwv1.LambdaIntegration(function, proxy=True)) 
        CfnOutput(self, "apiUrl", value=f"{apigw.url}hello")
8. Deploy your application.
cd ..
cdk deploy
9. Get the URL of the deployed application:
396AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Python) and the AWS CDK for tracing
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?OutputKey==`apiUrl`].OutputValue' --output text
10. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
11. To get the traces for the function, run sam traces.
sam traces
The traces output looks like this:
New XRay Service Graph 
  Start time: 2023-02-03 14:59:50+00:00 
  End time: 2023-02-03 14:59:50+00:00 
  Reference Id: 0 - (Root) AWS::Lambda - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [1] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.924 
  Reference Id: 1 - AWS::Lambda::Function - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.016 
  Reference Id: 2 - client - sam-app-HelloWorldFunction-YBg8yfYtOc9j - Edges: [0] 
   Summary_statistics: 
     - total requests: 0 
     - ok count(2XX): 0 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0
XRay Event [revision 1] at (2023-02-03T14:59:50.204000) with id 
 (1-63dd2166-434a12c22e1307ff2114f299) and duration (0.924s) 
 - 0.924s - sam-app-HelloWorldFunction-YBg8yfYtOc9j [HTTP: 200] 
 - 0.016s - sam-app-HelloWorldFunction-YBg8yfYtOc9j 
   - 0.739s - Initialization 
   - 0.016s - Invocation 
     - 0.013s - ## lambda_handler 
       - 0.000s - ## app.hello 
   - 0.000s - Overhead
12. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
397AWS Lambda Developer Guide
Using ADOT to instrument your Python functions
Using ADOT to instrument your Python functions
ADOT provides fully managed Lambda layers (p. 11) that package everything you need to collect 
telemetry data using the OTel SDK. By consuming this layer, you can instrument your Lambda functions 
without having to modify any function code. You can also conﬁgure your layer to do custom initialization 
of OTel. For more information, see Custom conﬁguration for the ADOT Collector on Lambda in the ADOT 
documentation.
For Python runtimes, you can add the AWS managed Lambda layer for ADOT Python to automatically 
instrument your functions. This layer works for both arm64 and x86_64 architectures. For detailed 
instructions on how to add this layer, see AWS Distro for OpenTelemetry Lambda Support for Python in 
the ADOT documentation.
Using the X-Ray SDK to instrument your Python 
functions
To record details about calls that your Lambda function makes to other resources in your application, you 
can also use the AWS X-Ray SDK for Python. To get the SDK, add the aws-xray-sdk  package to your 
application's dependencies.
Example requirements.txt
jsonpickle==1.3
aws-xray-sdk==2.4.3
In your function code, you can instrument AWS SDK clients by patching the boto3 library with the
aws_xray_sdk.core  module.
Example function – Tracing an AWS SDK client
import boto3
from aws_xray_sdk.core import xray_recorder
from aws_xray_sdk.core import patch_all
logger = logging.getLogger()
logger.setLevel(logging.INFO)
patch_all()
client = boto3.client('lambda')
client.get_account_settings()
def lambda_handler(event, context): 
    logger.info('## ENVIRONMENT VARIABLES\r' + jsonpickle.encode(dict(**os.environ))) 
  ...
After you add the correct dependencies and make the necessary code changes, activate tracing in your 
function's conﬁguration via the Lambda console or the API.
Activating tracing with the Lambda console
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
398AWS Lambda Developer Guide
Activating tracing with the Lambda API
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Activating tracing with the Lambda API
Conﬁgure tracing on your Lambda function with the AWS CLI or AWS SDK, use the following API 
operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Activating tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
Interpreting an X-Ray trace
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
399AWS Lambda Developer Guide
Interpreting an X-Ray trace
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
400AWS Lambda Developer Guide
Storing runtime dependencies in a layer (X-Ray SDK)
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see the AWS X-Ray SDK for Python in the AWS X-Ray 
Developer Guide .
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
Storing runtime dependencies in a layer (X-Ray SDK)
If you use the X-Ray SDK to instrument AWS SDK clients your function code, your deployment package 
can become quite large. To avoid uploading runtime dependencies every time you update your function 
code, package the X-Ray SDK in a Lambda layer (p. 988).
The following example shows an AWS::Serverless::LayerVersion  resource that stores the AWS X-
Ray SDK for Python.
Example template.yml – Dependencies layer
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: function/. 
      Tracing: Active 
       Layers: 
        - !Ref libs
      ... 
   libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-python-lib 
      Description: Dependencies for the blank-python sample app. 
      ContentUri: package/. 
      CompatibleRuntimes: 
        - python3.8
401AWS Lambda Developer Guide
Storing runtime dependencies in a layer (X-Ray SDK)
With this conﬁguration, you update the library layer only if you change your runtime dependencies. Since 
the function deployment package contains only your code, this can help reduce upload times.
Creating a layer for dependencies requires build changes to generate the layer archive prior to 
deployment. For a working example, see the blank-python sample application.
402AWS Lambda Developer Guide
Building Lambda functions with 
Ruby
You can run Ruby code in AWS Lambda. Lambda provides runtimes  (p. 41) for Ruby that run your code to 
process events. Your code runs in an environment that includes the AWS SDK for Ruby, with credentials 
from an AWS Identity and Access Management (IAM) role that you manage.
Lambda supports the following Ruby runtimes.
Ruby
Name Identiﬁer SDK Operating 
systemArchitectures Deprecation 
(Phase 1)
Ruby 3.2 ruby3.2 3.1.0 Amazon Linux 
2x86_64, arm64
Ruby 2.7 ruby2.7 3.1.0 Amazon Linux 
2x86_64, arm64 Dec 7, 2023
To create a Ruby function
1. Open the Lambda console.
2. Choose Create function.
3. Conﬁgure the following settings:
•Function name: Enter a name for the function.
•Runtime : Choose Ruby 3.2.
4. Choose Create function.
5. To conﬁgure a test event, choose Test.
6. For Event name, enter test .
7. Choose Save changes.
8. To invoke the function, choose Test.
The console creates a Lambda function with a single source ﬁle named lambda_function.rb . You can 
edit this ﬁle and add more ﬁles in the built-in code editor (p. 25). To save your changes, choose Save. 
Then, to run your code, choose Test.
Note
The Lambda console uses AWS Cloud9 to provide an integrated development environment 
in the browser. You can also use AWS Cloud9 to develop Lambda functions in your own 
environment. For more information, see Working with AWS Lambda functions using the AWS 
Toolkit in the AWS Cloud9 user guide.
The lambda_function.rb  ﬁle exports a function named lambda_handler  that takes an event 
object and a context object. This is the handler function (p. 405) that Lambda calls when the function 
is invoked. The Ruby function runtime gets invocation events from Lambda and passes them to the 
handler. In the function conﬁguration, the handler value is lambda_function.lambda_handler .
403AWS Lambda Developer Guide
Enabling Yet Another Ruby JIT (YJIT)
When you save your function code, the Lambda console creates a .zip ﬁle archive deployment package. 
When you develop your function code outside of the console (using an IDE) you need to create a 
deployment package (p. 406) to upload your code to the Lambda function.
Note
To get started with application development in your local environment, deploy one of the 
sample applications available in this guide's GitHub repository.
Sample Lambda applications in Ruby
•blank-ruby – A Ruby function that shows the use of logging, environment variables, AWS X-
Ray tracing, layers, unit tests and the AWS SDK.
•Ruby Code Samples for AWS Lambda – Code samples written in Ruby that demonstrate how 
to interact with AWS Lambda.
The function runtime passes a context object to the handler, in addition to the invocation event. The
context object (p. 423) contains additional information about the invocation, the function, and the 
execution environment. More information is available from environment variables.
Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details 
about each invocation to CloudWatch Logs. It relays any logs that your function outputs (p. 424) during 
invocation. If your function returns an error (p. 429), Lambda formats the error and returns it to the 
invoker.
Enabling Yet Another Ruby JIT (YJIT)
The Ruby 3.2 runtime supports YJIT, a lightweight, minimalistic Ruby JIT compiler. YJIT provides 
signiﬁcantly higher performance, but also uses more memory than the Ruby interpreter. YJIT is 
recommended for Ruby on Rails workloads.
YJIT is not enabled by default. To enable YJIT for a Ruby 3.2 function, set the RUBY_YJIT_ENABLE
environment variable to 1. To conﬁrm that YJIT is enabled, print the result of the
RubyVM::YJIT.enabled?  method.
Example — Conﬁrm that YJIT is enabled
puts(RubyVM::YJIT.enabled?())
# => true
Topics
•AWS Lambda function handler in Ruby (p. 405)
•Working with .zip ﬁle archives for Ruby Lambda functions (p. 406)
•Deploy Ruby Lambda functions with container images (p. 414)
•AWS Lambda context object in Ruby (p. 423)
•AWS Lambda function logging in Ruby (p. 424)
•AWS Lambda function errors in Ruby (p. 429)
•Instrumenting Ruby code in AWS Lambda (p. 433)
404AWS Lambda Developer Guide
Handler
AWS Lambda function handler in Ruby
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
In the following example, the ﬁle function.rb  deﬁnes a handler method named handler . The handler 
function takes two objects as input and returns a JSON document.
Example function.rb
require 'json'
def handler(event:, context:) 
    { event: JSON.generate(event), context: JSON.generate(context.inspect) }
end
In your function conﬁguration, the handler setting tells Lambda where to ﬁnd the handler. For the 
preceding example, the correct value for this setting is function.handler . It includes two names 
separated by a dot: the name of the ﬁle and the name of the handler method.
You can also deﬁne your handler method in a class. The following example deﬁnes a handler method 
named process  on a class named Handler  in a module named LambdaFunctions .
Example source.rb
module LambdaFunctions 
  class Handler 
    def self.process(event:,context:) 
      "Hello!" 
    end 
  end
end
In this case, the handler setting is source.LambdaFunctions::Handler.process .
The two objects that the handler accepts are the invocation event and context. The event is a Ruby 
object that contains the payload that's provided by the invoker. If the payload is a JSON document, 
the event object is a Ruby hash. Otherwise, it's a string. The context object (p. 423) has methods and 
properties that provide information about the invocation, the function, and the execution environment.
The function handler is executed every time your Lambda function is invoked. Static code outside of the 
handler is executed once per instance of the function. If your handler uses resources like SDK clients and 
database connections, you can create them outside of the handler method to reuse them for multiple 
invocations.
Each instance of your function can process multiple invocation events, but it only processes one event at 
a time. The number of instances processing an event at any given time is your function's concurrency. For 
more information about the Lambda execution environment, see Lambda execution environment (p. 14).
405AWS Lambda Developer Guide
Deploy Ruby .zip ﬁle archives
Working with .zip ﬁle archives for Ruby Lambda 
functions
Your AWS Lambda function’s code comprises a .rb ﬁle containing your function’s handler code, together 
with any additional dependencies (gems) your code depends on. To deploy this function code to Lambda, 
you use a deployment package . This package may either be a .zip ﬁle archive or a container image. For 
more information about using container images with Ruby, see Deploy Ruby Lambda functions with 
container images.
To create your deployment package as .zip ﬁle archive, you can use your command-line tool’s built-
in .zip ﬁle archive utility, or any other .zip ﬁle utility such as 7zip. The examples shown in the following 
sections assume you’re using a command-line zip tool in a Linux or MacOS environment. To use the 
same commands in Windows, you can install the Windows Subsystem for Linux to get a Windows-
integrated version of Ubuntu and Bash.
Note that Lambda uses POSIX ﬁle permissions, so you may need to set permissions for the deployment 
package folder  before you create the .zip ﬁle archive.
The example commands in the following sections use the Bundler  utility to add dependencies to your 
deployment package. To install bundler, run the following command.
gem install bundler
Sections
•Dependencies in Ruby (p. 406)
•Creating a .zip deployment package with no dependencies (p. 407)
•Creating a .zip deployment packaged with dependencies (p. 407)
•Creating .zip deployment packages with native libraries (p. 408)
•Creating and updating Ruby Lambda functions using .zip ﬁles (p. 409)
Dependencies in Ruby
For Lambda functions that use the Ruby runtime, a dependency can be any Ruby gem. When you deploy 
your function using a .zip archive, you can either add these dependencies to your .zip ﬁle with your 
function code or use a Lambda layer. A layer is a separate .zip ﬁle that can contain additional code and 
other content. To learn more about using Lambda layers, see Lambda layers  (p. 988).
Versions 2.7 and 3.2 of the Ruby runtime includes the AWS SDK for Ruby. If your function uses the SDK, 
you don't need to bundle it with your code. However, to maintain full control of your dependencies, 
or to use a speciﬁc version of the SDK, you can add it to your function's deployment package. You can 
either include the SDK in your .zip ﬁle, or add it using a Lambda layer. Dependencies in your .zip ﬁle or 
in Lambda layers take precedence over versions included in the runtime. To see which version of the SDK 
for Ruby is included in your runtime version, see Lambda runtimes  (p. 41).
Under the AWS shared responsibility model, you are responsible for the management of any 
dependencies in your functions' deployment packages. This includes applying updates and security 
patches. To update dependencies in your function's deployment package, ﬁrst create a new .zip ﬁle and 
then upload it to Lambda. See Creating a .zip deployment packaged with dependencies (p. 407) and
Creating and updating Ruby Lambda functions using .zip ﬁles (p. 409) for more information.
406AWS Lambda Developer Guide
Creating a .zip deployment package with no dependencies
Creating a .zip deployment package with no 
dependencies
If your function code has no dependencies, your .zip ﬁle contains only the .rb ﬁle with your function’s 
handler code. Use your preferred zip utility to create a .zip ﬁle with your .rb ﬁle at the root. If the .rb ﬁle 
is not at the root of your .zip ﬁle, Lambda won’t be able to run your code.
To learn how to deploy your .zip ﬁle to create a new Lambda function or update an existing one, see
Creating and updating Ruby Lambda functions using .zip ﬁles (p. 409).
Creating a .zip deployment packaged with 
dependencies
If your function code depends on additional Ruby gems, you can either add these dependencies to 
your .zip ﬁle with your function code or use a Lambda layer. The instructions in this section show you 
how to include dependencies in your .zip deployment package.
Suppose your function code is saved in a ﬁle named lambda_function.rb  in your project directory. 
The following example CLI commands create a .zip ﬁle named my_deployment_package.zip
containing your function code and its dependencies.
To create the deployment package
1. In your project directory, create a Gemfile to specify your dependencies in.
bundle init
2. Using your preferred text editor, edit the Gemfile to specify your function's dependencies. For 
example, to use the TZInfo gem, edit your Gemfile to look like the following.
source "https://rubygems.org"
gem "tzinfo"
3. Run the following command to install the gems speciﬁed in your Gemfile in your project directory. 
This command sets vendor/bundle  as the default path for gem installations.
bundle config set --local path 'vendor/bundle' && bundle install
You should see output similar to the following.
Fetching gem metadata from https://rubygems.org/...........
Resolving dependencies...
Using bundler 2.4.13
Fetching tzinfo 2.0.6
Installing tzinfo 2.0.6
...
Note
To install gems globally again later, run the following command.
bundle config set --local system 'true'
4. Create a .zip ﬁle archive containing the lambda_function.rb  ﬁle with your function's handler 
code and the dependencies you installed in the previous step.
407AWS Lambda Developer Guide
Creating .zip deployment packages with native libraries
zip -r my_deployment_package.zip lambda_function.rb vendor
You should see output similar to the following.
adding: lambda_function.rb (deflated 37%) 
  adding: vendor/ (stored 0%) 
  adding: vendor/bundle/ (stored 0%) 
  adding: vendor/bundle/ruby/ (stored 0%) 
  adding: vendor/bundle/ruby/3.2.0/ (stored 0%) 
  adding: vendor/bundle/ruby/3.2.0/build_info/ (stored 0%) 
  adding: vendor/bundle/ruby/3.2.0/cache/ (stored 0%) 
  adding: vendor/bundle/ruby/3.2.0/cache/aws-eventstream-1.0.1.gem (deflated 36%)
...
Creating .zip deployment packages with native 
libraries
Many common Ruby gems such as nokogiri , nio4r , and mysql contain native extensions written in 
C. When you add libraries containing C code to your deployment package, you must build your package 
correctly to ensure that it’s compatible with the Lambda execution environment.
For production applications, we recommend building and deploying your code using the AWS Serverless 
Application Model (AWS SAM). In AWS SAM use the sam build --use-container  option to build 
your function inside a Lambda-like Docker container. To learn more about using AWS SAM to deploy your 
function code, see Building applications  in the AWS SAM Developer Guide.
To create a .zip deployment package containing gems with native extensions without using AWS SAM, 
you can alternatively use a container to bundle your dependencies in an environment that is the same 
as the Lambda Ruby runtime environment. To complete these steps, you must have Docker installed on 
your build machine. To learn more about installing Docker, see Install Docker Engine.
To create a .zip deployment package in a Docker container
1. Create a folder on your local build machine to save your container in. Inside that folder, create a ﬁle 
named dockerfile  and paste the following code into it.
FROM public.ecr.aws/sam/build-ruby3.2:latest-x86_64
RUN gem update bundler  
CMD "/bin/bash"
2. Inside the folder you created your dockerfile  in, run the following command to create the Docker 
container.
docker build -t awsruby32 .
3. Navigate to the project directory containing the .rb ﬁle with your function's handler code and the
Gemfile specifying your function's dependencies. From inside that directory, run the following 
command to start the Lambda Ruby container.
Linux/MacOS
docker run --rm -it -v $PWD:/var/task -w /var/task awsruby32
408AWS Lambda Developer Guide
Creating and updating Ruby 
Lambda functions using .zip ﬁles
Note
In MacOS, you might see a warning informing you that the requested image's platform 
does not match the detected host platform. Ignore this warning.
Windows PowerShell
docker run --rm -it -v ${pwd}:var/task -w /var/task awsruby32
When your container starts, you should see a bash prompt.
bash-4.2#
4. Conﬁgure the bundle utility to install the gems speciﬁed in your Gemfile  in a local vendor/
bundle directory and install your dependencies.
bash-4.2# bundle config set --local path 'vendor/bundle' && bundle install
5. Create the .zip deployment package with your function code and its dependencies. In this example, 
the ﬁle containing your function's handler code is named lambda_function.rb .
bash-4.2# zip -r my_deployment_package.zip lambda_function.rb vendor
6. Exit the container and return to your local project directory.
bash-4.2# exit
You can now use the .zip ﬁle deployment package to create or update your Lambda function. See
Creating and updating Ruby Lambda functions using .zip ﬁles (p. 409)
Creating and updating Ruby Lambda functions 
using .zip ﬁles
Once you have created your .zip deployment package, you can use it to create a new Lambda function or 
update an existing one. You can deploy your .zip package using the Lambda console, the AWS Command 
Line Interface, and the Lambda API. You can also create and update Lambda functions using AWS 
Serverless Application Model (AWS SAM) and AWS CloudFormation.
The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit 
applies to the combined size of all the ﬁles you upload, including any Lambda layers.
Creating and updating functions with .zip ﬁles using the console
To create a new function, you must ﬁrst create the function in the console, then upload your .zip archive. 
To update an existing function, open the page for your function, then follow the same procedure to add 
your updated .zip ﬁle.
If your .zip ﬁle is less than 50MB, you can create or update a function by uploading the ﬁle directly 
from your local machine. For .zip ﬁles greater than 50MB, you must upload your package to an Amazon 
S3 bucket ﬁrst. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
Management Console, see Getting started with Amazon S3. To upload ﬁles using the AWS CLI, see Move 
objects in the AWS CLI User Guide.
409AWS Lambda Developer Guide
Creating and updating Ruby 
Lambda functions using .zip ﬁles
Note
You cannot convert an existing container image function to use a .zip archive. You must create a 
new function.
To create a new function (console)
1. Open the Functions page of the Lambda console and choose Create Function.
2. Choose Author from scratch .
3. Under Basic information , do the following:
a. For Function name, enter the name for your function.
b. For Runtime , select the runtime you want to use.
c. (Optional) For Architecture, choose the instruction set architecture for your function. The 
default architecture is x86_64. Ensure that the .zip deployment package for your function is 
compatible with the instruction set architecture you select.
4. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing one.
5. Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
To upload a .zip archive from your local machine (console)
1. In the Functions page of the Lambda console, choose the function you want to upload the .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose .zip ﬁle.
5. To upload the .zip ﬁle, do the following:
a. Select Upload, then select your .zip ﬁle in the ﬁle chooser.
b. Choose Open .
c. Choose Save.
To upload a .zip archive from an Amazon S3 bucket (console)
1. In the Functions page of the Lambda console, choose the function you want to upload a new .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose Amazon S3 location.
5. Paste the Amazon S3 link URL of your .zip ﬁle and choose Save.
Updating .zip ﬁle functions using the console code editor
For some functions with .zip deployment packages, you can use the Lambda console’s built-in code 
editor to update your function code directly. To use this feature, your function must meet the following 
criteria:
•Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
•Your function’s deployment package must be smaller than 3MB.
410AWS Lambda Developer Guide
Creating and updating Ruby 
Lambda functions using .zip ﬁles
Function code for functions with container image deployment packages cannot be edited directly in the 
console.
To update function code using the console code editor
1. Open the Functions page of the Lambda console and select your function.
2. Select the Code  tab.
3. In the Code source pane, select your source code ﬁle and edit it in the integrated code editor.
4. When you have ﬁnished editing your code, choose Deploy to save your changes and update your 
function.
Creating and updating functions with .zip ﬁles using the AWS 
CLI
You can can use the AWS CLI to create a new function or to update an existing one using a .zip ﬁle. Use 
the create-function and update-function-code commands to deploy your .zip package. If your .zip ﬁle is 
smaller than 50MB, you can upload the .zip package from a ﬁle location on your local build machine. For 
larger ﬁles, you must upload your .zip package from an Amazon S3 bucket. For instructions on how to 
upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
Note
If you upload your .zip ﬁle from an Amazon S3 bucket using the AWS CLI, the bucket must be 
located in the same AWS Region as your function.
To create a new function using a .zip ﬁle with the AWS CLI, you must specify the following:
•The name of your function (--function-name )
•Your function’s runtime (--runtime )
•The Amazon Resource Name (ARN) of your function’s execution role (--role )
•The name of the handler method in your function code (--handler )
You must also specify the location of your .zip ﬁle. If your .zip ﬁle is located in a folder on your local 
build machine, use the --zip-file  option to specify the ﬁle path, as shown in the following example 
command.
aws lambda create-function --function-name myFunction \
--runtime ruby3.2 --handler lambda_function.lambda_handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --code option as shown in the 
following example command. You only need to use the S3ObjectVersion  parameter for versioned 
objects.
aws lambda create-function --function-name myFunction \
--runtime ruby3.2 --handler lambda_function.lambda_handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=myBucketName,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
To update an existing function using the CLI, you specify the the name of your function using the --
function-name  parameter. You must also specify the location of the .zip ﬁle you want to use to update 
your function code. If your .zip ﬁle is located in a folder on your local build machine, use the --zip-
file option to specify the ﬁle path, as shown in the following example command.
aws lambda update-function-code --function-name myFunction \
411AWS Lambda Developer Guide
Creating and updating Ruby 
Lambda functions using .zip ﬁles
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --s3-bucket  and --s3-key  options 
as shown in the following example command. You only need to use the --s3-object-version
parameter for versioned objects.
aws lambda update-function-code --function-name myFunction \
--s3-bucket myBucketName --s3-key myFileName.zip --s3-object-version myObject Version
Creating and updating functions with .zip ﬁles using the 
Lambda API
To create and update functions using a .zip ﬁle archive, use the following API operations:
•CreateFunction
•UpdateFunctionCode
Creating and updating functions with .zip ﬁles using AWS SAM
The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of 
building and running serverless applications on AWS. You deﬁne the resources for your application in a 
YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, 
and deploy your applications. When you build a Lambda function from an AWS SAM template, AWS SAM 
automatically creates a .zip deployment package or container image with your function code and any 
dependencies you specify. To learn more about using AWS SAM to build and deploy Lambda functions, 
see Getting started with AWS SAM in the AWS Serverless Application Model Developer Guide.
You can also use AWS SAM to create a Lambda function using an existing .zip ﬁle archive. To create a 
Lambda function using AWS SAM, you can save your .zip ﬁle in an Amazon S3 bucket or in a local folder 
on your build machine. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
CLI, see Move objects in the AWS CLI User Guide.
In your AWS SAM template, the AWS::Serverless::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - set to Zip
•CodeUri - set to the function code's Amazon S3 URI, path to local folder, or FunctionCode object
•Runtime - Set to your chosen runtime
With AWS SAM, if your .zip ﬁle is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket 
ﬁrst. AWS SAM can upload .zip packages up to the maximum allowed size of 250MB (unzipped) from a 
location on your local build machine.
To learn more about deploying functions using .zip ﬁle in AWS SAM, see AWS::Serverless::Function in the
AWS SAM Developer Guide.
Creating and updating functions with .zip ﬁles using AWS 
CloudFormation
You can use AWS CloudFormation to create a Lambda function using a .zip ﬁle archive. To create a 
Lambda function from a .zip ﬁle, you must ﬁrst upload your ﬁle to an Amazon S3 bucket. For instructions 
on how to upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User 
Guide.
412AWS Lambda Developer Guide
Creating and updating Ruby 
Lambda functions using .zip ﬁles
In your AWS CloudFormation template, the AWS::Lambda::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - Set to Zip
•Code - Enter the Amazon S3 bucket name and the .zip ﬁle name in the S3Bucket  and S3Key  ﬁelds
•Runtime - Set to your chosen runtime
The .zip ﬁle that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying 
functions using .zip ﬁle in AWS CloudFormation, see AWS::Lambda::Function in the AWS CloudFormation 
User Guide .
413AWS Lambda Developer Guide
Deploy container images
Deploy Ruby Lambda functions with container 
images
There are three ways to build a container image for a Ruby Lambda function:
•Using an AWS base image for Ruby (p. 415)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, 
and code to these images. To make the image compatible with Lambda, you must include the runtime 
interface client for Ruby (p. 418) in the image.
•Using a non-AWS base image (p. 418)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the runtime interface client for Ruby (p. 418) in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
Topics
•AWS base images for Ruby (p. 414)
•Using an AWS base image for Ruby (p. 415)
•Using an alternative base image with the runtime interface client (p. 418)
AWS base images for Ruby
AWS provides the following base images for Ruby:
Tags Runtime Operating 
systemDockerﬁle Deprecation
3.2 Ruby 3.2 Amazon 
Linux 2Dockerﬁle for Ruby 3.2 on 
GitHub
2.7 Ruby 2.7 Amazon 
Linux 2Dockerﬁle for Ruby 2.7 on 
GitHubDec 7, 2023
Amazon ECR repository: gallery.ecr.aws/lambda/ruby
414AWS Lambda Developer Guide
Using an AWS base image
Using an AWS base image for Ruby
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Ruby
Creating an image from a base image
To create a container image for Ruby
1. Create a directory for the project, and then switch to that directory.
mkdir example
cd example
2. Create a new ﬁle called Gemfile. This is where you list your application's required RubyGems 
packages. The AWS SDK for Ruby is available from RubyGems. You should choose speciﬁc AWS 
service gems to install. For example, to use the Ruby gem for Lambda, your Gemﬁle should look like 
this:
source 'https://rubygems.org'
gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We 
recommend that you use it only if you depend on many AWS services.
3. Install the dependencies speciﬁed in the Gemﬁle using bundle install .
bundle install
4. Create a new ﬁle called lambda_function.rb . You can add the following sample function code to 
the ﬁle for testing, or use your own.
Example Ruby function
module LambdaFunction 
  class Handler 
    def self.process(event:,context:) 
      "Hello from Lambda!" 
    end 
  end
end
5. Create a new Dockerﬁle. The following is an example Dockerﬁle that uses an AWS base 
image  (p. 123). This Dockerﬁles uses the following conﬁguration:
•Set the FROM property to the URI of the base image.
•Use the COPY command to copy the function code and runtime dependencies to
{LAMBDA_TASK_ROOT} .
•Set the CMD argument to the Lambda function handler.
415AWS Lambda Developer Guide
Using an AWS base image
Example Dockerﬁle
FROM public.ecr.aws/lambda/ruby:3.2
# Copy function code
COPY lambda_function.rb  ${LAMBDA_TASK_ROOT}/
# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/
# Install Bundler and the specified gems
RUN gem install bundler:2.4.14 && \ 
    bundle config set --local path 'vendor/bundle'
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process " ]
6. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
416AWS Lambda Developer Guide
Using an AWS base image
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
417AWS Lambda Developer Guide
Using a non-AWS base image
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using an alternative base image with the runtime 
interface clientIf you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
the runtime interface client in your image. The runtime interface client extends the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code.
Install the Lambda runtime interface client for Ruby using the RubyGems.org package manager:
gem install aws_lambda_ric
You can also download the Ruby runtime interface client from GitHub. The runtime interface client 
supports Ruby versions 2.5.x to 2.7.x.
The following example demonstrates how to build a container image for Ruby using a non-AWS base 
image. The example Dockerﬁle uses an oﬃcial Ruby base image. The Dockerﬁle includes the runtime 
interface client.
Prerequisites
To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•Docker
•Ruby
Creating an image from an alternative base image
To create a container image for Ruby using an alternative base image
1. Create a directory for the project, and then switch to that directory.
418AWS Lambda Developer Guide
Using a non-AWS base image
mkdir example
cd example
2. Create a new ﬁle called Gemfile. This is where you list your application's required RubyGems 
packages. The AWS SDK for Ruby is available from RubyGems. You should choose speciﬁc AWS 
service gems to install. For example, to use the Ruby gem for Lambda, your Gemﬁle should look like 
this:
source 'https://rubygems.org'
gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We 
recommend that you use it only if you depend on many AWS services.
3. Install the dependencies speciﬁed in the Gemﬁle using bundle install .
bundle install
4. Create a new ﬁle called lambda_function.rb . You can add the following sample function code to 
the ﬁle for testing, or use your own.
Example Ruby function
module LambdaFunction 
  class Handler 
    def self.process(event:,context:) 
      "Hello from Lambda!" 
    end 
  end
end
5. Create a new Dockerﬁle. The following Dockerﬁle uses a Ruby base image instead of an AWS base 
image  (p. 123). The Dockerﬁle includes the runtime interface client for Ruby, which makes the image 
compatible with Lambda. Alternatively, you can add the runtime interface client to your application's 
Gemﬁle.
•Set the FROM property to the Ruby base image.
•Use the COPY command to copy the function code and runtime dependencies to
{LAMBDA_TASK_ROOT} .
•Set the ENTRYPOINT  to the module that you want the Docker container to run when it starts. In 
this case, the module is the runtime interface client.
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM ruby:2.7
# Install the runtime interface client for Ruby
RUN gem install aws_lambda_ric
# Add the runtime interface client to the PATH
ENV PATH="/usr/local/bundle/bin:${PATH}"
# Create a directory for the Lambda function
ENV LAMBDA_TASK_ROOT=/var/task
RUN mkdir -p ${LAMBDA_TASK_ROOT}
419AWS Lambda Developer Guide
Using a non-AWS base image
WORKDIR ${LAMBDA_TASK_ROOT}
# Copy function code
COPY lambda_function.rb  ${LAMBDA_TASK_ROOT}/
# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/
# Install Bundler and the specified gems
RUN gem install bundler:1.17.3 && \ 
    bundle install --path vendor/bundle
# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ " aws_lambda_ric " ]
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process" ]
6. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test the image. You can build the emulator into 
your image (p. 130) or install it on your local machine.
To install and run the runtime interface emulator on your local machine
1. From your project directory, run the following command to download the runtime interface 
emulator (x86-64 architecture) from GitHub and install it on your local machine.
mkdir -p ~/.aws-lambda-rie && \ 
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-
runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \ 
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
2. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•aws_lambda_ric lambda_function.LambdaFunction::Handler.process  is the
ENTRYPOINT  followed by the CMD from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         aws_lambda_ric lambda_function.LambdaFunction::Handler.process
420AWS Lambda Developer Guide
Using a non-AWS base image
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
3. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
4. Get the container ID.
docker ps
5. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
421AWS Lambda Developer Guide
Using a non-AWS base image
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
422AWS Lambda Developer Guide
Context
AWS Lambda context object in Ruby
When Lambda runs your function, it passes a context object to the handler  (p. 405). This object provides 
methods and properties that provide information about the invocation, function, and execution 
environment.
Context methods
•get_remaining_time_in_millis  – Returns the number of milliseconds left before the execution 
times out.
Context properties
•function_name  – The name of the Lambda function.
•function_version  – The version (p. 108) of the function.
•invoked_function_arn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•memory_limit_in_mb  – The amount of memory that's allocated for the function.
•aws_request_id  – The identiﬁer of the invocation request.
•log_group_name  – The log group for the function.
•log_stream_name  – The log stream for the function instance.
•deadline_ms – The date that the execution times out, in Unix time milliseconds.
•identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•client_context – (mobile apps) Client context that's provided to Lambda by the client application.
423AWS Lambda Developer Guide
Logging
AWS Lambda function logging in Ruby
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, or the CloudWatch console.
Sections
•Creating a function that returns logs (p. 424)
•Using the Lambda console (p. 425)
•Using the CloudWatch console (p. 425)
•Using the AWS Command Line Interface (AWS CLI) (p. 425)
•Deleting logs  (p. 428)
•Logger library (p. 428)
Creating a function that returns logs
To output logs from your function code, you can use puts statements, or any logging library that writes 
to stdout  or stderr. The following example logs the values of environment variables and the event 
object.
Example lambda_function.rb
# lambda_function.rb
def handler(event:, context:) 
    puts "## ENVIRONMENT VARIABLES" 
    puts ENV.to_a 
    puts "## EVENT" 
    puts event.to_a
end
Example log format
START RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95 Version: $LATEST
## ENVIRONMENT VARIABLES
environ({'AWS_LAMBDA_LOG_GROUP_NAME': '/aws/lambda/my-function', 
 'AWS_LAMBDA_LOG_STREAM_NAME': '2020/01/31/[$LATEST]3893xmpl7fac4485b47bb75b671a283c', 
 'AWS_LAMBDA_FUNCTION_NAME': 'my-function', ...})
## EVENT
{'key': 'value'}
END RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95
REPORT RequestId: 8f507cfc-xmpl-4697-b07a-ac58fc914c95  Duration: 15.74 ms  Billed 
 Duration: 16 ms Memory Size: 128 MB Max Memory Used: 56 MB  Init Duration: 130.49 ms
XRAY TraceId: 1-5e34a614-10bdxmplf1fb44f07bc535a1   SegmentId: 07f5xmpl2d1f6f85 Sampled: 
 true    
The Ruby runtime logs the START , END, and REPORT lines for each invocation. The report line provides 
the following details.
424AWS Lambda Developer Guide
Using the Lambda console
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
For more detailed logs, use the the section called “Logger library” (p. 428).
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
425AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
426AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
427AWS Lambda Developer Guide
Deleting logs
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
Logger library
The Ruby logger library returns streamlined logs that are easily read. Use the logger utility to output 
detailed information, messages, and errors codes related to your function.
# lambda_function.rb
require 'logger'
def handler(event:, context:)  
  logger = Logger.new($stdout) 
  logger.info('## ENVIRONMENT VARIABLES') 
  logger.info(ENV.to_a) 
  logger.info('## EVENT') 
  logger.info(event) 
  event.to_a
end
The output from logger includes the log level, timestamp, and request ID.
START RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125 Version: $LATEST
[INFO]  2020-01-31T22:12:58.534Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    ## ENVIRONMENT 
 VARIABLES
[INFO]  2020-01-31T22:12:58.534Z    1c8df7d3-xmpl-46da-9778-518e6eca8125 
    environ({'AWS_LAMBDA_LOG_GROUP_NAME': '/aws/lambda/my-function', 
 'AWS_LAMBDA_LOG_STREAM_NAME': '2020/01/31/[$LATEST]1bbe51xmplb34a2788dbaa7433b0aa4d', 
 'AWS_LAMBDA_FUNCTION_NAME': 'my-function', ...})
[INFO]  2020-01-31T22:12:58.535Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    ## EVENT
[INFO]  2020-01-31T22:12:58.535Z    1c8df7d3-xmpl-46da-9778-518e6eca8125    {'key': 
 'value'}
END RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125
REPORT RequestId: 1c8df7d3-xmpl-46da-9778-518e6eca8125  Duration: 2.75 ms   Billed 
 Duration: 3 ms Memory Size: 128 MB Max Memory Used: 56 MB  Init Duration: 113.51 ms
XRAY TraceId: 1-5e34a66a-474xmpl7c2534a87870b4370   SegmentId: 073cxmpl3e442861 Sampled: 
 true
428AWS Lambda Developer Guide
Errors
AWS Lambda function errors in Ruby
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the Ruby runtime using the 
Lambda console and the AWS CLI.
Sections
•Syntax (p. 429)
•How it works (p. 429)
•Using the Lambda console (p. 430)
•Using the AWS Command Line Interface (AWS CLI) (p. 430)
•Error handling in other AWS services (p. 431)
•Sample applications  (p. 432)
•What's next? (p. 432)
Syntax
Example function.rb
def handler(event:, context:) 
    puts "Processing event..." 
    [1, 2, 3].first("two") 
    "Success"
end
This code results in a type error. Lambda catches the error and generates a JSON document with ﬁelds 
for the error message, the type, and the stack trace.
{ 
  "errorMessage": "no implicit conversion of String into Integer", 
  "errorType": "Function<TypeError>", 
  "stackTrace": [ 
    "/var/task/function.rb:3:in `first'", 
    "/var/task/function.rb:3:in `handler'" 
  ]
}
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
429AWS Lambda Developer Guide
Using the Lambda console
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
430AWS Lambda Developer Guide
Error handling in other AWS services
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
{"errorMessage":"no implicit conversion of String into 
 Integer","errorType":"Function<TypeError>","stackTrace":["/var/task/function.rb:3:in 
 `first'","/var/task/function.rb:3:in `handler'"]}
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
431AWS Lambda Developer Guide
Sample applications
For more information, see Instrumenting Ruby code in AWS Lambda (p. 433).
Sample applications
The following sample code is available for the Ruby runtime.
Sample Lambda applications in Ruby
•blank-ruby – A Ruby function that shows the use of logging, environment variables, AWS X-Ray 
tracing, layers, unit tests and the AWS SDK.
•Ruby Code Samples for AWS Lambda – Code samples written in Ruby that demonstrate how to 
interact with AWS Lambda.
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 424) page.
432AWS Lambda Developer Guide
Tracing
Instrumenting Ruby code in AWS Lambda
Lambda integrates with AWS X-Ray to enable you to trace, debug, and optimize Lambda applications. 
You can use X-Ray to trace a request as it traverses resources in your application, from the frontend 
API to storage and database on the backend. By simply adding the X-Ray SDK library to your build 
conﬁguration, you can record errors and latency for any call that your function makes to an AWS service.
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
433AWS Lambda Developer Guide
Tracing
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can instrument your handler code to record metadata and trace downstream calls. To record detail 
about calls that your handler makes to other resources and services, use the X-Ray SDK for Ruby. To get 
the SDK, add the aws-xray-sdk  package to your application's dependencies.
Example blank-ruby/function/Gemﬁle
# Gemfile
source 'https://rubygems.org'
gem 'aws-xray-sdk', '0.11.4'
gem 'aws-sdk-lambda', '1.39.0'
gem 'test-unit', '3.3.5'
434AWS Lambda Developer Guide
Tracing
To instrument AWS SDK clients, require the aws-xray-sdk/lambda  module after creating a client in 
initialization code.
Example blank-ruby/function/lambda_function.rb – Tracing an AWS SDK client
# lambda_function.rb
require 'logger'
require 'json'
require 'aws-sdk-lambda'
$client = Aws::Lambda::Client.new()
$client.get_account_settings()
require 'aws-xray-sdk/lambda'
def lambda_handler(event:, context:) 
  logger = Logger.new($stdout) 
  ...
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
435AWS Lambda Developer Guide
Enabling active tracing with the Lambda API
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see The X-Ray SDK for Ruby in the AWS X-Ray 
Developer Guide.
Sections
•Enabling active tracing with the Lambda API (p. 436)
•Enabling active tracing with AWS CloudFormation (p. 436)
•Storing runtime dependencies in a layer (p. 437)
Enabling active tracing with the Lambda API
To manage tracing conﬁguration with the AWS CLI or AWS SDK, use the following API operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Enabling active tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
436AWS Lambda Developer Guide
Storing runtime dependencies in a layer
      ...
Storing runtime dependencies in a layer
If you use the X-Ray SDK to instrument AWS SDK clients your function code, your deployment package 
can become quite large. To avoid uploading runtime dependencies every time you update your function 
code, package the X-Ray SDK in a Lambda layer (p. 988).
The following example shows an AWS::Serverless::LayerVersion  resource that stores X-Ray SDK 
for Ruby.
Example template.yml – Dependencies layer
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: function/. 
      Tracing: Active 
       Layers: 
        - !Ref libs
      ... 
   libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-ruby-lib 
      Description: Dependencies for the blank-ruby sample app. 
      ContentUri: lib/. 
      CompatibleRuntimes: 
        - ruby2.5
With this conﬁguration, you update the library layer only if you change your runtime dependencies. Since 
the function deployment package contains only your code, this can help reduce upload times.
Creating a layer for dependencies requires build changes to generate the layer archive prior to 
deployment. For a working example, see the blank-ruby sample application.
437AWS Lambda Developer Guide
Building Lambda functions with Java
You can run Java code in AWS Lambda. Lambda provides runtimes  (p. 41) for Java that run your code to 
process events. Your code runs in an Amazon Linux environment that includes AWS credentials from an 
AWS Identity and Access Management (IAM) role that you manage.
Lambda supports the following Java runtimes.
Java
Name Identiﬁer Operating system Architectures Deprecation 
(Phase 1)
Java 17 java17 Amazon Linux 2 x86_64, arm64
Java 11 java11 Amazon Linux 2 x86_64, arm64
Java 8 java8.al2 Amazon Linux 2 x86_64, arm64
Java 8 java8 Amazon Linux x86_64 Dec 31, 2023
Lambda provides the following libraries for Java functions:
•com.amazonaws:aws-lambda-java-core (required) – Deﬁnes handler method interfaces and the context 
object that the runtime passes to the handler. If you deﬁne your own input types, this is the only 
library that you need.
•com.amazonaws:aws-lambda-java-events – Input types for events from services that invoke Lambda 
functions.
•com.amazonaws:aws-lambda-java-log4j2 – An appender library for Apache Log4j 2 that you can use to 
add the request ID for the current invocation to your function logs (p. 469).
•AWS SDK for Java 2.0 – The oﬃcial AWS SDK for the Java programming language.
To create a Java function
1. Open the Lambda console.
2. Choose Create function.
3. Conﬁgure the following settings:
•Function name: Enter a name for the function.
•Runtime : Choose Java 17.
4. Choose Create function.
5. To conﬁgure a test event, choose Test.
6. For Event name, enter test .
7. Choose Save changes.
8. To invoke the function, choose Test.
The console creates a Lambda function with a handler class named Hello. Since Java is a compiled 
language, you can't view or edit the source code in the Lambda console, but you can modify its 
conﬁguration, invoke it, and conﬁgure triggers.
438AWS Lambda Developer Guide
Note
To get started with application development in your local environment, deploy one of the
sample applications  (p. 511) available in this guide's GitHub repository.
The Hello class has a function named handleRequest  that takes an event object and a context 
object. This is the handler function (p. 440) that Lambda calls when the function is invoked. The Java 
function runtime gets invocation events from Lambda and passes them to the handler. In the function 
conﬁguration, the handler value is example.Hello::handleRequest .
To update the function's code, you create a deployment package, which is a .zip ﬁle archive that contains 
your function code. As your function development progresses, you will want to store your function 
code in source control, add libraries, and automate deployments. Start by creating a deployment 
package  (p. 446) and updating your code at the command line.
The function runtime passes a context object to the handler, in addition to the invocation event. The
context object (p. 466) contains additional information about the invocation, the function, and the 
execution environment. More information is available from environment variables.
Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details 
about each invocation to CloudWatch Logs. It relays any logs that your function outputs (p. 469) during 
invocation. If your function returns an error (p. 488), Lambda formats the error and returns it to the 
invoker.
Topics
•AWS Lambda function handler in Java (p. 440)
•Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446)
•Deploy Java Lambda functions with container images (p. 453)
•Java Lambda function customization settings (p. 464)
•AWS Lambda context object in Java (p. 466)
•AWS Lambda function logging in Java (p. 469)
•AWS Lambda function errors in Java (p. 488)
•Instrumenting Java code in AWS Lambda (p. 493)
•Creating a deployment package using Eclipse (p. 508)
•Java sample applications for AWS Lambda (p. 511)
439AWS Lambda Developer Guide
Handler
AWS Lambda function handler in Java
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
The GitHub repo for this guide provides easy-to-deploy sample applications that demonstrate a variety 
of handler types. For details, see the end of this topic  (p. 444).
Sections
•Example handler: Java 17 runtimes (p. 440)
•Example handler: Java 11 runtimes and below (p. 441)
•Initialization code (p. 442)
•Choosing input and output types (p. 442)
•Handler interfaces (p. 443)
•Sample handler code (p. 444)
Example handler: Java 17 runtimes
In the following Java 17 example, a class named HandlerIntegerJava17  deﬁnes a handler method 
named handleRequest . The handler method takes in the following inputs:
•An IntegerRecord , which is a custom Java  record that represents event data. In this example, we 
deﬁne IntegerRecord  as follows:
record IntegerRecord(int x, int y, String message) {
}
•A context object (p. 466), which provides methods and properties that provide information about the 
invocation, function, and execution environment.
Suppose we want to write a function that logs the message from the input IntegerRecord , and 
returns the sum of x and y. The following is the function code:
Example HandlerIntegerJava17.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler;
// Handler value: example.HandlerInteger
public class HandlerIntegerJava17 implements RequestHandler<IntegerRecord, Integer>{ 
  @Override 
  /* 
   * Takes in an InputRecord, which contains two integers and a String. 
   * Logs the String, then returns the sum of the two Integers. 
   */ 
  public Integer handleRequest(IntegerRecord event, Context context) 
  { 
    LambdaLogger logger = context.getLogger(); 
    logger.log("String found: " + event.message()); 
    return event.x() + event.y(); 
  }
440AWS Lambda Developer Guide
Example handler: Java 11 runtimes and below
}
record IntegerRecord(int x, int y, String message) {
}
You specify which method you want Lambda to invoke by setting the handler parameter on your 
function's conﬁguration. You can express the hander in the following formats:
•package.Class::method – Full format. For example: example.Handler::handleRequest .
•package.Class – Abbreviated format for functions that implement a handler interface (p. 443). For 
example: example.Handler .
When Lambda invokes your handler, the Lambda runtime  (p. 41) receives an event as a JSON-formatted 
string and converts it into an object. For the previous example, a sample event might look like the 
following:
Example event.json
{ 
  "x": 1, 
  "y": 20, 
  "message": "Hello World!"
}
You can save this ﬁle and test your function locally with the following AWS Command Line Interface (CLI) 
command:
aws lambda invoke --function-name function_name  --payload file://event.json out.json
Example handler: Java 11 runtimes and below
Lambda supports records for Java 17 runtimes only. In all Java runtimes, you can use a class to represent 
event data. The following example takes a list of integers and a context object as input, and returns the 
sum of all integers in the list.
Example Handler.java
In the following example, a class named Handler  deﬁnes a handler method named handleRequest . 
The handler method takes an event and context object as input and returns a string.
Example HandlerList.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import java.util.List;
// Handler value: example.HandlerList
public class HandlerList implements RequestHandler<List<Integer>, Integer>{ 
  @Override 
  /* 
   * Takes a list of Integers and returns its sum. 
   */ 
  public Integer handleRequest(List<Integer> event, Context context) 
  { 
441AWS Lambda Developer Guide
Initialization code
    LambdaLogger logger = context.getLogger(); 
    logger.log("EVENT TYPE: " + event.getClass().toString()); 
    return event.stream().mapToInt(Integer::intValue).sum(); 
  }
}
For more examples, see Sample handler code (p. 444).
Initialization code
Lambda runs your static code and the class constructor during the  initialization phase  (p. 15) before 
invoking your function for the ﬁrst time. Resources created during initialization stay in memory between 
invocations and can be reused by the handler thousands of times. Thus, you can add  initialization 
code outside of your main handler method to save compute time and reuse resources across multiple 
invocations.
In the following example, the client initialization code is outside the main handler method. The runtime 
initializes the client before the function serves its ﬁrst event. Subsequent events are much faster because 
Lambda doesn't need to initialize the client again.
Example Handler.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import java.util.Map;
import software.amazon.awssdk.services.lambda.LambdaClient;
import software.amazon.awssdk.services.lambda.model.GetAccountSettingsResponse;
import software.amazon.awssdk.services.lambda.model.LambdaException;
// Handler value: example.Handler
public class Handler implements RequestHandler<Map<String,String>, String> { 
    private static final LambdaClient lambdaClient = LambdaClient.builder().build(); 
    @Override 
    public String handleRequest(Map<String,String> event, Context context) { 
        LambdaLogger logger = context.getLogger(); 
        logger.log("Handler invoked"); 
        GetAccountSettingsResponse response = null; 
        try { 
            response = lambdaClient.getAccountSettings(); 
        } catch(LambdaException e) { 
            logger.log(e.getMessage()); 
        } 
        return response != null ? "Total code size for your account is " + 
 response.accountLimit().totalCodeSize() + " bytes" : "Error"; 
    }
}
Choosing input and output types
You specify the type of object that the event maps to in the handler method's signature. In the 
preceding example, the Java runtime deserializes the event into a type that implements the
Map<String,String>  interface. String-to-string maps work for ﬂat events like the following:
442AWS Lambda Developer Guide
Handler interfaces
Example Event.json – Weather data
{ 
  "temperatureK": 281, 
  "windKmh": -3, 
  "humidityPct": 0.55, 
  "pressureHPa": 1020
}
However, the value of each ﬁeld must be a string or number. If the event includes a ﬁeld that has an 
object as a value, the runtime can't deserialize it and returns an error.
Choose an input type that works with the event data that your function processes. You can use a basic 
type, a generic type, or a well-deﬁned type.
Input types
•Integer , Long , Double, etc. – The event is a number with no additional formatting—for example,
3.5. The runtime converts the value into an object of the speciﬁed type.
•String – The event is a JSON string, including quotes—for example, "My string." . The runtime 
converts the value (without quotes) into a String object.
•Type , Map<String, Type> etc. – The event is a JSON object. The runtime deserializes it into an object 
of the speciﬁed type or interface.
•List<Integer> , List<String> , List<Object> , etc. – The event is a JSON array. The runtime 
deserializes it into an object of the speciﬁed type or interface.
•InputStream  – The event is any JSON type. The runtime passes a byte stream of the document to the 
handler without modiﬁcation. You deserialize the input and write output to an output stream.
•Library type – For events sent by AWS services, use the types in the aws-lambda-java-events (p. 446)
library.
If you deﬁne your own input type, it should be a deserializable, mutable plain old Java object (POJO), 
with a default constructor and properties for each ﬁeld in the event. Keys in the event that don't map to 
a property as well as properties that aren't included in the event are dropped without error.
The output type can be an object or void. The runtime serializes return values into text. If the output is 
an object with ﬁelds, the runtime serializes it into a JSON document. If it's a type that wraps a primitive 
value, the runtime returns a text representation of that value.
Handler interfaces
The aws-lambda-java-core library deﬁnes two interfaces for handler methods. Use the provided 
interfaces to simplify handler conﬁguration and validate the handler method signature at compile time.
•com.amazonaws.services.lambda.runtime.RequestHandler
•com.amazonaws.services.lambda.runtime.RequestStreamHandler
The RequestHandler  interface is a generic type that takes two parameters: the input type and the 
output type. Both types must be objects. When you use this interface, the Java runtime deserializes the 
event into an object with the input type, and serializes the output into text. Use this interface when the 
built-in serialization works with your input and output types.
Example Handler.java – Handler interface
// Handler value: example.Handler
443AWS Lambda Developer Guide
Sample handler code
public class Handler implements RequestHandler<Map<String,String>, String>{ 
  @Override 
   public String handleRequest(Map<String,String> event, Context context)
To use your own serialization, implement the RequestStreamHandler  interface. With this interface, 
Lambda passes your handler an input stream and output stream. The handler reads bytes from the input 
stream, writes to the output stream, and returns void.
The following example uses buﬀered reader and writer types to work with the input and output streams. 
It uses the Gson  library for serialization and deserialization.
Example HandlerStream.java
import com.amazonaws.services.lambda.runtime.Context
import com.amazonaws.services.lambda.runtime.RequestStreamHandler
import com.amazonaws.services.lambda.runtime.LambdaLogger
...
// Handler value: example.HandlerStream
public class HandlerStream implements RequestStreamHandler  { 
  Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
  @Override 
   public void handleRequest(InputStream inputStream, OutputStream outputStream, Context 
 context) throws IOException
  { 
    LambdaLogger logger = context.getLogger(); 
    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, 
 Charset.forName("US-ASCII"))); 
    PrintWriter writer = new PrintWriter(new BufferedWriter(new 
 OutputStreamWriter(outputStream, Charset.forName("US-ASCII")))); 
    try 
    { 
      HashMap event = gson.fromJson(reader, HashMap.class); 
      logger.log("STREAM TYPE: " + inputStream.getClass().toString()); 
      logger.log("EVENT TYPE: " + event.getClass().toString()); 
      writer.write(gson.toJson(event)); 
      if (writer.checkError()) 
      { 
        logger.log("WARNING: Writer encountered an error."); 
      } 
    } 
    catch (IllegalStateException | JsonSyntaxException exception) 
    { 
      logger.log(exception.toString()); 
    } 
    finally 
    { 
      reader.close(); 
      writer.close(); 
    } 
  }
}
Sample handler code
The GitHub repository for this guide includes sample applications that demonstrate the use of various 
handler types and interfaces. Each sample application includes scripts for easy deployment and cleanup, 
an AWS SAM template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
444AWS Lambda Developer Guide
Sample handler code
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples 
do not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
The java-events  and s3-java applications take an AWS service event as input and return a string. The
java-basic  application includes several types of handlers:
•Handler.java – Takes a Map<String,String>  as input.
•HandlerInteger.java – Takes an Integer  as input.
•HandlerList.java – Takes a List<Integer>  as input.
•HandlerStream.java – Takes an InputStream  and OutputStream  as input.
•HandlerString.java – Takes a String  as input.
•HandlerWeatherData.java – Takes a custom type as input.
To test diﬀerent handler types, just change the handler value in the AWS SAM template. For detailed 
instructions, see the sample application's readme ﬁle.
445AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Deploy Java Lambda functions with .zip or JAR ﬁle 
archives
Your AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package  to deploy your function code to Lambda. Lambda supports two types of 
deployment packages: container images and .zip ﬁle archives.
This page describes how to create your deployment package as a .zip ﬁle or Jar ﬁle, and then use the 
deployment package to deploy your function code to AWS Lambda using the AWS Command Line 
Interface (AWS CLI).
Sections
•Prerequisites (p. 446)
•Tools and libraries (p. 446)
•Building a deployment package with Gradle (p. 447)
•Building a deployment package with Maven (p. 448)
•Uploading a deployment package with the Lambda console (p. 449)
•Uploading a deployment package with the AWS CLI (p. 450)
•Uploading a deployment package with AWS SAM (p. 451)
Prerequisites
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
Tools and libraries
Lambda provides the following libraries for Java functions:
•com.amazonaws:aws-lambda-java-core (required) – Deﬁnes handler method interfaces and the context 
object that the runtime passes to the handler. If you deﬁne your own input types, this is the only 
library that you need.
•com.amazonaws:aws-lambda-java-events – Input types for events from services that invoke Lambda 
functions.
•com.amazonaws:aws-lambda-java-log4j2 – An appender library for Apache Log4j 2 that you can use to 
add the request ID for the current invocation to your function logs (p. 469).
•AWS SDK for Java 2.0 – The oﬃcial AWS SDK for the Java programming language.
These libraries are available through Maven Central Repository. Add them to your build deﬁnition as 
follows:
Gradle
dependencies { 
     implementation 'com.amazonaws:aws-lambda-java-core:1.2.2' 
446AWS Lambda Developer Guide
Building a deployment package with Gradle
    implementation 'com.amazonaws:aws-lambda-java-events:3.11.1' 
    runtimeOnly 'com.amazonaws:aws-lambda-java-log4j2:1.5.1'
}
Maven
  <dependencies> 
    <dependency> 
      <groupId>com.amazonaws</groupId> 
      <artifactId>aws-lambda-java-core</artifactId> 
      <version>1.2.2</version> 
    </dependency> 
    <dependency> 
      <groupId>com.amazonaws</groupId> 
      <artifactId>aws-lambda-java-events</artifactId> 
      <version>3.11.1</version> 
    </dependency> 
    <dependency> 
      <groupId>com.amazonaws</groupId> 
      <artifactId>aws-lambda-java-log4j2</artifactId> 
      <version>1.5.1</version> 
    </dependency> 
  </dependencies>
To create a deployment package, compile your function code and dependencies into a single .zip ﬁle or 
Java Archive (JAR) ﬁle. For Gradle, use the Zip build type (p. 447). For Apache Maven, use the Maven 
Shade plugin  (p. 448). To upload your deployment package, use the Lambda console, the Lambda API, 
or AWS Serverless Application Model (AWS SAM).
Note
To keep your deployment package size small, package your function's dependencies in 
layers. Layers enable you to manage your dependencies independently, can be used by 
multiple functions, and can be shared with other accounts. For more information, see Lambda 
layers  (p. 988).
Building a deployment package with Gradle
To create a deployment package with your function's code and dependencies in Gradle, use the Zip build 
type. Here's an example from a complete sample build.gradle ﬁle:
Example build.gradle – Build task
task buildZip(type: Zip) { 
    into('lib') { 
        from(jar) 
        from(configurations.runtimeClasspath) 
    }
}
This build conﬁguration produces a deployment package in the build/distributions  directory. 
Within the into('lib')  statement, the jar task assembles a jar archive containing your main 
classes into a folder named lib. Additionally, the configurations.runtimeClassPath  task copies 
dependency libraries from the build's classpath into the same lib folder.
Example build.gradle – Dependencies
dependencies { 
447AWS Lambda Developer Guide
Building a deployment package with Maven
    ... 
     implementation 'com.amazonaws:aws-lambda-java-core:1.2.2' 
    implementation 'com.amazonaws:aws-lambda-java-events:3.11.1'
    implementation 'org.apache.logging.log4j:log4j-api:2.17.1' 
    implementation 'org.apache.logging.log4j:log4j-core:2.17.1' 
    runtimeOnly 'org.apache.logging.log4j:log4j-slf4j18-impl:2.17.1' 
     runtimeOnly 'com.amazonaws:aws-lambda-java-log4j2:1.5.1'
    ...
}
Lambda loads JAR ﬁles in Unicode alphabetical order. If multiple JAR ﬁles in the lib directory contain 
the same class, the ﬁrst one is used. You can use the following shell script to identify duplicate classes:
Example test-zip.sh
mkdir -p expanded
unzip path/to/my/function.zip -d expanded
find ./expanded/lib -name '*.jar' | xargs -n1 zipinfo -1 | grep '.*.class' | sort | uniq -c 
 | sort
Building a deployment package with Maven
To build a deployment package with Maven, use the Maven Shade plugin. The plugin creates a JAR ﬁle 
that contains the compiled function code and all of its dependencies.
Example pom.xml – Plugin conﬁguration
      <plugin> 
        <groupId>org.apache.maven.plugins</groupId> 
        <artifactId>maven-shade-plugin</artifactId> 
        <version>3.2.2</version> 
        <configuration> 
          <createDependencyReducedPom>false</createDependencyReducedPom> 
        </configuration> 
        <executions> 
          <execution> 
            <phase>package</phase> 
            <goals> 
              <goal>shade</goal> 
            </goals> 
          </execution> 
        </executions> 
      </plugin>
To build the deployment package, use the mvn package  command.
[INFO] Scanning for projects...
[INFO] -----------------------< com.example:java-maven >-----------------------
[INFO] Building java-maven-function 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ java-maven ---
[INFO] Building jar: target/java-maven-1.0-SNAPSHOT.jar
[INFO]
[INFO] --- maven-shade-plugin:3.2.2:shade (default) @ java-maven ---
[INFO] Including com.amazonaws:aws-lambda-java-core:jar:1.2.2 in the shaded jar.
[INFO] Including com.amazonaws:aws-lambda-java-events:jar:3.11.1 in the shaded jar.
[INFO] Including joda-time:joda-time:jar:2.6 in the shaded jar.
[INFO] Including com.google.code.gson:gson:jar:2.8.6 in the shaded jar.
[INFO] Replacing original artifact with shaded artifact.
448AWS Lambda Developer Guide
Uploading a deployment package with the Lambda console
[INFO] Replacing target/java-maven-1.0-SNAPSHOT.jar with target/java-maven-1.0-SNAPSHOT-
shaded.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  8.321 s
[INFO] Finished at: 2020-03-03T09:07:19Z
[INFO] ------------------------------------------------------------------------
This command generates a JAR ﬁle in the target directory.
Note
If you're working with a multi-release JAR (MRJAR), you must include the MRJAR (i.e. the shaded 
JAR produced by the Maven Shade plugin) in the lib directory and zip it before uploading your 
deployment package to Lambda. Otherwise, Lambda may not properly unpack your JAR ﬁle, 
causing your MANIFEST.MF  ﬁle to be ignored.
If you use the appender library (aws-lambda-java-log4j2 ), you must also conﬁgure a transformer for 
the Maven Shade plugin. The transformer library combines versions of a cache ﬁle that appear in both 
the appender library and in Log4j.
Example pom.xml – Plugin conﬁguration with Log4j 2 appender
      <plugin> 
        <groupId>org.apache.maven.plugins</groupId> 
        <artifactId>maven-shade-plugin</artifactId> 
        <version>3.2.2</version> 
        <configuration> 
          <createDependencyReducedPom>false</createDependencyReducedPom> 
        </configuration> 
        <executions> 
          <execution> 
            <phase>package</phase> 
            <goals> 
              <goal>shade</goal> 
            </goals> 
            <configuration> 
              <transformers> 
                <transformer 
 implementation="com.github.edwgiz.maven_shade_plugin.log4j2_cache_transformer.PluginsCacheFileTransformer"> 
                </transformer> 
              </transformers> 
            </configuration> 
          </execution> 
        </executions> 
        <dependencies> 
          <dependency> 
            <groupId>com.github.edwgiz</groupId> 
            <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</artifactId> 
            <version>2.13.0</version> 
          </dependency> 
        </dependencies> 
      </plugin>
Uploading a deployment package with the Lambda 
console
To create a new function, you must ﬁrst create the function in the console, then upload your .zip or JAR 
ﬁle. To update an existing function, open the page for your function, then follow the same procedure to 
add your updated .zip or JAR ﬁle.
449AWS Lambda Developer Guide
Uploading a deployment package with the AWS CLI
If your deployment package ﬁle is less than 50MB, you can create or update a function by uploading 
the ﬁle directly from your local machine. For .zip or JAR ﬁles greater than 50MB, you must upload your 
package to an Amazon S3 bucket ﬁrst. For instructions on how to upload a ﬁle to an Amazon S3 bucket 
using the AWS Management Console, see Getting started with Amazon S3. To upload ﬁles using the AWS 
CLI, see Move objects in the AWS CLI User Guide.
Note
You cannot convert an existing container image function to use a .zip archive. You must create a 
new function.
To create a new function (console)
1. Open the Functions page of the Lambda console and choose Create Function.
2. Choose Author from scratch .
3. Under Basic information , do the following:
a. For Function name, enter the name for your function.
b. For Runtime , select the runtime you want to use.
c. (Optional) For Architecture, choose the instruction set architecture for your function. The 
default architecture is x86_64. Ensure that the .zip deployment package for your function is 
compatible with the instruction set architecture you select.
4. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing one.
5. Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
To upload a .zip or JAR archive from your local machine (console)
1. In the Functions page of the Lambda console, choose the function you want to upload the .zip or 
JAR ﬁle for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose .zip or .jar ﬁle.
5. To upload the .zip or JAR ﬁle, do the following:
a. Select Upload, then select your .zip or JAR ﬁle in the ﬁle chooser.
b. Choose Open .
c. Choose Save.
To upload a .zip or JAR archive from an Amazon S3 bucket (console)
1. In the Functions page of the Lambda console, choose the function you want to upload a new .zip or 
JAR ﬁle for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose Amazon S3 location.
5. Paste the Amazon S3 link URL of your .zip ﬁle and choose Save.
Uploading a deployment package with the AWS CLI
You can can use the AWS CLI to create a new function or to update an existing one using a .zip or JAR 
ﬁle. Use the create-function and update-function-code commands to deploy your .zip or JAR package. 
450AWS Lambda Developer Guide
Uploading a deployment package with AWS SAM
If your ﬁle is smaller than 50MB, you can upload the package from a ﬁle location on your local build 
machine. For larger ﬁles, you must upload your .zip or JAR package from an Amazon S3 bucket. For 
instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the
AWS CLI User Guide.
Note
If you upload your .zip or JAR ﬁle from an Amazon S3 bucket using the AWS CLI, the bucket 
must be located in the same AWS Region as your function.
To create a new function using a .zip or JAR ﬁle with the AWS CLI, you must specify the following:
•The name of your function (--function-name )
•Your function’s runtime (--runtime )
•The Amazon Resource Name (ARN) of your function’s execution role (--role )
•The name of the handler method in your function code (--handler )
You must also specify the location of your .zip or JAR ﬁle. If your .zip or JAR ﬁle is located in a folder on 
your local build machine, use the --zip-file  option to specify the ﬁle path, as shown in the following 
example command.
aws lambda create-function --function-name myFunction \
--runtime java17 --handler example.handler \
--role arn:aws:iam::123456789012:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --code option as shown in the 
following example command. You only need to use the S3ObjectVersion  parameter for versioned 
objects.
aws lambda create-function --function-name myFunction \
--runtime java17 --handler example.handler \
--role arn:aws:iam::123456789012:role/service-role/my-lambda-role \
--code S3Bucket=myBucketName,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
To update an existing function using the CLI, you specify the the name of your function using the --
function-name  parameter. You must also specify the location of the .zip ﬁle you want to use to update 
your function code. If your .zip ﬁle is located in a folder on your local build machine, use the --zip-
file option to specify the ﬁle path, as shown in the following example command.
aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --s3-bucket  and --s3-key  options 
as shown in the following example command. You only need to use the --s3-object-version
parameter for versioned objects.
aws lambda update-function-code --function-name myFunction \
--s3-bucket myBucketName --s3-key myFileName.zip --s3-object-version myObject Version
Uploading a deployment package with AWS SAM
You can use AWS SAM to automate deployments of your function code, conﬁguration, and dependencies. 
AWS SAM is an extension of AWS CloudFormation that provides a simpliﬁed syntax for deﬁning 
serverless applications. The following example template deﬁnes a function with a deployment package 
in the build/distributions  directory that Gradle uses:
451AWS Lambda Developer Guide
Uploading a deployment package with AWS SAM
Example template.yml
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: An AWS Lambda application that calls the Lambda API.
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       CodeUri: build/distributions/java-basic.zip
      Handler: example.Handler 
      Runtime: java8 
      Description: Java function 
      MemorySize: 512 
      Timeout: 10 
      # Function's execution role 
      Policies: 
        - AWSLambdaBasicExecutionRole 
        - AWSLambda_ReadOnlyAccess 
        - AWSXrayWriteOnlyAccess 
        - AWSLambdaVPCAccessExecutionRole 
      Tracing: Active
To create the function, use the package  and deploy commands. These commands are customizations 
to the AWS CLI. They wrap other commands to upload the deployment package to Amazon S3, rewrite 
the template with the object URI, and update the function's code.
The following example script runs a Gradle build and uploads the deployment package that it creates. 
It creates an AWS CloudFormation stack the ﬁrst time you run it. If the stack already exists, the script 
updates it.
Example deploy.sh
#!/bin/bash
set -eo pipefail
aws cloudformation package --template-file template.yml --s3-bucket MY_BUCKET --output-
template-file out.yml
aws cloudformation deploy --template-file out.yml --stack-name java-basic --capabilities 
 CAPABILITY_NAMED_IAM
For a complete working example, see the following sample applications:
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples 
do not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
452AWS Lambda Developer Guide
Deploy container images
Deploy Java Lambda functions with container 
images
There are three ways to build a container image for a Java Lambda function:
•Using an AWS base image for Java (p. 454)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, 
and code to these images. To make the image compatible with Lambda, you must include the runtime 
interface client for Java (p. 458) in the image.
•Using an alternative base image (p. 458)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the runtime interface client for Java (p. 458) in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
Topics
•AWS base images for Java (p. 453)
•Using an AWS base image for Java (p. 454)
•Using an alternative base image with the runtime interface client (p. 458)
AWS base images for Java
AWS provides the following base images for Java:
Tags Runtime Operating 
systemDockerﬁle Deprecation
17 Java 17 Amazon 
Linux 2Dockerﬁle for Java 17 on 
GitHub
11 Java 11 Amazon 
Linux 2Dockerﬁle for Java 11 on 
GitHub
8.al2 Java 8 Amazon 
Linux 2Dockerﬁle for Java 8 on 
GitHub
8 Java 8 Amazon 
LinuxDockerﬁle for Java 8 on 
GitHubDec 31, 2023
453AWS Lambda Developer Guide
Using an AWS base image
Amazon ECR repository: gallery.ecr.aws/lambda/java
Using an AWS base image for Java
Prerequisites
To complete the steps in this section, you must have the following:
•Java (for example, Amazon Corretto)
•Docker
•Apache Maven or Gradle
•AWS Command Line Interface (AWS CLI) version 2
Creating an image from a base image
Maven
1. Run the following command to create a Maven project using the archetype for Lambda. The 
following parameters are required:
•service – The AWS service client to use in the Lambda function. For a list of available sources, 
see aws-sdk-java-v2/services on GitHub.
•region  – The AWS Region where you want to create the Lambda function.
•groupId  – The full package namespace of your application.
•artifactId – Your project name. This becomes the name of the directory for your project.
mvn -B archetype:generate \ 
   -DarchetypeGroupId=software.amazon.awssdk \ 
   -DarchetypeArtifactId=archetype-lambda -Dservice= s3 -Dregion= US_WEST_2  \ 
   -DgroupId= com.example.myapp  \ 
   -DartifactId= myapp
The Maven archetype for Lambda is preconﬁgured to compile with Java SE 8 and includes a 
dependency to the AWS SDK for Java. If you create your project with a diﬀerent archetype or by 
using another method, you must conﬁgure the Java compiler for Maven and declare the SDK as 
a dependency.
2. Open the myapp/src/main/java/com/example/ myapp directory, and ﬁnd the App.java
ﬁle. This is the code for the Lambda function. You can use the provided sample code for testing, 
or replace it with your own.
3. Navigate back to the project's root directory, and then create a new Dockerﬁle with the 
following conﬁguration:
•Set the FROM property to the URI of the base image .
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM public.ecr.aws/lambda/java:11 
   
# Copy function code and runtime dependencies from Maven layout
COPY target/classes ${LAMBDA_TASK_ROOT}
COPY target/dependency/* ${LAMBDA_TASK_ROOT}/lib/ 
     
454AWS Lambda Developer Guide
Using an AWS base image
# Set the CMD to your handler (could also be done as a parameter override outside 
 of the Dockerfile)
CMD [ "com.example.myapp.App::handleRequest" ]
4. Compile the project and collect the runtime dependencies.
mvn compile dependency:copy-dependencies -DincludeScope=runtime
5. Build the Docker image with the docker build command. The following example names the 
image docker-image  and gives it the test  tag.
docker build -t docker-image :test .
Gradle
1. Create a directory for the project, and then switch to that directory.
mkdir example
cd example
2. Run the following command to have Gradle generate a new Java application project in 
the example directory in your environment. To accept the default options provided in the 
interactive experience, press Enter .
gradle init --type java-application
3. Open the /example/app/src/main/java/ example directory, and ﬁnd the App.java  ﬁle. 
This is the code for the Lambda function. You can use the following sample code for testing, or 
replace it with your own.
Example App.java
package com.example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
public class App implements RequestHandler<Object, String> { 
    public String handleRequest(Object input, Context context) { 
        return "Hello world!"; 
    }
}
4. Open the build.gradle  ﬁle. If you're using the sample function code from the previous step, 
replace the contents of build.gradle  with the following. If you're using your own function 
code, modify your build.gradle  ﬁle as needed.
plugins { 
  id 'java'
}
group 'com.example'
version '1.0-SNAPSHOT'
sourceCompatibility = 1.8
repositories { 
  mavenCentral()
}
dependencies { 
  implementation 'com.amazonaws:aws-lambda-java-core:1.2.1'
}
jar { 
  manifest { 
455AWS Lambda Developer Guide
Using an AWS base image
      attributes 'Main-Class': 'com.example.App' 
  }
}
5. The gradle init  command from step 2 also generated a dummy test case in the app/test
directory. For the purposes of this tutorial, skip running tests by deleting the /test directory.
6. Build the project.
gradle build
7. In the project's root directory (/example ), create a Dockerﬁle with the following conﬁguration:
•Set the FROM property to the URI of the base image .
•Use the COPY command to copy the function code and runtime dependencies to
{LAMBDA_TASK_ROOT} .
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM public.ecr.aws/lambda/java:11 
   
# Copy function code and runtime dependencies from Gradle layout
COPY app/build/classes/java/main ${LAMBDA_TASK_ROOT} 
   
# Set the CMD to your handler (could also be done as a parameter override outside 
 of the Dockerfile)
CMD [ "com.example.App::handleRequest" ]
8. Build the Docker image with the docker build command. The following example names the 
image docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
456AWS Lambda Developer Guide
Using an AWS base image
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
457AWS Lambda Developer Guide
Using an alternative base image
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using an alternative base image with the runtime 
interface clientIf you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
the runtime interface client in your image. The runtime interface client extends the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code.
Install the runtime interface client for Java in your Dockerﬁle, or as a dependency in your project. For 
example, to install the runtime interface client using the Maven package manager, add the following to 
your pom.xml  ﬁle:
<dependency> 
    <groupId>com.amazonaws</groupId> 
    <artifactId>aws-lambda-java-runtime-interface-client</artifactId> 
    <version>2.3.2</version>
</dependency>
For package details, see AWS Lambda Java Runtime Interface Client in the Maven Central Repository. 
You can also review the runtime interface client source code in the AWS Lambda Java Support Libraries
GitHub repository.
458AWS Lambda Developer Guide
Using an alternative base image
The following example demonstrates how to build a container image for Java using an Amazon Corretto 
image . Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the Open Java 
Development Kit (OpenJDK). The Maven project includes the runtime interface client as a dependency.
Prerequisites
To complete the steps in this section, you must have the following:
•Java (for example, Amazon Corretto)
•Docker
•Apache Maven
•AWS Command Line Interface (AWS CLI) version 2
Creating an image from an alternative base image
1. Create a Maven project. The following parameters are required:
•groupId  – The full package namespace of your application.
•artifactId – Your project name. This becomes the name of the directory for your project.
mvn -B archetype:generate \ 
   -DarchetypeArtifactId=maven-archetype-quickstart \ 
   -DgroupId= example \ 
   -DartifactId= myapp \ 
   -DinteractiveMode=false
2. Open the project directory.
cd myapp
3. Open the pom.xml ﬁle and replace the contents with the following. This ﬁle includes the aws-
lambda-java-runtime-interface-client as a dependency. Alternatively, you can install the runtime 
interface client in the Dockerﬁle. However, the simplest approach is to include the library as a 
dependency.
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/
XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-
v4_0_0.xsd"> 
  <modelVersion>4.0.0</modelVersion> 
  <groupId>example</groupId> 
  <artifactId>hello-lambda</artifactId> 
  <packaging>jar</packaging> 
  <version>1.0-SNAPSHOT</version> 
  <name>hello-lambda</name> 
  <url>http://maven.apache.org</url> 
  <properties> 
    <maven.compiler.source>1.8</maven.compiler.source> 
    <maven.compiler.target>1.8</maven.compiler.target> 
  </properties> 
  <dependencies> 
    <dependency> 
      <groupId>com.amazonaws</groupId> 
      <artifactId> aws-lambda-java-runtime-interface-client </artifactId> 
      <version> 2.3.2</version> 
    </dependency> 
  </dependencies> 
  <build> 
459AWS Lambda Developer Guide
Using an alternative base image
    <plugins> 
      <plugin> 
        <groupId>org.apache.maven.plugins</groupId> 
        <artifactId>maven-dependency-plugin</artifactId> 
        <version>3.1.2</version> 
        <executions> 
          <execution> 
            <id>copy-dependencies</id> 
            <phase>package</phase> 
            <goals> 
              <goal>copy-dependencies</goal> 
            </goals> 
          </execution> 
        </executions> 
      </plugin> 
    </plugins> 
  </build>
</project>
4. Open the myapp/src/main/java/com/example/ myapp directory, and ﬁnd the App.java  ﬁle. 
This is the code for the Lambda function. Replace the code with the following.
Example function handler
package example;
public class App { 
    public static String sayHello() { 
        return "Hello world!"; 
    }
}
5. The mvn -B archetype:generate  command from step 1 also generated a dummy test case in 
the src/test  directory. For the purposes of this tutorial, skip over running tests by deleting this 
entire generated /test directory.
6. Navigate back to the project's root directory, and then create a new Dockerﬁle. The following 
example Dockerﬁle uses an Amazon Corretto image. Amazon Corretto is a no-cost, multiplatform, 
production-ready distribution of the OpenJDK.
•Set the FROM property to the URI of the base image.
•Set the ENTRYPOINT  to the module that you want the Docker container to run when it starts. In 
this case, the module is the runtime interface client.
•Set the CMD argument to the Lambda function handler.
Example Dockerﬁle
FROM public.ecr.aws/amazoncorretto/amazoncorretto:11  as base
# Configure the build environment
FROM base as build
RUN yum install -y maven
WORKDIR /src
# Cache and copy dependencies
ADD pom.xml .
RUN mvn dependency:go-offline dependency:copy-dependencies
# Compile the function
ADD . .
RUN mvn package  
460AWS Lambda Developer Guide
Using an alternative base image
# Copy the function artifact and dependencies onto a clean base
FROM base
WORKDIR /function
COPY --from=build /src/target/dependency/*.jar ./
COPY --from=build /src/target/*.jar ./
# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ " /usr/bin/java", "-cp", "./*", 
 "com.amazonaws.services.lambda.runtime.api.client.AWSLambda " ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "example.App::sayHello " ]
7. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test the image. You can build the emulator into 
your image (p. 130) or install it on your local machine.
To install and run the runtime interface emulator on your local machine
1. From your project directory, run the following command to download the runtime interface 
emulator (x86-64 architecture) from GitHub and install it on your local machine.
mkdir -p ~/.aws-lambda-rie && \ 
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-
runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \ 
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
2. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•/usr/bin/java -cp './*' 
com.amazonaws.services.lambda.runtime.api.client.AWSLambda 
example.App::sayHello  is the ENTRYPOINT  followed by the CMD from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /usr/bin/java -cp './*' 
 com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
3. Post an event to the following endpoint using a curl command:
461AWS Lambda Developer Guide
Using an alternative base image
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
4. Get the container ID.
docker ps
5. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
462AWS Lambda Developer Guide
Using an alternative base image
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
463AWS Lambda Developer Guide
Java customization
Java Lambda function customization settings
This page describes settings speciﬁc to Java functions in AWS Lambda. You can use these settings to 
customize Java runtime startup behavior. This can reduce overall function latency and improve overall 
function performance, without having to modify any code.
Sections
•JAVA_TOOL_OPTIONS environment variable (p. 464)
JAVA_TOOL_OPTIONS  environment variable
In Java, Lambda supports the JAVA_TOOL_OPTIONS  environment variable to set additional command-
line variables in Lambda. You can use this environment variable in various ways, such as to customize 
tiered-compilation settings. The next example demonstrates how to use the JAVA_TOOL_OPTIONS
environment variable for this use case.
Example: Customize tiered compilation settings
Tiered compliation is a feature of the Java virtual machine (JVM). You can use speciﬁc tiered compliation 
settings to make best use of the JVM's just-in-time (JIT) compilers. Typically, the C1 compiler is optimized 
for fast start-up time. The C2 compiler is optimized for best overall performance, but it also uses more 
memory and takes a longer time to achieve it.
There are 5 diﬀerent levels of tiered compilation. At Level 0, the JVM interprets Java byte code. At Level 
4, the JVM uses the C2 compiler to analyze proﬁling data collected during application startup. Over time, 
it monitors code usage to identify the best optimizations.
Customizing the tiered compilation level can help you reduce Java function cold start latency. For 
example, set the tiered compliation level to 1 to have the JVM use the C1 compiler. This compiler 
quickly produces optimized native code but it doesn't generate any proﬁling data and never uses the C2 
compiler.
In the Java 17 runtime, the JVM ﬂag for tiered compilation is set to stop at level 1 by default. For the 
Java 11 runtime and below, you can set the tiered compilation level to 1 by doing the following steps:
To customize tiered compilation settings (console)
1. Open the Functions page in the Lambda console.
2. Choose a Java function that you want to customize tiered compilation for.
3. Choose the Conﬁguration  tab, then choose Environment variables in the left menu.
4. Choose Edit.
5. Choose Add environment variable.
6. For the key, enter JAVA_TOOL_OPTIONS . For the value, enter -XX:+TieredCompilation -
XX:TieredStopAtLevel=1 .
464AWS Lambda Developer Guide
JAVA_TOOL_OPTIONS  environment variable
7. Choose Save.
Note
You can also use Lambda SnapStart to mitigate cold start issues. SnapStart uses cached 
snapshots of your execution environment to signiﬁcantly improve start-up performance. For 
more information about SnapStart features, limitations, and supported regions, see Improving 
startup performance with Lambda SnapStart (p. 1098 ).
Example: Customizing GC behavior using JAVA_TOOL_OPTIONS
Java 11 runtimes use the  Serial  garbage collector (GC) for garbage collection. By default, Java 17 
runtimes also use the Serial GC. However, with Java 17 you can also use the JAVA_TOOL_OPTIONS
environment variable to change the default GC. You can choose between the Parallel GC and 
Shenandoah GC .
For example, if your workload uses more memory and multiple CPUs, consider using the Parallel 
GC for better performance. You can do this by appending the following to the value of your
JAVA_TOOL_OPTIONS  environment variable:
-XX:+UseParallelGC
465AWS Lambda Developer Guide
Context
AWS Lambda context object in Java
When Lambda runs your function, it passes a context object to the handler  (p. 440). This object provides 
methods and properties that provide information about the invocation, function, and execution 
environment.
Context methods
•getRemainingTimeInMillis()  – Returns the number of milliseconds left before the execution 
times out.
•getFunctionName()  – Returns the name of the Lambda function.
•getFunctionVersion()  – Returns the version (p. 108) of the function.
•getInvokedFunctionArn()  – Returns the Amazon Resource Name (ARN) that's used to invoke the 
function. Indicates if the invoker speciﬁed a version number or alias.
•getMemoryLimitInMB()  – Returns the amount of memory that's allocated for the function.
•getAwsRequestId()  – Returns the identiﬁer of the invocation request.
•getLogGroupName()  – Returns the log group for the function.
•getLogStreamName()  – Returns the log stream for the function instance.
•getIdentity()  – (mobile apps) Returns information about the Amazon Cognito identity that 
authorized the request.
•getClientContext()  – (mobile apps) Returns the client context that's provided to Lambda by the 
client application.
•getLogger()  – Returns the logger object (p. 469) for the function.
The following example shows a function that uses the context object to access the Lambda logger.
Example Handler.java
package example;
import com.amazonaws.services.lambda.runtime.Context
import com.amazonaws.services.lambda.runtime.RequestHandler
import com.amazonaws.services.lambda.runtime.LambdaLogger
...
// Handler value: example.Handler
public class Handler implements RequestHandler<Map<String,String>, String>{ 
  Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
  @Override 
  public String handleRequest(Map<String,String> event, Context context) 
  { 
     LambdaLogger logger = context.getLogger();
    String response = new String("200 OK"); 
    // log execution details 
    logger.log("ENVIRONMENT VARIABLES: " + gson.toJson(System.getenv())); 
     logger.log("CONTEXT: " + gson.toJson(context));
    // process event 
    logger.log("EVENT: " + gson.toJson(event)); 
    logger.log("EVENT TYPE: " + event.getClass().toString()); 
    return response; 
  }
}
The function serializes the context object into JSON and records it in its log stream.
466AWS Lambda Developer Guide
Context in sample applications
Example log output
START RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 Version: $LATEST
...
CONTEXT:  
{ 
    "memoryLimit": 512, 
    "awsRequestId": "6bc28136-xmpl-4365-b021-0ce6b2e64ab0", 
    "functionName": "java-console", 
    ...
}
...
END RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0
REPORT RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 Duration: 198.50 ms Billed Duration: 
 200 ms Memory Size: 512 MB Max Memory Used: 90 MB Init Duration: 524.75 ms
The interface for the context object is available in the aws-lambda-java-core library. You can implement 
this interface to create a context class for testing. The following example shows a context class that 
returns dummy values for most properties and a working test logger.
Example src/test/java/example/TestContext.java
package example;
import com.amazonaws.services.lambda.runtime.Context ;
import com.amazonaws.services.lambda.runtime.CognitoIdentity ;
import com.amazonaws.services.lambda.runtime.ClientContext ;
import com.amazonaws.services.lambda.runtime.LambdaLogger
public class TestContext implements Context { 
  public TestContext() {} 
  public String getAwsRequestId(){ 
    return new String("495b12a8-xmpl-4eca-8168-160484189f99"); 
  } 
  public String getLogGroupName(){ 
    return new String("/aws/lambda/my-function"); 
  } 
  ... 
  public LambdaLogger getLogger(){ 
    return new TestLogger(); 
  }
}
For more information on logging, see AWS Lambda function logging in Java (p. 469).
Context in sample applications
The GitHub repository for this guide includes sample applications that demonstrate the use of the 
context object. Each sample application includes scripts for easy deployment and cleanup, an AWS 
Serverless Application Model (AWS SAM) template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
467AWS Lambda Developer Guide
Context in sample applications
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples do 
not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
All of the sample applications have a test context class for unit tests. The java-basic  application shows 
you how to use the context object to get a logger. It uses SLF4J and Log4J 2 to provide a logger that 
works for local unit tests.
468AWS Lambda Developer Guide
Logging
AWS Lambda function logging in Java
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
To output logs from your function code, you can use methods on java.lang.System, or any logging 
module that writes to stdout or stderr. For simple use cases, this approach might be suﬃcient.
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, the CloudWatch console, or Infrastructure as 
code tools such as the AWS Serverless Application Model(AWS SAM).
Sections
•Tools and libraries (p. 469)
•Creating a function that returns logs (p. 469)
•Using Powertools for AWS Lambda (Java) and AWS SAM for structured logging (p. 471)
•Using Powertools for AWS Lambda (Java) and the AWS CDK for structured logging (p. 474)
•Using the Lambda console (p. 482)
•Using the CloudWatch console (p. 482)
•Using the AWS Command Line Interface (AWS CLI) (p. 482)
•Deleting logs  (p. 484)
•Advanced logging with Log4j 2 and SLF4J (p. 484)
•Sample logging code (p. 486)
Tools and libraries
Powertools for AWS Lambda (Java) is a developer toolkit to implement Serverless best practices and 
increase developer velocity. The Logging utility provides a Lambda optimized logger which includes 
additional information about function context across all your functions with output structured as JSON. 
Use this utility to do the following:
•Capture key ﬁelds from the Lambda context, cold start and structures logging output as JSON
•Log Lambda invocation events when instructed (disabled by default)
•Print all the logs only for a percentage of invocations via log sampling (disabled by default)
•Append additional keys to structured log at any point in time
•Use a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with 
your organization’s Logging RFC
Creating a function that returns logs
To output logs from your function code, you can use methods on java.lang.System, or any logging 
module that writes to stdout  or stderr . The aws-lambda-java-core (p. 446) library provides a logger 
class named LambdaLogger  that you can access from the context object. The logger class supports 
multiline logs.
The following example uses the LambdaLogger  logger provided by the context object.
469AWS Lambda Developer Guide
Creating a function that returns logs
Example Handler.java
// Handler value: example.Handler
public class Handler implements RequestHandler<Object, String>{ 
  Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
  @Override 
  public String handleRequest(Object event, Context context) 
  { 
     LambdaLogger logger = context.getLogger();
    String response = new String("SUCCESS"); 
    // log execution details 
     logger.log("ENVIRONMENT VARIABLES: " + gson.toJson(System.getenv())); 
    logger.log("CONTEXT: " + gson.toJson(context));
    // process event 
     logger.log("EVENT: " + gson.toJson(event));
    return response; 
  }
}
Example log format
START RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 Version: $LATEST
ENVIRONMENT VARIABLES:  
{ 
    "_HANDLER": "example.Handler", 
    "AWS_EXECUTION_ENV": "AWS_Lambda_java8", 
    "AWS_LAMBDA_FUNCTION_MEMORY_SIZE": "512", 
    ...
}
CONTEXT:  
{ 
    "memoryLimit": 512, 
    "awsRequestId": "6bc28136-xmpl-4365-b021-0ce6b2e64ab0", 
    "functionName": "java-console", 
    ...
}
EVENT:
{ 
  "records": [ 
    { 
      "messageId": "19dd0b57-xmpl-4ac1-bd88-01bbb068cb78", 
      "receiptHandle": "MessageReceiptHandle", 
      "body": "Hello from SQS!", 
       ... 
    } 
  ]
}
END RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0
REPORT RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 Duration: 198.50 ms Billed Duration: 
 200 ms Memory Size: 512 MB Max Memory Used: 90 MB Init Duration: 524.75 ms
The Java runtime logs the START , END, and REPORT lines for each invocation. The report line provides 
the following details:
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
470AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and AWS SAM for structured logging
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
Using Powertools for AWS Lambda (Java) and AWS 
SAM for structured logging
Follow the steps below to download, build, and deploy a sample Hello World Java application with 
integrated Powertools for AWS Lambda (Java)~ modules using the AWS SAM. This application 
implements a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists 
of an Amazon API Gateway endpoint and a Lambda function. When you send a GET request to the API 
Gateway endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format 
to CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•Java 11
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World Java template.
sam init --app-template hello-world-powertools-java --name sam-app --package-type Zip 
 --runtime java11 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
471AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and AWS SAM for structured logging
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name sam-app
The log output looks like this:
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.095000 
 INIT_START Runtime Version: java:11.v15    Runtime Version ARN: arn:aws:lambda:eu-
central-1::runtime:0a25e3e7a1cc9ce404bc435eeb2ad358d8fa64338e618d0c224fe509403583ca
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.114000 Picked 
 up JAVA_TOOL_OPTIONS: -XX:+TieredCompilation -XX:TieredStopAtLevel=1
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.793000 
 Transforming org/apache/logging/log4j/core/lookup/JndiLookup 
 (lambdainternal.CustomerClassLoader@1a6c5a9e)
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:35.252000 START 
 RequestId: 7fcf1548-d2d4-41cd-a9a8-6ae47c51f765 Version: $LATEST
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:36.531000 { 
  "_aws": { 
    "Timestamp": 1675416276051, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "sam-app-powerools-java", 
        "Metrics": [ 
          { 
            "Name": "ColdStart", 
            "Unit": "Count" 
          } 
        ], 
        "Dimensions": [ 
          [ 
            "Service", 
            "FunctionName" 
          ] 
        ] 
      } 
    ] 
  }, 
  "function_request_id": "7fcf1548-d2d4-41cd-a9a8-6ae47c51f765", 
  "traceId": 
 "Root=1-63dcd2d1-25f90b9d1c753a783547f4dd;Parent=e29684c1be352ce4;Sampled=1", 
  "FunctionName": "sam-app-HelloWorldFunction-y9Iu1FLJJBGD", 
  "functionVersion": "$LATEST", 
  "ColdStart": 1.0, 
  "Service": "service_undefined", 
  "logStreamId": "2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81", 
  "executionEnvironment": "AWS_Lambda_java11"
}
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:36.974000 Feb 03, 
 2023 9:24:36 AM com.amazonaws.xray.AWSXRayRecorder <init>
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:36.993000 Feb 03, 
 2023 9:24:36 AM com.amazonaws.xray.config.DaemonConfiguration <init>
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:36.993000 INFO: 
 Environment variable AWS_XRAY_DAEMON_ADDRESS is set. Emitting to daemon on address 
 XXXX.XXXX.XXXX.XXXX:2000.
472AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and AWS SAM for structured logging
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:37.331000 
 09:24:37.294 [main] INFO  helloworld.App - {"version":null,"resource":"/
hello","path":"/hello/","httpMethod":"GET","headers":{"Accept":"*/
*","CloudFront-Forwarded-Proto":"https","CloudFront-Is-Desktop-
Viewer":"true","CloudFront-Is-Mobile-Viewer":"false","CloudFront-Is-
SmartTV-Viewer":"false","CloudFront-Is-Tablet-Viewer":"false","CloudFront-
Viewer-ASN":"16509","CloudFront-Viewer-Country":"IE","Host":"XXXX.execute-
api.eu-central-1.amazonaws.com","User-Agent":"curl/7.86.0","Via":"2.0 
 f0300a9921a99446a44423d996042050.cloudfront.net (CloudFront)","X-Amz-
Cf-Id":"t9W5ByT11HaY33NM8YioKECn_4eMpNsOMPfEVRczD7T1RdhbtiwV1Q==","X-
Amzn-Trace-Id":"Root=1-63dcd2d1-25f90b9d1c753a783547f4dd","X-Forwarded-
For":"XX.XXX.XXX.XX, XX.XXX.XXX.XX","X-Forwarded-Port":"443","X-Forwarded-
Proto":"https"},"multiValueHeaders":{"Accept":["*/*"],"CloudFront-Forwarded-Proto":
["https"],"CloudFront-Is-Desktop-Viewer":["true"],"CloudFront-Is-Mobile-Viewer":
["false"],"CloudFront-Is-SmartTV-Viewer":["false"],"CloudFront-Is-Tablet-Viewer":
["false"],"CloudFront-Viewer-ASN":["16509"],"CloudFront-Viewer-Country":["IE"],"Host":
["XXXX.execute-api.eu-central-1.amazonaws.com"],"User-Agent":["curl/7.86.0"],"Via":
["2.0 f0300a9921a99446a44423d996042050.cloudfront.net (CloudFront)"],"X-
Amz-Cf-Id":["t9W5ByT11HaY33NM8YioKECn_4eMpNsOMPfEVRczD7T1RdhbtiwV1Q=="],"X-
Amzn-Trace-Id":["Root=1-63dcd2d1-25f90b9d1c753a783547f4dd"],"X-Forwarded-
For":["XXX, XXX"],"X-Forwarded-Port":["443"],"X-Forwarded-Proto":
["https"]},"queryStringParameters":null,"multiValueQueryStringParameters":null,"pathParameters":null,"stageVariables":null,"requestContext":
{"accountId":"XXX","stage":"Prod","resourceId":"at73a1","requestId":"ba09ecd2-
acf3-40f6-89af-fad32df67597","operationName":null,"identity":
{"cognitoIdentityPoolId":null,"accountId":null,"cognitoIdentityId":null,"caller":null,"apiKey":null,"principalOrgId":null,"sourceIp":"54.240.197.236","cognitoAuthenticationType":null,"cognitoAuthenticationProvider":null,"userArn":null,"userAgent":"curl/7.86.0","user":null,"accessKey":null},"resourcePath":"/
hello","httpMethod":"GET","apiId":"XXX","path":"/Prod/
hello/","authorizer":null},"body":null,"isBase64Encoded":false}
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:37.351000 
 09:24:37.351 [main] INFO  helloworld.App - Retrieving https://checkip.amazonaws.com
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:39.313000 { 
  "function_request_id": "7fcf1548-d2d4-41cd-a9a8-6ae47c51f765", 
  "traceId": 
 "Root=1-63dcd2d1-25f90b9d1c753a783547f4dd;Parent=e29684c1be352ce4;Sampled=1", 
  "xray_trace_id": "1-63dcd2d1-25f90b9d1c753a783547f4dd", 
  "functionVersion": "$LATEST", 
  "Service": "service_undefined", 
  "logStreamId": "2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81", 
  "executionEnvironment": "AWS_Lambda_java11"
}
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:39.371000 END 
 RequestId: 7fcf1548-d2d4-41cd-a9a8-6ae47c51f765
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:39.371000 REPORT 
 RequestId: 7fcf1548-d2d4-41cd-a9a8-6ae47c51f765    Duration: 4118.98 ms    Billed 
 Duration: 4119 ms    Memory Size: 512 MB    Max Memory Used: 152 MB    Init Duration: 
 1155.47 ms     
XRAY TraceId: 1-63dcd2d1-25f90b9d1c753a783547f4dd    SegmentId: 3a028fee19b895cb    
 Sampled: true
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Managing log retention
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which CloudWatch automatically deletes the 
logs. To set up log retention, add the following to your AWS SAM template:
Resources: 
  HelloWorldFunction: 
    Type: AWS::Serverless::Function 
473AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
    Properties: 
      # Omitting other properties 
  LogGroup: 
    Type: AWS::Logs::LogGroup 
    Properties: 
      LogGroupName: !Sub "/aws/lambda/${HelloWorldFunction}" 
      RetentionInDays: 7
Using Powertools for AWS Lambda (Java) and the 
AWS CDK for structured logging
Follow the steps below to download, build, and deploy a sample Hello World Java application with 
integrated Powertools for AWS Lambda (Java) modules using the AWS CDK. This application implements 
a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon 
API Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway 
endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format to 
CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
•Java 11
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language java
3. Create a maven project with the following command:
mkdir app
cd app
mvn archetype:generate -DgroupId=helloworld -DartifactId=Function -
DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
4. Open pom.xml  in the hello-world\app\Function  directory and replace the existing code with 
the following code that includes dependencies and maven plugins for Powertools.
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/
XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-
v4_0_0.xsd"> 
  <modelVersion>4.0.0</modelVersion> 
  <groupId>helloworld</groupId> 
474AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
  <artifactId>Function</artifactId> 
  <packaging>jar</packaging> 
  <version>1.0-SNAPSHOT</version> 
  <name>Function</name> 
  <url>http://maven.apache.org</url>
<properties> 
    <maven.compiler.source>11</maven.compiler.source> 
    <maven.compiler.target>11</maven.compiler.target> 
    <log4j.version>2.17.2</log4j.version>
</properties> 
    <dependencies> 
        <dependency> 
            <groupId>junit</groupId> 
            <artifactId>junit</artifactId> 
            <version>3.8.1</version> 
            <scope>test</scope> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-tracing</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-metrics</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-logging</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>com.amazonaws</groupId> 
            <artifactId>aws-lambda-java-core</artifactId> 
            <version>1.2.2</version> 
        </dependency> 
        <dependency> 
            <groupId>com.amazonaws</groupId> 
            <artifactId>aws-lambda-java-events</artifactId> 
            <version>3.11.1</version> 
        </dependency> 
  </dependencies>
<build> 
    <plugins> 
        <plugin> 
            <groupId>org.codehaus.mojo</groupId> 
            <artifactId>aspectj-maven-plugin</artifactId> 
            <version>1.14.0</version> 
            <configuration> 
                <source>${maven.compiler.source}</source> 
                <target>${maven.compiler.target}</target> 
                <complianceLevel>${maven.compiler.target}</complianceLevel> 
                <aspectLibraries> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-tracing</artifactId> 
                    </aspectLibrary> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-metrics</artifactId> 
                    </aspectLibrary> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-logging</artifactId> 
                    </aspectLibrary> 
475AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
                </aspectLibraries> 
            </configuration> 
            <executions> 
                <execution> 
                    <goals> 
                        <goal>compile</goal> 
                    </goals> 
                </execution> 
            </executions> 
        </plugin> 
        <plugin> 
                <groupId>org.apache.maven.plugins</groupId> 
                <artifactId>maven-shade-plugin</artifactId> 
                <version>3.4.1</version> 
                <executions> 
                    <execution> 
                        <phase>package</phase> 
                        <goals> 
                            <goal>shade</goal> 
                        </goals> 
                        <configuration> 
                            <transformers> 
                                <transformer 
                                        
 implementation="com.github.edwgiz.maven_shade_plugin.log4j2_cache_transformer.PluginsCacheFileTransformer"> 
                                </transformer> 
                            </transformers> 
                            <createDependencyReducedPom>false</
createDependencyReducedPom> 
                            <finalName>function</finalName> 
                        </configuration> 
                    </execution> 
                </executions> 
                <dependencies> 
                    <dependency> 
                        <groupId>com.github.edwgiz</groupId> 
                        <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</
artifactId> 
                        <version>2.15</version> 
                    </dependency> 
                </dependencies> 
        </plugin> 
    </plugins>
</build>
</project>
5. Create the hello-world\app\src\main\resource  directory and create log4j.xml  for the log 
conﬁguration.
mkdir -p src/main/resource
cd src/main/resource
touch log4j.xml
6. Open log4j.xml  and add the following code.
<?xml version="1.0" encoding="UTF-8"?>
<Configuration> 
    <Appenders> 
        <Console name="JsonAppender" target="SYSTEM_OUT"> 
            <JsonTemplateLayout eventTemplateUri="classpath:LambdaJsonLayout.json" /> 
        </Console> 
    </Appenders> 
    <Loggers> 
476AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
        <Logger name="JsonLogger" level="INFO" additivity="false"> 
            <AppenderRef ref="JsonAppender"/> 
        </Logger> 
        <Root level="info"> 
            <AppenderRef ref="JsonAppender"/> 
        </Root> 
    </Loggers>
</Configuration>
7. Open App.java  from the hello-world\app\Function\src\main\java\helloworld
directory and replace the existing code with the following code. This is the code for the Lambda 
function.
package helloworld;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.logging.Logging;
import software.amazon.lambda.powertools.metrics.Metrics;
import software.amazon.lambda.powertools.tracing.CaptureMode;
import software.amazon.lambda.powertools.tracing.Tracing;
import static software.amazon.lambda.powertools.tracing.CaptureMode.*;
/** 
 * Handler for requests to Lambda function. 
 */
public class App implements RequestHandler<APIGatewayProxyRequestEvent, 
 APIGatewayProxyResponseEvent> { 
    Logger log = LogManager.getLogger(App.class); 
    @Logging(logEvent = true) 
    @Tracing(captureMode = DISABLED) 
    @Metrics(captureColdStart = true) 
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent 
 input, final Context context) { 
        Map<String, String> headers = new HashMap<>(); 
        headers.put("Content-Type", "application/json"); 
        headers.put("X-Custom-Header", "application/json"); 
        APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent() 
                .withHeaders(headers); 
        try { 
            final String pageContents = this.getPageContents("https://
checkip.amazonaws.com"); 
            String output = String.format("{ \"message\": \"hello world\", \"location
\": \"%s\" }", pageContents); 
            return response 
                    .withStatusCode(200) 
                    .withBody(output); 
        } catch (IOException e) { 
477AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
            return response 
                    .withBody("{}") 
                    .withStatusCode(500); 
        } 
    } 
    @Tracing(namespace = "getPageContents") 
    private String getPageContents(String address) throws IOException { 
        log.info("Retrieving {}", address); 
        URL url = new URL(address); 
        try (BufferedReader br = new BufferedReader(new 
 InputStreamReader(url.openStream()))) { 
            return br.lines().collect(Collectors.joining(System.lineSeparator())); 
        } 
    }
}
8. Open HelloWorldStack.java  from the hello-world\src\main\java\com\myorg  directory 
and replace the existing code with the following code. This code uses Lambda Constructorand the
ApiGatewayv2 Constructor to create a REST API and a Lambda function.
package com.myorg;
import software.amazon.awscdk.*;
import software.amazon.awscdk.services.apigatewayv2.alpha.*;
import 
 software.amazon.awscdk.services.apigatewayv2.integrations.alpha.HttpLambdaIntegration;
import 
 software.amazon.awscdk.services.apigatewayv2.integrations.alpha.HttpLambdaIntegrationProps;
import software.amazon.awscdk.services.lambda.Code;
import software.amazon.awscdk.services.lambda.Function;
import software.amazon.awscdk.services.lambda.FunctionProps;
import software.amazon.awscdk.services.lambda.Runtime;
import software.amazon.awscdk.services.logs.RetentionDays;
import software.amazon.awscdk.services.s3.assets.AssetOptions;
import software.constructs.Construct;
import java.util.Arrays;
import java.util.List;
import static java.util.Collections.singletonList;
import static software.amazon.awscdk.BundlingOutput.ARCHIVED;
public class HelloWorldStack extends Stack { 
    public HelloWorldStack(final Construct scope, final String id) { 
        this(scope, id, null); 
    } 
    public HelloWorldStack(final Construct scope, final String id, final StackProps 
 props) { 
        super(scope, id, props); 
        List<String> functionPackagingInstructions = Arrays.asList( 
                "/bin/sh", 
                "-c", 
                "cd Function " + 
                        "&& mvn clean install " + 
                        "&& cp /asset-input/Function/target/function.jar /asset-
output/" 
        ); 
        BundlingOptions.Builder builderOptions = BundlingOptions.builder() 
                .command(functionPackagingInstructions) 
                .image(Runtime.JAVA_11.getBundlingImage()) 
                .volumes(singletonList( 
                        // Mount local .m2 repo to avoid download all the dependencies 
 again inside the container 
478AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
                        DockerVolume.builder() 
                                .hostPath(System.getProperty("user.home") + "/.m2/") 
                                .containerPath("/root/.m2/") 
                                .build() 
                )) 
                .user("root") 
                .outputType(ARCHIVED); 
        Function function = new Function(this, "Function", FunctionProps.builder() 
                .runtime(Runtime.JAVA_11) 
                .code(Code.fromAsset("app", AssetOptions.builder() 
                        .bundling(builderOptions 
                                .command(functionPackagingInstructions) 
                                .build()) 
                        .build())) 
                .handler("helloworld.App::handleRequest") 
                .memorySize(1024) 
                .timeout(Duration.seconds(10)) 
                .logRetention(RetentionDays.ONE_WEEK) 
                .build()); 
        HttpApi httpApi = new HttpApi(this, "sample-api", HttpApiProps.builder() 
                .apiName("sample-api") 
                .build()); 
        httpApi.addRoutes(AddRoutesOptions.builder() 
                .path("/") 
                .methods(singletonList(HttpMethod.GET)) 
                .integration(new HttpLambdaIntegration("function", function, 
 HttpLambdaIntegrationProps.builder() 
                        .payloadFormatVersion(PayloadFormatVersion.VERSION_2_0) 
                        .build())) 
                .build()); 
        new CfnOutput(this, "HttpApi", CfnOutputProps.builder() 
                .description("Url for Http Api") 
                .value(httpApi.getApiEndpoint()) 
                .build()); 
    }
}
9. Open pom.xml from the hello-world  directory and replace the existing code with the following 
code.
<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/
xsd/maven-4.0.0.xsd" 
         xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/
XMLSchema-instance"> 
    <modelVersion>4.0.0</modelVersion> 
    <groupId>com.myorg</groupId> 
    <artifactId>hello-world</artifactId> 
    <version>0.1</version> 
    <properties> 
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 
        <cdk.version>2.70.0</cdk.version> 
        <constructs.version>[10.0.0,11.0.0)</constructs.version> 
        <junit.version>5.7.1</junit.version> 
    </properties> 
    <build> 
        <plugins> 
            <plugin> 
479AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
                <groupId>org.apache.maven.plugins</groupId> 
                <artifactId>maven-compiler-plugin</artifactId> 
                <version>3.8.1</version> 
                <configuration> 
                    <source>1.8</source> 
                    <target>1.8</target> 
                </configuration> 
            </plugin> 
            <plugin> 
                <groupId>org.codehaus.mojo</groupId> 
                <artifactId>exec-maven-plugin</artifactId> 
                <version>3.0.0</version> 
                <configuration> 
                    <mainClass>com.myorg.HelloWorldApp</mainClass> 
                </configuration> 
            </plugin> 
        </plugins> 
    </build> 
    <dependencies> 
        <!-- AWS Cloud Development Kit --> 
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>aws-cdk-lib</artifactId> 
            <version>${cdk.version}</version> 
        </dependency> 
        <dependency> 
            <groupId>software.constructs</groupId> 
            <artifactId>constructs</artifactId> 
            <version>${constructs.version}</version> 
        </dependency> 
        <dependency> 
          <groupId>org.junit.jupiter</groupId> 
          <artifactId>junit-jupiter</artifactId> 
          <version>${junit.version}</version> 
          <scope>test</scope> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>apigatewayv2-alpha</artifactId> 
            <version>${cdk.version}-alpha.0</version> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>apigatewayv2-integrations-alpha</artifactId> 
            <version>${cdk.version}-alpha.0</version> 
        </dependency> 
    </dependencies>
</project>
10. Make sure you’re in the hello-world  directory and deploy your application.
cdk deploy
11. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?OutputKey==`HttpApi`].OutputValue' --output text
12. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
480AWS Lambda Developer Guide
Using Powertools for AWS Lambda (Java) 
and the AWS CDK for structured logging
If successful, you'll see this response:
{"message":"hello world"}
13. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name HelloWorldStack
The log output looks like this:
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.095000 
 INIT_START Runtime Version: java:11.v15    Runtime Version ARN: arn:aws:lambda:eu-
central-1::runtime:0a25e3e7a1cc9ce404bc435eeb2ad358d8fa64338e618d0c224fe509403583ca
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.114000 Picked 
 up JAVA_TOOL_OPTIONS: -XX:+TieredCompilation -XX:TieredStopAtLevel=1
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:34.793000 
 Transforming org/apache/logging/log4j/core/lookup/JndiLookup 
 (lambdainternal.CustomerClassLoader@1a6c5a9e)
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:35.252000 START 
 RequestId: 7fcf1548-d2d4-41cd-a9a8-6ae47c51f765 Version: $LATEST
2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81 2023-02-03T09:24:36.531000 { 
  "_aws": { 
    "Timestamp": 1675416276051, 
    "CloudWatchMetrics": [ 
      { 
        "Namespace": "sam-app-powerools-java", 
        "Metrics": [ 
          { 
            "Name": "ColdStart", 
            "Unit": "Count" 
          } 
        ], 
        "Dimensions": [ 
          [ 
            "Service", 
            "FunctionName" 
          ] 
        ] 
      } 
    ] 
  }, 
  "function_request_id": "7fcf1548-d2d4-41cd-a9a8-6ae47c51f765", 
  "traceId": 
 "Root=1-63dcd2d1-25f90b9d1c753a783547f4dd;Parent=e29684c1be352ce4;Sampled=1", 
  "FunctionName": "sam-app-HelloWorldFunction-y9Iu1FLJJBGD", 
  "functionVersion": "$LATEST", 
  "ColdStart": 1.0, 
  "Service": "service_undefined", 
  "logStreamId": "2023/02/03/[$LATEST]851411a899b545eea2cffeba4cfbec81", 
  "executionEnvironment": "AWS_Lambda_java11"
}
14. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
481AWS Lambda Developer Guide
Using the Lambda console
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
482AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
483AWS Lambda Developer Guide
Deleting logs
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
Advanced logging with Log4j 2 and SLF4J
Note
AWS Lambda does not include Log4j2 in its managed runtimes or base container images. These 
are therefore not aﬀected by the issues described in CVE-2021-44228, CVE-2021-45046, and 
CVE-2021-45105.
For cases where a customer function includes an impacted Log4j2 version, we have applied 
a change to the Lambda Java managed runtimes  (p. 41) and base container images (p. 453)
that helps to mitigate the issues in CVE-2021-44228, CVE-2021-45046, and CVE-2021-45105. 
As a result of this change, customers using Log4J2 may see an additional log entry, similar 
to "Transforming org/apache/logging/log4j/core/lookup/JndiLookup 
(java.net.URLClassLoader@...) ". Any log strings that reference the jndi mapper in the 
Log4J2 output will be replaced with "Patched JndiLookup::lookup() ".
Independent of this change, we strongly encourage all customers whose functions include 
Log4j2 to update to the latest version. Speciﬁcally, customers using the aws-lambda-java-log4j2 
484AWS Lambda Developer Guide
Advanced logging with Log4j 2 and SLF4J
library in their functions should update to version 1.5.0 (or later), and redeploy their functions. 
This version updates the underlying Log4j2 utility dependencies to version 2.17.0 (or later). The 
updated aws-lambda-java-log4j2 binary is available at the Maven repository and its source code 
is available in Github .
To customize log output, support logging during unit tests, and log AWS SDK calls, use Apache Log4j 2 
with SLF4J. Log4j is a logging library for Java programs that enables you to conﬁgure log levels and use 
appender libraries. SLF4J is a facade library that lets you change which library you use without changing 
your function code.
To add the request ID to your function's logs, use the appender in the aws-lambda-java-log4j2 (p. 446)
library. The following example shows a Log4j 2 conﬁguration ﬁle that adds a timestamp and request ID 
to all logs.
Example src/main/resources/log4j2.xml – Appender conﬁguration
<Configuration status="WARN"> 
   <Appenders> 
    <Lambda name="Lambda"> 
      <PatternLayout> 
          <pattern>%d{yyyy-MM-dd HH:mm:ss} %X{AWSRequestId} %-5p %c{1} - %m%n</pattern> 
      </PatternLayout> 
    </Lambda> 
  </Appenders>
  <Loggers> 
     <Root level="INFO"> 
      <AppenderRef ref="Lambda"/> 
    </Root>
    <Logger name="software.amazon.awssdk" level="WARN" /> 
    <Logger name="software.amazon.awssdk.request" level="DEBUG" /> 
  </Loggers>
</Configuration>
With this conﬁguration, each line is prepended with the date, time, request ID, log level, and class name.
Example log format with appender
START RequestId: 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 Version: $LATEST
2020-03-18 08:52:43 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 INFO  Handler -  ENVIRONMENT 
 VARIABLES:
{ 
    "_HANDLER": "example.Handler", 
    "AWS_EXECUTION_ENV": "AWS_Lambda_java8", 
    "AWS_LAMBDA_FUNCTION_MEMORY_SIZE": "512", 
    ...
}
2020-03-18 08:52:43 6bc28136-xmpl-4365-b021-0ce6b2e64ab0 INFO  Handler -  CONTEXT:
{ 
    "memoryLimit": 512, 
    "awsRequestId": "6bc28136-xmpl-4365-b021-0ce6b2e64ab0", 
    "functionName": "java-console", 
    ...
}
SLF4J is a facade library for logging in Java code. In your function code, you use the SLF4J logger factory 
to retrieve a logger with methods for log levels like info()  and warn(). In your build conﬁguration, 
you include the logging library and SLF4J adapter in the classpath. By changing the libraries in the build 
conﬁguration, you can change the logger type without changing your function code. SLF4J is required to 
capture logs from the SDK for Java.
In the following example, the handler class uses SLF4J to retrieve a logger.
485AWS Lambda Developer Guide
Sample logging code
Example src/main/java/example/HandlerS3.java – Logging with SLF4J
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
// Handler value: example.Handler
public class HandlerS3 implements RequestHandler<S3Event, String>{ 
     private static final Logger logger = LoggerFactory.getLogger(HandlerS3.class);
    Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
    @Override 
    public String handleRequest(S3Event event, Context context) 
    { 
        ... 
        logger.info("RECORD: " + record); 
        logger.info("SOURCE BUCKET: " + srcBucket); 
        logger.info("SOURCE KEY: " + srcKey); 
        ... 
    }
}
The build conﬁguration takes runtime dependencies on the Lambda appender and SLF4J adapter, and 
implementation dependencies on Log4J 2.
Example build.gradle – Logging dependencies
dependencies { 
    ... 
     implementation 'org.apache.logging.log4j:log4j-api:[2.17.1,)' 
    implementation 'org.apache.logging.log4j:log4j-core:[2.17.1,)' 
    implementation 'org.apache.logging.log4j:log4j-slf4j18-impl:[2.17.1,)'
    ...
}
When you run your code locally for tests, the context object with the Lambda logger is not available, and 
there's no request ID for the Lambda appender to use. For example test conﬁgurations, see the sample 
applications in the next section.
Sample logging code
The GitHub repository for this guide includes sample applications that demonstrate the use of various 
logging conﬁgurations. Each sample application includes scripts for easy deployment and cleanup, an 
AWS SAM template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples do 
not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
486AWS Lambda Developer Guide
Sample logging code
The java-basic  sample application shows a minimal logging conﬁguration that supports logging 
tests. The handler code uses the LambdaLogger  logger provided by the context object. For tests, the 
application uses a custom TestLogger  class that implements the LambdaLogger  interface with a Log4j 
2 logger. It uses SLF4J as a facade for compatibility with the AWS SDK. Logging libraries are excluded 
from build output to keep the deployment package small.
487AWS Lambda Developer Guide
Errors
AWS Lambda function errors in Java
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the Java runtime using the 
Lambda console and the AWS CLI.
Sections
•Syntax (p. 488)
•How it works (p. 489)
•Creating a function that returns exceptions (p. 489)
•Using the Lambda console (p. 490)
•Using the AWS Command Line Interface (AWS CLI) (p. 491)
•Error handling in other AWS services (p. 491)
•Sample applications  (p. 492)
•What's next? (p. 492)
Syntax
In the following example, the runtime fails to deserialize the event into an object. The input is a valid 
JSON type, but it doesn't match the type expected by the handler method.
Example Lambda runtime error
{ 
  "errorMessage": "An error occurred during JSON parsing", 
  "errorType": "java.lang.RuntimeException", 
  "stackTrace": [], 
  "cause": { 
    "errorMessage": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not 
 construct instance of java.lang.Integer from String value '1000,10': not a valid Integer 
 value\n at [Source: lambdainternal.util.NativeMemoryAsInputStream@35fc6dc4; line: 1, 
 column: 1] (through reference chain: java.lang.Object[0])", 
    "errorType": "java.io.UncheckedIOException", 
    "stackTrace": [], 
    "cause": { 
      "errorMessage": "Can not construct instance of java.lang.Integer 
 from String value '1000,10': not a valid Integer value\n at [Source: 
 lambdainternal.util.NativeMemoryAsInputStream@35fc6dc4; line: 1, column: 1] (through 
 reference chain: java.lang.Object[0])", 
      "errorType": "com.fasterxml.jackson.databind.exc.InvalidFormatException", 
      "stackTrace": [ 
        
 "com.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:55)", 
        
 "com.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:907)", 
        ... 
      ] 
    } 
  }
}
488AWS Lambda Developer Guide
How it works
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Creating a function that returns exceptions
You can create a Lambda function that displays human-readable error messages to users.
Note
To test this code, you need to include InputLengthException.java in your project src folder.
Example src/main/java/example/HandlerDivide.java – Runtime exception
import java.util.List; 
  // Handler value: example.HandlerDivide 
  public class HandlerDivide implements RequestHandler<List<Integer>, Integer>{ 
    Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
    @Override 
    public Integer handleRequest(List<Integer> event, Context context) 
    { 
      LambdaLogger logger = context.getLogger(); 
      // process event 
       if ( event.size() != 2 ) 
      { 
489AWS Lambda Developer Guide
Using the Lambda console
        throw new InputLengthException("Input must be a list that contains 2 numbers."); 
      }
      int numerator = event.get(0); 
      int denominator = event.get(1); 
      logger.log("EVENT: " + gson.toJson(event)); 
      logger.log("EVENT TYPE: " + event.getClass().toString()); 
      return numerator/denominator; 
    } 
  }
When the function throws InputLengthException , the Java runtime serializes it into the following 
document.
Example error document (whitespace added)
{ 
    "errorMessage":"Input must be a list that contains 2 numbers.", 
    "errorType":"java.lang.InputLengthException", 
    "stackTrace": [ 
      "example.HandlerDivide.handleRequest(HandlerDivide.java:23)", 
      "example.HandlerDivide.handleRequest(HandlerDivide.java:14)" 
    ] 
  }
In this example, InputLengthException is a RuntimeException . The RequestHandler
interface (p. 443) does not allow checked exceptions. The RequestStreamHandler  interface supports 
throwing IOException  errors.
The return statement in the previous example can also throw a runtime exception.
    return numerator/denominator;
This code can return an arithmetic error.
{"errorMessage":"/ by zero","errorType":"java.lang.ArithmeticException","stackTrace":
["example.HandlerDivide.handleRequest(HandlerDivide.java:28)","example.HandlerDivide.handleRequest(HandlerDivide.java:13)"]}
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
490AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
{"errorMessage":"Input must contain 2 
 numbers.","errorType":"java.lang.InputLengthException","stackTrace": 
 ["example.HandlerDivide.handleRequest(HandlerDivide.java:23)","example.HandlerDivide.handleRequest(HandlerDivide.java:14)"]}
Lambda also records up to 256 KB of the error object in the function's logs. For more information, see
AWS Lambda function logging in Java (p. 469).
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
491AWS Lambda Developer Guide
Sample applications
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
For more information, see Instrumenting Java code in AWS Lambda (p. 493).
Sample applications
The GitHub repository for this guide includes sample applications that demonstrate the use of the 
errors. Each sample application includes scripts for easy deployment and cleanup, an AWS Serverless 
Application Model (AWS SAM) template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples do 
not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
The java-basic  function includes a handler (HandlerDivide ) that returns a custom runtime 
exception. The HandlerStream  handler implements the RequestStreamHandler  and can throw an
IOException  checked exception.
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 469) page.
492AWS Lambda Developer Guide
Tracing
Instrumenting Java code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of two SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for Java – An SDK for generating and sending trace data to X-Ray.
•Powertools for AWS Lambda (Java) – A developer toolkit to implement Serverless best practices and 
increase developer velocity.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using Powertools for AWS Lambda (Java) and AWS SAM for tracing (p. 493)
•Using Powertools for AWS Lambda (Java) and the AWS CDK for tracing (p. 495)
•Using ADOT to instrument your Java functions (p. 503)
•Using the X-Ray SDK to instrument your Java functions (p. 503)
•Activating tracing with the Lambda console (p. 504)
•Activating tracing with the Lambda API (p. 504)
•Activating tracing with AWS CloudFormation (p. 504)
•Interpreting an X-Ray trace (p. 505)
•Storing runtime dependencies in a layer (X-Ray SDK) (p. 506)
•X-Ray tracing in sample applications (X-Ray SDK) (p. 507)
Using Powertools for AWS Lambda (Java) and AWS 
SAM for tracing
Follow the steps below to download, build, and deploy a sample Hello World Java application with 
integrated Powertools for AWS Lambda (Java) modules using the AWS SAM. This application implements 
a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon 
API Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway 
endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format to 
CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
493AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and AWS SAM for tracing
•Java 11
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World Java template.
sam init --app-template hello-world-powertools-java --name sam-app --package-type Zip 
 --runtime java11 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
New XRay Service Graph 
  Start time: 2023-02-03 14:31:48+01:00 
  End time: 2023-02-03 14:31:48+01:00 
  Reference Id: 0 - (Root) AWS::Lambda - sam-app-HelloWorldFunction-y9Iu1FLJJBGD - 
 Edges: [] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 5.587 
494AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
  Reference Id: 1 - client - sam-app-HelloWorldFunction-y9Iu1FLJJBGD - Edges: [0] 
   Summary_statistics: 
     - total requests: 0 
     - ok count(2XX): 0 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0
XRay Event [revision 3] at (2023-02-03T14:31:48.500000) with id 
 (1-63dd0cc4-3c869dec72a586875da39777) and duration (5.603s) 
 - 5.587s - sam-app-HelloWorldFunction-y9Iu1FLJJBGD [HTTP: 200] 
 - 4.053s - sam-app-HelloWorldFunction-y9Iu1FLJJBGD 
   - 1.181s - Initialization 
   - 4.037s - Invocation 
     - 1.981s - ## handleRequest 
       - 1.840s - ## getPageContents 
   - 0.000s - Overhead
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Using Powertools for AWS Lambda (Java) and the 
AWS CDK for tracing
Follow the steps below to download, build, and deploy a sample Hello World Java application with 
integrated Powertools for AWS Lambda (Java) modules using the AWS CDK. This application implements 
a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon 
API Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway 
endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format to 
CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
•Java 11
•AWS CLI version 2
•AWS CDK version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
Deploy a sample AWS CDK application
1. Create a project directory for your new application.
mkdir hello-world
cd hello-world
2. Initialize the app.
cdk init app --language java
3. Create a maven project with the following command:
495AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
mkdir app
cd app
mvn archetype:generate -DgroupId=helloworld -DartifactId=Function -
DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
4. Open pom.xml  in the hello-world\app\Function  directory and replace the existing code with 
the following code that includes dependencies and maven plugins for Powertools.
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/
XMLSchema-instance" 
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-
v4_0_0.xsd"> 
  <modelVersion>4.0.0</modelVersion> 
  <groupId>helloworld</groupId> 
  <artifactId>Function</artifactId> 
  <packaging>jar</packaging> 
  <version>1.0-SNAPSHOT</version> 
  <name>Function</name> 
  <url>http://maven.apache.org</url>
<properties> 
    <maven.compiler.source>11</maven.compiler.source> 
    <maven.compiler.target>11</maven.compiler.target> 
    <log4j.version>2.17.2</log4j.version>
</properties> 
    <dependencies> 
        <dependency> 
            <groupId>junit</groupId> 
            <artifactId>junit</artifactId> 
            <version>3.8.1</version> 
            <scope>test</scope> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-tracing</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-metrics</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.lambda</groupId> 
            <artifactId>powertools-logging</artifactId> 
            <version>1.3.0</version> 
        </dependency> 
        <dependency> 
            <groupId>com.amazonaws</groupId> 
            <artifactId>aws-lambda-java-core</artifactId> 
            <version>1.2.2</version> 
        </dependency> 
        <dependency> 
            <groupId>com.amazonaws</groupId> 
            <artifactId>aws-lambda-java-events</artifactId> 
            <version>3.11.1</version> 
        </dependency> 
  </dependencies>
<build> 
    <plugins> 
        <plugin> 
            <groupId>org.codehaus.mojo</groupId> 
            <artifactId>aspectj-maven-plugin</artifactId> 
            <version>1.14.0</version> 
496AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
            <configuration> 
                <source>${maven.compiler.source}</source> 
                <target>${maven.compiler.target}</target> 
                <complianceLevel>${maven.compiler.target}</complianceLevel> 
                <aspectLibraries> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-tracing</artifactId> 
                    </aspectLibrary> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-metrics</artifactId> 
                    </aspectLibrary> 
                    <aspectLibrary> 
                        <groupId>software.amazon.lambda</groupId> 
                        <artifactId>powertools-logging</artifactId> 
                    </aspectLibrary> 
                </aspectLibraries> 
            </configuration> 
            <executions> 
                <execution> 
                    <goals> 
                        <goal>compile</goal> 
                    </goals> 
                </execution> 
            </executions> 
        </plugin> 
        <plugin> 
                <groupId>org.apache.maven.plugins</groupId> 
                <artifactId>maven-shade-plugin</artifactId> 
                <version>3.4.1</version> 
                <executions> 
                    <execution> 
                        <phase>package</phase> 
                        <goals> 
                            <goal>shade</goal> 
                        </goals> 
                        <configuration> 
                            <transformers> 
                                <transformer 
                                        
 implementation="com.github.edwgiz.maven_shade_plugin.log4j2_cache_transformer.PluginsCacheFileTransformer"> 
                                </transformer> 
                            </transformers> 
                            <createDependencyReducedPom>false</
createDependencyReducedPom> 
                            <finalName>function</finalName> 
                        </configuration> 
                    </execution> 
                </executions> 
                <dependencies> 
                    <dependency> 
                        <groupId>com.github.edwgiz</groupId> 
                        <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</
artifactId> 
                        <version>2.15</version> 
                    </dependency> 
                </dependencies> 
        </plugin> 
    </plugins>
</build>
</project>
497AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
5. Create the hello-world\app\src\main\resource  directory and create log4j.xml  for the log 
conﬁguration.
mkdir -p src/main/resource
cd src/main/resource
touch log4j.xml
6. Open log4j.xml  and add the following code.
<?xml version="1.0" encoding="UTF-8"?>
<Configuration> 
    <Appenders> 
        <Console name="JsonAppender" target="SYSTEM_OUT"> 
            <JsonTemplateLayout eventTemplateUri="classpath:LambdaJsonLayout.json" /> 
        </Console> 
    </Appenders> 
    <Loggers> 
        <Logger name="JsonLogger" level="INFO" additivity="false"> 
            <AppenderRef ref="JsonAppender"/> 
        </Logger> 
        <Root level="info"> 
            <AppenderRef ref="JsonAppender"/> 
        </Root> 
    </Loggers>
</Configuration>
7. Open App.java  from the hello-world\app\Function\src\main\java\helloworld
directory and replace the existing code with the following code. This is the code for the Lambda 
function.
package helloworld;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.lambda.powertools.logging.Logging;
import software.amazon.lambda.powertools.metrics.Metrics;
import software.amazon.lambda.powertools.tracing.CaptureMode;
import software.amazon.lambda.powertools.tracing.Tracing;
import static software.amazon.lambda.powertools.tracing.CaptureMode.*;
/** 
 * Handler for requests to Lambda function. 
 */
public class App implements RequestHandler<APIGatewayProxyRequestEvent, 
 APIGatewayProxyResponseEvent> { 
    Logger log = LogManager.getLogger(App.class); 
    @Logging(logEvent = true) 
    @Tracing(captureMode = DISABLED) 
498AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
    @Metrics(captureColdStart = true) 
    public APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent 
 input, final Context context) { 
        Map<String, String> headers = new HashMap<>(); 
        headers.put("Content-Type", "application/json"); 
        headers.put("X-Custom-Header", "application/json"); 
        APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent() 
                .withHeaders(headers); 
        try { 
            final String pageContents = this.getPageContents("https://
checkip.amazonaws.com"); 
            String output = String.format("{ \"message\": \"hello world\", \"location
\": \"%s\" }", pageContents); 
            return response 
                    .withStatusCode(200) 
                    .withBody(output); 
        } catch (IOException e) { 
            return response 
                    .withBody("{}") 
                    .withStatusCode(500); 
        } 
    } 
    @Tracing(namespace = "getPageContents") 
    private String getPageContents(String address) throws IOException { 
        log.info("Retrieving {}", address); 
        URL url = new URL(address); 
        try (BufferedReader br = new BufferedReader(new 
 InputStreamReader(url.openStream()))) { 
            return br.lines().collect(Collectors.joining(System.lineSeparator())); 
        } 
    }
}
8. Open HelloWorldStack.java  from the hello-world\src\main\java\com\myorg  directory 
and replace the existing code with the following code. This code uses Lambda Constructorand the
ApiGatewayv2 Constructor to create a REST API and a Lambda function.
package com.myorg;
import software.amazon.awscdk.*;
import software.amazon.awscdk.services.apigatewayv2.alpha.*;
import 
 software.amazon.awscdk.services.apigatewayv2.integrations.alpha.HttpLambdaIntegration;
import 
 software.amazon.awscdk.services.apigatewayv2.integrations.alpha.HttpLambdaIntegrationProps;
import software.amazon.awscdk.services.lambda.Code;
import software.amazon.awscdk.services.lambda.Function;
import software.amazon.awscdk.services.lambda.FunctionProps;
import software.amazon.awscdk.services.lambda.Runtime;
import software.amazon.awscdk.services.lambda.Tracing;
import software.amazon.awscdk.services.logs.RetentionDays;
import software.amazon.awscdk.services.s3.assets.AssetOptions;
import software.constructs.Construct;
import java.util.Arrays;
import java.util.List;
import static java.util.Collections.singletonList;
import static software.amazon.awscdk.BundlingOutput.ARCHIVED;
public class HelloWorldStack extends Stack { 
    public HelloWorldStack(final Construct scope, final String id) { 
        this(scope, id, null); 
499AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
    } 
    public HelloWorldStack(final Construct scope, final String id, final StackProps 
 props) { 
        super(scope, id, props); 
        List<String> functionPackagingInstructions = Arrays.asList( 
                "/bin/sh", 
                "-c", 
                "cd Function " + 
                        "&& mvn clean install " + 
                        "&& cp /asset-input/Function/target/function.jar /asset-
output/" 
        ); 
        BundlingOptions.Builder builderOptions = BundlingOptions.builder() 
                .command(functionPackagingInstructions) 
                .image(Runtime.JAVA_11.getBundlingImage()) 
                .volumes(singletonList( 
                        // Mount local .m2 repo to avoid download all the dependencies 
 again inside the container 
                        DockerVolume.builder() 
                                .hostPath(System.getProperty("user.home") + "/.m2/") 
                                .containerPath("/root/.m2/") 
                                .build() 
                )) 
                .user("root") 
                .outputType(ARCHIVED); 
        Function function = new Function(this, "Function", FunctionProps.builder() 
                .runtime(Runtime.JAVA_11) 
                .code(Code.fromAsset("app", AssetOptions.builder() 
                        .bundling(builderOptions 
                                .command(functionPackagingInstructions) 
                                .build()) 
                        .build())) 
                .handler("helloworld.App::handleRequest") 
                .memorySize(1024) 
                .tracing(Tracing.ACTIVE) 
                .timeout(Duration.seconds(10)) 
                .logRetention(RetentionDays.ONE_WEEK) 
                .build()); 
        HttpApi httpApi = new HttpApi(this, "sample-api", HttpApiProps.builder() 
                .apiName("sample-api") 
                .build()); 
        httpApi.addRoutes(AddRoutesOptions.builder() 
                .path("/") 
                .methods(singletonList(HttpMethod.GET)) 
                .integration(new HttpLambdaIntegration("function", function, 
 HttpLambdaIntegrationProps.builder() 
                        .payloadFormatVersion(PayloadFormatVersion.VERSION_2_0) 
                        .build())) 
                .build()); 
        new CfnOutput(this, "HttpApi", CfnOutputProps.builder() 
                .description("Url for Http Api") 
                .value(httpApi.getApiEndpoint()) 
                .build()); 
    }
}
9. Open pom.xml from the hello-world  directory and replace the existing code with the following 
code.
500AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/
xsd/maven-4.0.0.xsd" 
         xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/
XMLSchema-instance"> 
    <modelVersion>4.0.0</modelVersion> 
    <groupId>com.myorg</groupId> 
    <artifactId>hello-world</artifactId> 
    <version>0.1</version> 
    <properties> 
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 
        <cdk.version>2.70.0</cdk.version> 
        <constructs.version>[10.0.0,11.0.0)</constructs.version> 
        <junit.version>5.7.1</junit.version> 
    </properties> 
    <build> 
        <plugins> 
            <plugin> 
                <groupId>org.apache.maven.plugins</groupId> 
                <artifactId>maven-compiler-plugin</artifactId> 
                <version>3.8.1</version> 
                <configuration> 
                    <source>1.8</source> 
                    <target>1.8</target> 
                </configuration> 
            </plugin> 
            <plugin> 
                <groupId>org.codehaus.mojo</groupId> 
                <artifactId>exec-maven-plugin</artifactId> 
                <version>3.0.0</version> 
                <configuration> 
                    <mainClass>com.myorg.HelloWorldApp</mainClass> 
                </configuration> 
            </plugin> 
        </plugins> 
    </build> 
    <dependencies> 
        <!-- AWS Cloud Development Kit --> 
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>aws-cdk-lib</artifactId> 
            <version>${cdk.version}</version> 
        </dependency> 
        <dependency> 
            <groupId>software.constructs</groupId> 
            <artifactId>constructs</artifactId> 
            <version>${constructs.version}</version> 
        </dependency> 
        <dependency> 
          <groupId>org.junit.jupiter</groupId> 
          <artifactId>junit-jupiter</artifactId> 
          <version>${junit.version}</version> 
          <scope>test</scope> 
        </dependency> 
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>apigatewayv2-alpha</artifactId> 
            <version>${cdk.version}-alpha.0</version> 
        </dependency> 
501AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(Java) and the AWS CDK for tracing
        <dependency> 
            <groupId>software.amazon.awscdk</groupId> 
            <artifactId>apigatewayv2-integrations-alpha</artifactId> 
            <version>${cdk.version}-alpha.0</version> 
        </dependency> 
    </dependencies>
</project>
10. Make sure you’re in the hello-world  directory and deploy your application.
cdk deploy
11. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name HelloWorldStack --query 
 'Stacks[0].Outputs[?OutputKey==`HttpApi`].OutputValue' --output text
12. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
13. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
New XRay Service Graph 
  Start time: 2023-02-03 14:59:50+00:00 
  End time: 2023-02-03 14:59:50+00:00 
  Reference Id: 0 - (Root) AWS::Lambda - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [1] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.924 
  Reference Id: 1 - AWS::Lambda::Function - sam-app-HelloWorldFunction-YBg8yfYtOc9j - 
 Edges: [] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0.016 
  Reference Id: 2 - client - sam-app-HelloWorldFunction-YBg8yfYtOc9j - Edges: [0] 
   Summary_statistics: 
     - total requests: 0 
     - ok count(2XX): 0 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0
XRay Event [revision 1] at (2023-02-03T14:59:50.204000) with id 
 (1-63dd2166-434a12c22e1307ff2114f299) and duration (0.924s) 
502AWS Lambda Developer Guide
Using ADOT to instrument your Java functions
 - 0.924s - sam-app-HelloWorldFunction-YBg8yfYtOc9j [HTTP: 200] 
 - 0.016s - sam-app-HelloWorldFunction-YBg8yfYtOc9j 
   - 0.739s - Initialization 
   - 0.016s - Invocation 
     - 0.013s - ## lambda_handler 
       - 0.000s - ## app.hello 
   - 0.000s - Overhead
14. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
cdk destroy
Using ADOT to instrument your Java functions
ADOT provides fully managed Lambda layers (p. 11) that package everything you need to collect 
telemetry data using the OTel SDK. By consuming this layer, you can instrument your Lambda functions 
without having to modify any function code. You can also conﬁgure your layer to do custom initialization 
of OTel. For more information, see Custom conﬁguration for the ADOT Collector on Lambda in the ADOT 
documentation.
For Java runtimes, you can choose between two layers to consume:
•AWS managed Lambda layer for ADOT Java (Auto-instrumentation Agent) – This layer automatically 
transforms your function code at startup to collect tracing data. For detailed instructions on how to 
consume this layer together with the ADOT Java agent, see AWS Distro for OpenTelemetry Lambda 
Support for Java (Auto-instrumentation Agent) in the ADOT documentation.
•AWS managed Lambda layer for ADOT Java – This layer also provides built-in instrumentation for 
Lambda functions, but it requires a few manual code changes to initialize the OTel SDK. For detailed 
instructions on how to consume this layer, see AWS Distro for OpenTelemetry Lambda Support for 
Java in the ADOT documentation.
Using the X-Ray SDK to instrument your Java 
functions
To record data about calls that your function makes to other resources and services in your application, 
you can add the X-Ray SDK for Java to your build conﬁguration. The following example shows a Gradle 
build conﬁguration that includes the libraries that activate automatic instrumentation of AWS SDK for 
Java 2.x clients.
Example build.gradle – Tracing dependencies
dependencies { 
    implementation platform('software.amazon.awssdk:bom:2.15.0') 
     implementation platform('com.amazonaws:aws-xray-recorder-sdk-bom:2.11.0')
    ... 
     implementation 'com.amazonaws:aws-xray-recorder-sdk-core' 
    implementation 'com.amazonaws:aws-xray-recorder-sdk-aws-sdk' 
    implementation 'com.amazonaws:aws-xray-recorder-sdk-aws-sdk-instrumentor'
    ...
}
After you add the correct dependencies and make the necessary code changes, activate tracing in your 
function's conﬁguration via the Lambda console or the API.
503AWS Lambda Developer Guide
Activating tracing with the Lambda console
Activating tracing with the Lambda console
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Activating tracing with the Lambda API
Conﬁgure tracing on your Lambda function with the AWS CLI or AWS SDK, use the following API 
operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Activating tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
504AWS Lambda Developer Guide
Interpreting an X-Ray trace
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
Interpreting an X-Ray trace
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
505AWS Lambda Developer Guide
Storing runtime dependencies in a layer (X-Ray SDK)
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
Note
Lambda SnapStart (p. 1098 ) functions also include a Restore  subsegment. The Restore
subsegment shows the time it takes for Lambda to restore a snapshot, load the runtime (JVM), 
and run any afterRestore  runtime hooks  (p. 1107 ). The process of restoring snapshots can 
include time spent on activities outside the MicroVM. This time is not reported in the Restore
subsegment, but is included in the AWS::Lambda  segment in X-Ray traces.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see AWS X-Ray SDK for Java in the AWS X-Ray 
Developer Guide .
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
Storing runtime dependencies in a layer (X-Ray SDK)
If you use the X-Ray SDK to instrument AWS SDK clients your function code, your deployment package 
can become quite large. To avoid uploading runtime dependencies every time you update your function 
code, package the X-Ray SDK in a Lambda layer (p. 988).
The following example shows an AWS::Serverless::LayerVersion  resource that stores the AWS 
SDK for Java and X-Ray SDK for Java.
Example template.yml – Dependencies layer
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: build/distributions/blank-java.zip 
506AWS Lambda Developer Guide
X-Ray tracing in sample applications (X-Ray SDK)
      Tracing: Active 
       Layers: 
        - !Ref libs
      ... 
   libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-java-lib 
      Description: Dependencies for the blank-java sample app. 
      ContentUri: build/blank-java-lib.zip 
      CompatibleRuntimes: 
        - java8
With this conﬁguration, you update the library layer only if you change your runtime dependencies. Since 
the function deployment package contains only your code, this can help reduce upload times.
Creating a layer for dependencies requires build conﬁguration changes to generate the layer archive prior 
to deployment. For a working example, see the java-basic sample application on GitHub.
X-Ray tracing in sample applications (X-Ray SDK)
The GitHub repository for this guide includes sample applications that demonstrate the use of X-
Ray tracing. Each sample application includes scripts for easy deployment and cleanup, an AWS SAM 
template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples do 
not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
All of the sample applications have active tracing enabled for Lambda functions. For example, the
s3-java application shows automatic instrumentation of AWS SDK for Java 2.x clients, segment 
management for tests, custom subsegments, and the use of Lambda layers to store runtime 
dependencies.
507AWS Lambda Developer Guide
Tutorial - Eclipse IDE
Creating a deployment package using Eclipse
This section shows how to package your Java code into a deployment package using Eclipse IDE and 
Maven plugin for Eclipse.
Note
The AWS SDK Eclipse Toolkit provides an Eclipse plugin for you to both create a deployment 
package and also upload it to create a Lambda function. If you can use Eclipse IDE as your 
development environment, this plugin enables you to author Java code, create and upload a 
deployment package, and create your Lambda function. For more information, see the AWS 
Toolkit for Eclipse Getting Started Guide. For an example of using the toolkit for authoring 
Lambda functions, see Using Lambda with the AWS toolkit for Eclipse.
Topics
•Prerequisites (p. 508)
•Create and build a project (p. 508)
Prerequisites
Install the Maven Plugin for Eclipse.
1. Start Eclipse. From the Help  menu in Eclipse, choose Install New Software.
2. In the Install  window, type http://download.eclipse.org/technology/m2e/releases  in 
the Work with: box, and choose Add.
3. Follow the steps to complete the setup.
Create and build a project
In this step, you start Eclipse and create a Maven project. You will add the necessary dependencies, and 
build the project. The build will produce a .jar, which is your deployment package.
1. Create a new Maven project in Eclipse.
a. From the File menu, choose New , and then choose Project.
b. In the New Project window, choose Maven Project.
c. In the New Maven Project window, choose Create a simple project, and leave other default 
selections.
d. In the New Maven Project, Conﬁgure project windows, type the following Artifact information:
•Group Id : doc-examples
•Artifact Id: lambda-java-example
•Version: 0.0.1-SNAPSHOT
•Packaging: jar
•Name : lambda-java-example
2. Add the aws-lambda-java-core  dependency to the pom.xml  ﬁle.
It provides deﬁnitions of the RequestHandler , RequestStreamHandler , and Context
interfaces. This allows you to compile code that you can use with AWS Lambda.
a. Open the context (right-click) menu for the pom.xml  ﬁle, choose Maven, and then choose Add 
Dependency.
b. In the Add Dependency windows, type the following values:
508AWS Lambda Developer Guide
Create and build a project
Group Id:  com.amazonaws
Artifact Id: aws-lambda-java-core
Version: 1.2.2
Note
If you are following other tutorial topics in this guide, the speciﬁc tutorials might 
require you to add more dependencies. Make sure to add those dependencies as 
required.
3. Add Java class to the project.
a. Open the context (right-click) menu for the src/main/java  subdirectory in the project, choose
New , and then choose Class .
b. In the New Java Class window, type the following values:
•Package: example
•Name : Hello
Note
If you are following other tutorial topics in this guide, the speciﬁc tutorials might 
recommend diﬀerent package name or class name.
c. Add your Java code. If you are following other tutorial topics in this guide, add the provided 
code.
4. Build the project.
Open the context (right-click) menu for the project in Package Explorer, choose Run As , and then 
choose Maven Build .... In the Edit Conﬁguration window, type package  in the Goals  box.
Note
The resulting .jar, lambda-java-example-0.0.1-SNAPSHOT.jar , is not the ﬁnal 
standalone .jar that you can use as your deployment package. In the next step, you add the 
Apache maven-shade-plugin  to create the standalone .jar. For more information, go to
Apache Maven Shade plugin.
5. Add the maven-shade-plugin  plugin and rebuild.
The maven-shade-plugin will take artifacts (jars) produced by the package  goal (produces customer 
code .jar), and created a standalone .jar that contains the compiled customer code, and the resolved 
dependencies from the pom.xml .
a. Open the context (right-click) menu for the pom.xml  ﬁle, choose Maven, and then choose Add 
Plugin .
b. In the Add Plugin  window, type the following values:
•Group Id:  org.apache.maven.plugins
•Artifact Id: maven-shade-plugin
•Version: 3.2.2
c. Now build again.
This time we will create the jar as before, and then use the maven-shade-plugin  to pull in 
dependencies to make the standalone .jar.
i. Open the context (right-click) menu for the project, choose Run As , and then choose Maven 
build ....
509AWS Lambda Developer Guide
Create and build a project
ii. In the Edit Conﬁguration windows, type package shade:shade  in the Goals  box.
iii. Choose Run.
You can ﬁnd the resulting standalone .jar (that is, your deployment package), in the /
target subdirectory.
Open the context (right-click) menu for the /target subdirectory, choose Show In, choose
System Explorer, and you will ﬁnd the lambda-java-example-0.0.1-SNAPSHOT.jar .
510AWS Lambda Developer Guide
Sample apps
Java sample applications for AWS Lambda
The GitHub repository for this guide provides sample applications that demonstrate the use of Java 
in AWS Lambda. Each sample application includes scripts for easy deployment and cleanup, an AWS 
CloudFormation template, and supporting resources.
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an input 
event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging conﬁguration.
•java-events – A collection of Java functions that contain skeleton code for how to handle events from 
various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These functions use 
the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). These examples do 
not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java Class 
Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB table 
that contains employee information. It then uses Amazon Simple Notiﬁcation Service to send a text 
message to employees celebrating their work anniversaries. This example uses API Gateway to invoke 
the function.
Sample Spring applications in Lambda
•spring-cloud-function-samples – An example that shows how to use the Spring Cloud Function
framework to create AWS Lambda functions.
If you're new to Lambda functions in Java, start with the java-basic  examples. To get started with 
Lambda event sources, see the java-events  examples. Both of these example sets show the use of 
Lambda's Java libraries, environment variables, the AWS SDK, and the AWS X-Ray SDK. Each example 
uses a Lambda layer to package its dependencies separately from the function code, which speeds up 
deployment times. These examples require minimal setup and you can deploy them from the command 
line in less than a minute.
511AWS Lambda Developer Guide
Go runtime support
Building Lambda functions with Go
Go is implemented diﬀerently than other managed runtimes. Because Go compiles to native code, 
Lambda treats Go as a custom runtime. We recommend that you use the provided.al2  runtime to 
deploy Go functions to Lambda.
Go runtime support
The Go 1.x managed runtime for Lambda is based on the Amazon Linux AMI (AL1). Lambda will 
continue to support the Go 1.x managed runtime until maintenance support for the Amazon Linux AMI 
ends on December 31, 2023. If you're using the Go 1.x runtime, you must migrate your functions to
provided.al2 . No code changes are required for this migration. The only required changes relate to 
how you build your deployment package and which runtime you use to create your function. For more 
information, see the deployment instructions for .zip packages  (p. 520) and container images (p. 529).
Go
Name Identiﬁer Operating system Architectures Deprecation 
(Phase 1)
Go 1.x go1.x Amazon Linux x86_64 Dec 31, 2023
The provided.al2  runtime oﬀers several advantages over go1.x, including support for the arm64 
architecture (AWS Graviton2 processors), smaller binaries, and slightly faster invoke times.
Custom
Name Identiﬁer Operating system Architectures Deprecation 
(Phase 1)
Custom Runtime provided.al2 Amazon Linux 2 x86_64, arm64
Custom Runtime provided Amazon Linux x86_64 Dec 31, 2023
Tools and libraries
Lambda provides the following tools and libraries for the Go runtime:
•AWS SDK for Go: the oﬃcial AWS SDK for the Go programming language.
•github.com/aws/aws-lambda-go/lambda: The implementation of the Lambda programming model for 
Go. This package is used by AWS Lambda to invoke your handler  (p. 514).
•github.com/aws/aws-lambda-go/lambdacontext: Helpers for accessing context information from the
context object (p. 518).
•github.com/aws/aws-lambda-go/events: This library provides type deﬁnitions for common event 
source integrations.
•github.com/aws/aws-lambda-go/cmd/build-lambda-zip: This tool can be used to create a .zip ﬁle 
archive on Windows.
512AWS Lambda Developer Guide
Tools and libraries
For more information, see aws-lambda-go on GitHub.
Lambda provides the following sample applications for the Go runtime:
Sample Lambda applications in Go
•go-al2  – A hello world function that returns the public IP address. This app uses the provided.al2
custom runtime.
•blank-go – A Go function that shows the use of Lambda's Go libraries, logging, environment variables, 
and the AWS SDK. This app uses the go1.x  runtime.
Topics
•AWS Lambda function handler in Go (p. 514)
•AWS Lambda context object in Go (p. 518)
•Deploy Go Lambda functions with .zip ﬁle archives (p. 520)
•Deploy Go Lambda functions with container images (p. 529)
•AWS Lambda function logging in Go (p. 542)
•AWS Lambda function errors in Go (p. 547)
•Instrumenting Go code in AWS Lambda (p. 551)
•Using environment variables (p. 555)
513AWS Lambda Developer Guide
Handler
AWS Lambda function handler in Go
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
A Lambda function written in Go is authored as a Go executable. In your Lambda function code, you 
need to include the github.com/aws/aws-lambda-go/lambda package, which implements the Lambda 
programming model for Go. In addition, you need to implement handler function code and a main()
function.
package main
import ( 
        "fmt" 
        "context" 
        "github.com/aws/aws-lambda-go/lambda"
)
type MyEvent struct { 
        Name string `json:"name"`
}
func HandleRequest(ctx context.Context, name MyEvent) (string, error) { 
        return fmt.Sprintf("Hello %s!", name.Name ), nil
}
func main() { 
        lambda.Start(HandleRequest)
}
Note the following:
•package main : In Go, the package containing func main()  must always be named main .
•import: Use this to include the libraries your Lambda function requires. In this instance, it includes:
•context: AWS Lambda context object in Go (p. 518).
•fmt:  The Go Formatting object used to format the return value of your function.
•github.com/aws/aws-lambda-go/lambda: As mentioned previously, implements the Lambda 
programming model for Go.
•func HandleRequest(ctx context.Context, name MyEvent) (string, error): This is your Lambda 
handler signature and includes the code which will be executed. In addition, the parameters included 
denote the following:
•ctx context.Context: Provides runtime information for your Lambda function invocation. ctx is 
the variable you declare to leverage the information available via AWS Lambda context object in 
Go (p. 518).
•name MyEvent: An input type with a variable name of name whose value will be returned in the
return  statement.
•string, error : Returns two values: string for success and standard error information. For more 
information on custom error handling, see AWS Lambda function errors in Go (p. 547).
•return fmt.Sprintf("Hello %s!", name), nil: Simply returns a formatted "Hello" greeting with the 
name you supplied in the input event. nil indicates there were no errors and the function executed 
successfully.
•func main() : The entry point that runs your Lambda function code. This is required.
514AWS Lambda Developer Guide
Naming
By adding lambda.Start(HandleRequest)  between func main(){}  code brackets, your Lambda 
function will be executed. Per Go language standards, the opening bracket, { must be placed directly 
at the end of the main function signature.
Naming
provided.al2 runtime
For Go functions that use the provided.al2  runtime in a .zip deployment package (p. 520), 
the executable ﬁle that contains your function code must be named bootstrap . For Go functions 
that use the provided.al2  runtime in a container image (p. 529), you can use any name for the 
executable ﬁle.
You can use any name for the handler. To reference the handler value in your code, you can use the
_HANDLER  environment variable.
go1.x runtime
For Go functions that use the go1.x runtime, the executable ﬁle and the handler can share any 
name. For example, if you set the value of the handler to Handler , Lambda will call the main()
function in the Handler executable ﬁle.
To change the function handler name in the Lambda console, on the Runtime settings pane, choose
Edit.
Lambda function handler using structured types
In the example above, the input type was a simple string. But you can also pass in structured events to 
your function handler:
package main 
  
import ( 
        "fmt" 
        "github.com/aws/aws-lambda-go/lambda"
)
type MyEvent struct { 
        Name string `json:"What is your name?"` 
        Age int     `json:"How old are you?"`
} 
  
type MyResponse struct { 
        Message string `json:"Answer:"`
} 
  
func HandleLambdaEvent(event MyEvent) (MyResponse, error) { 
        return MyResponse{Message: fmt.Sprintf("%s is %d years old!", event.Name, 
 event.Age)}, nil
} 
  
func main() { 
        lambda.Start(HandleLambdaEvent)
}
Your request would then look like this:
515AWS Lambda Developer Guide
Lambda function handler using structured types
# request
{ 
    "What is your name?": "Jim", 
    "How old are you?": 33
}
And the response would look like this:
# response
{ 
    "Answer": "Jim is 33 years old!"
}
To be exported, ﬁeld names in the event struct must be capitalized. For more information on handling 
events from AWS event sources, see aws-lambda-go/events.
Valid handler signatures
You have several options when building a Lambda function handler in Go, but you must adhere to the 
following rules:
•The handler must be a function.
•The handler may take between 0 and 2 arguments. If there are two arguments, the ﬁrst argument 
must implement context.Context .
•The handler may return between 0 and 2 arguments. If there is a single return value, it must 
implement error. If there are two return values, the second value must implement error. For 
more information on implementing error-handling information, see AWS Lambda function errors in 
Go (p. 547).
The following lists valid handler signatures. TIn and TOut represent types compatible with the
encoding/json  standard library. For more information, see func Unmarshal  to learn how these types are 
deserialized.
•func ()
•func () error
•func (TIn) error
•func () (TOut, error)
•func (context.Context) error
•func (context.Context, TIn) error
•func (context.Context) (TOut, error)
•func (context.Context, TIn) (TOut, error)
516AWS Lambda Developer Guide
Using global state
Using global state
You can declare and modify global variables that are independent of your Lambda function's handler 
code. In addition, your handler may declare an init function that is executed when your handler is 
loaded. This behaves the same in AWS Lambda as it does in standard Go programs. A single instance of 
your Lambda function will never handle multiple events simultaneously.
package main 
  
import ( 
        "log" 
        "github.com/aws/aws-lambda-go/lambda" 
        "github.com/aws/aws-sdk-go/aws/session" 
        "github.com/aws/aws-sdk-go/service/s3" 
        "github.com/aws/aws-sdk-go/aws"
) 
  
var invokeCount = 0
var myObjects []*s3.Object
func init() { 
        svc := s3.New(session.New()) 
        input := &s3.ListObjectsV2Input{ 
                Bucket: aws.String("examplebucket"), 
        } 
        result, _ := svc.ListObjectsV2(input) 
        myObjects = result.Contents
} 
  
func LambdaHandler() (int, error) { 
        invokeCount = invokeCount + 1 
        log.Print(myObjects) 
        return invokeCount, nil
} 
  
func main() { 
        lambda.Start(LambdaHandler)
}
517AWS Lambda Developer Guide
Context
AWS Lambda context object in Go
When Lambda runs your function, it passes a context object to the handler  (p. 514). This object provides 
methods and properties with information about the invocation, function, and execution environment.
The Lambda context library provides the following global variables, methods, and properties.
Global variables
•FunctionName  – The name of the Lambda function.
•FunctionVersion  – The version (p. 108) of the function.
•MemoryLimitInMB  – The amount of memory that's allocated for the function.
•LogGroupName  – The log group for the function.
•LogStreamName  – The log stream for the function instance.
Context methods
•Deadline  – Returns the date that the execution times out, in Unix time milliseconds.
Context properties
•InvokedFunctionArn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•AwsRequestID  – The identiﬁer of the invocation request.
•Identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•ClientContext  – (mobile apps) Client context that's provided to Lambda by the client application.
Accessing invoke context information
Lambda functions have access to metadata about their environment and the invocation request. This 
can be accessed at Package context. Should your handler include context.Context  as a parameter, 
Lambda will insert information about your function into the context's Value property. Note that you 
need to import the lambdacontext  library to access the contents of the context.Context  object.
package main 
  
import ( 
        "context" 
        "log" 
        "github.com/aws/aws-lambda-go/lambda" 
        "github.com/aws/aws-lambda-go/lambdacontext"
) 
  
func CognitoHandler(ctx context.Context) { 
        lc, _ := lambdacontext.FromContext(ctx) 
        log.Print(lc.Identity.CognitoIdentityPoolID)
} 
  
func main() { 
        lambda.Start(CognitoHandler)
}
518AWS Lambda Developer Guide
Accessing invoke context information
In the example above, lc is the variable used to consume the information that the context object 
captured and log.Print(lc.Identity.CognitoIdentityPoolID)  prints that information, in this 
case, the CognitoIdentityPoolID.
The following example introduces how to use the context object to monitor how long your Lambda 
function takes to complete. This allows you to analyze performance expectations and adjust your 
function code accordingly, if needed.
package main
import ( 
        "context" 
        "log" 
        "time" 
        "github.com/aws/aws-lambda-go/lambda"
)
func LongRunningHandler(ctx context.Context) (string, error) { 
        deadline, _ := ctx.Deadline() 
        deadline = deadline.Add(-100 * time.Millisecond) 
        timeoutChannel := time.After(time.Until(deadline)) 
        for { 
                select { 
                case <- timeoutChannel: 
                        return "Finished before timing out.", nil 
                default: 
                        log.Print("hello!") 
                        time.Sleep(50 * time.Millisecond) 
                } 
        }
}
func main() { 
        lambda.Start(LongRunningHandler)
}
519AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Deploy Go Lambda functions with .zip ﬁle archives
Your AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package  to deploy your function code to Lambda. Lambda supports two types of 
deployment packages: container images and .zip ﬁle archives.
This page describes how to create a .zip ﬁle as your deployment package for the Go runtime, and then 
use the .zip ﬁle to deploy your function code to AWS Lambda using the AWS Management Console, AWS 
Command Line Interface (AWS CLI), and AWS Serverless Application Model (AWS SAM).
Note that Lambda uses POSIX ﬁle permissions, so you may need to  set permissions for the deployment 
package folder  before you create the .zip ﬁle archive.
Sections
•Creating a .zip ﬁle on macOS and Linux (p. 520)
•Creating a .zip ﬁle on Windows (p. 522)
•Creating and updating Go Lambda functions using .zip ﬁles (p. 524)
Creating a .zip ﬁle on macOS and Linux
The following steps show how to compile your executable using the go build  command and create 
a .zip ﬁle deployment package for Lambda. Before compiling your code, make sure you have installed 
the lambda  package from GitHub. This module provides an implementation of the runtime interface, 
which manages the interaction between Lambda and your function code. To download this library, run 
the following command.
go get github.com/aws/aws-lambda-go/lambda
If your function uses the AWS SDK for Go, download the standard set of SDK modules, along with any 
AWS service API clients required by your application. To learn how to install the SDK for Go, see Getting 
Started with the AWS SDK for Go V2.
Using the provided.al2 runtime (recommended)
Go is implemented diﬀerently than other managed runtimes. Because Go compiles to native code, 
Lambda treats Go as a custom runtime. We recommend that you use the provided.al2  runtime to 
deploy Go functions to Lambda.
To create a .zip deployment package (macOS/Linux)
1. In the project directory that contains your application's main.go ﬁle, compile your executable. Note 
the following:
•The executable must be named bootstrap . For more information, see Naming  (p. 515).
•Set your target instruction set architecture (p. 33). The provided.al2  runtime supports both 
arm64 and x86_64.
•You can use the optional lambda.norpc  tag to exclude the Remote Procedure Call (RPC) 
component of the lambda  library. The RPC component is only required when using the Go 1.x 
runtime. Excluding the RPC reduces the size of the deployment package.
For the arm64 architecture:
GOOS=linux GOARCH= arm64 go build -tags lambda.norpc -o bootstrap main.go
520AWS Lambda Developer Guide
Creating a .zip ﬁle on macOS and Linux
For the x86_64 architecture:
GOOS=linux GOARCH= amd64 go build -tags lambda.norpc -o bootstrap main.go
2. (Optional) You may need to compile packages with CGO_ENABLED=0  set on Linux:
GOOS=linux GOARCH= arm64 CGO_ENABLED=0 go build -o bootstrap -tags lambda.norpc main.go
This command creates a stable binary package for standard C library (libc) versions, which may be 
diﬀerent on Lambda and other devices.
3. Create a deployment package by packaging the executable in a .zip ﬁle.
zip myFunction.zip bootstrap
4. Create the function. Note the following:
•The handler value must be bootstrap . For more information, see Naming  (p. 515).
•The --architectures  option is only required if you're using arm64. The default value is x86_64.
•For --role, specify the Amazon Resource Name (ARN) of the execution role (p. 913).
aws lambda create-function --function-name myFunction \
--runtime provided.al2 --handler bootstrap  \
--architectures arm64 \
--role arn:aws:iam::111122223333:role/lambda-ex  \
--zip-file fileb://myFunction.zip
Using the Go 1.x runtime (legacy)
The Go 1.x managed runtime for Lambda is based on the Amazon Linux AMI (AL1). Lambda will 
continue to support the Go 1.x managed runtime until maintenance support for the Amazon Linux AMI 
ends on December 31, 2023. If you're using the Go 1.x runtime, you must migrate your functions to
provided.al2 .
To create a .zip deployment package (MacOS/Linux)
1. In the project directory containing your application's main.go ﬁle, compile your executable using go 
build .
GOOS=linux GOARCH=amd64 go build main.go
Setting GOOS  to linux  and GOARCH  to amd64 ensures that the compiled executable is compatible 
with the Go runtime  (p. 41), even if you compile it in a non-Linux environment or on a machine with 
an ARM processor.
2. (Optional) If your main package consists of multiple ﬁles, use the following go build  command to 
compile the package:
GOOS=linux GOARCH=amd64 go build main
3. (Optional) You may need to compile packages with CGO_ENABLED=0  set on Linux:
GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build main.go
521AWS Lambda Developer Guide
Creating a .zip ﬁle on Windows
This command creates a stable binary package for standard C library (libc) versions, which may be 
diﬀerent on Lambda and other devices.
4. Create a deployment package by packaging the executable in a .zip ﬁle.
zip myFunction.zip main
5. Create the function. For --role, specify the Amazon Resource Name (ARN) of the execution 
role (p. 913).
aws lambda create-function --function-name myFunction \
--runtime go1.x --handler main \
--role arn:aws:iam::111122223333:role/lambda-ex  \
--zip-file fileb://myFunction.zip
Creating a .zip ﬁle on Windows
The following steps show how to download the build-lambda-zip  tool for Windows from GitHub, 
compile your executable, and create a .zip deployment package.
Note
If you have not already done so, you must install git and then add the git executable to your 
Windows %PATH% environment variable.
Before compiling your code, make sure you have installed the lambda  library from GitHub. To download 
this library, run the following command.
go get github.com/aws/aws-lambda-go/lambda
If your function uses the AWS SDK for Go, download the standard set of SDK modules, along with any 
AWS service API clients required by your application. To learn how to install the SDK for Go, see Getting 
Started with the AWS SDK for Go V2.
Using the provided.al2 runtime (recommended)
Go is implemented diﬀerently than other managed runtimes. Because Go compiles to native code, 
Lambda treats Go as a custom runtime. We recommend that you use the provided.al2  runtime to 
deploy Go functions to Lambda.
To create a .zip deployment package (Windows)
1. Download the build-lambda-zip tool from GitHub.
go install github.com/aws/aws-lambda-go/cmd/build-lambda-zip@latest
2. Use the tool from your GOPATH to create a .zip ﬁle. If you have a default installation of Go, the tool 
is typically in %USERPROFILE%\Go\bin . Otherwise, navigate to where you installed the Go runtime 
and do one of the following:
cmd.exe
In cmd.exe, run one of the following, depending on your target instruction set 
architecture (p. 33). The provided.al2  runtime supports both arm64 and x86_64.
You can use the optional lambda.norpc  tag to exclude the Remote Procedure Call (RPC) 
component of the lambda  library. The RPC component is only required when using the Go 1.x 
runtime. Excluding the RPC reduces the size of the deployment package.
522AWS Lambda Developer Guide
Creating a .zip ﬁle on Windows
Example — For the x86_64 architecture
set GOOS=linux
set GOARCH=amd64
set CGO_ENABLED=0
go build -tags lambda.norpc -o bootstrap main.go
%USERPROFILE%\Go\bin\build-lambda-zip.exe -o myFunction.zip bootstrap
Example — For the arm64 architecture
set GOOS=linux
set GOARCH=arm64
set CGO_ENABLED=0
go build -tags lambda.norpc -o bootstrap main.go
%USERPROFILE%\Go\bin\build-lambda-zip.exe -o myFunction.zip bootstrap
PowerShell
In PowerShell, run one of the following, depending on your target instruction set 
architecture (p. 33). The provided.al2  runtime supports both arm64 and x86_64.
You can use the optional lambda.norpc  tag to exclude the Remote Procedure Call (RPC) 
component of the lambda  library. The RPC component is only required when using the Go 1.x 
runtime. Excluding the RPC reduces the size of the deployment package.
For the x86_64 architecture:
$env:GOOS = "linux"
$env:GOARCH = "amd64"
$env:CGO_ENABLED = "0"
go build -tags lambda.norpc -o bootstrap main.go
~\Go\Bin\build-lambda-zip.exe -o myFunction.zip bootstrap
For the arm64 architecture:
$env:GOOS = "linux"
$env:GOARCH = "arm64"
$env:CGO_ENABLED = "0"
go build -tags lambda.norpc -o bootstrap main.go
~\Go\Bin\build-lambda-zip.exe -o myFunction.zip bootstrap
3. Create the function. Note the following:
•The handler value must be bootstrap . For more information, see Naming  (p. 515).
•The --architectures  option is only required if you're using arm64. The default value is x86_64.
•For --role, specify the Amazon Resource Name (ARN) of the execution role (p. 913).
aws lambda create-function --function-name myFunction \
--runtime provided.al2 --handler bootstrap  \
--architectures arm64 \
--role arn:aws:iam::111122223333:role/lambda-ex  \
--zip-file fileb://myFunction.zip
523AWS Lambda Developer Guide
Creating and updating Go Lambda functions using .zip ﬁles
Using the Go 1.x runtime (legacy)
The Go 1.x managed runtime for Lambda is based on the Amazon Linux AMI (AL1). Lambda will 
continue to support the Go 1.x managed runtime until maintenance support for the Amazon Linux AMI 
ends on December 31, 2023. If you're using the Go 1.x runtime, you must migrate your functions to
provided.al2 .
To create a .zip deployment package (Windows)
1. Download the build-lambda-zip tool from GitHub.
go install github.com/aws/aws-lambda-go/cmd/build-lambda-zip@latest
2. Use the tool from your GOPATH to create a .zip ﬁle. If you have a default installation of Go, the tool 
is typically in %USERPROFILE%\Go\bin . Otherwise, navigate to where you installed the Go runtime 
and do one of the following:
cmd.exe
In cmd.exe, run the following:
set GOOS=linux
set GOARCH=amd64
set CGO_ENABLED=0
go build main.go
%USERPROFILE%\Go\bin\build-lambda-zip.exe -o myFunction.zip main
PowerShell
In PowerShell, run the following:
$env:GOOS = "linux"
$env:GOARCH = "amd64"
$env:CGO_ENABLED = "0"
go build main.go
~\Go\Bin\build-lambda-zip.exe -o myFunction.zip main
3. Create the function. For --role, specify the Amazon Resource Name (ARN) of the execution 
role (p. 913).
aws lambda create-function --function-name myFunction \
--runtime go1.x --handler main \
--role arn:aws:iam::111122223333:role/lambda-ex  \
--zip-file fileb://myFunction.zip
Creating and updating Go Lambda functions 
using .zip ﬁles
Once you have created your .zip deployment package, you can use it to create a new Lambda function or 
update an existing one. You can deploy your .zip package using the Lambda console, the AWS Command 
Line Interface, and the Lambda API. You can also create and update Lambda functions using AWS 
Serverless Application Model (AWS SAM) and AWS CloudFormation.
The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit 
applies to the combined size of all the ﬁles you upload, including any Lambda layers.
524AWS Lambda Developer Guide
Creating and updating Go Lambda functions using .zip ﬁles
Creating and updating functions with .zip ﬁles using the console
To create a new function, you must ﬁrst create the function in the console, then upload your .zip archive. 
To update an existing function, open the page for your function, then follow the same procedure to add 
your updated .zip ﬁle.
If your .zip ﬁle is less than 50MB, you can create or update a function by uploading the ﬁle directly 
from your local machine. For .zip ﬁles greater than 50MB, you must upload your package to an Amazon 
S3 bucket ﬁrst. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
Management Console, see Getting started with Amazon S3. To upload ﬁles using the AWS CLI, see Move 
objects in the AWS CLI User Guide.
Note
You cannot convert an existing container image function to use a .zip archive. You must create a 
new function.
To create a new function (console)
1. Open the Functions page of the Lambda console and choose Create Function.
2. Choose Author from scratch .
3. Under Basic information , do the following:
a. For Function name, enter the name for your function.
b. For Runtime , choose one of the following, depending on which type of deployment package 
you created:
•Provide your own bootstrap on Amazon Linux 2 (recommended): Choose this option to 
create the function using the provided.al2  runtime.
•Go 1.x  (legacy): This runtime is based on the Amazon Linux AMI (AL1). Lambda will continue 
to support the Go 1.x runtime until maintenance support for the Amazon Linux AMI ends on 
December 31, 2023. We recommend that you use the provided.al2  runtime instead.
4. (Optional) Under Permissions, expand Change default execution role. You can create a new
Execution role or use an existing one.
5. Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
To upload a .zip archive from your local machine (console)
1. In the Functions page of the Lambda console, choose the function you want to upload the .zip ﬁle 
for.
2. Select the Code  tab.
3. In the Code source pane, choose Upload from.
4. Choose .zip ﬁle.
5. To upload the .zip ﬁle, do the following:
a. Select Upload, then select your .zip ﬁle in the ﬁle chooser.
b. Choose Open .
c. Choose Save.
To upload a .zip archive from an Amazon S3 bucket (console)
1. In the Functions page of the Lambda console, choose the function you want to upload a new .zip ﬁle 
for.
2. Select the Code  tab.
525AWS Lambda Developer Guide
Creating and updating Go Lambda functions using .zip ﬁles
3. In the Code source pane, choose Upload from.
4. Choose Amazon S3 location.
5. Paste the Amazon S3 link URL of your .zip ﬁle and choose Save.
Creating and updating functions with .zip ﬁles using the AWS 
CLI
You can can use the AWS CLI to create a new function or to update an existing one using a .zip ﬁle. Use 
the create-function and update-function-code commands to deploy your .zip package. If your .zip ﬁle is 
smaller than 50MB, you can upload the .zip package from a ﬁle location on your local build machine. For 
larger ﬁles, you must upload your .zip package from an Amazon S3 bucket. For instructions on how to 
upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
Note
If you upload your .zip ﬁle from an Amazon S3 bucket using the AWS CLI, the bucket must be 
located in the same AWS Region as your function.
To create a new function using a .zip ﬁle with the AWS CLI, you must specify the following:
•The name of your function (--function-name )
•Your function’s runtime (--runtime )
•The Amazon Resource Name (ARN) of your function’s execution role (--role )
•The name of the handler method in your function code (--handler )
You must also specify the location of your .zip ﬁle. If your .zip ﬁle is located in a folder on your local 
build machine, use the --zip-file  option to specify the ﬁle path, as shown in the following example 
command.
aws lambda create-function --function-name myFunction \
--runtime provided.al2 --handler bootstrap \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --code option as shown in the 
following example command. You only need to use the S3ObjectVersion  parameter for versioned 
objects.
aws lambda create-function --function-name myFunction \
--runtime provided.al2 --handler bootstrap \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=myBucketName,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
To update an existing function using the CLI, you specify the the name of your function using the --
function-name  parameter. You must also specify the location of the .zip ﬁle you want to use to update 
your function code. If your .zip ﬁle is located in a folder on your local build machine, use the --zip-
file option to specify the ﬁle path, as shown in the following example command.
aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
To specify the location of .zip ﬁle in an Amazon S3 bucket, use the --s3-bucket  and --s3-key  options 
as shown in the following example command. You only need to use the --s3-object-version
parameter for versioned objects.
526AWS Lambda Developer Guide
Creating and updating Go Lambda functions using .zip ﬁles
aws lambda update-function-code --function-name myFunction \
--s3-bucket myBucketName --s3-key myFileName.zip --s3-object-version myObject Version
Creating and updating functions with .zip ﬁles using the 
Lambda API
To create and update functions using a .zip ﬁle archive, use the following API operations:
•CreateFunction
•UpdateFunctionCode
Creating and updating functions with .zip ﬁles using AWS SAM
The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of 
building and running serverless applications on AWS. You deﬁne the resources for your application in a 
YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, 
and deploy your applications. When you build a Lambda function from an AWS SAM template, AWS SAM 
automatically creates a .zip deployment package or container image with your function code and any 
dependencies you specify. To learn more about using AWS SAM to build and deploy Lambda functions, 
see Getting started with AWS SAM in the AWS Serverless Application Model Developer Guide.
You can also use AWS SAM to create a Lambda function using an existing .zip ﬁle archive. To create a 
Lambda function using AWS SAM, you can save your .zip ﬁle in an Amazon S3 bucket or in a local folder 
on your build machine. For instructions on how to upload a ﬁle to an Amazon S3 bucket using the AWS 
CLI, see Move objects in the AWS CLI User Guide.
In your AWS SAM template, the AWS::Serverless::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - set to Zip
•CodeUri - set to the function code's Amazon S3 URI, path to local folder, or FunctionCode object
•Runtime - Set to your chosen runtime
With AWS SAM, if your .zip ﬁle is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket 
ﬁrst. AWS SAM can upload .zip packages up to the maximum allowed size of 250MB (unzipped) from a 
location on your local build machine.
To learn more about deploying functions using .zip ﬁle in AWS SAM, see AWS::Serverless::Function in the
AWS SAM Developer Guide.
Example: Using AWS SAM to build a Go function with provided.al2
1. Create an AWS SAM template with the following properties:
•BuildMethod: Speciﬁes the compiler for your application. Use go1.x .
•Runtime : Use provided.al2 .
•CodeUri : Enter the path to your code.
•Architectures: Use [arm64] for the arm64 architecture. For the x86_64 instruction set 
architecture, use [amd64] or remove the Architectures  property.
Example template.yaml
AWSTemplateFormatVersion: '2010-09-09'
527AWS Lambda Developer Guide
Creating and updating Go Lambda functions using .zip ﬁles
Transform: 'AWS::Serverless-2016-10-31'
Resources: 
  HelloWorldFunction: 
    Type: AWS::Serverless::Function 
    Metadata: 
      BuildMethod: go1.x
    Properties: 
      CodeUri: hello-world/  # folder where your main program resides 
      Handler: bootstrap 
      Runtime: provided.al2
      Architectures: [arm64]
2. Use the sam build  command to compile the executable.
sam build
3. Use the sam deploy command to deploy the function to Lambda.
sam deploy --guided
Creating and updating functions with .zip ﬁles using AWS 
CloudFormation
You can use AWS CloudFormation to create a Lambda function using a .zip ﬁle archive. To create a 
Lambda function from a .zip ﬁle, you must ﬁrst upload your ﬁle to an Amazon S3 bucket. For instructions 
on how to upload a ﬁle to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User 
Guide.
In your AWS CloudFormation template, the AWS::Lambda::Function  resource speciﬁes your Lambda 
function. In this resource, set the following properties to create a function using a .zip ﬁle archive:
•PackageType  - Set to Zip
•Code - Enter the Amazon S3 bucket name and the .zip ﬁle name in the S3Bucket  and S3Key  ﬁelds
•Runtime - Set to your chosen runtime
The .zip ﬁle that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying 
functions using .zip ﬁle in AWS CloudFormation, see AWS::Lambda::Function in the AWS CloudFormation 
User Guide .
528AWS Lambda Developer Guide
Deploy container images
Deploy Go Lambda functions with container 
images
There are three ways to build a container image for a Go Lambda function:
•Using the provided.al2 AWS base image (p. 529)
Go is implemented diﬀerently than other managed runtimes. Because Go compiles to native code, 
Lambda treats Go as a custom runtime. We recommend that you use the provided.al2 base image for 
custom runtimes to build Go images for Lambda. To make the image compatible with Lambda, you 
must include the aws-lambda-go/lambda  package in the image.
•Using a non-AWS base image (p. 533)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the aws-lambda-go/lambda  package in the image.
•Using the AWS base image for Go 1.x (legacy) (p. 537)
Lambda will continue to support the Go 1.x base image until maintenance support for the Amazon 
Linux AMI ends on December 31, 2023. We recommend that you use the provided.al2 custom 
runtime  (p. 529) instead of the Go 1.x base image .
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
AWS base images for Go
AWS provides the following base image for Go:
Tags Runtime Operating 
systemDockerﬁle Deprecation
1 Go 1.x Amazon 
LinuxDockerﬁle for Go 1.x on 
GitHubDec 31, 2023
Amazon Elastic Container Registry repository: gallery.ecr.aws/lambda/go
Go runtime interface client
The aws-lambda-go/lambda  package includes an implementation of the runtime interface. For 
examples of how to use aws-lambda-go/lambda  in your image, see Using the provided.al2 AWS base 
image  (p. 529) or Using a non-AWS base image (p. 533).
Using the provided.al2 AWS base image
Go is implemented diﬀerently than other managed runtimes. Because Go compiles to native code, 
Lambda treats Go as a custom runtime. We recommend that you use the provided.al2  base image for 
custom runtimes to build container images for Go functions.
529AWS Lambda Developer Guide
Using the provided.al2 AWS base image
Tags Runtime Operating 
systemDockerﬁle Deprecation
al2 Custom 
RuntimeAmazon 
Linux 2Dockerﬁle for Custom 
Runtime on GitHub
alami Custom 
RuntimeAmazon 
LinuxDockerﬁle for Custom 
Runtime on GitHubDec 31, 2023
For more information about these base images, see provided in the Amazon ECR public gallery.
You must include the aws-lambda-go/lambda package with your Go handler. This package implements 
the programming model for Go, including the runtime interface.
Prerequisites
To complete the steps in this section, you must have the following:
•Go
•Docker
•AWS Command Line Interface (AWS CLI) version 2
Creating an image from the provided.al2 base image
To build and deploy a Go function with the provided.al2  base image.
1. Create a directory for the project, and then switch to that directory.
mkdir hello
cd hello
2. Initialize a new Go module.
go mod init example.com/hello-world
3. Add the lambda  library as a dependency of your new module.
go get github.com/aws/aws-lambda-go/lambda
4. Create a ﬁle named main.go and then open it in a text editor. This is the code for the Lambda 
function. You can use the following sample code for testing, or replace it with your own.
package main
import ( 
 "context" 
 "github.com/aws/aws-lambda-go/events" 
 "github.com/aws/aws-lambda-go/lambda"
)
func handler(ctx context.Context, event events.APIGatewayProxyRequest) 
 (events.APIGatewayProxyResponse, error) { 
 response := events.APIGatewayProxyResponse{ 
  StatusCode: 200, 
  Body:       "\"Hello from Lambda!\"", 
 } 
530AWS Lambda Developer Guide
Using the provided.al2 AWS base image
 return response, nil
}
func main() { 
 lambda.Start(handler)
}
5. Use a text editor to create a Dockerﬁle in your project directory. The following example Dockerﬁle 
uses a multi-stage build . This allows you to use a diﬀerent base image in each step. You can use one 
image, such as a Go base image , to compile your code and build the executable binary. You can then 
use a diﬀerent image, such as provided.al2 , in the ﬁnal FROM  statement to deﬁne the image that 
you deploy to Lambda. The build process is separated from the ﬁnal deployment image, so the ﬁnal 
image only contains the ﬁles needed to run the application.
You can use the optional lambda.norpc  tag to exclude the Remote Procedure Call (RPC) 
component of the lambda  library. The RPC component is only required when using the Go 1.x 
runtime. Excluding the RPC reduces the size of the deployment package.
Example — Multi-stage build Dockerﬁle
Note
Make sure that the version of Go that you specify in your Dockerﬁle (for example,
golang:1.20 ) is the same version of Go that you used to create your application.
FROM golang:1.20  as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build with optional lambda.norpc tag
COPY main.go .
RUN go build -tags lambda.norpc  -o main main.go
# Copy artifacts to a clean image
FROM public.ecr.aws/lambda/provided:al2
COPY --from=build /helloworld/main ./main
ENTRYPOINT [ "./main" ]
6. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test your image. The runtime interface emulator is 
included in the provided.al2  base image.
To run the runtime interface emulator on your local machine
1. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•./main  is the ENTRYPOINT  from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
--entrypoint /aws-lambda/aws-lambda-rie \
docker-image:test  \ 
     ./main
531AWS Lambda Developer Guide
Using the provided.al2 AWS base image
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
532AWS Lambda Developer Guide
Using a non-AWS base image
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using a non-AWS base image
You can build a container image for Go from a non-AWS base image. The example Dockerﬁle in the 
following steps uses an Alpine base image .
You must include the aws-lambda-go/lambda package with your Go handler. This package implements 
the programming model for Go, including the runtime interface.
533AWS Lambda Developer Guide
Using a non-AWS base image
Prerequisites
To complete the steps in this section, you must have the following:
•Go
•Docker
•AWS Command Line Interface (AWS CLI) version 2
Creating an image from an alternative base image
To build and deploy a Go function with an Alpine base image
1. Create a directory for the project, and then switch to that directory.
mkdir hello
cd hello
2. Initialize a new Go module.
go mod init example.com/hello-world
3. Add the lambda  library as a dependency of your new module.
go get github.com/aws/aws-lambda-go/lambda
4. Create a ﬁle named main.go and then open it in a text editor. This is the code for the Lambda 
function. You can use the following sample code for testing, or replace it with your own.
package main
import ( 
 "context" 
 "github.com/aws/aws-lambda-go/events" 
 "github.com/aws/aws-lambda-go/lambda"
)
func handler(ctx context.Context, event events.APIGatewayProxyRequest) 
 (events.APIGatewayProxyResponse, error) { 
 response := events.APIGatewayProxyResponse{ 
  StatusCode: 200, 
  Body:       "\"Hello from Lambda!\"", 
 } 
 return response, nil
}
func main() { 
 lambda.Start(handler)
}
5. Use a text editor to create a Dockerﬁle in your project directory. The following example Dockerﬁle 
uses an Alpine base image .
Example Dockerﬁle
Note
Make sure that the version of Go that you specify in your Dockerﬁle (for example,
golang:1.20 ) is the same version of Go that you used to create your application.
FROM golang:1.20.2-alpine3.16 as build
534AWS Lambda Developer Guide
Using a non-AWS base image
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build
COPY main.go .
RUN go build -o main main.go
# Copy artifacts to a clean image
FROM alpine:3.16
COPY --from=build /helloworld/main /main
ENTRYPOINT [ "/main" ]
6. Build your Docker image with the docker build  command. The following example names the 
image docker-image .
docker build -t docker-image :test .
(Optional) Test the image locally
Use the runtime interface emulator (p. 127) to locally test the image. You can build the emulator into 
your image (p. 130) or install it on your local machine.
To install and run the runtime interface emulator on your local machine
1. From your project directory, run the following command to download the runtime interface 
emulator (x86-64 architecture) from GitHub and install it on your local machine.
mkdir -p ~/.aws-lambda-rie && \ 
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-
runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \ 
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
To install the arm64 emulator, replace the GitHub repository URL in the previous command with the 
following:
https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/
aws-lambda-rie-arm64
2. Start the Docker image with the docker run command. Note the following:
•docker-image  is the image name and test  is the tag.
•/main  is the ENTRYPOINT  from your Dockerﬁle.
docker run -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \ 
    --entrypoint /aws-lambda/aws-lambda-rie \ 
     docker-image:test  \ 
         /main
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
3. Post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. Some functions 
might require a JSON payload. Example:
535AWS Lambda Developer Guide
Using a non-AWS base image
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
4. Get the container ID.
docker ps
5. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
536AWS Lambda Developer Guide
Using the Go 1.x base image
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
Using the AWS base image for Go 1.x (legacy)
We recommend that you use the provided.al2  custom runtime instead of the Go 1.x base image . 
Lambda will continue to support the Go 1.x base image until maintenance support for the Amazon Linux 
AMI ends on December 31, 2023. For more information about Amazon Linux AMI support, see Amazon 
Linux AMI FAQs.
If you're using the Go 1.x base image, you must migrate your functions to provided.al2 . No code 
changes are required for this migration. The only required changes relate to how you build your 
deployment package and which runtime you use to create your function. For more information, see
Using the provided.al2 AWS base image (p. 529).
Prerequisites
To complete the steps in this section, you must have the following:
•Go
•Docker
537AWS Lambda Developer Guide
Using the Go 1.x base image
•AWS Command Line Interface (AWS CLI) version 2
Creating an image from a base image
1. Create a directory for the project, and then switch to that directory.
mkdir hello
cd hello
2. Initialize a new Go module.
go mod init example.com/hello-world
3. Add the lambda  library as a dependency of your new module.
go get github.com/aws/aws-lambda-go/lambda
4. Create a ﬁle named main.go and then open it in a text editor. This is the code for the Lambda 
function. You can use the following sample code for testing, or replace it with your own.
package main
import ( 
 "context" 
 "github.com/aws/aws-lambda-go/events" 
 "github.com/aws/aws-lambda-go/lambda"
)
func handler(ctx context.Context, event events.APIGatewayProxyRequest) 
 (events.APIGatewayProxyResponse, error) { 
 response := events.APIGatewayProxyResponse{ 
  StatusCode: 200, 
  Body:       "\"Hello from Lambda!\"", 
 } 
 return response, nil
}
func main() { 
 lambda.Start(handler)
}
5. Build the Go project. This command creates an executable called main .
GOOS=linux GOARCH=amd64 go build -o main main.go
Setting GOOS  to linux  and GOARCH  to amd64 ensures that the compiled executable is compatible 
with the architecture of the Go base image, even if you compile it in a non-Linux environment.
6. Create a new Dockerﬁle. The example Dockerﬁle uses the following conﬁguration:
•FROM : The URI of the base image  that you want to use.
•COPY: Copies the function code into the /var/task  directory in your image.
•CMD: The Lambda function handler or executable.
FROM public.ecr.aws/lambda/go:1
# Copy function handler executable
COPY main ${LAMBDA_TASK_ROOT}
538AWS Lambda Developer Guide
Using the Go 1.x base image
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
CMD [ "main" ]
7. Build the Docker image with the docker build command. The following example names the image
docker-image  and gives it the test  tag.
docker build -t docker-image :test .
(Optional) Test the image locally
1. Start the Docker image with the docker run command. In this example, docker-image  is the image 
name and test  is the tag.
docker run -p 9000:8080 docker-image :test
This command runs the image as a container and creates a local endpoint at
localhost:9000/2015-03-31/functions/function/invocations .
2. From a new terminal window, post an event to the following endpoint using a curl command:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
This command invokes the function with an empty event and returns a response. If you're using your 
own function code rather than the sample function code, you might want to invoke the function 
with a JSON payload. Example:
curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d 
 '{"payload":"hello world!"} '
3. Get the container ID.
docker ps
4. Use the docker kill command to stop the container. In this command, replace 3766c4ab331c  with 
the container ID from the previous step.
docker kill 3766c4ab331c
Deploying the image
To upload the image to Amazon ECR and create the Lambda function
1. Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
•Set the --region  value to the AWS Region where you want to create the Amazon ECR repository.
•Replace 111122223333  with your AWS account ID.
aws ecr get-login-password --region us-east-1  | docker login --username AWS --password-
stdin 111122223333 .dkr.ecr. us-east-1 .amazonaws.com
2. Create a repository in Amazon ECR using the create-repository command.
539AWS Lambda Developer Guide
Using the Go 1.x base image
aws ecr create-repository --repository-name hello-world  --image-scanning-configuration 
 scanOnPush=true --image-tag-mutability MUTABLE
If successful, you see a response like this:
{ 
    "repository": { 
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world", 
        "registryId": "111122223333", 
        "repositoryName": "hello-world", 
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world", 
        "createdAt": "2023-03-09T10:39:01+00:00", 
        "imageTagMutability": "MUTABLE", 
        "imageScanningConfiguration": { 
            "scanOnPush": true 
        }, 
        "encryptionConfiguration": { 
            "encryptionType": "AES256" 
        } 
    }
}
3. Copy the repositoryUri  from the output in the previous step.
4. Run the docker tag command to tag your local image into your Amazon ECR repository as the latest 
version. In this command:
•Replace docker-image:test  with the name and tag of your Docker image.
•Replace the Amazon ECR repository URI with the repositoryUri  that you copied. Make sure to 
include :latest  at the end of the URI.
docker tag docker-image :test 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-
world:latest
5. Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure 
to include :latest at the end of the repository URI.
docker push 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest
6. Create an execution role (p. 214) for the function, if you don't already have one. You need the 
Amazon Resource Name (ARN) of the role in the next step.
7. Create the Lambda function. For ImageUri , specify the repository URI from earlier. Make sure to 
include :latest  at the end of the URI.
aws lambda create-function \ 
  --function-name hello-world  \ 
  --package-type Image \ 
  --code ImageUri= 111122223333 .dkr.ecr. us-east-1 .amazonaws.com/ hello-world :latest \ 
  --role arn:aws:iam::111122223333:role/lambda-ex
8. Invoke the function.
aws lambda invoke --function-name hello-world  response.json
You should see a response like this:
{ 
540AWS Lambda Developer Guide
Using the Go 1.x base image
  "ExecutedVersion": "$LATEST",  
  "StatusCode": 200
}
9. To see the output of the function, check the response.json  ﬁle.
To update the function code, you must build the image again, upload the new image to the Amazon 
ECR repository, and then use the update-function-code command to deploy the image to the Lambda 
function.
541AWS Lambda Developer Guide
Logging
AWS Lambda function logging in Go
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, or the CloudWatch console.
Sections
•Creating a function that returns logs (p. 542)
•Using the Lambda console (p. 543)
•Using the CloudWatch console (p. 543)
•Using the AWS Command Line Interface (AWS CLI) (p. 543)
•Deleting logs  (p. 546)
Creating a function that returns logs
To output logs from your function code, you can use methods on the fmt package , or any logging library 
that writes to stdout  or stderr. The following example uses the log package .
Example main.go  – Logging
func handleRequest(ctx context.Context, event events.SQSEvent) (string, error) { 
  // event 
  eventJson, _ := json.MarshalIndent(event, "", "  ") 
  log.Printf("EVENT: %s", eventJson) 
  // environment variables 
  log.Printf("REGION: %s", os.Getenv("AWS_REGION")) 
  log.Println("ALL ENV VARS:") 
  for _, element := range os.Environ() { 
    log.Println(element) 
  }
Example log format
START RequestId: dbda340c-xmpl-4031-8810-11bb609b4c71 Version: $LATEST
2020/03/27 03:40:05 EVENT: { 
  "Records": [ 
    { 
      "messageId": "19dd0b57-b21e-4ac1-bd88-01bbb068cb78", 
      "receiptHandle": "MessageReceiptHandle", 
      "body": "Hello from SQS!", 
      "md5OfBody": "7b27xmplb47ff90a553787216d55d91d", 
      "md5OfMessageAttributes": "", 
      "attributes": { 
        "ApproximateFirstReceiveTimestamp": "1523232000001", 
        "ApproximateReceiveCount": "1", 
        "SenderId": "123456789012", 
        "SentTimestamp": "1523232000000" 
      }, 
      ...
2020/03/27 03:40:05 AWS_LAMBDA_LOG_STREAM_NAME=2020/03/27/
[$LATEST]569cxmplc3c34c7489e6a97ad08b4419
542AWS Lambda Developer Guide
Using the Lambda console
2020/03/27 03:40:05 AWS_LAMBDA_FUNCTION_NAME=blank-go-function-9DV3XMPL6XBC
2020/03/27 03:40:05 AWS_LAMBDA_FUNCTION_MEMORY_SIZE=128
2020/03/27 03:40:05 AWS_LAMBDA_FUNCTION_VERSION=$LATEST
2020/03/27 03:40:05 AWS_EXECUTION_ENV=AWS_Lambda_go1.x
END RequestId: dbda340c-xmpl-4031-8810-11bb609b4c71
REPORT RequestId: dbda340c-xmpl-4031-8810-11bb609b4c71 Duration: 38.66 ms Billed Duration: 
 39 ms Memory Size: 128 MB Max Memory Used: 54 MB Init Duration: 203.69 ms  
XRAY TraceId: 1-5e7d7595-212fxmpl9ee07c4884191322 SegmentId: 42ffxmpl0645f474 Sampled: true
The Go runtime logs the START , END, and REPORT lines for each invocation. The report line provides the 
following details.
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
543AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
544AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
545AWS Lambda Developer Guide
Deleting logs
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
546AWS Lambda Developer Guide
Errors
AWS Lambda function errors in Go
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the Go runtime using the Lambda 
console and the AWS CLI.
Sections
•Creating a function that returns exceptions (p. 547)
•How it works (p. 547)
•Using the Lambda console (p. 548)
•Using the AWS Command Line Interface (AWS CLI) (p. 548)
•Error handling in other AWS services (p. 549)
•What's next? (p. 550)
Creating a function that returns exceptions
The following code sample demonstrates custom error handling that raises an exception directly from a 
Lambda function and handles it directly. Note that custom errors in Go must import the errors  module.
package main 
  
import ( 
        "errors" 
        "github.com/aws/aws-lambda-go/lambda"
) 
  
func OnlyErrors() error { 
        return errors.New("something went wrong!")
} 
  
func main() { 
        lambda.Start(OnlyErrors)
}
Which returns the following:
{ 
  "errorMessage": "something went wrong!", 
  "errorType": "errorString"
}
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
547AWS Lambda Developer Guide
Using the Lambda console
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
548AWS Lambda Developer Guide
Error handling in other AWS services
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
For more information, see Instrumenting Go code in AWS Lambda (p. 551).
549AWS Lambda Developer Guide
What's next?
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 542) page.
550AWS Lambda Developer Guide
Tracing
Instrumenting Go code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of two SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for Go – An SDK for generating and sending trace data to X-Ray.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using ADOT to instrument your Go functions (p. 551)
•Using the X-Ray SDK to instrument your Go functions (p. 551)
•Activating tracing with the Lambda console (p. 552)
•Activating tracing with the Lambda API (p. 552)
•Activating tracing with AWS CloudFormation (p. 552)
•Interpreting an X-Ray trace (p. 553)
Using ADOT to instrument your Go functions
ADOT provides fully managed Lambda layers (p. 11) that package everything you need to collect 
telemetry data using the OTel SDK. By consuming this layer, you can instrument your Lambda functions 
without having to modify any function code. You can also conﬁgure your layer to do custom initialization 
of OTel. For more information, see Custom conﬁguration for the ADOT Collector on Lambda in the ADOT 
documentation.
For Go runtimes, you can add the AWS managed Lambda layer for ADOT Go to automatically 
instrument your functions. For detailed instructions on how to add this layer, see AWS Distro for 
OpenTelemetry Lambda Support for Go in the ADOT documentation.
Using the X-Ray SDK to instrument your Go functions
To record details about calls that your Lambda function makes to other resources in your application, you 
can also use the AWS X-Ray SDK for Go. To get the SDK, download the SDK from its GitHub repository
with go get :
go get github.com/aws/aws-xray-sdk-go
551AWS Lambda Developer Guide
Activating tracing with the Lambda console
To instrument AWS SDK clients, pass the client to the xray.AWS()  method. You can then trace calls by 
using the WithContext  version of the method.
svc := s3.New(session.New())
xray.AWS(svc.Client)
...
svc.ListBucketsWithContext(ctx aws.Context, input *ListBucketsInput)
After you add the correct dependencies and make the necessary code changes, activate tracing in your 
function's conﬁguration via the Lambda console or the API.
Activating tracing with the Lambda console
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Activating tracing with the Lambda API
Conﬁgure tracing on your Lambda function with the AWS CLI or AWS SDK, use the following API 
operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Activating tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
552AWS Lambda Developer Guide
Interpreting an X-Ray trace
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
Interpreting an X-Ray trace
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
553AWS Lambda Developer Guide
Interpreting an X-Ray trace
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see the AWS X-Ray SDK for Go in the AWS X-Ray 
Developer Guide .
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
554AWS Lambda Developer Guide
Environment variables
Using environment variables
To access environment variables (p. 77) in Go, use the Getenv function.
The following explains how to do this. Note that the function imports the fmt package to format the 
printed results and the os package, a platform-independent system interface that allows you to access 
environment variables.
package main
import ( 
 "fmt" 
 "os" 
 "github.com/aws/aws-lambda-go/lambda"
)
func main() { 
 fmt.Printf("%s is %s. years old\n", os.Getenv("NAME"), os.Getenv("AGE"))
}
For a list of environment variables that are set by the Lambda runtime, see Deﬁned runtime environment 
variables  (p. 80).
555AWS Lambda Developer Guide
Building Lambda functions with C#
The following sections explain how common programming patterns and core concepts apply when 
authoring Lambda function code in C#.
AWS Lambda provides the following libraries for C# functions. These packages are available as Nuget 
packages .
Tools and libraries for C#
•Amazon.Lambda.Core – This library provides a static Lambda logger, serialization interfaces and a 
context object. The Context object (AWS Lambda context object in C# (p. 577)) provides runtime 
information about your Lambda function.
•Amazon.Lambda.Serialization.Json  – This is an implementation of the serialization interface in
Amazon.Lambda.Core.
•Amazon.Lambda.Logging.AspNetCore  – This provides a library for logging from ASP.NET.
•Event objects (POCOs) for several AWS services, including:
•Amazon.Lambda.APIGatewayEvents
•Amazon.Lambda.CognitoEvents
•Amazon.Lambda.ConﬁgEvents
•Amazon.Lambda.DynamoDBEvents
•Amazon.Lambda.KinesisEvents
•Amazon.Lambda.S3Events
•Amazon.Lambda.SQSEvents
•Amazon.Lambda.SNSEvents
Lambda provides the following runtimes for .NET languages:
.NET
Name Identiﬁer Operating system Architectures Deprecation 
(Phase 1)
.NET 7 (container 
only)dotnet7 Amazon Linux 2 x86_64, arm64 May 14, 2024
.NET 6 dotnet6 Amazon Linux 2 x86_64, arm64
To get started with application development in your local environment, deploy one of the sample 
applications available in this guide's GitHub repository.
Sample Lambda applications in C#
•blank-csharp – A C# function that shows the use of Lambda's .NET libraries, logging, environment 
variables, AWS X-Ray tracing, unit tests, and the AWS SDK.
•ec2-spot  – A function that manages spot instance requests in Amazon EC2.
Topics
•Lambda function handler in C# (p. 558)
556AWS Lambda Developer Guide
•Deploy C# Lambda functions with .zip ﬁle archives (p. 566)
•Deploy .NET Lambda functions with container images (p. 571)
•AWS Lambda context object in C# (p. 577)
•Lambda function logging in C# (p. 578)
•AWS Lambda function errors in C# (p. 586)
•Instrumenting C# code in AWS Lambda (p. 591)
•.NET functions with native AOT compilation (p. 597)
557AWS Lambda Developer Guide
Handler
Lambda function handler in C#
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
You deﬁne a Lambda function handler as an instance or static method in a class. For access to the 
Lambda context object, you can deﬁne a method parameter of type ILambdaContext. You can use this 
to access information about the current invocation, such as the name of the function, memory limit, 
remaining execution time, and logging.
returnType  handler-name (inputType  input, ILambdaContext context) { 
   ...
}
In the syntax, note the following:
•inputType  – The ﬁrst handler parameter is the input to the handler. This can be event data (that an 
event source publishes) or custom input that you provide, such as a string or any custom data object.
•returnType  – If you plan to invoke the Lambda function synchronously (using the
RequestResponse  invocation type), you can return the output of your function using any of the 
supported data types. For example, if you use a Lambda function as a mobile application backend, you 
are invoking it synchronously. Your output data type is serialized into JSON.
If you plan to invoke the Lambda function asynchronously (using the Event invocation type), the
returnType  should be void. For example, if you use Lambda with event sources such as Amazon 
Simple Storage Service (Amazon S3) or Amazon Simple Notiﬁcation Service (Amazon SNS), these event 
sources invoke the Lambda function using the Event invocation type.
•ILambdaContext context  – The second argument in the handler signature is optional. It provides 
access to the context object (p. 577), which has information about the function and request.
Handling streams
By default, Lambda supports only the System.IO.Stream  type as an input parameter.
For example, consider the following C# example code.
using System.IO;
namespace Example
{             
  public class Hello 
  { 
    public Stream MyHandler(Stream stream) 
    { 
       //function logic 
    } 
  }
}
In the example C# code, the ﬁrst handler parameter is the input to the handler (MyHandler). This can be 
event data (published by an event source such as Amazon S3) or custom input that you provide, such as a
Stream (as in this example) or any custom data object. The output is of type Stream .
558AWS Lambda Developer Guide
Handling standard data types
Handling standard data types
All the following other types require you to specify a serializer:
•Primitive .NET types (such as string or int)
•Collections and maps – IList, IEnumerable, IList<T>, Array, IDictionary, IDictionary<TKey, TValue>
•POCO types (Plain old CLR objects)
•Predeﬁned AWS event types
•For asynchronous invocations, Lambda ignores the return type. In such cases, the return type may be 
set to void.
•If you are using .NET asynchronous programming, the return type can be Task and Task<T> types 
and use async  and await keywords. For more information, see Using async in C# functions with 
Lambda  (p. 564).
Unless your function input and output parameters are of type System.IO.Stream , you must serialize 
them. Lambda provides default serializers that can be applied at the assembly or method level of your 
application, or you can deﬁne your own by implementing the ILambdaSerializer  interface provided 
by the Amazon.Lambda.Core  library. For more information, see Deploy C# Lambda functions with .zip 
ﬁle archives (p. 566).
To add the default serializer attribute to a method, ﬁrst add a dependency on
Amazon.Lambda.Serialization.SystemTextJson  in your .csproj  ﬁle.
<Project Sdk="Microsoft.NET.Sdk"> 
      <PropertyGroup> 
        <TargetFramework>net6.0</TargetFramework> 
        <ImplicitUsings>enable</ImplicitUsings> 
        <Nullable>enable</Nullable> 
        <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles> 
        <AWSProjectType>Lambda</AWSProjectType> 
        <!-- Makes the build directory similar to a publish directory and helps the 
 AWS .NET Lambda Mock Test Tool find project dependencies. --> 
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> 
        <!-- Generate ready to run images during publishing to improve cold start time. --> 
        <PublishReadyToRun>true</PublishReadyToRun> 
      </PropertyGroup> 
     
      <ItemGroup> 
        <PackageReference Include="Amazon.Lambda.Core" Version="2.1.0 " /> 
        <PackageReference Include="Amazon.Lambda.Serialization.SystemTextJson" 
 Version="2.2.0" /> 
      </ItemGroup> 
     
    </Project> 
     
The example below illustrates the ﬂexibility you can leverage by specifying the default System.Text.Json 
serializer on one method and another of your choosing on a diﬀerent method:
public class ProductService 
      { 
      
 [LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))] 
      public Product DescribeProduct(DescribeProductRequest request) 
      { 
        return catalogService.DescribeProduct(request.Id); 
      } 
559AWS Lambda Developer Guide
Handling standard data types
     
     [LambdaSerializer(typeof(MyJsonSerializer))] 
     public Customer DescribeCustomer(DescribeCustomerRequest request) 
     { 
        return customerService.DescribeCustomer(request.Id); 
     }
}
Source generation for JSON serialization
C# 9 provides source generators that can generate code during compilation. Starting with .NET 6, the 
native JSON library System.Text.Json  can use source generators to parse JSON without the need for 
reﬂection APIs. This can help improve cold start performance.
To use the source generator
1. In your project, deﬁne an empty, partial class that derives from
System.Text.Json.Serialization.JsonSerializerContext .
2. Add the JsonSerializable  attribute for each .NET type that the source generator must generate 
serialization code for.
Example API Gateway integration leveraging source generation
using System.Collections.Generic;
using System.Net;
using System.Text.Json.Serialization;
using Amazon.Lambda.Core;
using Amazon.Lambda.APIGatewayEvents;
using Amazon.Lambda.Serialization.SystemTextJson;
[assembly:
LambdaSerializer(typeof(SourceGeneratorLambdaJsonSerializer<SourceGeneratorExa
mple.HttpApiJsonSerializerContext>))]
namespace SourceGeneratorExample;
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyRequest))]
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyResponse))]
public partial class HttpApiJsonSerializerContext : JsonSerializerContext
{
}
public class Functions
{ 
    public APIGatewayProxyResponse Get(APIGatewayHttpApiV2ProxyRequest
request, ILambdaContext context) 
    { 
        context.Logger.LogInformation("Get Request"); 
        var response = new APIGatewayHttpApiV2ProxyResponse 
        { 
            StatusCode = (int)HttpStatusCode.OK, 
            Body = "Hello AWS Serverless", 
            Headers = new Dictionary<string, string> { { "Content-Type",
"text/plain" } } 
            }; 
             
            return response; 
    }
}
560AWS Lambda Developer Guide
Handler signatures
When you invoke your function, Lambda uses the source-generated JSON serialization code to handle 
the serialization of Lambda events and responses.
Handler signatures
When creating Lambda functions, you have to provide a handler string that tells Lambda where to look 
for the code to invoke. In C#, the format is:
ASSEMBLY::TYPE::METHOD  where:
•ASSEMBLY  is the name of the .NET assembly ﬁle for your application. When using the .NET Core CLI 
to build your application, if you haven't set the assembly name using the AssemblyName  property 
in the .csproj ﬁle, the ASSEMBLY  name is the .csproj ﬁle name. For more information, see .NET Core 
CLI (p. 566). In this case, let's assume that the .csproj ﬁle is HelloWorldApp.csproj .
•TYPE is the full name of the handler type, which consists of the Namespace  and the ClassName . In 
this case Example.Hello .
•METHOD is name of the function handler, in this case MyHandler .
Ultimately, the signature is of this format: Assembly::Namespace.ClassName::MethodName
Consider the following example:
using System.IO;
namespace Example
{             
  public class Hello 
  { 
    public Stream MyHandler(Stream stream) 
    { 
       //function logic 
    } 
  }
}
The handler string would be: HelloWorldApp::Example.Hello::MyHandler
Important
If the method speciﬁed in your handler string is overloaded, you must provide the exact 
signature of the method that Lambda should invoke. If the resolution would require selecting 
among multiple (overloaded) signatures, Lambda will reject an otherwise valid signature.
Using top-level statements
In .NET 6, you can write functions using C# 9's top-level statements. Top-level statements remove some 
of the initial boilerplate code for .NET projects, reducing the number of lines of code that you write.
Top-level statements require the build output to be an executable. To conﬁgure this setting, specify Exe
as the output type in your .csproj ﬁle:
Example .csproj ﬁle
<PropertyGroup>
<TargetFramework> net6.0</TargetFramework>
<OutputType> Exe</OutputType>
...
</PropertyGroup>
561AWS Lambda Developer Guide
Using Lambda Annotations
Here's an example of how you can rewrite the previous function code example (p. 561) using top-level 
statements:
Example – Using top-level statements
using Amazon.Lambda.RuntimeSupport;
var handler = (Stream stream) =>
{ 
  //function logic
};
await LambdaBootstrapBuilder.Create(handler).Build().RunAsync();
When using top-level statements, you only include the ASSEMBLY  name when providing the 
handler signature. Continuing from the previous example (p. 561), the handler string would be
HelloWorldApp .
By setting the handler to the assembly name Lambda will treat the assembly as an executable and 
execute it at startup. You must add the NuGet package Amazon.Lambda.RuntimeSupport  to the 
project so that the executable that runs at startup starts the Lambda runtime client.
For more information about using top-level statements, see Introducing the .NET 6 runtime for AWS 
Lambda  on the AWS Compute Blog.
Using Lambda Annotations
The Lambda Annotations framework can simplify the process of writing handler code, updating 
CloudFormation templates, and conﬁguring dependency injection for .NET 6 Lambda functions. When 
you use Lambda Annotations, you must deploy with CloudFormation.
The following examples demonstrate the beneﬁts of using Lambda Annotations. This function adds two 
numbers.
Example – Without Lambda Annotations
public class Functions 
  { 
      public APIGatewayProxyResponse LambdaMathPlus(APIGatewayProxyRequest request, 
 ILambdaContext context) 
      { 
          if (!request.PathParameters.TryGetValue("x", out var xs)) 
          { 
              return new APIGatewayProxyResponse 
              { 
                  StatusCode = (int)HttpStatusCode.BadRequest 
              }; 
          } 
          if (!request.PathParameters.TryGetValue("y", out var ys)) 
          { 
              return new APIGatewayProxyResponse 
              { 
                  StatusCode = (int)HttpStatusCode.BadRequest 
              }; 
          } 
   
          var x = int.Parse(xs); 
          var y = int.Parse(ys); 
   
          return new APIGatewayProxyResponse 
562AWS Lambda Developer Guide
Serializing Lambda functions
          { 
              StatusCode = (int)HttpStatusCode.OK, 
              Body = (x + y).ToString(), 
              Headers = new Dictionary<string, string> { { "Content-Type", "text/plain" } } 
          }; 
      }  
  }
Example – With Lambda Annotations
public class Functions 
  { 
      [LambdaFunction] 
      [RestApi("/plus/{x}/{y}")] 
      public int Plus(int x, int y) 
      { 
          return x + y; 
      } 
  }
For details about how to use the Lambda Annotations framework, see the following resources:
•The aws/aws-lambda-dotnet GitHub repository.
•The blog post  for Lambda Annotations.
•The Amazon.Lambda.Annotations  NuGet package.
Serializing Lambda functions
For any Lambda functions that use input or output types other than a Stream object, you must add a 
serialization library to your application. You can do this in the following ways:
•Use the Amazon.Lambda.Serialization.SystemTextJson  NuGet package. This library uses 
the native .NET Core JSON serializer to handle serialization. This package provides a performance 
improvement over Amazon.Lambda.Serialization.Json , but note the limitations described in the
Microsoft documentation. This library is available for .NET Core 3.1 and later runtimes.
•Use the Amazon.Lambda.Serialization.Json  NuGet package. This library uses JSON.NET to 
handle serialization.
•Create your own serialization library by implementing the ILambdaSerializer  interface, which is 
available as part of the Amazon.Lambda.Core  library. The interface deﬁnes two methods:
•T Deserialize<T>(Stream requestStream);
You implement this method to deserialize the request payload from the Invoke API into the object 
that is passed to the Lambda function handler.
•T Serialize<T>(T response, Stream responseStream); .
You implement this method to serialize the result returned from the Lambda function handler into 
the response payload that the Invoke API operation returns.
To use the serializer, you must add a dependency to your MyProject.csproj  ﬁle.
... 
 <ItemGroup> 
    <PackageReference Include="Amazon.Lambda.Serialization.SystemTextJson" 
 Version="2.1.0" /> 
    <!-- or --> 
563AWS Lambda Developer Guide
Lambda function handler restrictions
    <PackageReference Include="Amazon.Lambda.Serialization.Json" Version="2.0.0" /> 
  </ItemGroup>
Next, you must deﬁne the serializer. The following example deﬁnes the 
Amazon.Lambda.Serialization.SystemTextJson  serializer in the AssemblyInfo.cs ﬁle.
[assembly: LambdaSerializer(typeof(DefaultLambdaJsonSerializer))]
The following example deﬁnes the Amazon.Lambda.Serialization.Json  serializer in the 
AssemblyInfo.cs ﬁle.
[assembly: LambdaSerializer(typeof(JsonSerializer))]
You can deﬁne a custom serialization attribute at the method level, which overrides the default serializer 
speciﬁed at the assembly level.
public class ProductService{ 
    [LambdaSerializer(typeof(JsonSerializer))] 
    public Product DescribeProduct(DescribeProductRequest request) 
    { 
      return catalogService.DescribeProduct(request.Id); 
    } 
    
   [LambdaSerializer(typeof(MyJsonSerializer))] 
   public Customer DescribeCustomer(DescribeCustomerRequest request) 
   { 
      return customerService.DescribeCustomer(request.Id); 
   }
} 
     
Lambda function handler restrictions
Note that there are some restrictions on the handler signature.
•It may not be unsafe and use pointer types in the handler signature, though you can use unsafe
context inside the handler method and its dependencies. For more information, see unsafe (C# 
Reference) on the Microsoft Docs website.
•It may not pass a variable number of parameters using the params keyword, or use ArgIterator  as 
an input or a return parameter, which is used to support a variable number of parameters.
•The handler may not be a generic method, for example, IList<T> Sort<T>(IList<T> input).
•Async handlers with signature async void  are not supported.
Using async in C# functions with Lambda
If you know that your Lambda function will require a long-running process, such as uploading large ﬁles 
to Amazon S3 or reading a large stream of records from Amazon DynamoDB, you can take advantage of 
the async/await pattern. When you use this signature, Lambda invokes the function synchronously and 
waits for the function to return a response or for execution to time out.
public async Task<Response> ProcessS3ImageResizeAsync(SimpleS3Event input)
{ 
564AWS Lambda Developer Guide
Using async in C# functions with Lambda
   var response = await client.DoAsyncWork(input); 
   return response;
}
If you use this pattern, consider the following:
•Lambda does not support async void  methods.
•If you create an async Lambda function without implementing the await operator, .NET will issue a 
compiler warning and you will observe unexpected behavior. For example, some async actions will run 
while others won't. Or some async actions won't complete before the function invocation completes.
public async Task ProcessS3ImageResizeAsync(SimpleS3Event event) // Compiler warning
{ 
    client.DoAsyncWork(input);  
}
•Your Lambda function can include multiple async calls, which can be invoked in parallel. You can 
use the Task.WhenAll  and Task.WhenAny  methods to work with multiple tasks. To use the
Task.WhenAll  method, you pass a list of the operations as an array to the method. Note that in the 
following example, if you neglect to include any operation to the array, that call may return before its 
operation completes.
public async Task DoesNotWaitForAllTasks1()
{ 
   // In Lambda, Console.WriteLine goes to CloudWatch Logs. 
   var task1 = Task.Run(() => Console.WriteLine("Test1")); 
   var task2 = Task.Run(() => Console.WriteLine("Test2")); 
   var task3 = Task.Run(() => Console.WriteLine("Test3")); 
  
   // Lambda may return before printing "Test2" since we never wait on task2. 
   await Task.WhenAll(task1, task3);
}
To use the Task.WhenAny  method, you again pass a list of operations as an array to the method. The 
call returns as soon as the ﬁrst operation completes, even if the others are still running.
public async Task DoesNotWaitForAllTasks2()
{ 
  // In Lambda, Console.WriteLine goes to CloudWatch Logs. 
  var task1 = Task.Run(() => Console.WriteLine("Test1")); 
  var task2 = Task.Run(() => Console.WriteLine("Test2")); 
  var task3 = Task.Run(() => Console.WriteLine("Test3")); 
  
  // Lambda may return before printing all tests since we're waiting for only one to 
 finish. 
  await Task.WhenAny(task1, task2, task3);
}
565AWS Lambda Developer Guide
Deployment package
Deploy C# Lambda functions with .zip ﬁle archives
A .NET Core deployment package (.zip ﬁle archive) contains your function's compiled assembly along 
with all of its assembly dependencies. The package also contains a proj.deps.json  ﬁle. This signals 
to the .NET Core runtime all of your function's dependencies and a proj.runtimeconfig.json
ﬁle, which is used to conﬁgure the runtime. The .NET command line interface (CLI) publish
command can create a folder with all of these ﬁles. By default, the proj.runtimeconfig.json
is not included because a Lambda project is typically conﬁgured to be a class library. To force the
proj.runtimeconfig.json  to be written as part of the publish process, pass in the command line 
argument /p:GenerateRuntimeConfigurationFiles=true  to the publish command.
Although it is possible to create the deployment package with the dotnet publish  command, we 
recommend that you create the deployment package with either the .NET Core CLI (p. 566) or the AWS 
Toolkit for Visual Studio (p. 569). These are tools optimized speciﬁcally for Lambda to ensure that the
lambda-project .runtimeconfig.json  ﬁle exists and optimizes the package bundle, including the 
removal of any non-Linux-based dependencies.
Topics
•.NET Core CLI (p. 566)
•AWS Toolkit for Visual Studio (p. 569)
.NET Core CLI
The .NET Core CLI oﬀers a cross-platform way for you to create .NET-based Lambda applications. This 
section assumes that you have installed the .NET Core CLI. If you haven't, see Download .NET on the 
Microsoft website.
In the .NET CLI, you use the new command to create .NET projects from a command line. This is useful if 
you want to create a project outside of Visual Studio. To view a list of the available project types, open 
a command line, navigate to where you installed the .NET Core runtime, and then run the following 
command:
dotnet new list
Usage: new [options]
...
Templates                                         Short Name         Language          Tags 
                              
----------------------------------------------------------------------------------------------------------------------------
Console Application                               console            [C#], F#, VB      
 Common/Console                    
Class library                                     classlib           [C#], F#, VB      
 Common/Library                    
Unit Test Project                                 mstest             [C#], F#, VB      
 Test/MSTest                       
xUnit Test Project                                xunit              [C#], F#, VB      
 Test/xUnit                        
...
Examples: 
    dotnet new mvc --auth Individual 
    dotnet new viewstart 
    dotnet new --help
Lambda oﬀers additional templates via the Amazon.Lambda.Templates NuGet package. To install this 
package, run the following command:
dotnet new -i Amazon.Lambda.Templates
566AWS Lambda Developer Guide
.NET Core CLI
Once the install is complete, the Lambda templates show up as part of dotnet new . To examine details 
about a template, use the help  option.
dotnet new lambda.EmptyFunction --help
The lambda.EmptyFunction  template supports the following options:
•--name – The name of the function
•--profile  – The name of a proﬁle in your AWS SDK for .NET credentials ﬁle
•--region  – The AWS Region to create the function in
These options are saved to a ﬁle named aws-lambda-tools-defaults.json .
Create a function project with the lambda.EmptyFunction  template.
dotnet new lambda.EmptyFunction --name MyFunction
Under the src/myfunction  directory, examine the following ﬁles:
•aws-lambda-tools-defaults.json: This is where you specify the command line options when deploying 
your Lambda function. For example:
  "profile" : "default", 
  "region" : "us-east-2", 
  "configuration" : "Release", 
  "function-runtime":"dotnet6", 
  "function-memory-size" : 256, 
  "function-timeout" : 30, 
  "function-handler" : "MyFunction::MyFunction.Function::FunctionHandler"
•Function.cs: Your Lambda handler function code. It's a C# template that includes the default
Amazon.Lambda.Core  library and a default LambdaSerializer  attribute. For more information 
on serialization requirements and options, see Serializing Lambda functions (p. 563). It also includes a 
sample function that you can edit to apply your Lambda function code.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
// Assembly attribute to enable the Lambda function's JSON input to be converted into 
 a .NET class.
[assembly: 
 LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]
namespace MyFunction
{ 
    public class Function 
    {       
       
        public string FunctionHandler(string input, ILambdaContext context) 
        { 
            return input.ToUpper(); 
        } 
    }
}
567AWS Lambda Developer Guide
.NET Core CLI
•MyFunction.csproj: An MSBuild  ﬁle that lists the ﬁles and assemblies that comprise your application.
<Project Sdk="Microsoft.NET.Sdk"> 
  <PropertyGroup> 
    <TargetFramework>net6.0</TargetFramework> 
    <ImplicitUsings>enable</ImplicitUsings> 
    <Nullable>enable</Nullable> 
    <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles> 
    <AWSProjectType>Lambda</AWSProjectType> 
    <!-- Makes the build directory similar to a publish directory and helps the AWS .NET 
 Lambda Mock Test Tool find project dependencies. --> 
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> 
    <!-- Generate ready to run images during publishing to improve cold start time. --> 
    <PublishReadyToRun>true</PublishReadyToRun> 
  </PropertyGroup> 
  <ItemGroup> 
    <PackageReference Include="Amazon.Lambda.Core" Version="2.1.0 " /> 
    <PackageReference Include="Amazon.Lambda.Serialization.SystemTextJson" 
 Version="2.2.0" /> 
  </ItemGroup>
</Project>
•Readme: Use this ﬁle to document your Lambda function.
Under the myfunction/test  directory, examine the following ﬁles:
•myFunction.Tests.csproj: As noted previously, this is an MSBuild  ﬁle that lists the ﬁles and assemblies 
that comprise your test project. Note also that it includes the Amazon.Lambda.Core  library, so you 
can seamlessly integrate any Lambda templates required to test your function.
<Project Sdk="Microsoft.NET.Sdk"> 
   ...  
    <PackageReference Include="Amazon.Lambda.Core" Version="2.1.0 " /> 
   ...
•FunctionTest.cs: The same C# code template ﬁle that it is included in the src directory. Edit this ﬁle 
to mirror your function's production code and test it before uploading your Lambda function to a 
production environment.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Xunit;
using Amazon.Lambda.Core;
using Amazon.Lambda.TestUtilities;
using MyFunction;
namespace MyFunction.Tests
{ 
    public class FunctionTest 
    { 
        [Fact] 
        public void TestToUpperFunction() 
        { 
568AWS Lambda Developer Guide
AWS Toolkit for Visual Studio
            // Invoke the lambda function and confirm the string was upper cased. 
            var function = new Function(); 
            var context = new TestLambdaContext(); 
            var upperCase = function.FunctionHandler("hello world", context); 
            Assert.Equal("HELLO WORLD", upperCase); 
        } 
    }
}
Once your function has passed its tests, you can build and deploy using the Amazon.Lambda.Tools .NET 
Core Global Tool. To install the .NET Core Global Tool, run the following command:
dotnet tool install -g Amazon.Lambda.Tools
If you already have the tool installed, you can make sure that it is the latest version using the following 
command:
dotnet tool update -g Amazon.Lambda.Tools
For more information about the Amazon.Lambda.Tools .NET Core Global Tool, see the AWS Extensions 
for .NET CLI  repository on GitHub.
With the Amazon.Lambda.Tools installed, you can deploy your function using the following command:
dotnet lambda deploy-function MyFunction --function-role role
After deployment, you can re-test it in a production environment using the following command, and 
pass in a diﬀerent value to your Lambda function handler:
dotnet lambda invoke-function MyFunction --payload "Just Checking If Everything is OK"
If everything is successful, you see the following:
dotnet lambda invoke-function MyFunction --payload "Just Checking If Everything is OK"
Payload:
"JUST CHECKING IF EVERYTHING IS OK"
Log Tail:
START RequestId: id Version: $LATEST
END RequestId: id
REPORT RequestId: id  Duration: 0.99 ms       Billed Duration: 1 ms         Memory Size: 
 256 MB     Max Memory Used: 12 MB
AWS Toolkit for Visual Studio
You can build .NET-based Lambda applications using the Lambda plugin for the AWS Toolkit for Visual 
Studio . The toolkit is available as a Visual Studio extension.
1. Launch Microsoft Visual Studio and choose New project.
a. From the File menu, choose New , and then choose Project.
b. In the New Project window, choose Lambda Project (.NET Core), and then choose OK.
c. In the Select Blueprint window, select from the list of sample applications with sample code to 
help you get started with creating a .NET-based Lambda application.
569AWS Lambda Developer Guide
AWS Toolkit for Visual Studio
d. To create a Lambda application from scratch, choose Empty Function, and then choose Finish .
2. Review the aws-lambda-tools-defaults.json  ﬁle, which is created as part of your project. You 
can set the options in this ﬁle, which the Lambda tooling reads by default. The project templates 
created in Visual Studio set many of these ﬁelds with default values. Note the following ﬁelds:
•proﬁle – The name of a proﬁle in your AWS SDK for .NET credentials ﬁle
•function-handler – The ﬁeld where you specify the function handler . (This is why you don't 
have to set it in the wizard.) However, whenever you rename the Assembly , Namespace , Class , 
or Function  in your function code, you must update the corresponding ﬁelds in the aws-
lambda-tools-defaults.json  ﬁle.
{ 
  "profile":" default", 
  "region" : " us-east-2 ", 
  "configuration" : "Release", 
  "function-runtime":"dotnet6", 
  "function-memory-size" : 256, 
  "function-timeout" : 30, 
  "function-handler" : " Assembly ::Namespace .Class::Function"  
}
3. Open the Function.cs ﬁle. You are provided with a template to implement your Lambda function 
handler code.
4. After writing the code that represents your Lambda function, upload it by opening the context 
(right-click) menu for the Project node in your application and then choosing Publish to AWS 
Lambda .
5. In the Upload Lambda Function window, enter a name for the function, or select a previously 
published function to republish. Then choose Next.
6. In the Advanced Function Details window, conﬁgure the following options:
•Role Name (required) – The AWS Identity and Access Management (IAM) role (p. 913) that 
Lambda assumes when it runs your function.
•Environment – Key-value pairs that Lambda sets in the execution environment. To extend your 
function's conﬁguration outside of code, use environment variables (p. 77).
•Memory – The amount of memory available to the function at runtime. Choose an amount
between 128 MB and 10,240 MB (p. 1269 ) in 1-MB increments.
•Timeout  – The amount of time that Lambda allows a function to run before stopping it. The 
default is three seconds. The maximum allowed value is 900 seconds.
•VPC – If your function needs network access to resources that are not available over the internet,
conﬁgure it to connect to a virtual private cloud (VPC) (p. 85).
•DLQ – If your function is invoked asynchronously, choose a dead-letter queue (p. 148) to receive 
failed invocations.
•Enable active tracing – Sample incoming requests and trace sampled requests with AWS X-
Ray (p. 973).
7. Choose Next, and then choose Upload to deploy your application.
For more information, see Deploying an AWS Lambda Project with the .NET Core CLI.
570AWS Lambda Developer Guide
Deploy container images
Deploy .NET Lambda functions with container 
images
There are three ways to build a container image for a .NET Lambda function:
•Using an AWS base image for .NET (p. 572)
The AWS base images (p. 123) are preloaded with a language runtime, a runtime interface client to 
manage the interaction between Lambda and your function code, and a runtime interface emulator for 
local testing.
•Using an AWS base image for custom runtimes (p. 123)
AWS provides base images that contain the Amazon Linux or Amazon Linux 2 operating system and 
the runtime interface emulator (p. 127). You can add your preferred runtime (p. 60), dependencies, and 
code to these images. To make the image compatible with Lambda, you must include the the runtime 
interface client for .NET (p. 573) in the image.
•Using a non-AWS base image (p. 573)
You can use an alternative base image from another container registry, such as Alpine Linux or Debian. 
You can also use a custom image created by your organization. To make the image compatible with 
Lambda, you must include the the runtime interface client for .NET (p. 573) in the image.
Tip
To reduce the time it takes for Lambda container functions to become active, see Use multi-
stage builds  in the Docker documentation. To build eﬃcient container images, follow the Best 
practices for writing Dockerﬁles.
This page explains how to build, test, and deploy container images for Lambda.
Topics
•AWS base images for .NET (p. 571)
•Using an AWS base image for .NET (p. 572)
•Using an alternative base image with the runtime interface client (p. 573)
AWS base images for .NET
AWS provides the following base images for .NET:
Tags Runtime Operating 
systemDockerﬁle Deprecation
7 .NET 7 Amazon 
Linux 2Dockerﬁle for .NET 7 on 
GitHubMay 14, 2024
6 .NET 6 Amazon 
Linux 2Dockerﬁle for .NET 6 on 
GitHub
Amazon ECR repository: gallery.ecr.aws/lambda/dotnet
571AWS Lambda Developer Guide
Using an AWS base image
Using an AWS base image for .NET
Prerequisites
To complete the steps in this section, you must have the following:
•.NET SDK  – The following steps use the .NET 7 base image. Make sure that your .NET version matches 
the version of the base image  that you specify in your Dockerﬁle.
•Docker
Creating and deploying an image using a base image
In the following steps, you use Amazon.Lambda.Templates and Amazon.Lambda.Tools to create a .NET 
project. Then, you build a Docker image, upload the image to Amazon ECR, and deploy it to a Lambda 
function.
1. Install the Amazon.Lambda.Templates NuGet package.
dotnet new install Amazon.Lambda.Templates
2. Create a .NET project using the lambda.image.EmptyFunction  template.
dotnet new lambda.image.EmptyFunction --name MyFunction  --region us-east-1
3. Navigate to the MyFunction /src/MyFunction  directory. This is where the project ﬁles are stored. 
Examine the following ﬁles:
•aws-lambda-tools-defaults.json – This ﬁle is where you specify the command line options when 
deploying your Lambda function.
•Function.cs – Your Lambda handler function code. This is a C# template that includes the 
default Amazon.Lambda.Core  library and a default LambdaSerializer  attribute. For 
more information about serialization requirements and options, see Serializing Lambda 
functions (p. 563). You can use the provided code for testing, or replace it with your own.
•MyFunction.csproj – A .NET project ﬁle, which lists the ﬁles and assemblies that comprise your 
application.
•Readme.md – This ﬁle contains more information about the sample Lambda function.
4. Examine the Dockerﬁle in the src/MyFunction  directory. You can use the provided Dockerﬁle for 
testing, or replace it with your own. If you use your own, make sure to:
•Set the FROM property to the URI of the base image . Your .NET version must match the version of 
the base image.
•Set the CMD argument to the Lambda function handler. This should match the image-command  in
aws-lambda-tools-defaults.json .
Example Dockerﬁle
# You can also pull these images from DockerHub amazon/aws-lambda-dotnet:7
FROM public.ecr.aws/lambda/dotnet:7
  
# Copy function code
COPY publish/* ${LAMBDA_TASK_ROOT} 
   
# Set the CMD to your handler (could also be done as a parameter override outside of 
 the Dockerfile)
572AWS Lambda Developer Guide
Using a non-AWS base image
CMD [ "MyFunction::MyFunction.Function::FunctionHandler " ]
5. Install the Amazon.Lambda.Tools .NET Core Global Tool.
dotnet tool install -g Amazon.Lambda.Tools
If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
dotnet tool update -g Amazon.Lambda.Tools
6. Change the directory to MyFunction /src/MyFunction , if you're not there already.
cd src/MyFunction
7. Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and 
deploy the Lambda function.
For --function-role , specify the role name—not the Amazon Resource Name (ARN)—of the
execution role (p. 913) for the function. For example, lambda-role .
dotnet lambda deploy-function MyFunction  --function-role lambda-role
For more information about the Amazon.Lambda.Tools .NET Core Global Tool, see the AWS 
Extensions for .NET CLI repository on GitHub.
8. Invoke the function.
dotnet lambda invoke-function MyFunction  --payload "Testing the function"
If everything is successful, you see the following:
Payload:
"TESTING THE FUNCTION"
Log Tail:
START RequestId: id Version: $LATEST
END RequestId: id
REPORT RequestId: id  Duration: 0.99 ms       Billed Duration: 1 ms         Memory 
 Size: 256 MB     Max Memory Used: 12 MB
9. Delete the Lambda function.
dotnet lambda delete-function MyFunction
Using an alternative base image with the runtime 
interface clientIf you use a base image for custom runtimes  (p. 123) or an alternative base image, you must include 
the runtime interface client in your image. The runtime interface client extends the Lambda runtime 
API (p. 55), which manages the interaction between Lambda and your function code.
The following example demonstrates how to build a container image for .NET using a non-AWS base 
image, and how to add the Amazon.Lambda.RuntimeSupport package, which is the Lambda runtime 
interface client for .NET. The example Dockerﬁle uses the Microsoft .NET 7 base image.
573AWS Lambda Developer Guide
Using a non-AWS base image
Prerequisites
To complete the steps in this section, you must have the following:
•.NET SDK  – The following steps use a .NET 7 base image. Make sure that your .NET version matches the 
version of the base image  that you specify in your Dockerﬁle.
•Docker
Creating and deploying an image using an alternative base 
image
1. Install the Amazon.Lambda.Templates NuGet package.
dotnet new install Amazon.Lambda.Templates
2. Create a .NET project using the lambda.CustomRuntimeFunction  template. This template 
includes the Amazon.Lambda.RuntimeSupport package.
dotnet new lambda.CustomRuntimeFunction --name MyFunction  --region us-east-1
3. Navigate to the MyFunction /src/MyFunction  directory. This is where the project ﬁles are stored. 
Examine the following ﬁles:
•aws-lambda-tools-defaults.json – This ﬁle is where you specify the command line options when 
deploying your Lambda function.
•Function.cs – The code contains a class with a Main method that initializes the
Amazon.Lambda.RuntimeSupport  library as the bootstrap. The Main method is the entry point 
for the function's process. The Main method wraps the function handler in a wrapper that the 
bootstrap can work with. For more information, see Using Amazon.Lambda.RuntimeSupport as a 
class library in the GitHub repository.
•MyFunction.csproj – A .NET project ﬁle, which lists the ﬁles and assemblies that comprise your 
application.
•Readme.md – This ﬁle contains more information about the sample Lambda function.
4. Open the aws-lambda-tools-defaults.json  ﬁle and Add the following lines:
  "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
•package-type: Deﬁnes the deployment package as a container image.
•docker-host-build-output-dir: Sets the output directory for the build process.
Example aws-lambda-tools-defaults.json
{ 
  "Information": [ 
    "This file provides default values for the deployment wizard inside Visual Studio 
 and the AWS Lambda commands added to the .NET Core CLI.", 
    "To learn more about the Lambda commands with the .NET Core CLI execute the 
 following command at the command line in the project root directory.", 
    "dotnet lambda help", 
    "All the command line options for the Lambda command can be specified in this 
 file." 
  ], 
574AWS Lambda Developer Guide
Using a non-AWS base image
  "profile": "", 
  "region": "us-east-1", 
  "configuration": "Release", 
  "function-runtime": "provided.al2", 
  "function-memory-size": 256, 
  "function-timeout": 30, 
  "function-handler": "bootstrap", 
  "msbuild-parameters": "--self-contained true", 
   "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
}
5. Create a Dockerﬁle in the MyFunction /src/MyFunction  directory. The following example 
Dockerﬁle uses a Microsoft .NET base image instead of an AWS base image (p. 571).
•Set the FROM property to the base image identiﬁer. Your .NET version must match the version of 
the base image.
•Use the COPY command to copy the function into the /var/task  directory.
•Set the ENTRYPOINT  to the module that you want the Docker container to run when it starts. In 
this case, the module is the bootstrap, which initializes the Amazon.Lambda.RuntimeSupport
library.
Example Dockerﬁle
# You can also pull these images from DockerHub amazon/aws-lambda-dotnet:7
FROM mcr.microsoft.com/dotnet/runtime:7.0
# Set the image's internal work directory
WORKDIR /var/task 
   
# Copy function code
COPY "bin/Release/net7.0/linux-x64"  . 
   
# Set the entrypoint to the bootstrap
ENTRYPOINT [" /usr/bin/dotnet", "exec", "/var/task/bootstrap.dll "]
6. Install the Amazon.Lambda.Tools .NET Core Global Tool.
dotnet tool install -g Amazon.Lambda.Tools
If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
dotnet tool update -g Amazon.Lambda.Tools
7. Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and 
deploy the Lambda function.
For --function-role , specify the role name—not the Amazon Resource Name (ARN)—of the
execution role (p. 913) for the function. For example, lambda-role .
dotnet lambda deploy-function MyFunction  --function-role lambda-role
For more information about the Amazon.Lambda.Tools .NET Core Global Tool, see the AWS 
Extensions for .NET CLI repository on GitHub.
8. Invoke the function.
575AWS Lambda Developer Guide
Using a non-AWS base image
dotnet lambda invoke-function MyFunction  --payload "Testing the function"
If everything is successful, you see the following:
Payload:
"TESTING THE FUNCTION"
Log Tail:
START RequestId: id Version: $LATEST
END RequestId: id
REPORT RequestId: id  Duration: 0.99 ms       Billed Duration: 1 ms         Memory 
 Size: 256 MB     Max Memory Used: 12 MB
9. Delete the Lambda function.
dotnet lambda delete-function MyFunction
576AWS Lambda Developer Guide
Context
AWS Lambda context object in C#
When Lambda runs your function, it passes a context object to the handler  (p. 558). This object provides 
properties with information about the invocation, function, and execution environment.
Context properties
•FunctionName  – The name of the Lambda function.
•FunctionVersion  – The version (p. 108) of the function.
•InvokedFunctionArn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•MemoryLimitInMB  – The amount of memory that's allocated for the function.
•AwsRequestId  – The identiﬁer of the invocation request.
•LogGroupName  – The log group for the function.
•LogStreamName  – The log stream for the function instance.
•RemainingTime  (TimeSpan ) – The number of milliseconds left before the execution times out.
•Identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•ClientContext  – (mobile apps) Client context that's provided to Lambda by the client application.
•Logger  The logger object (p. 578) for the function.
The following C# code snippet shows a simple handler function that prints some of the context 
information.
public async Task Handler(ILambdaContext context)
{ 
    Console.WriteLine("Function name: " + context.FunctionName); 
    Console.WriteLine("RemainingTime: " + context.RemainingTime); 
    await Task.Delay(TimeSpan.FromSeconds(0.42)); 
    Console.WriteLine("RemainingTime after sleep: " + context.RemainingTime);
}
577AWS Lambda Developer Guide
Logging
Lambda function logging in C#
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, the CloudWatch console, or Infrastructure as 
code tools such as the AWS Serverless Application Model(AWS SAM).
Sections
•Tools and libraries (p. 578)
•Creating a function that returns logs (p. 578)
•Using log levels (p. 580)
•Using Powertools for AWS Lambda (.NET) and AWS SAM for structured logging (p. 580)
•Using the Lambda console (p. 582)
•Using the CloudWatch console (p. 582)
•Using the AWS Command Line Interface (AWS CLI) (p. 583)
•Deleting logs  (p. 585)
Tools and libraries
Powertools for AWS Lambda (.NET) is a developer toolkit to implement Serverless best practices and 
increase developer velocity. The Logging utility provides a Lambda optimized logger which includes 
additional information about function context across all your functions with output structured as JSON. 
Use this utility to do the following:
•Capture key ﬁelds from the Lambda context, cold start and structures logging output as JSON
•Log Lambda invocation events when instructed (disabled by default)
•Print all the logs only for a percentage of invocations via log sampling (disabled by default)
•Append additional keys to structured log at any point in time
•Use a custom log formatter (Bring Your Own Formatter) to output logs in a structure compatible with 
your organization’s Logging RFC
Creating a function that returns logs
To output logs from your function code, you can use methods on the Console class , or any logging 
library that writes to stdout  or stderr. The following example uses the LambdaLogger  class from the
Amazon.Lambda.Core (p. 556) library.
Example src/blank-csharp/Function.cs – Logging
public async Task<AccountUsage> FunctionHandler(SQSEvent invocationEvent, ILambdaContext 
 context) 
  { 
    GetAccountSettingsResponse accountSettings; 
    try 
578AWS Lambda Developer Guide
Creating a function that returns logs
    { 
      accountSettings = await callLambda(); 
    } 
    catch (AmazonLambdaException ex) 
    { 
      throw ex; 
    } 
    AccountUsage accountUsage = accountSettings.AccountUsage; 
    LambdaLogger.Log("ENVIRONMENT VARIABLES: " + 
 JsonConvert.SerializeObject(System.Environment.GetEnvironmentVariables())); 
    LambdaLogger.Log("CONTEXT: " + JsonConvert.SerializeObject(context)); 
    LambdaLogger.Log("EVENT: " + JsonConvert.SerializeObject(invocationEvent)); 
    return accountUsage; 
  }
Example log format
START RequestId: d1cf0ccb-xmpl-46e6-950d-04c96c9b1c5d Version: $LATEST
ENVIRONMENT VARIABLES:  
{ 
  "AWS_EXECUTION_ENV": "AWS_Lambda_dotnet6", 
  "AWS_LAMBDA_FUNCTION_MEMORY_SIZE": "256", 
  "AWS_LAMBDA_LOG_GROUP_NAME": "/aws/lambda/blank-csharp-function-WU56XMPLV2XA", 
  "AWS_LAMBDA_FUNCTION_VERSION": "$LATEST", 
  "AWS_LAMBDA_LOG_STREAM_NAME": "2020/03/27/[$LATEST]5296xmpl084f411d9fb73b258393f30c", 
  "AWS_LAMBDA_FUNCTION_NAME": "blank-csharp-function-WU56XMPLV2XA", 
  ...
EVENT:  
{ 
  "Records": [ 
      { 
          "MessageId": "19dd0b57-b21e-4ac1-bd88-01bbb068cb78", 
          "ReceiptHandle": "MessageReceiptHandle", 
          "Body": "Hello from SQS!", 
          "Md5OfBody": "7b270e59b47ff90a553787216d55d91d", 
          "Md5OfMessageAttributes": null, 
          "EventSourceArn": "arn:aws:sqs:us-west-2:123456789012:MyQueue", 
          "EventSource": "aws:sqs", 
          "AwsRegion": "us-west-2", 
          "Attributes": { 
              "ApproximateReceiveCount": "1", 
              "SentTimestamp": "1523232000000", 
              "SenderId": "123456789012", 
              "ApproximateFirstReceiveTimestamp": "1523232000001" 
          }, 
          ...
END RequestId: d1cf0ccb-xmpl-46e6-950d-04c96c9b1c5d
REPORT RequestId: d1cf0ccb-xmpl-46e6-950d-04c96c9b1c5d Duration: 4157.16 ms Billed 
 Duration: 4200 ms Memory Size: 256 MB Max Memory Used: 99 MB Init Duration: 841.60 ms  
XRAY TraceId: 1-5e7e8131-7ff0xmpl32bfb31045d0a3bb SegmentId: 0152xmpl6016310f Sampled: true
The .NET runtime logs the START , END, and REPORT lines for each invocation. The report line provides 
the following details.
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
579AWS Lambda Developer Guide
Using log levels
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
Using log levels
Starting with .NET 6, you can use log levels for additional logging from Lambda functions. Log levels 
provide ﬁltering and categorization for the logs that your function writes to Amazon EventBridge 
(CloudWatch Events).
The log levels available are:
•LogCritical
•LogError
•LogWarning
•LogInformation
•LogDebug
•LogTrace
By default, Lambda writes LogInformation  level logs and above to CloudWatch. You can adjust the 
level of logs that Lambda writes using the AWS_LAMBDA_HANDLER_LOG_LEVEL  environment variable. 
Set the value of the environment variable to the string enum value for the level desired, as outlined in 
the LogLevel enum. For example, if you set AWS_LAMBDA_HANDLER_LOG_LEVEL  to Error , Lambda 
writes LogError  and LogCritical  messages to CloudWatch.
Lambda writes Console.WriteLine  calls as info level messages, and Console.Error.WriteLine
calls as error level messages.
If you prefer the previous style of logging in .NET, set AWS_LAMBDA_HANDLER_LOG_FORMAT  to
Unformatted .
Using Powertools for AWS Lambda (.NET) and AWS 
SAM for structured logging
Follow the steps below to download, build, and deploy a sample Hello World C# application with 
integrated Powertools for AWS Lambda (.NET) modules using the AWS SAM. This application implements 
a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon 
API Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway 
endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format to 
CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world  message.
Prerequisites
To complete the steps in this section, you must have the following:
•.NET 6
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
580AWS Lambda Developer Guide
Using Powertools for AWS Lambda (.NET) 
and AWS SAM for structured logging
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World TypeScript template.
sam init --app-template hello-world-powertools-dotnet --name sam-app --package-type Zip 
 --runtime dotnet6 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl -X GET <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the logs for the function, run sam logs . For more information, see Working with logs in the
AWS Serverless Application Model Developer Guide.
sam logs --stack-name sam-app
The log output looks like this:
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 
 2023-02-20T14:15:27.988000 INIT_START Runtime Version: 
 dotnet:6.v13        Runtime Version ARN: arn:aws:lambda:ap-
southeast-2::runtime:699f346a05dae24c58c45790bc4089f252bf17dae3997e79b17d939a288aa1ec
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:28.229000 START 
 RequestId: bed25b38-d012-42e7-ba28-f272535fb80e Version: $LATEST
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:29.259000 
 2023-02-20T14:15:29.201Z        bed25b38-d012-42e7-ba28-f272535fb80e    info 
   {"_aws":{"Timestamp":1676902528962,"CloudWatchMetrics":[{"Namespace":"sam-
app-logging","Metrics":[{"Name":"ColdStart","Unit":"Count"}],"Dimensions":
[["FunctionName"],["Service"]]}]},"FunctionName":"sam-app-HelloWorldFunction-
haKIoVeose2p","Service":"PowertoolsHelloWorld","ColdStart":1}
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:30.479000 
 2023-02-20T14:15:30.479Z        bed25b38-d012-42e7-ba28-f272535fb80e    info   
 {"ColdStart":true,"XrayTraceId":"1-63f3807f-5dbcb9910c96f50742707542","CorrelationId":"d3d4de7f-4ccc-411a-
a549-4d67b2fdc015","FunctionName":"sam-app-HelloWorldFunction-
haKIoVeose2p","FunctionVersion":"$LATEST","FunctionMemorySize":256,"FunctionArn":"arn:aws:lambda:ap-
581AWS Lambda Developer Guide
Using the Lambda console
southeast-2:123456789012:function:sam-app-HelloWorldFunction-
haKIoVeose2p","FunctionRequestId":"bed25b38-d012-42e7-ba28-
f272535fb80e","Timestamp":"2023-02-20T14:15:30.4602970Z","Level":"Information","Service":"PowertoolsHelloWorld","Name":"AWS.Lambda.Powertools.Logging.Logger","Message":"Hello 
 world API - HTTP 200"}
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:30.599000 
 2023-02-20T14:15:30.599Z        bed25b38-d012-42e7-ba28-f272535fb80e    info 
   {"_aws":{"Timestamp":1676902528922,"CloudWatchMetrics":[{"Namespace":"sam-
app-logging","Metrics":[{"Name":"ApiRequestCount","Unit":"Count"}],"Dimensions":
[["Service"]]}]},"Service":"PowertoolsHelloWorld","ApiRequestCount":1}
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:30.680000 END 
 RequestId: bed25b38-d012-42e7-ba28-f272535fb80e
2023/02/20/[$LATEST]4eaf8445ba7a4a93b999cb17fbfbecd8 2023-02-20T14:15:30.680000 REPORT 
 RequestId: bed25b38-d012-42e7-ba28-f272535fb80e  Duration: 2450.99 ms   Billed 
 Duration: 2451 ms Memory Size: 256 MB     Max Memory Used: 74 MB  Init Duration: 
 240.05 ms
XRAY TraceId: 1-63f3807f-5dbcb9910c96f50742707542       SegmentId: 16b362cd5f52cba0
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
Managing log retention
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which CloudWatch automatically deletes the 
logs. To set up log retention, add the following to your AWS SAM template:
Resources: 
  HelloWorldFunction: 
    Type: AWS::Serverless::Function 
    Properties: 
      # Omitting other properties 
  LogGroup: 
    Type: AWS::Logs::LogGroup 
    Properties: 
      LogGroupName: !Sub "/aws/lambda/${HelloWorldFunction}" 
      RetentionInDays: 7
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
582AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
583AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
584AWS Lambda Developer Guide
Deleting logs
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
585AWS Lambda Developer Guide
Errors
AWS Lambda function errors in C#
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the C# runtime using the Lambda 
console and the AWS CLI.
Sections
•Syntax (p. 586)
•How it works (p. 588)
•Using the Lambda console (p. 589)
•Using the AWS Command Line Interface (AWS CLI) (p. 589)
•Error handling in other AWS services (p. 590)
•What's next? (p. 590)
Syntax
In the initialization phase, exceptions can be thrown for invalid handler strings, a rule-breaking type or 
method (see Lambda function handler restrictions (p. 564)), or any other validation method (such as 
forgetting the serializer attribute and having a POCO as your input or output type). These exceptions are 
of type LambdaException . For example:
{ 
  "errorType": "LambdaException", 
  "errorMessage": "Invalid lambda function handler: 'http://this.is.not.a.valid.handler/'.  
  The valid format is 'ASSEMBLY::TYPE::METHOD'."
}
If your constructor throws an exception, the error type is also of type LambdaException , but the 
exception thrown during construction is provided in the cause property, which is itself a modeled 
exception object:
{ 
  "errorType": "LambdaException", 
  "errorMessage": "An exception was thrown when the constructor for type 
 'LambdaExceptionTestFunction.ThrowExceptionInConstructor' 
   was invoked. Check inner exception for more details.", 
  "cause":   { 
    "errorType": "TargetInvocationException", 
    "errorMessage": "Exception has been thrown by the target of an invocation.", 
    "stackTrace": [ 
      "at System.RuntimeTypeHandle.CreateInstance(RuntimeType type, Boolean publicOnly, 
 Boolean noCheck, Boolean&canBeCached,  
      RuntimeMethodHandleInternal&ctor, Boolean& bNeedSecurityCheck)", 
      "at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly, Boolean skipCheckThis, 
 Boolean fillCache, StackCrawlMark& stackMark)", 
      "at System.Activator.CreateInstance(Type type, Boolean nonPublic)", 
      "at System.Activator.CreateInstance(Type type)" 
    ], 
    "cause":     { 
      "errorType": "ArithmeticException", 
      "errorMessage": "Sorry, 2 + 2 = 5", 
      "stackTrace": [ 
        "at LambdaExceptionTestFunction.ThrowExceptionInConstructor..ctor()" 
      ] 
    } 
586AWS Lambda Developer Guide
Syntax
  }
}
As the example shows, the inner exceptions are always preserved (as the cause property), and can be 
deeply nested.
Exceptions can also occur during invocation. In this case, the exception type is preserved and the 
exception is returned directly as the payload and in the CloudWatch logs. For example:
{ 
  "errorType": "AggregateException", 
  "errorMessage": "One or more errors occurred. (An unknown web exception occurred!)", 
  "stackTrace": [ 
    "at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean 
 includeTaskCanceledExceptions)", 
    "at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)", 
    "at lambda_method(Closure , Stream , Stream , ContextInfo )" 
  ], 
  "cause":   { 
    "errorType": "UnknownWebException", 
    "errorMessage": "An unknown web exception occurred!", 
    "stackTrace": [ 
      "at LambdaDemo107.LambdaEntryPoint.<GetUriResponse>d__1.MoveNext()", 
      "--- End of stack trace from previous location where exception was thrown ---", 
      "at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)", 
      "at 
 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task 
 task)", 
      "at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()", 
      "at LambdaDemo107.LambdaEntryPoint.<CheckWebsiteStatus>d__0.MoveNext()" 
    ], 
    "cause":     { 
      "errorType": "WebException", 
      "errorMessage": "An error occurred while sending the request. SSL peer certificate or 
 SSH remote key was not OK", 
      "stackTrace": [ 
        "at System.Net.HttpWebRequest.EndGetResponse(IAsyncResult asyncResult)", 
        "at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, 
 Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)", 
        "--- End of stack trace from previous location where exception was thrown ---", 
        "at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)", 
        "at 
 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task 
 task)", 
        "at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()", 
        "at LambdaDemo107.LambdaEntryPoint.<GetUriResponse>d__1.MoveNext()" 
      ], 
      "cause":       { 
        "errorType": "HttpRequestException", 
        "errorMessage": "An error occurred while sending the request.", 
        "stackTrace": [ 
          "at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)", 
          "at 
 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task 
 task)", 
          "at System.Net.Http.HttpClient.<FinishSendAsync>d__58.MoveNext()", 
          "--- End of stack trace from previous location where exception was thrown ---", 
          "at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)", 
          "at 
 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task 
 task)", 
          "at System.Net.HttpWebRequest.<SendRequest>d__63.MoveNext()", 
          "--- End of stack trace from previous location where exception was thrown ---", 
          "at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)", 
587AWS Lambda Developer Guide
How it works
          "at 
 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task 
 task)", 
          "at System.Net.HttpWebRequest.EndGetResponse(IAsyncResult asyncResult)" 
        ], 
        "cause":         { 
          "errorType": "CurlException", 
          "errorMessage": "SSL peer certificate or SSH remote key was not OK", 
          "stackTrace": [ 
            "at System.Net.Http.CurlHandler.ThrowIfCURLEError(CURLcode error)", 
            "at 
 System.Net.Http.CurlHandler.MultiAgent.FinishRequest(StrongToWeakReference`1 easyWrapper, 
 CURLcode messageResult)" 
          ] 
        } 
      } 
    } 
  }
}
The method in which error information is conveyed depends on the invocation type:
•RequestResponse  invocation type (that is, synchronous execution): In this case, you get the error 
message back.
For example, if you invoke a Lambda function using the Lambda console, the RequestResponse  is 
always the invocation type and the console displays the error information returned by AWS Lambda in 
the Execution result section of the console.
•Event invocation type (that is, asynchronous execution): In this case AWS Lambda does not return 
anything. Instead, it logs the error information in CloudWatch Logs and CloudWatch metrics.
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
588AWS Lambda Developer Guide
Using the Lambda console
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
589AWS Lambda Developer Guide
Error handling in other AWS services
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
Lambda also records up to 256 KB of the error object in the function's logs. For more information, see
Lambda function logging in C# (p. 578).
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
For more information, see Instrumenting C# code in AWS Lambda (p. 591).
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 578) page.
590AWS Lambda Developer Guide
Tracing
Instrumenting C# code in AWS Lambda
Lambda integrates with AWS X-Ray to help you trace, debug, and optimize Lambda applications. You 
can use X-Ray to trace a request as it traverses resources in your application, which may include Lambda 
functions and other AWS services.
To send tracing data to X-Ray, you can use one of three SDK libraries:
•AWS Distro for OpenTelemetry (ADOT) – A secure, production-ready, AWS-supported distribution of 
the OpenTelemetry (OTel) SDK.
•AWS X-Ray SDK for .NET – An SDK for generating and sending trace data to X-Ray.
•Powertools for AWS Lambda (.NET) – A developer toolkit to implement Serverless best practices and 
increase developer velocity.
Each of the SDKs oﬀer ways to send your telemetry data to the X-Ray service. You can then use X-
Ray to view, ﬁlter, and gain insights into your application's performance metrics to identify issues and 
opportunities for optimization.
Important
The X-Ray and Powertools for AWS Lambda SDKs are part of a tightly integrated 
instrumentation solution oﬀered by AWS. The ADOT Lambda Layers are part of an industry-wide 
standard for tracing instrumentation that collect more data in general, but may not be suited 
for all use cases. You can implement end-to-end tracing in X-Ray using either solution. To learn 
more about choosing between them, see Choosing between the AWS Distro for Open Telemetry 
and X-Ray SDKs.
Sections
•Using Powertools for AWS Lambda (.NET) and AWS SAM for tracing (p. 591)
•Using the X-Ray SDK to instrument your .NET functions (p. 593)
•Activating tracing with the Lambda console (p. 594)
•Activating tracing with the Lambda API (p. 594)
•Activating tracing with AWS CloudFormation (p. 594)
•Interpreting an X-Ray trace (p. 595)
Using Powertools for AWS Lambda (.NET) and AWS 
SAM for tracing
Follow the steps below to download, build, and deploy a sample Hello World C# application with 
integrated Powertools for AWS Lambda (.NET) modules using the AWS SAM. This application implements 
a basic API backend and uses Powertools for emitting logs, metrics, and traces. It consists of an Amazon 
API Gateway endpoint and a Lambda function. When you send a GET request to the API Gateway 
endpoint, the Lambda function invokes, sends logs and metrics using Embedded Metric Format to 
CloudWatch, and sends traces to AWS X-Ray. The function returns a hello world message.
Prerequisites
To complete the steps in this section, you must have the following:
•.NET 6
•AWS CLI version 2
•AWS SAM CLI version 1.75 or later. If you have an older version of the AWS SAM CLI, see Upgrading the 
AWS SAM CLI.
591AWS Lambda Developer Guide
Using Powertools for AWS Lambda 
(.NET) and AWS SAM for tracing
Deploy a sample AWS SAM application
1. Initialize the application using the Hello World TypeScript template.
sam init --app-template hello-world-powertools-dotnet --name sam-app --package-type Zip 
 --runtime dotnet6 --no-tracing
2. Build the app.
cd sam-app && sam build
3. Deploy the app.
sam deploy --guided
4. Follow the on-screen prompts. To accept the default options provided in the interactive experience, 
press Enter .
Note
For HelloWorldFunction may not have authorization deﬁned, Is this okay?, make sure to 
enter y.
5. Get the URL of the deployed application:
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[0].Outputs[?
OutputKey==`HelloWorldApi`].OutputValue' --output text
6. Invoke the API endpoint:
curl <URL_FROM_PREVIOUS_STEP>
If successful, you'll see this response:
{"message":"hello world"}
7. To get the traces for the function, run sam traces.
sam traces
The trace output looks like this:
New XRay Service Graph 
  Start time: 2023-02-20 23:05:16+08:00 
  End time: 2023-02-20 23:05:16+08:00 
  Reference Id: 0 - AWS::Lambda - sam-app-HelloWorldFunction-pNjujb7mEoew - Edges: [1] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 2.814 
  Reference Id: 1 - AWS::Lambda::Function - sam-app-HelloWorldFunction-pNjujb7mEoew - 
 Edges: [] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 2.429 
592AWS Lambda Developer Guide
Using the X-Ray SDK to instrument your .NET functions
  Reference Id: 2 - (Root) AWS::ApiGateway::Stage - sam-app/Prod - Edges: [0] 
   Summary_statistics: 
     - total requests: 1 
     - ok count(2XX): 1 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 2.839 
  Reference Id: 3 - client - sam-app/Prod - Edges: [2] 
   Summary_statistics: 
     - total requests: 0 
     - ok count(2XX): 0 
     - error count(4XX): 0 
     - fault count(5XX): 0 
     - total response time: 0
XRay Event [revision 3] at (2023-02-20T23:05:16.521000) with id 
 (1-63f38c2c-270200bf1d292a442c8e8a00) and duration (2.877s) 
 - 2.839s - sam-app/Prod [HTTP: 200] 
   - 2.836s - Lambda [HTTP: 200] 
 - 2.814s - sam-app-HelloWorldFunction-pNjujb7mEoew [HTTP: 200] 
 - 2.429s - sam-app-HelloWorldFunction-pNjujb7mEoew 
   - 0.230s - Initialization 
   - 2.389s - Invocation 
     - 0.600s - ## FunctionHandler 
       - 0.517s - Get Calling IP 
   - 0.039s - Overhead
8. This is a public API endpoint that is accessible over the internet. We recommend that you delete the 
endpoint after testing.
sam delete
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
Using the X-Ray SDK to instrument your .NET 
functions
You can instrument your function code to record metadata and trace downstream calls. To record detail 
about calls that your function makes to other resources and services, use the X-Ray SDK for .NET. To get 
the SDK, add the AWSXRayRecorder  packages to your project ﬁle.
Example src/blank-csharp/blank-csharp.csproj
<Project Sdk="Microsoft.NET.Sdk"> 
  <PropertyGroup> 
    <TargetFramework>net6.0</TargetFramework> 
    <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles> 
    <AWSProjectType>Lambda</AWSProjectType> 
  </PropertyGroup> 
  <ItemGroup> 
    <PackageReference Include="Amazon.Lambda.Core" Version="2.1.0" /> 
    <PackageReference Include="Amazon.Lambda.SQSEvents" Version="2.1.0" /> 
    <PackageReference Include="Amazon.Lambda.Serialization.Json" Version="2.1.0" /> 
    <PackageReference Include="AWSSDK.Core" Version="3.7.103.24" /> 
593AWS Lambda Developer Guide
Activating tracing with the Lambda console
    <PackageReference Include="AWSSDK.Lambda" Version="3.7.104.3" /> 
     <PackageReference Include="AWSXRayRecorder.Core" Version="2.13.0" /> 
    <PackageReference Include="AWSXRayRecorder.Handlers.AwsSdk" Version="2.11.0" />
  </ItemGroup>
</Project>
To instrument AWS SDK clients, call the RegisterXRayForAllServices  method in your initialization 
code.
Example src/blank-csharp/Function.cs – Initialize X-Ray
{ 
      AWSSDKHandler.RegisterXRayForAllServices(); 
      lambdaClient = new AmazonLambdaClient(); 
      await callLambda(); 
    }
Activating tracing with the Lambda console
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Activating tracing with the Lambda API
Conﬁgure tracing on your Lambda function with the AWS CLI or AWS SDK, use the following API 
operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Activating tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
594AWS Lambda Developer Guide
Interpreting an X-Ray trace
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
Interpreting an X-Ray trace
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, 
add the AWSXRayDaemonWriteAccess policy to the execution role.
After you've conﬁgured active tracing, you can observe speciﬁc requests through your application. The 
X-Ray service graph shows information about your application and all its components. The following 
example from the error processor (p. 1121 ) sample application shows an application with two functions. 
The primary function processes events and sometimes returns errors. The second function at the top 
processes errors that appear in the ﬁrst's log group and uses the AWS SDK to call X-Ray, Amazon Simple 
Storage Service (Amazon S3), and Amazon CloudWatch Logs.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
595AWS Lambda Developer Guide
Interpreting an X-Ray trace
When using active tracing, Lambda records 2 segments per trace, which creates two nodes on the service 
graph. The following image highlights these two nodes for the primary function from the error processor 
sample application  (p. 1121 ).
The ﬁrst node on the left represents the Lambda service, which receives the invocation request. The 
second node represents your speciﬁc Lambda function. The following example shows a trace with these 
two segments. Both are named my-function, but one has an origin of AWS::Lambda  and the other has 
origin AWS::Lambda::Function .
This example expands the function segment to show its three subsegments:
•Initialization  – Represents time spent loading your function and running initialization code (p. 13). 
This subsegment only appears for the ﬁrst event that each instance of your function processes.
•Invocation – Represents the time spent running your handler code.
•Overhead – Represents the time the Lambda runtime spends preparing to handle the next event.
You can also instrument HTTP clients, record SQL queries, and create custom subsegments with 
annotations and metadata. For more information, see the AWS X-Ray SDK for .NET in the AWS X-Ray 
Developer Guide .
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
596AWS Lambda Developer Guide
Native AOT compilation
.NET functions with native AOT compilation
.NET 7 supports native ahead-of-time (AOT) compilation. With native AOT, you can compile your Lambda 
function code to a native runtime format, which removes the need to compile .NET code at runtime. 
Native AOT compilation can reduce the cold start time for Lambda functions that you write in .NET. For 
more information, see Building serverless .NET applications on AWS Lambda using .NET 7  on the AWS 
Compute Blog.
Sections
•Limitations  (p. 597)
•Prerequisites (p. 597)
•Lambda runtime  (p. 598)
•Set up your project (p. 598)
•Edit your Lambda function code (p. 598)
•Deploy your Lambda function (p. 598)
•Add support for complex types (p. 598)
•Troubleshooting (p. 599)
Limitations
There are limitations to functionality that you can include in native AOT functions. For more information, 
see Limitations of Native AOT deployment on the Microsoft Learn website.
Prerequisites
Docker
You must compile your function with native AOT on the same operating system that your code will 
run on. As a result, on any operating system other than Amazon Linux 2, you need Docker to develop 
Lambda functions that use native AOT.
.NET 7 SDK
Native AOT compilation is a feature of .NET 7. You must install the .NET 7 SDK  on your build 
machine, not only the runtime.
Amazon.Lambda.Tools
To create your Lambda functions, use the Amazon.Lambda.Tools .NET Core global tool. The current 
version of the .NET Core global tool for Lambda supports using Docker for native AOT. To install 
Amazon.Lambda.Tools, run the following command:
dotnet tool install -g Amazon.Lambda.Tools
For more information about the Amazon.Lambda.Tools .NET Core global tool, see the AWS 
Extensions for .NET CLI repository on GitHub.
Amazon.Lambda.Templates
To generate your Lambda function code, use the Amazon.Lambda.Templates NuGet package. To 
install this template package, run the following command:
dotnet new install Amazon.Lambda.Templates
597AWS Lambda Developer Guide
Lambda runtime
Lambda runtime
Use the provided.al2  custom runtime with the x86_64 architecture to deploy a Lambda function 
that you build with native AOT compilation. When you use a .NET Lambda runtime, your application 
is compiled into Intermediate Language (IL) code. At runtime, the just-in-time (JIT) compiler takes the 
IL code and compiles it into machine code as needed. With a Lambda function that is compiled ahead 
of time with native AOT, the runtime environment doesn't include the .NET SDK or .NET runtime. You 
compile your code into machine code before it runs.
Set up your project
Use the .NET Core global tool for Lambda to create your new environment. To initialize your project, run 
the following command:
dotnet new lambda.NativeAOT
Edit your Lambda function code
The .NET Core global tool for Lambda generates a basic Lambda function that accepts a String
and returns a String. Edit the function code as required for your use case. For how to change the 
parameters and return types of your function, see the section called “Add support for complex 
types” (p. 598).
Deploy your Lambda function
If you're using Windows or macOS, make sure that Docker is running.
Then, to compile and deploy your Lambda function, run the following command:
dotnet lambda deploy-function
The deploy-function  process automatically downloads a Docker image of Amazon Linux 2 to perform 
the native AOT compilation for your function. After this container image has downloaded, the deploy 
process builds your function and then creates a .zip ﬁle that gets deployed into your AWS account.
Add support for complex types
The default Lambda function provides a basic starting point of a String  parameter and a String
return type. To accept or return complex types, update your code to include functionality that generates 
serialization code at compile time, rather than at runtime.
Add more JsonSerializable attributes to your custom serializer object deﬁnition as needed.
API Gateway example
For example, to use Amazon API Gateway events, add a reference to the NuGet package
Amazon.Lambda.ApiGatewayEvents . Then, add the following using statement to your Lambda 
function source code:
using Amazon.Lambda.APIGatewayEvents;
Add the following attributes to your class deﬁnition of your custom serializer:
598AWS Lambda Developer Guide
Troubleshooting
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyRequest))]
[JsonSerializable(typeof(APIGatewayHttpApiV2ProxyResponse))]
Update your function signature to the following:
public static async Task<APIGatewayHttpApiV2ProxyResponse> 
 FunctionHandler(APIGatewayHttpApiV2ProxyRequest input, ILambdaContext context)
Troubleshooting
Error: Cross-OS native compilation is not supported.
Your version of the Amazon.Lambda.Tools .NET Core global tool is out of date. Update to the latest 
version and try again.
Docker: image operating system "linux" cannot be used on this platform.
Docker on your system is conﬁgured to use Windows containers. Swap to Linux containers to run the 
native AOT build environment.
Unhandled Exception: System.ApplicationException: The serializer 
NativeAoT.MyCustomJsonSerializerContext is missing a constructor that takes in 
JsonSerializerOptions object
If you encounter this error when you invoke your Lambda function, add an rd.xml ﬁle to your 
project, and then redeploy.
For more information about common errors, see the AWS NativeAOT for .NET repository on GitHub.
599AWS Lambda Developer Guide
Building Lambda functions with 
PowerShell
The following sections explain how common programming patterns and core concepts apply when you 
author Lambda function code in PowerShell.
Lambda provides the following sample applications for PowerShell:
•blank-powershell – A PowerShell function that shows the use of logging, environment variables, and 
the AWS SDK.
Before you get started, you must ﬁrst set up a PowerShell development environment. For instructions on 
how to do this, see Setting Up a PowerShell Development Environment (p. 601).
To learn about how to use the AWSLambdaPSCore module to download sample PowerShell projects 
from templates, create PowerShell deployment packages, and deploy PowerShell functions to the AWS 
Cloud, see Deploy PowerShell Lambda functions with .zip ﬁle archives (p. 602).
Lambda provides the following runtimes for .NET languages:
.NET
Name Identiﬁer Operating system Architectures Deprecation 
(Phase 1)
.NET 7 (container 
only)dotnet7 Amazon Linux 2 x86_64, arm64 May 14, 2024
.NET 6 dotnet6 Amazon Linux 2 x86_64, arm64
Topics
•Setting Up a PowerShell Development Environment (p. 601)
•Deploy PowerShell Lambda functions with .zip ﬁle archives (p. 602)
•AWS Lambda function handler in PowerShell (p. 604)
•AWS Lambda context object in PowerShell (p. 605)
•AWS Lambda function logging in PowerShell (p. 606)
•AWS Lambda function errors in PowerShell (p. 611)
600AWS Lambda Developer Guide
Development Environment
Setting Up a PowerShell Development 
Environment
Lambda provides a set of tools and libraries for the PowerShell runtime. For installation instructions, see
Lambda tools for PowerShell on GitHub.
The AWSLambdaPSCore module includes the following cmdlets to help author and publish PowerShell 
Lambda functions:
•Get-AWSPowerShellLambdaTemplate – Returns a list of getting started templates.
•New-AWSPowerShellLambda – Creates an initial PowerShell script based on a template.
•Publish-AWSPowerShellLambda – Publishes a given PowerShell script to Lambda.
•New-AWSPowerShellLambdaPackage – Creates a Lambda deployment package that you can use in a 
CI/CD system for deployment.
601AWS Lambda Developer Guide
Deployment package
Deploy PowerShell Lambda functions with .zip ﬁle 
archives
A deployment package for the PowerShell runtime contains your PowerShell script, PowerShell modules 
that are required for your PowerShell script, and the assemblies needed to host PowerShell Core.
Creating the Lambda function
To get started writing and invoking a PowerShell script with Lambda, you can use the New-
AWSPowerShellLambda  cmdlet to create a starter script based on a template. You can use the
Publish-AWSPowerShellLambda  cmdlet to deploy your script to Lambda. Then you can test your 
script either through the command line or the Lambda console.
To create a new PowerShell script, upload it, and test it, do the following:
1. To view the list of available templates, run the following command:
PS C:\> Get-AWSPowerShellLambdaTemplate
Template               Description
--------               -----------
Basic                  Bare bones script
CodeCommitTrigger      Script to process AWS CodeCommit Triggers
...
2. To create a sample script based on the Basic template, run the following command:
New-AWSPowerShellLambda -ScriptName MyFirstPSScript -Template Basic
A new ﬁle named MyFirstPSScript.ps1  is created in a new subdirectory of the current directory. 
The name of the directory is based on the -ScriptName  parameter. You can use the -Directory
parameter to choose an alternative directory.
You can see that the new ﬁle has the following contents:
# PowerShell script file to run as a Lambda function
#  
# When executing in Lambda the following variables are predefined.
#   $LambdaInput - A PSObject that contains the Lambda function input data.
#   $LambdaContext - An Amazon.Lambda.Core.ILambdaContext object that contains 
 information about the currently running Lambda environment.
#
# The last item in the PowerShell pipeline is returned as the result of the Lambda 
 function.
#
# To include PowerShell modules with your Lambda function, like the 
 AWSPowerShell.NetCore module, add a "#Requires" statement  
# indicating the module and version. 
                 
#Requires -Modules @{ModuleName='AWSPowerShell.NetCore';ModuleVersion='3.3.618.0'}
# Uncomment to send the input to CloudWatch Logs
# Write-Host (ConvertTo-Json -InputObject $LambdaInput -Compress -Depth 5)
3. To see how log messages from your PowerShell script are sent to Amazon CloudWatch Logs, 
uncomment the Write-Host  line of the sample script.
602AWS Lambda Developer Guide
Creating a Lambda function
To demonstrate how you can return data back from your Lambda functions, add a new line at the 
end of the script with $PSVersionTable . This adds the $PSVersionTable  to the PowerShell 
pipeline. After the PowerShell script is complete, the last object in the PowerShell pipeline is the 
return data for the Lambda function. $PSVersionTable  is a PowerShell global variable that also 
provides information about the running environment.
After making these changes, the last two lines of the sample script look like this:
Write-Host (ConvertTo-Json -InputObject $LambdaInput -Compress -Depth 5)
$PSVersionTable
4. After editing the MyFirstPSScript.ps1  ﬁle, change the directory to the script's location. Then 
run the following command to publish the script to Lambda:
Publish-AWSPowerShellLambda -ScriptPath .\MyFirstPSScript.ps1 -Name  MyFirstPSScript -
Region us-east-2
Note that the -Name parameter speciﬁes the Lambda function name, which appears in the Lambda 
console. You can use this function to invoke your script manually.
5. Invoke your function using the AWS Command Line Interface (AWS CLI) invoke command.
> aws lambda invoke --function-name MyFirstPSScript out
603AWS Lambda Developer Guide
Handler
AWS Lambda function handler in PowerShell
When a Lambda function is invoked, the Lambda handler invokes the PowerShell script.
When the PowerShell script is invoked, the following variables are predeﬁned:
•$LambdaInput  – A PSObject that contains the input to the handler. This input can be event data 
(published by an event source) or custom input that you provide, such as a string or any custom data 
object.
•$LambdaContext  – An Amazon.Lambda.Core.ILambdaContext object that you can use to access 
information about the current invocation—such as the name of the current function, the memory 
limit, execution time remaining, and logging.
For example, consider the following PowerShell example code.
#Requires -Modules @{ModuleName='AWSPowerShell.NetCore';ModuleVersion='3.3.618.0'}
Write-Host 'Function Name:' $LambdaContext.FunctionName
This script returns the FunctionName property that's obtained from the $LambdaContext variable.
Note
You're required to use the #Requires  statement within your PowerShell scripts to indicate 
the modules that your scripts depend on. This statement performs two important tasks. 1) 
It communicates to other developers which modules the script uses, and 2) it identiﬁes the 
dependent modules that AWS PowerShell tools need to package with the script, as part of the 
deployment. For more information about the #Requires  statement in PowerShell, see  About 
requires. For more information about PowerShell deployment packages, see Deploy PowerShell 
Lambda functions with .zip ﬁle archives (p. 602).
When your PowerShell Lambda function uses the AWS PowerShell cmdlets, be sure to set a
#Requires  statement that references the AWSPowerShell.NetCore  module, which supports 
PowerShell Core—and not the AWSPowerShell  module, which only supports Windows 
PowerShell. Also, be sure to use version 3.3.270.0 or newer of AWSPowerShell.NetCore  which 
optimizes the cmdlet import process. If you use an older version, you'll experience longer cold 
starts. For more information, see AWS Tools for PowerShell.
Returning data
Some Lambda invocations are meant to return data back to their caller. For example, if an invocation 
was in response to a web request coming from API Gateway, then our Lambda function needs to return 
back the response. For PowerShell Lambda, the last object that's added to the PowerShell pipeline is the 
return data from the Lambda invocation. If the object is a string, the data is returned as is. Otherwise the 
object is converted to JSON by using the ConvertTo-Json  cmdlet.
For example, consider the following PowerShell statement, which adds $PSVersionTable  to the 
PowerShell pipeline:
$PSVersionTable
After the PowerShell script is ﬁnished, the last object in the PowerShell pipeline is the return data for 
the Lambda function. $PSVersionTable  is a PowerShell global variable that also provides information 
about the running environment.
604AWS Lambda Developer Guide
Context
AWS Lambda context object in PowerShell
When Lambda runs your function, it passes context information by making a $LambdaContext  variable 
available to the handler  (p. 604). This variable provides methods and properties with information about 
the invocation, function, and execution environment.
Context properties
•FunctionName  – The name of the Lambda function.
•FunctionVersion  – The version (p. 108) of the function.
•InvokedFunctionArn  – The Amazon Resource Name (ARN) that's used to invoke the function. 
Indicates if the invoker speciﬁed a version number or alias.
•MemoryLimitInMB  – The amount of memory that's allocated for the function.
•AwsRequestId  – The identiﬁer of the invocation request.
•LogGroupName  – The log group for the function.
•LogStreamName  – The log stream for the function instance.
•RemainingTime  – The number of milliseconds left before the execution times out.
•Identity  – (mobile apps) Information about the Amazon Cognito identity that authorized the 
request.
•ClientContext  – (mobile apps) Client context that's provided to Lambda by the client application.
•Logger  – The logger object (p. 606) for the function.
The following PowerShell code snippet shows a simple handler function that prints some of the context 
information.
#Requires -Modules @{ModuleName='AWSPowerShell.NetCore';ModuleVersion='3.3.618.0'}
Write-Host 'Function name:' $LambdaContext.FunctionName
Write-Host 'Remaining milliseconds:' $LambdaContext.RemainingTime.TotalMilliseconds
Write-Host 'Log group name:' $LambdaContext.LogGroupName
Write-Host 'Log stream name:' $LambdaContext.LogStreamName
605AWS Lambda Developer Guide
Logging
AWS Lambda function logging in PowerShell
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
This page describes how to produce log output from your Lambda function's code, or access logs using 
the AWS Command Line Interface, the Lambda console, or the CloudWatch console.
Sections
•Creating a function that returns logs (p. 606)
•Using the Lambda console (p. 607)
•Using the CloudWatch console (p. 607)
•Using the AWS Command Line Interface (AWS CLI) (p. 608)
•Deleting logs  (p. 610)
Creating a function that returns logs
To output logs from your function code, you can use cmdlets on Microsoft.PowerShell.Utility , or any 
logging module that writes to stdout  or stderr. The following example uses Write-Host .
Example function/Handler.ps1 – Logging
#Requires -Modules @{ModuleName='AWSPowerShell.NetCore';ModuleVersion='3.3.618.0'}
Write-Host `## Environment variables
Write-Host AWS_LAMBDA_FUNCTION_VERSION=$Env:AWS_LAMBDA_FUNCTION_VERSION
Write-Host AWS_LAMBDA_LOG_GROUP_NAME=$Env:AWS_LAMBDA_LOG_GROUP_NAME
Write-Host AWS_LAMBDA_LOG_STREAM_NAME=$Env:AWS_LAMBDA_LOG_STREAM_NAME
Write-Host AWS_EXECUTION_ENV=$Env:AWS_EXECUTION_ENV
Write-Host AWS_LAMBDA_FUNCTION_NAME=$Env:AWS_LAMBDA_FUNCTION_NAME
Write-Host PATH=$Env:PATH
Write-Host `## Event
Write-Host (ConvertTo-Json -InputObject $LambdaInput -Compress -Depth 3)
Example log format
START RequestId: 56639408-xmpl-435f-9041-ac47ae25ceed Version: $LATEST
Importing module ./Modules/AWSPowerShell.NetCore/3.3.618.0/AWSPowerShell.NetCore.psd1
[Information] - ## Environment variables
[Information] - AWS_LAMBDA_FUNCTION_VERSION=$LATEST
[Information] - AWS_LAMBDA_LOG_GROUP_NAME=/aws/lambda/blank-powershell-
function-18CIXMPLHFAJJ
[Information] - AWS_LAMBDA_LOG_STREAM_NAME=2020/04/01/
[$LATEST]53c5xmpl52d64ed3a744724d9c201089
[Information] - AWS_EXECUTION_ENV=AWS_Lambda_dotnet6_powershell_1.0.0
[Information] - AWS_LAMBDA_FUNCTION_NAME=blank-powershell-function-18CIXMPLHFAJJ
[Information] - PATH=/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin
[Information] - ## Event
[Information] -  
{ 
    "Records": [ 
        { 
            "messageId": "19dd0b57-b21e-4ac1-bd88-01bbb068cb78", 
606AWS Lambda Developer Guide
Using the Lambda console
            "receiptHandle": "MessageReceiptHandle", 
            "body": "Hello from SQS!", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1523232000000", 
                "SenderId": "123456789012", 
                "ApproximateFirstReceiveTimestamp": "1523232000001" 
            }, 
            ...
END RequestId: 56639408-xmpl-435f-9041-ac47ae25ceed
REPORT RequestId: 56639408-xmpl-435f-9041-ac47ae25ceed Duration: 3906.38 ms Billed 
 Duration: 4000 ms Memory Size: 512 MB Max Memory Used: 367 MB Init Duration: 5960.19 ms  
XRAY TraceId: 1-5e843da6-733cxmple7d0c3c020510040 SegmentId: 3913xmpl20999446 Sampled: true
The .NET runtime logs the START , END, and REPORT lines for each invocation. The report line provides 
the following details.
Report Log
•RequestId – The unique request ID for the invocation.
•Duration  – The amount of time that your function's handler method spent processing the event.
•Billed Duration – The amount of time billed for the invocation.
•Memory Size – The amount of memory allocated to the function.
•Max Memory Used – The amount of memory used by the function.
•Init Duration  – For the ﬁrst request served, the amount of time it took the runtime to load the 
function and run code outside of the handler method.
•XRAY TraceId – For traced requests, the AWS X-Ray trace ID (p. 973).
•SegmentId  – For traced requests, the X-Ray segment ID.
•Sampled – For traced requests, the sampling result.
Using the Lambda console
You can use the Lambda console to view log output after you invoke a Lambda function. For more 
information, see Accessing Amazon CloudWatch logs for AWS Lambda (p. 969).
Using the CloudWatch console
You can use the Amazon CloudWatch console to view logs for all Lambda function invocations.
To view logs on the CloudWatch console
1. Open the Log groups page on the CloudWatch console.
2. Choose the log group for your function (/aws/lambda/your-function-name ).
3. Choose a log stream.
Each log stream corresponds to an instance of your function (p. 14). A log stream appears when you 
update your Lambda function, and when additional instances are created to handle multiple concurrent 
invocations. To ﬁnd logs for a speciﬁc invocation, we recommend instrumenting your function with AWS 
X-Ray. X-Ray records details about the request and the log stream in the trace.
To use a sample application that correlates logs and traces with X-Ray, see Error processor sample 
application for AWS Lambda (p. 1121 ).
607AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
608AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
609AWS Lambda Developer Guide
Deleting logs
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Deleting logs
Log groups aren't deleted automatically when you delete a function. To avoid storing logs indeﬁnitely, 
delete the log group, or conﬁgure a retention period after which logs are deleted automatically.
610AWS Lambda Developer Guide
Errors
AWS Lambda function errors in PowerShell
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output.
This page describes how to view Lambda function invocation errors for the PowerShell runtime using the 
Lambda console and the AWS CLI.
Sections
•Syntax (p. 611)
•How it works (p. 612)
•Using the Lambda console (p. 612)
•Using the AWS Command Line Interface (AWS CLI) (p. 613)
•Error handling in other AWS services (p. 613)
•What's next? (p. 614)
Syntax
Consider the following PowerShell script example statement:
throw 'The Account is not found'
When you invoke this Lambda function, it throws a terminating error, and AWS Lambda returns the 
following error message:
{ 
  "errorMessage": "The Account is not found", 
  "errorType": "RuntimeException"
}
Note the errorType  is RuntimeException , which is the default exception thrown by PowerShell. You 
can use custom error types by throwing the error like this:
throw @{'Exception'='AccountNotFound';'Message'='The Account is not found'}
The error message is serialized with errorType  set to AccountNotFound :
{ 
  "errorMessage": "The Account is not found", 
  "errorType": "AccountNotFound"
}
If you don't need an error message, you can throw a string in the format of an error code. The error code 
format requires that the string starts with a character and only contain letters and digits afterwards, with 
no spaces or symbols.
For example, if your Lambda function contains the following:
throw 'AccountNotFound'
The error is serialized like this:
611AWS Lambda Developer Guide
How it works
{ 
  "errorMessage": "AccountNotFound", 
  "errorType": "AccountNotFound"
}
How it works
When you invoke a Lambda function, Lambda receives the invocation request and validates the 
permissions in your execution role, veriﬁes that the event document is a valid JSON document, and 
checks parameter values.
If the request passes validation, Lambda sends the request to a function instance. The Lambda 
runtime  (p. 41) environment converts the event document into an object, and passes it to your function 
handler.
If Lambda encounters an error, it returns an exception type, message, and HTTP status code that 
indicates the cause of the error. The client or service that invoked the Lambda function can handle the 
error programmatically, or pass it along to an end user. The correct error handling behavior depends on 
the type of application, the audience, and the source of the error.
The following list describes the range of status codes you can receive from Lambda.
2xx
A 2xx series error with a X-Amz-Function-Error  header in the response indicates a Lambda 
runtime or function error. A 2xx series status code indicates that Lambda accepted the request, but 
instead of an error code, Lambda indicates the error by including the X-Amz-Function-Error
header in the response.
4xx
A 4xx series error indicates an error that the invoking client or service can ﬁx by modifying the 
request, requesting permission, or by retrying the request. 4xx series errors other than 429
generally indicate an error with the request.
5xx
A 5xx series error indicates an issue with Lambda, or an issue with the function's conﬁguration or 
resources. 5xx series errors can indicate a temporary condition that can be resolved without any 
action by the user. These issues can't be addressed by the invoking client or service, but a Lambda 
function's owner may be able to ﬁx the issue.
For a complete list of invocation errors, see InvokeFunction errors (p. 1401 ).
Using the Lambda console
You can invoke your function on the Lambda console by conﬁguring a test event and viewing the output. 
The output is captured in the function's execution logs and, when active tracing (p. 973) is enabled, in 
AWS X-Ray.
To invoke a function on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose the function to test, and choose Test.
3. Under Test event, select New event.
4. Select a Template.
612AWS Lambda Developer Guide
Using the AWS Command Line Interface (AWS CLI)
5. For Name , enter a name for the test. In the text entry box, enter the JSON test event.
6. Choose Save changes.
7. Choose Test.
The Lambda console invokes your function synchronously (p. 139) and displays the result. To see the 
response, logs, and other information, expand the Details  section.
Using the AWS Command Line Interface (AWS CLI)
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
When you invoke a Lambda function in the AWS CLI, the AWS CLI splits the response into two 
documents. The AWS CLI response is displayed in your command prompt. If an error has occurred, the 
response contains a FunctionError  ﬁeld. The invocation response or error returned by the function is 
written to an output ﬁle. For example, output.json  or output.txt .
The following invoke command example demonstrates how to invoke a function and write the invocation 
response to an output.txt  ﬁle.
aws lambda invoke   \ 
  --function-name my-function   \ 
      --cli-binary-format raw-in-base64-out  \ 
          --payload '{"key1": "value1", "key2": "value2", "key3": "value3"}' output.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the AWS CLI response in your command prompt:
{ 
    "StatusCode": 200, 
    "FunctionError": "Unhandled", 
    "ExecutedVersion": "$LATEST"
}
You should see the function invocation response in the output.txt  ﬁle. In the same command prompt, 
you can also view the output in your command prompt using:
cat output.txt
You should see the invocation response in your command prompt.
Lambda also records up to 256 KB of the error object in the function's logs. For more information, see
AWS Lambda function logging in PowerShell (p. 606).
Error handling in other AWS services
When another AWS service invokes your function, the service chooses the invocation type and retry 
behavior. AWS services can invoke your function on a schedule, in response to a lifecycle event on a 
613AWS Lambda Developer Guide
What's next?
resource, or to serve a request from a user. Some services invoke functions asynchronously and let 
Lambda handle errors, while others retry or pass errors back to the user.
For example, API Gateway treats all invocation and function errors as internal errors. If the Lambda API 
rejects the invocation request, API Gateway returns a 500 error code. If the function runs but returns an 
error, or returns a response in the wrong format, API Gateway returns a 502 error code. To customize the 
error response, you must catch errors in your code and format a response in the required format.
We recommend using AWS X-Ray to determine the source of an error and its cause. X-Ray allows you to 
ﬁnd out which component encountered an error, and see details about the errors. The following example 
shows a function error that resulted in a 502 response from API Gateway.
For more information, see Using AWS Lambda with AWS X-Ray (p. 973).
What's next?
•Learn how to show logging events for your Lambda function on the the section called 
“Logging”  (p. 606) page.
614AWS Lambda Developer Guide
Building Lambda functions with Rust
Because Rust compiles to native code, you don't need a dedicated runtime to run Rust code on Lambda. 
Instead, use the Rust runtime client  to build your project locally, and then deploy it to Lambda using 
the provided.al2  runtime. When you use provided.al2 , Lambda automatically keeps the operating 
system up to date with the latest patches.
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
Rust
Name Identiﬁer Operating system Architectures
Rust provided.al2 Amazon Linux x86_64, arm64
Tools and libraries for Rust
•AWS SDK for Rust: The AWS SDK for Rust is in developer preview release. Do not use it in production as 
it is subject to breaking changes.
•Rust runtime client for Lambda : The Rust runtime client is an experimental package. It is subject to 
breaking changes and not recommended for production.
•Cargo Lambda: This library provides a command line application to work with Lambda functions built 
with Rust.
•Lambda HTTP: This library provides a wrapper to work with HTTP events.
•Lambda Extension: This library provides support to write Lambda Extensions with Rust.
•AWS Lambda Events: This library provides type deﬁnitions for common event source integrations.
Sample Lambda applications for Rust
•Basic Lambda function: A Rust function that shows how to process basic events.
•Lambda function with error handling: A Rust function that shows how to handle custom Rust errors in 
Lambda.
•Lambda function with shared resources: A Rust project that initializes shared resources before creating 
the Lambda function.
•Lambda HTTP events: A Rust function that handles HTTP events.
•Lambda HTTP events with CORS headers: A Rust function that uses Tower to inject CORS headers.
•Lambda REST API : A REST API that uses Axum and Diesel to connect to a PostgreSQL database.
•Serverless Rust demo: A Rust project that shows the use of Lambda's Rust libraries, logging, 
environment variables, and the AWS SDK.
•Basic Lambda Extension: A Rust extension that shows how to process basic extension events.
•Lambda Logs Amazon Kinesis Data Firehose Extension: A Rust extension that shows how to send 
Lambda logs to Kinesis Data Firehose.
Topics
•Lambda function handler in Rust (p. 617)
•Lambda context object in Rust (p. 619)
615AWS Lambda Developer Guide
•Processing HTTP events with Rust (p. 620)
•Deploy Rust Lambda functions with .zip ﬁle archives (p. 622)
•Lambda function logging in Rust (p. 625)
•Lambda function errors in Rust (p. 627)
616AWS Lambda Developer Guide
Handler
Lambda function handler in Rust
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
Write your Lambda function code as a Rust executable. Implement the handler function code and a main 
function and include the following:
•The lambda_runtime  crate from crates.io, which implements the Lambda programming model for 
Rust.
•Include Tokio in your dependencies. The Rust runtime client for Lambda  uses Tokio to handle 
asynchronous calls.
Example — Rust handler that processes JSON events
The following example uses the serde_json crate to process basic JSON events:
use lambda_runtime::{service_fn, LambdaEvent, Error};
use serde_json::{json, Value};
async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error> { 
 let payload = event.payload; 
 let first_name = payload["firstName"].as_str().unwrap_or("world"); 
 Ok(json!({ "message": format!("Hello, {first_name}!") }))
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
 lambda_runtime::run(service_fn(handler)).await
}
Note the following:
•use: Imports the libraries that your Lambda function requires.
•async fn main : The entry point that runs the Lambda function code. The Rust runtime client uses
Tokio as an async runtime, so you must annotate the main function with #[tokio::main] .
•async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error>: This is the 
Lambda handler signature. It includes the code that runs when the function is invoked.
•LambdaEvent<Value> : This is a generic type that describes the event received by the Lambda 
runtime as well as the Lambda function context (p. 619).
•Result<Value, Error> : The function returns a Resulttype. If the function is successful, the 
result is a JSON value. If the function is not successful, the result is an error.
Using shared state
You can declare shared variables that are independent of your Lambda function's handler code. These 
variables can help you load state information during the Init phase  (p. 15), before your function receives 
any events.
617AWS Lambda Developer Guide
Using shared state
Example — Share Amazon S3 client across function instances
Note the following:
•use aws_sdk_s3::Client : This example requires you to add aws-sdk-s3 = "0.26.0"  to the list 
of dependencies in your Cargo.toml  ﬁle.
•aws_config::from_env : This example requires you to add aws-config = "0.55.1"  to the list of 
dependencies in your Cargo.toml  ﬁle.
use aws_sdk_s3::Client;
use lambda_runtime::{service_fn, Error, LambdaEvent};
use serde::{Deserialize, Serialize};
#[derive(Deserialize)]
struct Request { 
    bucket: String,
}
#[derive(Serialize)]
struct Response { 
    keys: Vec<String>,
}
async fn handler(client: &Client, event: LambdaEvent<Request>) -> Result<Response, Error> { 
    let bucket = event.payload.bucket; 
    let objects = client.list_objects_v2().bucket(bucket).send().await?; 
    let keys = objects 
        .contents() 
        .map(|s| s.iter().flat_map(|o| o.key().map(String::from)).collect()) 
        .unwrap_or_default(); 
    Ok(Response { keys })
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    let shared_config = aws_config::from_env().load().await; 
    let client = Client::new(&shared_config); 
    let shared_client = &client; 
    lambda_runtime::run(service_fn(move |event: LambdaEvent<Request>| async move { 
        handler(&shared_client, event).await 
    })) 
    .await
}
618AWS Lambda Developer Guide
Context
Lambda context object in Rust
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
When Lambda runs your function, it adds a context object to the LambdaEvent that the handler  (p. 617)
receives. This object provides properties with information about the invocation, function, and execution 
environment.
Context properties
•request_id : The AWS request ID generated by the Lambda service.
•deadline : The execution deadline for the current invocation in milliseconds.
•invoked_function_arn : The Amazon Resource Name (ARN) of the Lambda function being invoked.
•xray_trace_id : The AWS X-Ray trace ID for the current invocation.
•client_content : The client context object sent by the AWS mobile SDK. This ﬁeld is empty unless 
the function is invoked using an AWS mobile SDK.
•identity : The Amazon Cognito identity that invoked the function. This ﬁeld is empty unless the 
invocation request to the Lambda APIs was made using AWS credentials issued by Amazon Cognito 
identity pools.
•env_config : The Lambda function conﬁguration from the local environment variables. This property 
includes information such as the function name, memory allocation, version, and log streams.
Accessing invoke context information
Lambda functions have access to metadata about their environment and the invocation request. The
LambaEvent  object that your function handler receives includes the context  metadata:
use lambda_runtime::{service_fn, LambdaEvent, Error};
use serde_json::{json, Value};
async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error> { 
    let invoked_function_arn = event.context.invoked_function_arn; 
    Ok(json!({ "message": format!("Hello, this is function {invoked_function_arn}!") }))
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    lambda_runtime::run(service_fn(handler)).await
}
619AWS Lambda Developer Guide
HTTP events
Processing HTTP events with Rust
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
Amazon API Gateway APIs, Application Load Balancers, and Lambda function URLs (p. 189) can send 
HTTP events to Lambda. You can use the aws_lambda_events crate from crates.io to process events from 
these sources.
Example — Handle API Gateway proxy request
Note the following:
•use aws_lambda_events::apigw::{ApiGatewayProxyRequest, 
ApiGatewayProxyResponse} : The aws_lambda_events crate includes many Lambda events. 
To reduce compilation time, use feature ﬂags to activate the events you need. Example:
aws_lambda_events = { version = "0.8.3", default-features = false, features = 
["apigw"] } .
•use http::HeaderMap : This import requires you to add the http crate to your dependencies.
use aws_lambda_events::apigw::{ApiGatewayProxyRequest, ApiGatewayProxyResponse};
use http::HeaderMap;
use lambda_runtime::{service_fn, Error, LambdaEvent};
async fn handler( 
    event: LambdaEvent<ApiGatewayProxyRequest>,
) -> Result<ApiGatewayProxyResponse, Error> { 
    let mut headers = HeaderMap::new(); 
    headers.insert("content-type", "text/html".parse().unwrap()); 
    let resp = ApiGatewayProxyResponse { 
        status_code: 200, 
        multi_value_headers: headers.clone(), 
        is_base64_encoded: Some(false), 
        body: Some("Hello AWS Lambda HTTP request".into()), 
        headers, 
    }; 
    Ok(resp)
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    lambda_runtime::run(service_fn(handler)).await
}
The Rust runtime client for Lambda  also provides an abstraction over these event types that allows you 
to work with native HTTP types, regardless of which service sends the events. The following code is 
equivalent to the previous example, and it works out of the box with Lambda function URLs, Application 
Load Balancers, and API Gateway.
Note
The lambda_http crate uses the lambda_runtime  crate underneath. You don't have to import
lambda_runtime  separately.
Example — Handle HTTP requests
use lambda_http::{service_fn, Error, IntoResponse, Request, RequestExt, Response};
async fn handler(event: Request) -> Result<impl IntoResponse, Error> { 
620AWS Lambda Developer Guide
HTTP events
    let resp = Response::builder() 
        .status(200) 
        .header("content-type", "text/html") 
        .body("Hello AWS Lambda HTTP request") 
        .map_err(Box::new)?; 
    Ok(resp)
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    lambda_http::run(service_fn(handler)).await
}
For another example of how to use lambda_http , see the http-axum code sample on the AWS Labs 
GitHub repository.
Sample HTTP Lambda events for Rust
•Lambda HTTP events: A Rust function that handles HTTP events.
•Lambda HTTP events with CORS headers: A Rust function that uses Tower to inject CORS headers.
•Lambda HTTP events with shared resources: A Rust function that uses shared resources initialized 
before the function handler is created.
621AWS Lambda Developer Guide
Deploy .zip ﬁle archives
Deploy Rust Lambda functions with .zip ﬁle 
archives
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
This page describes how to compile your Rust function, and then deploy the compiled binary to AWS 
Lambda using Cargo Lambda. It also shows how to deploy the compiled binary with the AWS Command 
Line Interface and the AWS Serverless Application Model CLI.
Sections
•Prerequisites (p. 622)
•Building Rust functions on macOS, Windows, or Linux (p. 622)
•Deploying the Rust function binary with Cargo Lambda (p. 623)
•Invoking your Rust function with Cargo Lambda (p. 624)
Prerequisites
•Rust
•AWS Command Line Interface (AWS CLI) version 2
Building Rust functions on macOS, Windows, or Linux
The following steps demonstrate how to create the project for your ﬁrst Lambda function with Rust and 
compile it with Cargo Lambda.
1. Install Cargo Lambda, a Cargo subcommand, that compiles Rust functions for Lambda on macOS, 
Windows, and Linux.
To install Cargo Lambda on any system that has Python 3 installed, use pip:
pip3 install cargo-lambda
To install Cargo Lambda on macOS or Linux, use Homebrew:
brew tap cargo-lambda/cargo-lambda
brew install cargo-lambda
To install Cargo Lambda on Windows, use Scoop:
scoop bucket add cargo-lambda
scoop install cargo-lambda/cargo-lambda
For other options, see Installation  in the Cargo Lambda documentation.
2. Create the package structure. This command creates some basic function code in src/main.rs . You 
can use this code for testing or replace it with your own.
cargo lambda new my-function
622AWS Lambda Developer Guide
Deploying the function
3. Inside the package's root directory, run the build  subcommand to compile the code in your function.
cargo lambda build --release
(Optional) If you want to use AWS Graviton2 on Lambda, add the --arm64 ﬂag to compile your 
code for ARM CPUs.
cargo lambda build --release --arm64
4. Before deploying your Rust function, conﬁgure AWS credentials on your machine.
aws configure
Deploying the Rust function binary with Cargo 
Lambda
Use the deploy subcommand to deploy the compiled binary to Lambda. This command creates an
execution role (p. 913) and then creates the Lambda function. To specify an existing execution role, use 
the --iam-role ﬂag.
cargo lambda deploy my-function
Deploying your Rust function binary with the AWS CLI
You can also deploy your binary with the AWS CLI.
1. Use the build  subcommand to build the .zip deployment package.
cargo lambda build --release --output-format zip
2. Deploy the .zip package to Lambda. For --role, specify the ARN of the execution role.
aws lambda create-function --function-name my-function  \ 
     --runtime provided.al2 \ 
     --role arn:aws:iam::111122223333:role/lambda-role  \ 
     --handler rust.handler \ 
     --zip-file fileb://target/lambda/my-function/bootstrap.zip
Deploying your Rust function binary with the AWS SAM CLI
You can also deploy your binary with the AWS SAM CLI.
1. Create an AWS SAM template with the resource and property deﬁnition. For more information, see
AWS::Serverless::Function in the AWS Serverless Application Model Developer Guide.
Example SAM resource and property deﬁnition for a Rust binary
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: SAM template for Rust binaries
Resources: 
  RustFunction: 
623AWS Lambda Developer Guide
Invoking the function
    Type: AWS::Serverless::Function  
    Properties: 
      CodeUri: target/lambda/my-function/ 
      Handler: rust.handler 
      Runtime: provided.al2
Outputs: 
  RustFunction: 
    Description: "Lambda Function ARN" 
    Value: !GetAtt RustFunction.Arn
2. Use the build  subcommand to compile the function.
cargo lambda build --release
3. Use the sam deploy command to deploy the function to Lambda.
sam deploy --guided
For more information about building Rust functions with the AWS SAM CLI, see Building Rust Lambda 
functions with Cargo Lambda in the AWS Serverless Application Model Developer Guide.
Invoking your Rust function with Cargo Lambda
Use the invoke subcommand to test your function with a payload.
cargo lambda invoke --remote --data-ascii '{"command": "Hello world"}' my-function
Invoking your Rust function with the AWS CLI
You can also use the AWS CLI to invoke the function.
aws lambda invoke --function-name my-function  --cli-binary-format raw-in-base64-out --
payload '{"command": "Hello world"}' /tmp/out.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
624AWS Lambda Developer Guide
Logging
Lambda function logging in Rust
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
AWS Lambda automatically monitors Lambda functions on your behalf and sends logs to Amazon 
CloudWatch. Your Lambda function comes with a CloudWatch Logs log group and a log stream for each 
instance of your function. The Lambda runtime environment sends details about each invocation to 
the log stream, and relays logs and other output from your function's code. For more information, see
Accessing Amazon CloudWatch logs for AWS Lambda (p. 969). This page describes how to produce log 
output from your Lambda function's code.
Creating a function that writes logs
To output logs from your function code, you can use any logging function that writes to stdout  or
stderr , such as the println!  macro. The following example uses println!  to print a message when 
the function handler starts and before it ﬁnishes.
use lambda_runtime::{service_fn, LambdaEvent, Error};
use serde_json::{json, Value};
async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error> { 
    println!("Rust function invoked"); 
    let payload = event.payload; 
    let first_name = payload["firstName"].as_str().unwrap_or("world"); 
    println!("Rust function responds to {}", &first_name); 
    Ok(json!({ "message": format!("Hello, {first_name}!") }))
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    lambda_runtime::run(service_fn(handler)).await
}
Advanced logging with the Tracing crate
Tracing is a framework for instrumenting Rust programs to collect structured, event-based diagnostic 
information. This framework provides utilities to customize logging output levels and formats, like 
creating structured JSON log messages. To use this framework, you must initialize a subscriber  before 
implementing the function handler. Then, you can use tracing macros like debug , info , and error , to 
specify the level of logging that you want for each scenario.
Example — Using the Tracing crate
Note the following:
•tracing_subscriber::fmt().json() : When this option is included, logs are formatted in JSON. 
To use this option, you must include the json feature in the tracing-subscriber  dependency (for 
example,tracing-subscriber = { version = "0.3.11", features = ["json"] } ).
•#[tracing::instrument(skip(event), fields(req_id = 
%event.context.request_id))] : This annotation generates a span every time the handler is 
invoked. The span adds the request ID to each log line.
•{ %first_name } : This construct adds the first_name  ﬁeld to the log line where it's used. The 
value for this ﬁeld corresponds to the variable with the same name.
use lambda_runtime::{service_fn, Error, LambdaEvent};
625AWS Lambda Developer Guide
Advanced logging with the Tracing crate
use serde_json::{json, Value};
#[tracing::instrument(skip(event), fields(req_id = %event.context.request_id))]
async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error> { 
    tracing::info!("Rust function invoked"); 
    let payload = event.payload; 
    let first_name = payload["firstName"].as_str().unwrap_or("world"); 
    tracing::info!({ %first_name }, "Rust function responds to event"); 
    Ok(json!({ "message": format!("Hello, {first_name}!") }))
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    tracing_subscriber::fmt().json() 
        .with_max_level(tracing::Level::INFO) 
        // this needs to be set to remove duplicated information in the log. 
        .with_current_span(false) 
        // this needs to be set to false, otherwise ANSI color codes will 
        // show up in a confusing manner in CloudWatch logs. 
        .with_ansi(false) 
        // disabling time is handy because CloudWatch will add the ingestion time. 
        .without_time() 
        // remove the name of the function from every log entry 
        .with_target(false) 
        .init(); 
    lambda_runtime::run(service_fn(handler)).await
}
When this Rust function is invoked, it prints two log lines similar to the following:
{"level":"INFO","fields":{"message":"Rust function invoked"},"spans":
[{"req_id":"45daaaa7-1a72-470c-9a62-e79860044bb5","name":"handler"}]}
{"level":"INFO","fields":{"message":"Rust function responds to 
 event","first_name":"David"},"spans":[{"req_id":"45daaaa7-1a72-470c-9a62-
e79860044bb5","name":"handler"}]}
626AWS Lambda Developer Guide
Errors
Lambda function errors in Rust
Note
The Rust runtime client  is an experimental package. It is subject to change and intended only for 
evaluation purposes.
When your code raises an error, Lambda generates a JSON representation of the error. This error 
document appears in the invocation log and, for synchronous invocations, in the output. The Rust 
runtime client  also writes the error in the log. The error appears in Amazon CloudWatch Logs by default. 
This page demonstrates how to return errors in your Lambda function's output.
Creating a function that returns errors
The following code sample shows a Lambda function that returns an error. The Rust Runtime handles 
this error directly.
Example
use lambda_runtime::{service_fn, Error, LambdaEvent};
use serde_json::{json, Value};
async fn handler(_event: LambdaEvent<Value>) -> Result<Value, String> { 
    Err("something went wrong!".into())
}
#[tokio::main]
async fn main() -> Result<(), Error> { 
    lambda_runtime::run(service_fn(handler)).await
}
This code returns the following error payload:
{ 
    "errorType": "&alloc::string::String", 
    "errorMessage": "something went wrong!"
}
For a more advanced error handling example, see the sample application  in the AWS Labs GitHub 
repository.
627AWS Lambda Developer Guide
Listing of services and links to more information
Using AWS Lambda with other 
services
AWS Lambda integrates with other AWS services to invoke functions or take other actions. These are 
some common use cases:
•Invoke a function in response to resource lifecycle events, such as with Amazon Simple Storage Service 
(Amazon S3). For more information, see Using AWS Lambda with Amazon S3 (p. 815).
•Respond to incoming HTTP requests. For more information, see Tutorial: Using Lambda with API 
Gateway (p. 640).
•Consume events from a queue. For more information, see Using Lambda with Amazon SQS (p. 875).
•Run a function on a schedule. For more information, see Using AWS Lambda with Amazon EventBridge 
(CloudWatch Events) (p. 663).
Depending on which service you're using with Lambda, the invocation generally works in one of two 
ways. An event drives the invocation or Lambda polls a queue or data stream and invokes the function in 
response to activity in the queue or data stream. Lambda integrates with Amazon Elastic File System and 
AWS X-Ray in a way that doesn't involve invoking functions.
For more information, see Event-driven invocation (p. 630) and Lambda polling  (p. 630). Or, look up 
the service that you want to work with in the following section to ﬁnd a link to information about using 
that service with Lambda.
You can also use Lambda functions to interact programmatically with other AWS services using one of 
the AWS Software Development Kits (SDKs). For example, you can have a Lambda function create an 
Amazon S3 bucket or write data to a DynamoDB table using an API call from within your function. To 
learn more about AWS SDKs, see Tools to build on AWS.
Listing of services and links to more information
Find the service that you want to work with in the following table, to determine which method of 
invocation you should use. Follow the link from the service name to ﬁnd information about how to set 
up the integration between the services. These topics also include example events that you can use to 
test your function.
Tip
Entries in this table are alphabetical by service name, excluding the "Amazon" or "AWS" preﬁx. 
You can also use your browser's search functionality to ﬁnd your service in the list.
Service Method of invocation
Amazon Alexa (p. 633) Event-driven; synchronous invocation
Amazon Managed Streaming for 
Apache Kafka  (p. 789)Lambda polling
Self-managed Apache 
Kafka  (p. 743)Lambda polling
Amazon API Gateway (p. 634) Event-driven; synchronous invocation
AWS CloudFormation (p. 670) Event-driven; asynchronous invocation
628AWS Lambda Developer Guide
Listing of services and links to more information
Service Method of invocation
Amazon CloudFront 
(Lambda@Edge) (p. 673)Event-driven; synchronous invocation
Amazon EventBridge 
(CloudWatch Events) (p. 663)Event-driven; asynchronous invocation
Amazon CloudWatch 
Logs  (p. 669)Event-driven; asynchronous invocation
AWS CodeCommit (p. 675)Event-driven; asynchronous invocation
AWS CodePipeline (p. 676)Event-driven; asynchronous invocation
Amazon Cognito (p. 679)Event-driven; synchronous invocation
AWS Conﬁg (p. 680)Event-driven; asynchronous invocation
Amazon Connect (p. 681)Event-driven; synchronous invocation
Amazon DynamoDB (p. 707) Lambda polling
Amazon Elastic File 
System (p. 738)Special integration
Elastic Load Balancing 
(Application Load 
Balancer) (p. 736)Event-driven; synchronous invocation
AWS IoT (p. 740)Event-driven; asynchronous invocation
AWS IoT Events (p. 741)Event-driven; asynchronous invocation
Amazon Kinesis (p. 756) Lambda polling
Amazon Kinesis Data 
Firehose (p. 755)Event-driven; synchronous invocation
Amazon Lex (p. 778)Event-driven; synchronous invocation
Amazon MQ (p. 780) Lambda polling
Amazon Simple Email 
Service (p. 861)Event-driven; asynchronous invocation
Amazon Simple Notiﬁcation 
Service (p. 863)Event-driven; asynchronous invocation
Amazon Simple Queue 
Service (p. 875)Lambda polling
Amazon Simple Storage Service 
(Amazon S3) (p. 815)Event-driven; asynchronous invocation
Amazon Simple Storage Service 
Batch  (p. 857)Event-driven; synchronous invocation
Secrets Manager (p. 860)Event-driven; synchronous invocation
Amazon VPC Lattice (p. 900)Event-driven; synchronous invocation
629AWS Lambda Developer Guide
Event-driven invocation
Service Method of invocation
AWS X-Ray (p. 973) Special integration
Event-driven invocation
Some services generate events that can invoke your Lambda function. For more information about 
designing these types of architectures , see  Event driven architectures in Serverless Land.
When you implement an event-driven architecture, you grant the event-generating service permission to 
invoke your function in the function's resource-based policy (p. 929). Then you conﬁgure that service to 
generate events that invoke your function.
The events are data structured in JSON format. The JSON structure varies depending on the service that 
generates it and the event type, but they all contain the data that the function needs to process the 
event.
Lambda converts the event document into an object and passes it to your function handler (p. 9). For 
compiled languages, Lambda provides deﬁnitions for event types in a library. For more information, 
see the topic about building functions with your language: Building Lambda functions with C# (p. 556),
Building Lambda functions with Go (p. 512), Building Lambda functions with Java (p. 438), or Building 
Lambda functions with PowerShell (p. 600).
Depending on the service, the event-driven invocation can be synchronous or asynchronous.
•For synchronous invocation, the service that generates the event waits for the response from your 
function. That service deﬁnes the data that the function needs to return in the response. The service 
controls the error strategy, such as whether to retry on errors. For more information, see the section 
called “Synchronous invocation” (p. 139).
•For asynchronous invocation, Lambda queues the event before passing it to your function. When 
Lambda queues the event, it immediately sends a success response to the service that generated 
the event. After the function processes the event, Lambda doesn’t return a response to the event-
generating service. For more information, see the section called “Asynchronous invocation” (p. 142).
For more information about how Lambda manages error handling for synchronously and asychronously 
invoked functions, see the section called “Error handling” (p. 181).
Lambda polling
For services that generate a queue or data stream, you set up an event source mapping (p. 150) in 
Lambda to have Lambda poll the queue or a data stream.
When you implement a Lambda polling architecture, you grant Lambda permission to access the other 
service in the function's execution role (p. 913). Lambda reads data from the other service, creates an 
event, and invokes your function.
630AWS Lambda Developer Guide
Use cases
Common Lambda application types and use cases
Lambda functions and triggers are the core components of building applications on AWS Lambda. A 
Lambda function is the code and runtime that process events, while a trigger is the AWS service or 
application that invokes the function. To illustrate, consider the following scenarios:
•File processing – Suppose you have a photo sharing application. People use your application to upload 
photos, and the application stores these user photos in an Amazon S3 bucket. Then, your application 
creates a thumbnail version of each user's photos and displays them on the user's proﬁle page. In this 
scenario, you may choose to create a Lambda function that creates a thumbnail automatically. Amazon 
S3 is one of the supported AWS event sources that can publish object-created events  and invoke your 
Lambda function. Your Lambda function code can read the photo object from the S3 bucket, create a 
thumbnail version, and then save it in another S3 bucket.
•Data and analytics – Suppose you are building an analytics application and storing raw data in a 
DynamoDB table. When you write, update, or delete items in a table, DynamoDB streams can publish 
item update events to a stream associated with the table. In this case, the event data provides the 
item key, event name (such as insert, update, and delete), and other relevant details. You can write a 
Lambda function to generate custom metrics by aggregating raw data.
•Websites – Suppose you are creating a website and you want to host the backend logic on Lambda. 
You can invoke your Lambda function over HTTP using Amazon API Gateway as the HTTP endpoint. 
Now, your web client can invoke the API, and then API Gateway can route the request to Lambda.
•Mobile applications – Suppose you have a custom mobile application that produces events. You can 
create a Lambda function to process events published by your custom application. For example, you 
can conﬁgure a Lambda function to process the clicks within your custom mobile application.
AWS Lambda supports many AWS services as event sources. For more information, see Using AWS 
Lambda with other services (p. 628). When you conﬁgure these event sources to trigger a Lambda 
function, the Lambda function is invoked automatically when events occur. You deﬁne event source 
mapping , which is how you identify what events to track and which Lambda function to invoke.
The following are introductory examples of event sources and how the end-to-end experience works.
Example 1: Amazon S3 pushes events and invokes a 
Lambda function
Amazon S3 can publish events of diﬀerent types, such as PUT, POST, COPY, and DELETE object events on 
a bucket. Using the bucket notiﬁcation feature, you can conﬁgure an event source mapping that directs 
Amazon S3 to invoke a Lambda function when a speciﬁc type of event occurs.
The following is a typical sequence:
1.The user creates an object in a bucket.
2.Amazon S3 detects the object created event.
3.Amazon S3 invokes your Lambda function using the permissions provided by the execution 
role (p. 913).
4.AWS Lambda runs the Lambda function, specifying the event as a parameter.
You conﬁgure Amazon S3 to invoke your function as a bucket notiﬁcation action. To grant Amazon S3 
permission to invoke the function, update the function's resource-based policy (p. 929).
631AWS Lambda Developer Guide
Example 2: AWS Lambda pulls events from a 
Kinesis stream and invokes a Lambda function
Example 2: AWS Lambda pulls events from a Kinesis 
stream and invokes a Lambda function
For poll-based event sources, AWS Lambda polls the source and then invokes the Lambda function when 
records are detected on that source.
•CreateEventSourceMapping (p. 1292 )
•UpdateEventSourceMapping (p. 1495 )
The following steps describe how a custom application writes records to a Kinesis stream:
1.The custom application writes records to a Kinesis stream.
2.AWS Lambda continuously polls the stream, and invokes the Lambda function when the service 
detects new records on the stream. AWS Lambda knows which stream to poll and which Lambda 
function to invoke based on the event source mapping you create in Lambda.
3.The Lambda function is invoked with the incoming event.
When working with stream-based event sources, you create event source mappings in AWS Lambda. 
Lambda reads items from the stream and invokes the function synchronously. You don't need to grant 
Lambda permission to invoke the function, but it does need permission to read from the stream.
632AWS Lambda Developer Guide
Alexa
Using AWS Lambda with Alexa
You can use Lambda functions to build services that give new skills to Alexa, the Voice assistant on 
Amazon Echo. The Alexa Skills Kit provides the APIs, tools, and documentation to create these new skills, 
powered by your own services running as Lambda functions. Amazon Echo users can access these new 
skills by asking Alexa questions or making requests.
The Alexa Skills Kit is available on GitHub.
•Alexa Skills Kit SDK for Java
•Alexa Skills Kit SDK for Node.js
•Alexa Skills Kit SDK for Python
Example Alexa smart home event
{ 
  "header": { 
    "payloadVersion": "1", 
    "namespace": "Control", 
    "name": "SwitchOnOffRequest" 
  }, 
  "payload": { 
    "switchControlAction": "TURN_ON", 
    "appliance": { 
      "additionalApplianceDetails": { 
        "key2": "value2", 
        "key1": "value1" 
      }, 
      "applianceId": "sampleId" 
    }, 
    "accessToken": "sampleAccessToken" 
  }
}
For more information, see  Host a custom skill as an AWS Lambda Function in the Build Skills with the 
Alexa Skills Kit guide.
633AWS Lambda Developer Guide
API Gateway
Using AWS Lambda with Amazon API Gateway
You can create a web API with an HTTP endpoint for your Lambda function by using Amazon API 
Gateway. API Gateway provides tools for creating and documenting web APIs that route HTTP requests 
to Lambda functions. You can secure access to your API with authentication and authorization controls. 
Your APIs can serve traﬃc over the internet or can be accessible only within your VPC.
Resources in your API deﬁne one or more methods, such as GET or POST. Methods have an integration 
that routes requests to a Lambda function or another integration type. You can deﬁne each resource and 
method individually, or use special resource and method types to match all requests that ﬁt a pattern. A
proxy resource catches all paths beneath a resource. The ANY method catches all HTTP methods.
This section explains general information on how to choose an API type, add an endpoint to your 
Lambda function, and information on events, permissions, responses, and error handling.
Sections
•Adding an endpoint to your Lambda function (p. 634)
•Proxy integration (p. 634)
•Event format (p. 635)
•Response format (p. 636)
•Permissions (p. 636)
•Handling errors with an API Gateway API (p. 638)
•Choosing an API type (p. 639)
•Sample applications  (p. 640)
•Tutorial: Using Lambda with API Gateway (p. 640)
•AWS SAM template for an API Gateway application (p. 654)
Adding an endpoint to your Lambda function
To add a public endpoint to your Lambda function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Under Function overview, choose Add trigger .
4. Select API Gateway.
5. Choose Create an API  or Use an existing API .
a. New API:  For API type, choose HTTP API. For more information, see API types (p. 639).
b. Existing API:  Select the API from the dropdown menu or enter the API ID (for example, 
r3pmxmplak).
6. For Security, choose Open .
7. Choose Add.
Proxy integration
API Gateway APIs are comprised of stages, resources, methods, and integrations. The stage and resource 
determine the path of the endpoint:
634AWS Lambda Developer Guide
Event format
API path format
•/prod/  – The prod stage and root resource.
•/prod/user  – The prod  stage and user resource.
•/dev/{proxy+}  – Any route in the dev stage.
•/ – (HTTP APIs) The default stage and root resource.
A Lambda integration maps a path and HTTP method combination to a Lambda function. You can 
conﬁgure API Gateway to pass the body of the HTTP request as-is (custom integration), or to encapsulate 
the request body in a document that includes all of the request information including headers, resource, 
path, and method.
Event format
Amazon API Gateway invokes your function synchronously (p. 139) with an event that contains a JSON 
representation of the HTTP request. For a custom integration, the event is the body of the request. For a 
proxy integration, the event has a deﬁned structure. The following example shows a proxy event from an 
API Gateway REST API.
Example event.json API Gateway proxy event (REST API)
{ 
      "resource": "/", 
      "path": "/", 
      "httpMethod": "GET", 
      "requestContext": { 
          "resourcePath": "/", 
          "httpMethod": "GET", 
          "path": "/Prod/", 
          ... 
      }, 
      "headers": { 
          "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/
webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", 
          "accept-encoding": "gzip, deflate, br", 
          "Host": "70ixmpl4fl.execute-api.us-east-2.amazonaws.com", 
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 
 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36", 
          "X-Amzn-Trace-Id": "Root=1-5e66d96f-7491f09xmpl79d18acf3d050", 
          ... 
      }, 
      "multiValueHeaders": { 
          "accept": [ 
              "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/
apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9" 
          ], 
          "accept-encoding": [ 
              "gzip, deflate, br" 
          ], 
          ... 
      }, 
      "queryStringParameters": null, 
      "multiValueQueryStringParameters": null, 
      "pathParameters": null, 
      "stageVariables": null, 
      "body": null, 
      "isBase64Encoded": false 
  }
635AWS Lambda Developer Guide
Response format
Response format
API Gateway waits for a response from your function and relays the result to the caller. For a custom 
integration, you deﬁne an integration response and a method response to convert the output from the 
function to an HTTP response. For a proxy integration, the function must respond with a representation 
of the response in a speciﬁc format.
The following example shows a response object from a Node.js function. The response object represents 
a successful HTTP response that contains a JSON document.
Example index.js  – Proxy integration response object (Node.js)
var response = { 
      "statusCode": 200, 
      "headers": { 
        "Content-Type": "application/json" 
      }, 
      "isBase64Encoded": false, 
      "multiValueHeaders": {  
        "X-Custom-Header": ["My value", "My other value"], 
      }, 
      "body": "{\n  \"TotalCodeSize\": 104330022,\n  \"FunctionCount\": 26\n}" 
    }
The Lambda runtime serializes the response object into JSON and sends it to the API. The API parses the 
response and uses it to create an HTTP response, which it then sends to the client that made the original 
request.
Example HTTP response
< HTTP/1.1 200 OK 
  < Content-Type: application/json 
  < Content-Length: 55 
  < Connection: keep-alive 
  < x-amzn-RequestId: 32998fea-xmpl-4268-8c72-16138d629356 
  < X-Custom-Header: My value 
  < X-Custom-Header: My other value 
  < X-Amzn-Trace-Id: Root=1-5e6aa925-ccecxmplbae116148e52f036 
  < 
  { 
    "TotalCodeSize": 104330022, 
    "FunctionCount": 26 
  }
Permissions
Amazon API Gateway gets permission to invoke your function from the function's resource-based 
policy (p. 929). You can grant invoke permission to an entire API, or grant limited access to a stage, 
resource, or method.
When you add an API to your function by using the Lambda console, using the API Gateway console, or 
in an AWS SAM template, the function's resource-based policy is updated automatically. The following is 
an example function policy.
Example function policy
{ 
  "Version": "2012-10-17", 
636AWS Lambda Developer Guide
Permissions
  "Id": "default", 
  "Statement": [ 
    { 
      "Sid": "nodejs-apig-functiongetEndpointPermissionProd-BWDBXMPLXE2F", 
      "Effect": "Allow", 
      "Principal": { 
        "Service": "apigateway.amazonaws.com" 
      }, 
      "Action": "lambda:InvokeFunction", 
      "Resource": "arn:aws:lambda:us-east-2:111122223333:function:nodejs-apig-
function-1G3MXMPLXVXYI", 
      "Condition": { 
        "StringEquals": { 
          "aws:SourceAccount": "111122223333" 
        }, 
        "ArnLike": { 
          "aws:SourceArn": "arn:aws:execute-api:us-east-2:111122223333:ktyvxmpls1/*/GET/" 
        } 
      } 
    } 
  ]
}
You can manage function policy permissions manually with the following API operations:
•AddPermission (p. 1280 )
•RemovePermission (p. 1482 )
•GetPolicy (p. 1391 )
To grant invocation permission to an existing API, use the add-permission  command.
aws lambda add-permission --function-name my-function \
--statement-id apigateway-get --action lambda:InvokeFunction \
--principal apigateway.amazonaws.com \
--source-arn "arn:aws:execute-api:us-east-2:123456789012:mnh1xmpli7/default/GET/"
You should see the following output:
{ 
    "Statement": "{\"Sid\":\"apigateway-test-2\",\"Effect\":\"Allow\",\"Principal\":
{\"Service\":\"apigateway.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource
\":\"arn:aws:lambda:us-east-2:123456789012:function:my-function\",\"Condition\":{\"ArnLike
\":{\"AWS:SourceArn\":\"arn:aws:execute-api:us-east-2:123456789012:mnh1xmpli7/default/GET
\"}}}"
}
Note
If your function and API are in diﬀerent regions, the region identiﬁer in the source ARN must 
match the region of the function, not the region of the API. When API Gateway invokes a 
function, it uses a resource ARN that is based on the ARN of the API, but modiﬁed to match the 
function's region.
The source ARN in this example grants permission to an integration on the GET method of the root 
resource in the default stage of an API, with ID mnh1xmpli7 . You can use an asterisk in the source ARN 
to grant permissions to multiple stages, methods, or resources.
Resource patterns
•mnh1xmpli7/*/GET/*  – GET method on all resources in all stages.
637AWS Lambda Developer Guide
Handling errors with an API Gateway API
•mnh1xmpli7/prod/ANY/user  – ANY method on the user resource in the prod  stage.
•mnh1xmpli7/*/*/*  – Any method on all resources in all stages.
For details on viewing the policy and removing statements, see Cleaning up resource-based 
policies  (p. 934).
Handling errors with an API Gateway API
API Gateway treats all invocation and function errors as internal errors. If the Lambda API rejects the 
invocation request, API Gateway returns a 500 error code. If the function runs but returns an error, 
or returns a response in the wrong format, API Gateway returns a 502. In both cases, the body of the 
response from API Gateway is {"message": "Internal server error"} .
Note
API Gateway does not retry any Lambda invocations. If Lambda returns an error, API Gateway 
returns an error response to the client.
The following example shows an X-Ray trace map for a request that resulted in a function error and a 
502 from API Gateway. The client receives the generic error message.
To customize the error response, you must catch errors in your code and format a response in the 
required format.
Example index.js  – Error formatting
var formatError = function(error){ 
  var response = { 
    "statusCode": error.statusCode, 
    "headers": { 
      "Content-Type": "text/plain", 
      "x-amzn-ErrorType": error.code 
    }, 
    "isBase64Encoded": false, 
    "body": error.code + ": " + error.message 
  } 
  return response
}
API Gateway converts this response into an HTTP error with a custom status code and body. In the trace 
map, the function node is green because it handled the error.
638AWS Lambda Developer Guide
Choosing an API type
Choosing an API type
API Gateway supports three types of APIs that invoke Lambda functions:
•HTTP API – A lightweight, low-latency RESTful API.
•REST API  – A customizable, feature-rich RESTful API.
•WebSocket API – A web API that maintains persistent connections with clients for full-duplex 
communication.
HTTP APIs and REST APIs are both RESTful APIs that process HTTP requests and return responses. HTTP 
APIs are newer and are built with the API Gateway version 2 API. The following features are new for 
HTTP APIs:
HTTP API features
•Automatic deployments – When you modify routes or integrations, changes deploy automatically to 
stages that have automatic deployment enabled.
•Default stage  – You can create a default stage ($default ) to serve requests at the root path of your 
API's URL. For named stages, you must include the stage name at the beginning of the path.
•CORS conﬁguration – You can conﬁgure your API to add CORS headers to outgoing responses, instead 
of adding them manually in your function code.
REST APIs are the classic RESTful APIs that API Gateway has supported since launch. REST APIs currently 
have more customization, integration, and management features.
REST API features
•Integration types – REST APIs support custom Lambda integrations. With a custom integration, you 
can send just the body of the request to the function, or apply a transform template to the request 
body before sending it to the function.
•Access control – REST APIs support more options for authentication and authorization.
•Monitoring and tracing  – REST APIs support AWS X-Ray tracing and additional logging options.
For a detailed comparison, see Choosing between HTTP APIs and REST APIs in the API Gateway Developer 
Guide .
WebSocket APIs also use the API Gateway version 2 API and support a similar feature set. Use a 
WebSocket API for applications that beneﬁt from a persistent connection between the client and API. 
WebSocket APIs provide full-duplex communication, which means that both the client and the API can 
send messages continuously without waiting for a response.
HTTP APIs support a simpliﬁed event format (version 2.0). The following example shows an event from 
an HTTP API.
Example event-v2.json – API Gateway proxy event (HTTP API)
{ 
    "version": "2.0", 
    "routeKey": "ANY /nodejs-apig-function-1G3XMPLZXVXYI", 
    "rawPath": "/default/nodejs-apig-function-1G3XMPLZXVXYI", 
    "rawQueryString": "", 
    "cookies": [ 
        "s_fid=7AABXMPL1AFD9BBF-0643XMPL09956DE2", 
639AWS Lambda Developer Guide
Sample applications
        "regStatus=pre-register" 
    ], 
    "headers": { 
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/
apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", 
        "accept-encoding": "gzip, deflate, br", 
        ... 
    }, 
    "requestContext": { 
        "accountId": "123456789012", 
        "apiId": "r3pmxmplak", 
        "domainName": "r3pmxmplak.execute-api.us-east-2.amazonaws.com", 
        "domainPrefix": "r3pmxmplak", 
        "http": { 
            "method": "GET", 
            "path": "/default/nodejs-apig-function-1G3XMPLZXVXYI", 
            "protocol": "HTTP/1.1", 
            "sourceIp": "205.255.255.176", 
            "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 
 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36" 
        }, 
        "requestId": "JKJaXmPLvHcESHA=", 
        "routeKey": "ANY /nodejs-apig-function-1G3XMPLZXVXYI", 
        "stage": "default", 
        "time": "10/Mar/2020:05:16:23 +0000", 
        "timeEpoch": 1583817383220 
    }, 
    "isBase64Encoded": true
}
For more information, see AWS Lambda integrations in the API Gateway Developer Guide.
Sample applications
The GitHub repository for this guide provides the following sample application for API Gateway.
•API Gateway with Node.js – A function with an AWS SAM template that creates a REST API that has 
AWS X-Ray tracing enabled. It includes scripts for deploying, invoking the function, testing the API, 
and cleanup.
Lambda also provides blueprints  (p. 39) and templates  (p. 40) that you can use to create an API Gateway 
application in the Lambda console.
Tutorial: Using Lambda with API Gateway
In this tutorial, you create a REST API through which you invoke a Lambda function using an HTTP 
request. Your Lambda function will perform create, read, update, and delete (CRUD) operations on a 
DynamoDB table. This function is provided here for demonstration, but you will learn to conﬁgure an API 
Gateway REST API that can invoke any Lambda function.
640AWS Lambda Developer Guide
Tutorial
Using API Gateway provides users with a secure HTTP endpoint to invoke your Lambda function and can 
help manage large volumes of calls to your function by throttling traﬃc and automatically validating 
and authorizing API calls. API Gateway also provides ﬂexible security controls using AWS Identity and 
Access Management (IAM) and Amazon Cognito. This is useful for use cases where advance authorization 
is required for calls to your application.
To complete this tutorial, you will go through the following stages:
1.Create and conﬁgure a Lambda function in Python or Node.js to perform operations on a DynamoDB 
table.
2.Create a REST API in API Gateway to connect to your Lambda function.
3.Create a DynamoDB table and test it with your Lambda function in the console.
4.Deploy your API and test the full setup using curl in a terminal.
By completing these stages, you will learn how to use API Gateway to create an HTTP endpoint that can 
securely invoke a Lambda function at any scale. You will also learn how to deploy your API, and how to 
test it in the console and by sending an HTTP request using a terminal.
A sample AWS Serverless Application Model (AWS SAM) template for the Lambda application you create 
in this tutorial is also available. See AWS SAM template for an API Gateway application (p. 654).
Sections
•Prerequisites (p. 642)
•Create a permissions policy (p. 643)
•Create an execution role (p. 644)
•Create the function (p. 645)
•Invoke the function using the AWS CLI (p. 648)
•Create a REST API using API Gateway (p. 649)
•Create a resource on your REST API (p. 649)
641AWS Lambda Developer Guide
Tutorial
•Create an HTTP POST method (p. 650)
•Create a DynamoDB table (p. 650)
•Test the integration of API Gateway, Lambda, and DynamoDB (p. 651)
•Deploy the API (p. 652)
•Use curl to invoke your function using HTTP requests (p. 653)
•Clean up your resources (optional) (p. 116)
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
642AWS Lambda Developer Guide
Tutorial
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Install the AWS Command Line Interface
If you have not yet installed the AWS Command Line Interface, follow the steps at Installing or updating 
the latest version of the AWS CLI to install it.
The tutorial requires a command line terminal or shell to run commands. In Linux and macOS, use your 
preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) are 
not supported by the operating system's built-in terminals. To get a Windows-integrated version 
of Ubuntu and Bash, install the Windows Subsystem for Linux.
Create a permissions policy
Before you can create an execution role (p. 913) for your Lambda function, you ﬁrst need to create 
a permissions policy to give your function permission to access the required AWS resources. For this 
tutorial, the policy allows Lambda to perform CRUD operations on a DynamoDB table and write to 
Amazon CloudWatch Logs.
To create the policy
1. Open the Policies page of the IAM console.
2. Choose Create Policy.
3. Choose the JSON tab, and then paste the following custom policy into the JSON editor.
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "Stmt1428341300017", 
      "Action": [ 
        "dynamodb:DeleteItem", 
        "dynamodb:GetItem", 
        "dynamodb:PutItem", 
        "dynamodb:Query", 
        "dynamodb:Scan", 
643AWS Lambda Developer Guide
Tutorial
        "dynamodb:UpdateItem" 
      ], 
      "Effect": "Allow", 
      "Resource": "*" 
    }, 
    { 
      "Sid": "", 
      "Resource": "*", 
      "Action": [ 
        "logs:CreateLogGroup", 
        "logs:CreateLogStream", 
        "logs:PutLogEvents" 
      ], 
      "Effect": "Allow" 
    } 
  ]
}
4. Choose Next: Tags.
5. Choose Next: Review.
6. Under Review policy, for the policy Name , enter lambda-apigateway-policy .
7. Choose Create policy.
Create an execution role
An execution role (p. 913) is an AWS Identity and Access Management (IAM) role that grants a Lambda 
function permission to access AWS services and resources. To enable your function to perform operations 
on a DynamoDB table, you attach the permissions policy you created in the previous step.
To create an execution role and attach your custom permissions policy
1. Open the Roles page of the IAM console.
2. Choose Create role.
3. For the type of trusted entity, choose AWS service, then for the use case, choose Lambda .
4. Choose Next.
5. In the policy search box, enter lambda-apigateway-policy .
6. In the search results, select the policy that you created (lambda-apigateway-policy ), and then 
choose Next.
7. Under Role details, for the Role name, enter lambda-apigateway-role , then choose Create role.
Later in the tutorial, you need the Amazon Resource Name (ARN) of the role you just created. On the
Roles page of the IAM console, choose the name of your role (lambda-apigateway-role ) and copy 
the Role ARN displayed on the Summary page.
644AWS Lambda Developer Guide
Tutorial
Create the function
The following code example receives an event input from API Gateway specifying an operation to 
perform on the DynamoDB table you will create and some payload data. If the parameters the function 
receives are valid, it performs the requested operation on the table.
Node.js
Example index.mjs
console.log('Loading function');
import { DynamoDBDocumentClient, PutCommand, GetCommand,  
         UpdateCommand, DeleteCommand} from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
const ddbClient = new DynamoDBClient({ region: "us-west-2" });
const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
// Define the name of the DDB table to perform the CRUD operations on
const tablename = "lambda-apigateway";
/** 
 * Provide an event that contains the following keys: 
 * 
 *   - operation: one of 'create,' 'read,' 'update,' 'delete,' or 'echo' 
 *   - payload: a JSON object containing the parameters for the table item 
 *              to perform the operation on 
 */
export const handler = async (event, context) => { 
    
     const operation = event.operation; 
    
     if (operation == 'echo'){ 
          return(event.payload); 
     } 
      
    else {  
        event.payload.TableName = tablename; 
         
        switch (operation) { 
          case 'create': 
               await ddbDocClient.send(new PutCommand(event.payload)); 
               break; 
          case 'read': 
               var table_item = await ddbDocClient.send(new GetCommand(event.payload)); 
               console.log(table_item); 
               break; 
          case 'update': 
               await ddbDocClient.send(new UpdateCommand(event.payload)); 
645AWS Lambda Developer Guide
Tutorial
               break; 
          case 'delete': 
               await ddbDocClient.send(new DeleteCommand(event.payload)); 
               break; 
          default: 
            return ('Unknown operation: ${operation}'); 
          } 
    }
};
Note
In this example, the name of the DynamoDB table is deﬁned as a variable in your function 
code. In a real application, best practice is to pass this parameter as an environment variable 
and to avoid hardcoding the table name. For more information see Using AWS Lambda 
environment variables.
To create the function
1. Save the code example as a ﬁle named index.mjs  and, if necessary, edit the AWS region 
speciﬁed in the code. The region speciﬁed in the code must be the same as the region in which 
you create your DynamoDB table later in the tutorial.
2. Create a deployment package using the following zip command.
zip function.zip index.mjs
3. Create a Lambda function using the create-function  AWS CLI command. For the role
parameter, enter the execution role's Amazon Resource Name (ARN) that you copied earlier.
aws lambda create-function --function-name LambdaFunctionOverHttps \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam::123456789012:role/service-role/lambda-apigateway-role
Python 3
Example LambdaFunctionOverHttps.py
import boto3
import json
# define the DynamoDB table that Lambda will connect to
tableName = "lambda-apigateway"
# create the DynamoDB resource
dynamo = boto3.resource('dynamodb').Table(tableName)
print('Loading function')
def handler(event, context): 
    '''Provide an event that contains the following keys: 
      - operation: one of the operations in the operations dict below 
      - payload: a JSON object containing parameters to pass to the  
                 operation being performed 
    ''' 
     
    # define the functions used to perform the CRUD operations 
    def ddb_create(x): 
        dynamo.put_item(**x) 
646AWS Lambda Developer Guide
Tutorial
    def ddb_read(x): 
        dynamo.get_item(**x) 
    def ddb_update(x): 
        dynamo.update_item(**x) 
         
    def ddb_delete(x): 
        dynamo.delete_item(**x) 
    def echo(x): 
        return x 
    operation = event['operation'] 
    operations = { 
        'create': ddb_create, 
        'read': ddb_read, 
        'update': ddb_update, 
        'delete': ddb_delete, 
        'echo': echo, 
    } 
    if operation in operations: 
        return operations[operation](event.get('payload')) 
    else: 
        raise ValueError('Unrecognized operation "{}"'.format(operation))
Note
In this example, the name of the DynamoDB table is deﬁned as a variable in your function 
code. In a real application, best practice is to pass this parameter as an environment variable 
and to avoid hardcoding the table name. For more information see Using AWS Lambda 
environment variables.
To create the function
1. Save the code example as a ﬁle named LambdaFunctionOverHttps.py .
2. Create a deployment package using the following zip command.
zip function.zip LambdaFunctionOverHttps.py
3. Create a Lambda function using the create-function  AWS CLI command. For the role
parameter, enter the execution role's Amazon Resource Name (ARN) that you copied earlier.
aws lambda create-function --function-name LambdaFunctionOverHttps \
--zip-file fileb://function.zip --handler LambdaFunctionOverHttps.handler --runtime 
 python3.9 \
--role arn:aws:iam::123456789012:role/service-role/lambda-apigateway-role
647AWS Lambda Developer Guide
Tutorial
Invoke the function using the AWS CLI
Before integrating your function with API Gateway, conﬁrm that you have deployed the function 
successfully. Create a test event containing the parameters your API Gateway API will send to Lambda 
and use the AWS CLI invoke command to run your function.
To invoke the Lambda function with the AWS CLI
1. Save the following JSON as a ﬁle named input.txt .
{ 
    "operation": "echo", 
    "payload": { 
        "somekey1": "somevalue1", 
        "somekey2": "somevalue2" 
    }
}
2. Run the following invoke AWS CLI command.
aws lambda invoke --function-name LambdaFunctionOverHttps \
--payload file://input.txt outputfile.txt --cli-binary-format raw-in-base64-out
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following response:
{
"StatusCode": 200,
"ExecutedVersion": "LATEST"
}
3. Conﬁrm that your function performed the echo operation you speciﬁed in the JSON test event. 
Inspect the outputfile.txt  ﬁle and verify it contains the following:
{"somekey1": "somevalue1", "somekey2": "somevalue2"}
648AWS Lambda Developer Guide
Tutorial
Create a REST API using API Gateway
In this step, you create the API Gateway REST API you will use to invoke your Lambda function.
To create the API
1. Open the API Gateway console.
2. Choose Create API .
3. In the REST API  box, choose Build.
4. Under Settings, for API Name  enter DynamoDBOperations .
5. Choose Create API .
Create a resource on your REST API
To add an HTTP method to your API, you ﬁrst need to create a resource for that method to operate on. 
Here you create the resource to manage your DynamoDB table.
To create the resource
1. In the API Gateway console, in the Resources tree of your API, make sure that the root (/) level is 
highlighted. Then, choose Actions, Create Resource.
2. Under New child resource, do the following:
1.For Resource Name, enter DynamoDBManager .
2.Keep Resource Path set to /dynamodbmanager .
3. Choose Create Resource.
649AWS Lambda Developer Guide
Tutorial
Create an HTTP POST method
In this step, you create a method (POST) for your DynamoDBManager  resource. You link this POST
method to your Lambda function so that when the method receives an HTTP request, API Gateway 
invokes your Lambda function.
Note
For the purpose of this tutorial, one HTTP method (POST) is used to invoke a single Lambda 
function which carries out all of the operations on your DynamoDB table. In a real application, 
best practice is to use a diﬀerent Lambda function and HTTP method for each operation. For 
more information, see The Lambda monolith  in Serverless Land.
To create the POST method
1. In the API Gateway console, in the Resources tree of your API, make sure that /dynamodbmanager
is highlighted. Then, choose Actions, Create Method .
2. In the small dropdown menu that appears under /dynamodbmanager , choose POST , and then 
choose the check mark icon.
3. In the method's Setup  pane, do the following:
1.For Integration type, choose Lambda Function.
2.For Lambda Region, choose the same AWS Region as your Lambda function.
3.For Lambda Function, enter the name of your function (LambdaFunctionOverHttps ).
4.Select Use Default Timeout .
5.Choose Save.
4. In the Add Permission to Lambda Function dialog box, choose OK.
Create a DynamoDB table
Create an empty DynamoDB table that your Lambda function will perform CRUD operations on.
650AWS Lambda Developer Guide
Tutorial
To create the DynamoDB table
1. Open the Tables page of the DynamoDB console.
2. Choose Create table.
3. Under Table details, do the following:
1.For Table name, enter lambda-apigateway .
2.For Partition key, enter id, and keep the data type set as String .
4. Under Table settings, keep the Default settings.
5. Choose Create table.
Test the integration of API Gateway, Lambda, and DynamoDB
You're now ready to test the integration of your API Gateway API method with your Lambda function 
and your DynamoDB table. Using the API Gateway console, you send requests directly to your POST
method using the console's test function. In this step, you ﬁrst use a create  operation to add a new 
item to your DynamoDB table, then you use an update operation to modify the item.
Test 1: To create a new item in your DynamoDB table
1. In the API Gateway console, choose your API (DynamoDBOperations ).
2. In the Resources tree, under /dynamodbmanager , choose your POST  method.
3. In the Method Execution pane, in the Client  box, choose Test.
4. In the Method Test pane, keep Query Strings and Headers  empty. For Request Body, paste the 
following JSON:
{ 
  "operation": "create", 
  "payload": { 
    "Item": { 
      "id": "1234ABCD", 
      "number": 5 
    } 
  }
}
5. Choose Test.
The results that are displayed when the test completes should show status 200. This status code 
indicates that the create operation was successful.
To conﬁrm, check that your DynamoDB table now contains the new item.
6. Open the Tables page of the DynamoDB console and choose the lambda-apigateway  table.
651AWS Lambda Developer Guide
Tutorial
7. Chose Explore table items. In the Items returned  pane, you should see one item with the id
1234ABCD  and the number  5.
Test 2: To update the item in your DynamoDB table
1. In the API Gateway console, return to your POST method's Method Test pane.
2. In the Method Test pane, keep Query Strings and Headers  empty. In Request Body, paste the 
following JSON:
{ 
    "operation": "update", 
    "payload": { 
        "Key": { 
            "id": "1234ABCD" 
        }, 
        "AttributeUpdates": { 
            "number": { 
                "Value": 10 
            } 
        } 
    }
}
3. Choose Test.
The results which are displayed when the test completes should show status 200. This status code 
indicates that the update operation was successful.
To conﬁrm, check that the item in yout DynamoDB table has been modiﬁed.
4. Open the Tables page of the DynamoDB console and choose the lambda-apigateway  table.
5. Chose Explore table items. In the Items returned  pane, you should see one item with the id
1234ABCD  and the number  10.
Deploy the API
For a client to call the API, you must create a deployment and an associated stage. A stage represents a 
snapshot of your API including its methods and integrations.
To deploy the API
1. Open the APIs  page of the API Gateway console and choose the DynamoDBOperations  API.
2. Choose Actions, Deploy API.
3. For Deployment stage, choose [New Stage] , then for Stage name , enter test .
4. Choose Deploy.
652AWS Lambda Developer Guide
Tutorial
5. In the test Stage Editor pane, copy the Invoke URL. You will use this in the next step to invoke your 
function using an HTTP request.
Use curl to invoke your function using HTTP requests
You can now invoke your Lambda function by issuing an HTTP request to your API. In this step, you will 
create a new item in your DynamoDB table and then delete it.
To invoke the Lambda function using curl
1. Run the following curl command using the invoke URL you copied in the previous step. When you 
use curl with the -d (data) option, it automatically uses the HTTP POST method.
curl https:// l8togsqxd8.execute-api.us-west-2.amazonaws.com/test /dynamodbmanager \
-d '{"operation": "create", "payload": {"Item": {"id": "5678EFGH", "number": 15}}}'
2. To verify that the create operation was successful, do the following:
1.Open the Tables page of the DynamoDB console and choose the lambda-apigateway  table.
2.Choose Explore table items. In the Items returned  pane, you should see an item with the id
5678EFGH  and the number  15.
3. Run the following curl command to delete the item you just created. Use your own invoke URL.
curl https:// l8togsqxd8.execute-api.us-west-2.amazonaws.com/test /dynamodbmanager \
-d '{"operation": "delete", "payload": {"Key": {"id": "5678EFGH"}}}'
4. Conﬁrm that the delete operation was successful. In the Items returned  pane of the DynamoDB 
console Explore items page, verify that the item with id 5678EFGH  is no longer in the table.
Clean up your resources (optional)
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
653AWS Lambda Developer Guide
Sample template
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the API
1. Open the APIs page  of the API Gateway console.
2. Select the API you created.
3. Choose Actions, Delete.
4. Choose Delete.
To delete the DynamoDB table
1. Open the Tables page of the DynamoDB console.
2. Select the table you created.
3. Choose Delete.
4. Enter delete in the text box.
5. Choose Delete table.
AWS SAM template for an API Gateway application
Below is a sample AWS SAM template for the Lambda application from the tutorial  (p. 640). Copy the 
text below to a ﬁle and save it next to the ZIP package you created previously. Note that the Handler
and Runtime parameter values should match the ones you used when you created the function in the 
previous section.
Example template.yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Resources: 
  LambdaFunctionOverHttps: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler 
      Runtime: nodejs18.x 
      Policies: AmazonDynamoDBFullAccess 
      Events: 
        HttpPost: 
          Type: Api 
          Properties: 
            Path: '/DynamoDBOperations/DynamoDBManager' 
            Method: post
For information on how to package and deploy your serverless application using the package and deploy 
commands, see Deploying serverless applications in the AWS Serverless Application Model Developer 
Guide .
654AWS Lambda Developer Guide
CloudTrail
Using AWS Lambda with AWS CloudTrail
AWS CloudTrail is a service that provides a record of actions taken by a user, role, or an AWS service. 
CloudTrail captures API calls as events. For an ongoing record of events in your AWS account, you create 
a trail. A trail enables CloudTrail to deliver log ﬁles of events to an Amazon S3 bucket.
You can take advantage of Amazon S3's bucket notiﬁcation feature and direct Amazon S3 to publish 
object-created events to AWS Lambda. Whenever CloudTrail writes logs to your S3 bucket, Amazon S3 
can then invoke your Lambda function by passing the Amazon S3 object-created event as a parameter. 
The S3 event provides information, including the bucket name and key name of the log object that 
CloudTrail created. Your Lambda function code can read the log object and process the access records 
logged by CloudTrail. For example, you might write Lambda function code to notify you if speciﬁc API 
call was made in your account.
In this scenario, CloudTrail writes access logs to your S3 bucket. As for AWS Lambda, Amazon S3 is the 
event source so Amazon S3 publishes events to AWS Lambda and invokes your Lambda function.
Example CloudTrail log
{   
   "Records":[   
      {   
         "eventVersion":"1.02", 
         "userIdentity":{   
            "type":"Root", 
            "principalId":"123456789012", 
            "arn":"arn:aws:iam::123456789012:root", 
            "accountId":"123456789012", 
            "accessKeyId":"access-key-id", 
            "sessionContext":{   
               "attributes":{   
                  "mfaAuthenticated":"false", 
                  "creationDate":"2015-01-24T22:41:54Z" 
               } 
            } 
         }, 
         "eventTime":"2015-01-24T23:26:50Z", 
         "eventSource":"sns.amazonaws.com", 
         "eventName":"CreateTopic", 
         "awsRegion":"us-east-2", 
         "sourceIPAddress":"205.251.233.176", 
         "userAgent":"console.amazonaws.com", 
         "requestParameters":{   
            "name":"dropmeplease" 
         }, 
         "responseElements":{   
            "topicArn":"arn:aws:sns:us-east-2:123456789012:exampletopic" 
         }, 
         "requestID":"3fdb7834-9079-557e-8ef2-350abc03536b", 
         "eventID":"17b46459-dada-4278-b8e2-5a4ca9ff1a9c", 
         "eventType":"AwsApiCall", 
         "recipientAccountId":"123456789012" 
      }, 
      {   
         "eventVersion":"1.02", 
         "userIdentity":{   
            "type":"Root", 
            "principalId":"123456789012", 
            "arn":"arn:aws:iam::123456789012:root", 
            "accountId":"123456789012", 
            "accessKeyId": "AKIAIOSFODNN7EXAMPLE", 
            "sessionContext":{   
655AWS Lambda Developer Guide
CloudTrail
               "attributes":{   
                  "mfaAuthenticated":"false", 
                  "creationDate":"2015-01-24T22:41:54Z" 
               } 
            } 
         }, 
         "eventTime":"2015-01-24T23:27:02Z", 
         "eventSource":"sns.amazonaws.com", 
         "eventName":"GetTopicAttributes", 
         "awsRegion":"us-east-2", 
         "sourceIPAddress":"205.251.233.176", 
         "userAgent":"console.amazonaws.com", 
         "requestParameters":{   
            "topicArn":"arn:aws:sns:us-east-2:123456789012:exampletopic" 
         }, 
         "responseElements":null, 
         "requestID":"4a0388f7-a0af-5df9-9587-c5c98c29cbec", 
         "eventID":"ec5bb073-8fa1-4d45-b03c-f07b9fc9ea18", 
         "eventType":"AwsApiCall", 
         "recipientAccountId":"123456789012" 
      } 
   ]
}
For detailed information about how to conﬁgure Amazon S3 as the event source, see Using AWS Lambda 
with Amazon S3 (p. 815).
Topics
•Logging Lambda API calls with CloudTrail (p. 657)
•Sample function code (p. 660)
656AWS Lambda Developer Guide
CloudTrail logs
Logging Lambda API calls with CloudTrail
Lambda is integrated with AWS CloudTrail, a service that provides a record of actions taken by a user, 
role, or an AWS service in Lambda. CloudTrail captures API calls for Lambda as events. The calls captured 
include calls from the Lambda console and code calls to the Lambda API operations. If you create a trail, 
you can enable continuous delivery of CloudTrail events to an Amazon Simple Storage Service (Amazon 
S3) bucket, including events for Lambda. If you don't conﬁgure a trail, you can still view the most recent 
events in the CloudTrail console in Event history. Using the information collected by CloudTrail, you can 
determine the request that was made to Lambda, the IP address from which the request was made, who 
made the request, when it was made, and additional details.
For more information about CloudTrail, including how to conﬁgure and enable it, see the AWS CloudTrail 
User Guide .
Lambda information in CloudTrail
CloudTrail is enabled on your AWS account when you create the account. When supported event activity 
occurs in Lambda, that activity is recorded in a CloudTrail event along with other AWS service events 
in Event history. You can view, search, and download recent events in your AWS account. For more 
information, see Viewing events with CloudTrail event history in the AWS CloudTrail User Guide.
For an ongoing record of events in your AWS account, including events for Lambda, you create a trail. A 
trail enables CloudTrail to deliver log ﬁles to an Amazon S3 bucket. By default, when you create a trail 
in the console, the trail applies to all AWS Regions. The trail logs events from all Regions in the AWS 
partition and delivers the log ﬁles to the S3 bucket that you specify. Additionally, you can conﬁgure 
other AWS services to further analyze and act upon the event data collected in CloudTrail logs.
For more information, see the following topics in the AWS CloudTrail User Guide:
•Overview for creating a trail
•CloudTrail supported services and integrations
•Conﬁguring Amazon SNS notiﬁcations for CloudTrail
•Receiving CloudTrail log ﬁles from multiple regions and Receiving CloudTrail log ﬁles from multiple 
accounts
Every log entry contains information about who generated the request. The user identity information 
in the log helps you determine whether the request was made with user credentials, with temporary 
security credentials for a role or federated user, or by another AWS service. For more information, see the
userIdentity ﬁeld in the CloudTrail event reference.
You can store your log ﬁles in your bucket for as long as you want, but you can also deﬁne Amazon S3 
lifecycle rules to archive or delete log ﬁles automatically. By default, your log ﬁles are encrypted by using 
Amazon S3 server-side encryption (SSE).
You can choose to have CloudTrail publish Amazon Simple Notiﬁcation Service (Amazon SNS) 
notiﬁcations when new log ﬁles are delivered if you want to take quick action upon log ﬁle delivery. For 
more information, see Conﬁguring Amazon SNS notiﬁcations for CloudTrail.
You can also aggregate Lambda log ﬁles from multiple Regions and multiple AWS accounts into a single 
S3 bucket. For more information, see Working with CloudTrail log ﬁles.
List of supported Lambda API actions
Lambda supports logging the following actions as events in CloudTrail log ﬁles.
657AWS Lambda Developer Guide
CloudTrail logs
Note
In the CloudTrail log ﬁle, the eventName  might include date and version information, but it is 
still referring to the same public API. For example the, GetFunction  action might appear as
"GetFunction20150331" . To see the eventName  for a particular action, view a log ﬁle entry 
in your event history. For more information, see Viewing events with CloudTrail event history in 
the AWS CloudTrail User Guide.
•AddLayerVersionPermission (p. 1276 )
•AddPermission (p. 1280 )
•CreateAlias (p. 1285 )
•CreateEventSourceMapping (p. 1292 )
•CreateFunction (p. 1304 )
(The Environment  and ZipFile parameters are omitted from the CloudTrail logs for
CreateFunction .)
•CreateFunctionUrlConﬁg
•DeleteEventSourceMapping (p. 1325 )
•DeleteFunction (p. 1332 )
•DeleteFunctionUrlConﬁg
•GetEventSourceMapping (p. 1353 )
•GetFunction (p. 1359 )
•GetFunctionUrlConﬁg
•GetFunctionConﬁguration (p. 1368 )
•GetLayerVersionPolicy (p. 1389 )
•GetPolicy (p. 1391 )
•ListEventSourceMappings (p. 1418 )
•ListFunctions (p. 1425 )
•ListFunctionUrlConﬁgs
•PublishLayerVersion (p. 1449 )
(The ZipFile parameter is omitted from the CloudTrail logs for PublishLayerVersion .)
•RemovePermission (p. 1482 )
•UpdateAlias  (p. 1488 )
•UpdateEventSourceMapping (p. 1495 )
•UpdateFunctionCode (p. 1506 )
(The ZipFile parameter is omitted from the CloudTrail logs for UpdateFunctionCode .)
•UpdateFunctionConﬁguration (p. 1516 )
(The Environment  parameter is omitted from the CloudTrail logs for
UpdateFunctionConfiguration .)
•UpdateFunctionUrlConﬁg
Understanding Lambda log ﬁle entries
CloudTrail log ﬁles contain one or more log entries where each entry is made up of multiple JSON-
formatted events. A log entry represents a single request from any source and includes information 
about the requested action, any parameters, the date and time of the action, and so on. The log entries 
658AWS Lambda Developer Guide
CloudTrail logs
are not guaranteed to be in any particular order. That is, they are not an ordered stack trace of the public 
API calls.
The following example shows CloudTrail log entries for the GetFunction  and DeleteFunction
actions.
Note
The eventName  might include date and version information, such as
"GetFunction20150331" , but it is still referring to the same public API.
{ 
  "Records": [ 
    { 
      "eventVersion": "1.03", 
      "userIdentity": { 
        "type": "IAMUser", 
        "principalId": "A1B2C3D4E5F6G7EXAMPLE", 
        "arn": "arn:aws:iam::999999999999:user/myUserName", 
        "accountId": "999999999999", 
        "accessKeyId": "AKIAIOSFODNN7EXAMPLE", 
        "userName": "myUserName" 
      }, 
      "eventTime": "2015-03-18T19:03:36Z", 
      "eventSource": "lambda.amazonaws.com", 
      "eventName": "GetFunction", 
      "awsRegion": "us-east-1", 
      "sourceIPAddress": "127.0.0.1", 
      "userAgent": "Python-httplib2/0.8 (gzip)", 
      "errorCode": "AccessDenied", 
      "errorMessage": "User: arn:aws:iam::999999999999:user/myUserName is not 
 authorized to perform: lambda:GetFunction on resource: arn:aws:lambda:us-
west-2:999999999999:function:other-acct-function", 
      "requestParameters": null, 
      "responseElements": null, 
      "requestID": "7aebcd0f-cda1-11e4-aaa2-e356da31e4ff", 
      "eventID": "e92a3e85-8ecd-4d23-8074-843aabfe89bf", 
      "eventType": "AwsApiCall", 
      "recipientAccountId": "999999999999" 
    }, 
    { 
      "eventVersion": "1.03", 
      "userIdentity": { 
        "type": "IAMUser", 
        "principalId": "A1B2C3D4E5F6G7EXAMPLE", 
        "arn": "arn:aws:iam::999999999999:user/myUserName", 
        "accountId": "999999999999", 
        "accessKeyId": "AKIAIOSFODNN7EXAMPLE", 
        "userName": "myUserName" 
      }, 
      "eventTime": "2015-03-18T19:04:42Z", 
      "eventSource": "lambda.amazonaws.com", 
      "eventName": "DeleteFunction", 
      "awsRegion": "us-east-1", 
      "sourceIPAddress": "127.0.0.1", 
      "userAgent": "Python-httplib2/0.8 (gzip)", 
      "requestParameters": { 
        "functionName": "basic-node-task" 
      }, 
      "responseElements": null, 
      "requestID": "a2198ecc-cda1-11e4-aaa2-e356da31e4ff", 
      "eventID": "20b84ce5-730f-482e-b2b2-e8fcc87ceb22", 
      "eventType": "AwsApiCall", 
      "recipientAccountId": "999999999999" 
    } 
  ]
659AWS Lambda Developer Guide
Sample code
}
Using CloudTrail to track function invocations
CloudTrail also logs data events. You can turn on data event logging so that you log an event every time 
Lambda functions are invoked. This helps you understand what identities are invoking the functions and 
the frequency of their invocations. For more information on this option, see Logging data events for 
trails .
Note
CloudTrail logs only authenticated and authorized requests. CloudTrail does not log requests 
that fail authentication (credentials are missing or the provided credentials are not valid) or 
requests with credentials that are not authorized to invoke the function.
Using CloudTrail to troubleshoot disabled event sources
One data event that can be encountered is a LambdaESMDisabled  event. There are ﬁve general 
categories of error that are associated with this event:
RESOURCE_NOT_FOUND
The resource speciﬁed in the request does not exist.
FUNCTION_NOT_FOUND
The function attached to the event source does not exist.
REGION_NAME_NOT_VALID
A Region name provided to the event source or function is invalid.
AUTHORIZATION_ERROR
Permissions have not been set, or are misconﬁgured.
FUNCTION_IN_FAILED_STATE
The function code does not compile, has encountered an unrecoverable exception, or a bad 
deployment has occurred.
These errors are included in the CloudTrail event message within the serviceEventDetails  entity.
Example serviceEventDetails  entity
 "serviceEventDetails":{ 
    "ESMDisableReason":"Lambda Function not found"
}
Sample function code
Sample code is available for the following languages.
Topics
•Node.js  (p. 660)
Node.js
The following example processes CloudTrail logs, and sends a notiﬁcation when an Amazon SNS topic 
was created.
660AWS Lambda Developer Guide
Sample code
Example index.js
var aws  = require('aws-sdk');
var zlib = require('zlib');
var async = require('async');
var EVENT_SOURCE_TO_TRACK = /sns.amazonaws.com/;   
var EVENT_NAME_TO_TRACK   = /CreateTopic/;  
var DEFAULT_SNS_REGION  = 'us-west-2';
var SNS_TOPIC_ARN       = ' The ARN of your SNS topic ';
var s3 = new aws.S3();
var sns = new aws.SNS({ 
    apiVersion: '2010-03-31', 
    region: DEFAULT_SNS_REGION
});
exports.handler = function(event, context, callback) { 
    var srcBucket = event.Records[0].s3.bucket.name; 
    var srcKey = event.Records[0].s3.object.key; 
    
    async.waterfall([ 
        function fetchLogFromS3(next){ 
            console.log('Fetching compressed log from S3...'); 
            s3.getObject({ 
               Bucket: srcBucket, 
               Key: srcKey 
            }, 
            next); 
        }, 
        function uncompressLog(response, next){ 
            console.log("Uncompressing log..."); 
            zlib.gunzip(response.Body, next); 
        }, 
        function publishNotifications(jsonBuffer, next) { 
            console.log('Filtering log...'); 
            var json = jsonBuffer.toString(); 
            console.log('CloudTrail JSON from S3:', json); 
            var records; 
            try { 
                records = JSON.parse(json); 
            } catch (err) { 
                next('Unable to parse CloudTrail JSON: ' + err); 
                return; 
            } 
            var matchingRecords = records 
                .Records 
                .filter(function(record) { 
                    return record.eventSource.match(EVENT_SOURCE_TO_TRACK) 
                        && record.eventName.match(EVENT_NAME_TO_TRACK); 
                }); 
                 
            console.log('Publishing ' + matchingRecords.length + ' notification(s) in 
 parallel...'); 
            async.each( 
                matchingRecords, 
                function(record, publishComplete) { 
                    console.log('Publishing notification: ', record); 
                    sns.publish({ 
                        Message: 
                            'Alert... SNS topic created: \n TopicARN=' + 
 record.responseElements.topicArn + '\n\n' +  
                            JSON.stringify(record), 
                        TopicArn: SNS_TOPIC_ARN 
                    }, publishComplete); 
661AWS Lambda Developer Guide
Sample code
                }, 
                next 
            ); 
        } 
    ], function (err) { 
        if (err) { 
            console.error('Failed to publish notifications: ', err); 
        } else { 
            console.log('Successfully published all notifications.'); 
        } 
        callback(null,"message"); 
    });
};
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
662AWS Lambda Developer Guide
EventBridge (CloudWatch Events)
Using AWS Lambda with Amazon EventBridge 
(CloudWatch Events)
Note
Amazon EventBridge is the preferred way to manage your events. CloudWatch Events and 
EventBridge are the same underlying service and API, but EventBridge provides more features. 
Changes you make in either CloudWatch Events or EventBridge will appear in each console. For 
more information, see the Amazon EventBridge documentation.
EventBridge (CloudWatch Events) helps you to respond to state changes in your AWS resources. For more 
information about EventBridge, see What is Amazon EventBridge? in the Amazon EventBridge User Guide .
When your resources change state, they automatically send events into an event stream. With 
EventBridge (CloudWatch Events), you can create rules that match selected events in the stream and 
route them to your AWS Lambda function to take action. For example, you can automatically invoke an 
AWS Lambda function to log the state of an EC2 instance or AutoScaling group.
EventBridge (CloudWatch Events) invokes your function asynchronously with an event document that 
wraps the event from its source. The following example shows an event that originated from a database 
snapshot in Amazon Relational Database Service.
Example EventBridge (CloudWatch Events) event
{ 
    "version": "0", 
    "id": "fe8d3c65-xmpl-c5c3-2c87-81584709a377", 
    "detail-type": "RDS DB Instance Event", 
    "source": "aws.rds", 
    "account": "123456789012", 
    "time": "2020-04-28T07:20:20Z", 
    "region": "us-east-2", 
    "resources": [ 
        "arn:aws:rds:us-east-2:123456789012:db:rdz6xmpliljlb1" 
    ], 
    "detail": { 
        "EventCategories": [ 
            "backup" 
        ], 
        "SourceType": "DB_INSTANCE", 
        "SourceArn": "arn:aws:rds:us-east-2:123456789012:db:rdz6xmpliljlb1", 
        "Date": "2020-04-28T07:20:20.112Z", 
        "Message": "Finished DB Instance backup", 
        "SourceIdentifier": "rdz6xmpliljlb1" 
    }
}
You can also create a Lambda function and direct AWS Lambda to invoke it on a regular schedule. You 
can specify a ﬁxed rate (for example, invoke a Lambda function every hour or 15 minutes), or you can 
specify a Cron expression.
Example EventBridge (CloudWatch Events) message event
{ 
  "version": "0", 
  "account": "123456789012", 
  "region": "us-east-2", 
  "detail": {}, 
  "detail-type": "Scheduled Event", 
663AWS Lambda Developer Guide
Tutorial
  "source": "aws.events", 
  "time": "2019-03-01T01:23:45Z", 
  "id": "cdc73f9d-aea9-11e3-9d5a-835b769c0d9c", 
  "resources": [ 
    "arn:aws:events:us-east-2:123456789012:rule/my-schedule" 
  ]
}
To conﬁgure EventBridge (CloudWatch Events) to invoke your function
1. Open the Functions page of the Lambda console.
2. Choose a function
3. Under Function overview, choose Add trigger .
4. Set the trigger type to EventBridge (CloudWatch Events).
5. For Rule, choose Create a new rule.
6. Conﬁgure the remaining options and choose Add.
For more information on expressions schedules, see Schedule expressions using rate or cron (p. 667).
Each AWS account can have up to 100 unique event sources of the EventBridge (CloudWatch Events)- 
Schedule source type. Each of these can be the event source for up to ﬁve Lambda functions. That is, you 
can have up to 500 Lambda functions that can be executing on a schedule in your AWS account.
Topics
•Tutorial: Using AWS Lambda with scheduled events (p. 664)
•Schedule expressions using rate or cron (p. 667)
Tutorial: Using AWS Lambda with scheduled events
In this tutorial, you do the following:
•Create a Lambda function using the Schedule a periodic check of any URL blueprint. You conﬁgure 
the Lambda function to run every minute. Note that if the function returns an error, Lambda logs error 
metrics to Amazon CloudWatch.
•Conﬁgure a CloudWatch alarm on the Errors metric of your Lambda function to post a message to 
your Amazon SNS topic when AWS Lambda emits error metrics to CloudWatch. You subscribe to the 
Amazon SNS topics to get email notiﬁcation. In this tutorial, you do the following to set this up:
•Create an Amazon SNS topic.
•Subscribe to the topic so you can get email notiﬁcations when a new message is posted to the topic.
•In Amazon CloudWatch, set an alarm on the Errors metric of your Lambda function to publish a 
message to your SNS topic when errors occur.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
Create a Lambda function
1. Sign in to the AWS Management Console and open the AWS Lambda console at https:// 
console.aws.amazon.com/lambda/.
664AWS Lambda Developer Guide
Tutorial
2. Choose Create function.
3. Choose Use a blueprint .
4. Open the Select blueprint dropdown list and choose the Schedule a periodic check of any URL
blueprint.
5. Conﬁgure the following settings.
•Function name – lambda-canary .
•Execution role – Create a new role from AWS policy templates.
•Role name – lambda-eventbridge-role .
•Policy templates – Simple microservice permissions.
•Rule – Create a new rule.
•Rule name – CheckWebsiteScheduledEvent .
•Rule description – CheckWebsiteScheduledEvent trigger .
•Rule type – Schedule expression .
•Schedule expression – rate(1 minute) .
•Environment variables
•site – https://docs.aws.amazon.com/lambda/latest/dg/welcome.html
•expected – What is AWS Lambda?
6. Choose Create function.
EventBridge (CloudWatch Events) emits an event every minute, based on the schedule expression. The 
event triggers the Lambda function, which veriﬁes that the expected string appears in the speciﬁed page. 
For more information on expressions schedules, see Schedule expressions using rate or cron (p. 667).
Test the Lambda function
Test the function with a sample event provided by the Lambda console.
1. Open the Functions page of the Lambda console.
2. Choose the lambda-canary function.
3. Choose Test.
4. Create a new event using the CloudWatch event template (cloudwatch-scheduled-event).
5. Choose Create event.
6. Choose Invoke.
The output from the function execution is shown at the top of the page.
Create an Amazon SNS topic and subscribe to it
Create an Amazon Simple Notiﬁcation Service (Amazon SNS) topic to receive notiﬁcations when the 
canary function returns an error.
To create a topic
1. Open the Amazon SNS console.
2. Switch to the AWS Region where you created the Lambda function.
3. Choose Topics, and then choose Create topic .
4. Create a topic with the following settings.
•Type – Standard .
665AWS Lambda Developer Guide
Tutorial
•Name  – lambda-canary-notifications .
•Display name – Canary .
5. Choose Create topic .
6. On the lambda-canary-notiﬁcations topic page, choose Create subscription .
7. Create a subscription with the following settings.
•Protocol – Email .
•Endpoint  – Your email address.
8. Choose Create subscription .
Amazon SNS sends an email from Canary <no-reply@sns.amazonaws.com> , reﬂecting the friendly 
name of the topic. Use the link in the email to conﬁrm your address.
Conﬁgure an alarm
Conﬁgure an alarm in Amazon CloudWatch that monitors the Lambda function and sends a notiﬁcation 
when it fails.
To create an alarm
1. Open the CloudWatch console.
2. Switch to the AWS Region where you created the Lambda function.
3. Choose All alarms .
4. Choose Create alarm .
5. On the Specify metric and conditions page, choose Select metric.
6. In the Metrics  search box, enter lambda-canary Errors.
7. Choose Lambda > By Function 1 Name.
8. Select the lambda-canary Errors metric.
9. On the Specify metric and conditions page, in the Statistic  drop-down menu, choose Sum .
10. Set the threshold to Greater/Equal than 1.
11. On the Conﬁgure actions page, add a notiﬁcation with the following settings:
•Alarm state trigger – In alarm
•Send notiﬁcation to...  – lambda-canary-notifications
12. On the Add name and description  page, enter the following:
•Name  – lambda-canary-alarm
•Description  – Lambda canary alarm
13. Choose Create alarm .
Test the alarm
Update the function conﬁguration to cause the function to return an error, which triggers the alarm.
To trigger an alarm
1. Open the Functions page of the Lambda console.
2. Choose the lambda-canary function.
3. Scroll down. Under Environment variables, choose Edit.
666AWS Lambda Developer Guide
Schedule expressions
4. Set expected to 404.
5. Choose Save.
Wait a minute, and then check your email for a message from Amazon SNS.
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the CloudWatch alarm
1. Open the All alarms page  of the CloudWatch console.
2. Select the alarm you created.
3. Choose Actions, Delete.
4. Choose Delete.
To delete the Amazon SNS subscription
1. Open the Subscriptions page  of the Amazon SNS console.
2. Select the subscription you created.
3. Choose Delete, Delete.
To delete the Amazon SNS topic
1. Open the Topics page of the Amazon SNS console.
2. Select the topic you created.
3. Choose Delete.
4. Enter delete me  in the text input ﬁeld.
5. Choose Delete.
Schedule expressions using rate or cron
AWS Lambda supports standard rate and cron expressions for frequencies of up to once per minute. Rate 
expressions are simpler to deﬁne but do not oﬀer the ﬁne-grained schedule control that cron triggers 
support.
EventBridge (CloudWatch Events) rate expressions have the following format.
rate(Value Unit)
667AWS Lambda Developer Guide
Schedule expressions
Where Value is a positive integer and Unit can be minute(s), hour(s), or day(s). A rate expression starts 
when you create the scheduled event rule. For a singular value the unit must be singular (for example,
rate(1 day) ), otherwise plural (for example, rate(5 days) ).
Rate expression examples
Frequency Expression
Every 5 minutes rate(5 minutes)
Every hour rate(1 hour)
Every seven days rate(7 days)
Cron expressions have the following format.
cron(Minutes Hours Day-of-month  Month Day-of-week  Year)
Cron expression examples
Frequency Expression
10:15 AM (UTC+0) every daycron(15 10 * * ? *)
6:00 PM (UTC+0) Monday 
through Fridaycron(0 18 ? * MON-FRI *)
8:00 AM (UTC+0) on the ﬁrst day 
of the monthcron(0 8 1 * ? *)
Every 10 min on weekdayscron(0/10 * ? * MON-FRI *)
Every 5 minutes between 8:00 
AM (UTC+0) and 5:55 PM (UTC
+0) weekdayscron(0/5 8-17 ? * MON-FRI *)
9:00 AM (UTC+0) on the ﬁrst 
Monday of each monthcron(0 9 ? * 2#1 *)
Note the following:
•All scheduled events use UTC+0 time zone.
•If you are using the Lambda console, do not include the cron preﬁx in your expression.
•One of the day-of-month or day-of-week values must be a question mark (?).
For more information, see Schedule expressions for rules in the EventBridge User Guide .
668AWS Lambda Developer Guide
CloudWatch Logs
Using Lambda with CloudWatch Logs
You can use a Lambda function to monitor and analyze logs from an Amazon CloudWatch Logs log 
stream. Create subscriptions  for one or more log streams to invoke a function when logs are created or 
match an optional pattern. Use the function to send a notiﬁcation or persist the log to a database or 
storage.
CloudWatch Logs invokes your function asynchronously with an event that contains log data. The value 
of the data ﬁeld is a Base64-encoded .gzip ﬁle archive.
Example CloudWatch Logs message event
{ 
  "awslogs": { 
    "data": 
 "ewogICAgIm1lc3NhZ2VUeXBlIjogIkRBVEFfTUVTU0FHRSIsCiAgICAib3duZXIiOiAiMTIzNDU2Nzg5MDEyIiwKICAgICJsb2dHcm91cCI6I..." 
  }
}
When decoded and decompressed, the log data is a JSON document with the following structure:
Example CloudWatch Logs message data (decoded)
{ 
    "messageType": "DATA_MESSAGE", 
    "owner": "123456789012", 
    "logGroup": "/aws/lambda/echo-nodejs", 
    "logStream": "2019/03/13/[$LATEST]94fa867e5374431291a7fc14e2f56ae7", 
    "subscriptionFilters": [ 
        "LambdaStream_cloudwatchlogs-node" 
    ], 
    "logEvents": [ 
        { 
            "id": "34622316099697884706540976068822859012661220141643892546", 
            "timestamp": 1552518348220, 
            "message": "REPORT RequestId: 6234bffe-149a-b642-81ff-2e8e376d8aff\tDuration: 
 46.84 ms\tBilled Duration: 47 ms \tMemory Size: 192 MB\tMax Memory Used: 72 MB\t\n" 
        } 
    ]
}
For a sample application that uses CloudWatch Logs as a trigger, see Error processor sample application 
for AWS Lambda (p. 1121 ).
669AWS Lambda Developer Guide
CloudFormation
Using AWS Lambda with AWS CloudFormation
In an AWS CloudFormation template, you can specify a Lambda function as the target of a custom 
resource. Use custom resources to process parameters, retrieve conﬁguration values, or call other AWS 
services during stack lifecycle events.
The following example invokes a function that's deﬁned elsewhere in the template.
Example – Custom resource deﬁnition
Resources: 
  primerinvoke: 
    Type: AWS::CloudFormation::CustomResource
    Version: "1.0" 
    Properties: 
       ServiceToken: !GetAtt primer.Arn 
      FunctionName: !Ref randomerror
The service token is the Amazon Resource Name (ARN) of the function that AWS CloudFormation 
invokes when you create, update, or delete the stack. You can also include additional properties like
FunctionName , which AWS CloudFormation passes to your function as is.
AWS CloudFormation invokes your Lambda function asynchronously (p. 142) with an event that includes 
a callback URL.
Example – AWS CloudFormation message event
{ 
    "RequestType": "Create", 
    "ServiceToken": "arn:aws:lambda:us-east-1:123456789012:function:lambda-error-processor-
primer-14ROR2T3JKU66", 
    "ResponseURL": " https://cloudformation-custom-resource-response-useast1.s3-us-
east-1.amazonaws.com/arn%3Aaws%3Acloudformation%3Aus-east-1%3A123456789012%3Astack/lambda-
error-processor/1134083a-2608-1e91-9897-022501a2c456%7Cprimerinvoke%7C5d478078-13e9-
baf0-464a-7ef285ecc786?
AWSAccessKeyId=AKIAIOSFODNN7EXAMPLE&Expires=1555451971&Signature=28UijZePE5I4dvukKQqM
%2F9Rf1o4%3D ", 
    "StackId": "arn:aws:cloudformation:us-east-1:123456789012:stack/lambda-error-
processor/1134083a-2608-1e91-9897-022501a2c456", 
    "RequestId": "5d478078-13e9-baf0-464a-7ef285ecc786", 
    "LogicalResourceId": "primerinvoke", 
    "ResourceType": "AWS::CloudFormation::CustomResource", 
    "ResourceProperties": { 
        "ServiceToken": "arn:aws:lambda:us-east-1:123456789012:function:lambda-error-
processor-primer-14ROR2T3JKU66", 
        "FunctionName": "lambda-error-processor-randomerror-ZWUC391MQAJK" 
    }
}
The function is responsible for returning a response to the callback URL that indicates success or failure. 
For the full response syntax, see Custom resource response objects.
Example – AWS CloudFormation custom resource response
{ 
    "Status": "SUCCESS", 
    "PhysicalResourceId": "2019/04/18/[$LATEST]b3d1bfc65f19ec610654e4d9b9de47a0", 
    "StackId": "arn:aws:cloudformation:us-east-1:123456789012:stack/lambda-error-
processor/1134083a-2608-1e91-9897-022501a2c456", 
    "RequestId": "5d478078-13e9-baf0-464a-7ef285ecc786", 
    "LogicalResourceId": "primerinvoke"
670AWS Lambda Developer Guide
CloudFormation
}
AWS CloudFormation provides a library called cfn-response  that handles sending the response. If you 
deﬁne your function within a template, you can require the library by name. AWS CloudFormation then 
adds the library to the deployment package that it creates for the function.
If your function that a Custom Resource uses has an Elastic Network Interface (p. 22) attached to it, add 
the following resources to the VPC policy where region is the Region the function is in without the 
dashes. For example, us-east-1  is useast1. This will allow the Custom Resource to respond to the 
callback URL that sends a signal back to the AWS CloudFormation stack.
arn:aws:s3:::cloudformation-custom-resource-response- region",
"arn:aws:s3:::cloudformation-custom-resource-response- region/*",
The following example function invokes a second function. If the call succeeds, the function sends 
a success response to AWS CloudFormation, and the stack update continues. The template uses the
AWS::Serverless::Function resource type provided by AWS Serverless Application Model.
Example error-processor/template.yml – Custom resource function
Transform: 'AWS::Serverless-2016-10-31'
Resources: 
  primer: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler 
      Runtime: nodejs16.x 
      InlineCode: | 
        var aws = require('aws-sdk'); 
         var response = require('cfn-response');
        exports.handler = function(event, context) { 
            // For Delete requests, immediately send a SUCCESS response. 
            if (event.RequestType == "Delete") { 
                response.send(event, context, "SUCCESS"); 
                return; 
            } 
            var responseStatus = "FAILED"; 
            var responseData = {}; 
            var functionName = event.ResourceProperties.FunctionName 
            var lambda = new aws.Lambda(); 
            lambda.invoke({ FunctionName: functionName }, function(err, invokeResult) { 
                if (err) { 
                    responseData = {Error: "Invoke call failed"}; 
                    console.log(responseData.Error + ":\n", err); 
                } 
                else responseStatus = "SUCCESS"; 
                response.send(event, context, responseStatus, responseData); 
            }); 
        }; 
      Description: Invoke a function to create a log stream. 
      MemorySize: 128 
      Timeout: 8 
      Role: !GetAtt role.Arn 
      Tracing: Active
If the function that the custom resource invokes isn't deﬁned in a template, you can get the source code 
for cfn-response  from cfn-response module in the AWS CloudFormation User Guide.
For a sample application that uses a custom resource to ensure that a function's log group is 
created before another resource that depends on it, see Error processor sample application for AWS 
Lambda  (p. 1121 ).
671AWS Lambda Developer Guide
CloudFormation
For more information about custom resources, see Custom resources in the AWS CloudFormation User 
Guide .
672AWS Lambda Developer Guide
CloudFront (Lambda@Edge)
Using AWS Lambda with CloudFront 
Lambda@Edge
Lambda@Edge lets you run Node.js and Python Lambda functions to customize content that CloudFront 
delivers, executing the functions in AWS locations closer to the viewer. The functions run in response to 
CloudFront events, without provisioning or managing servers. You can use Lambda functions to change 
CloudFront requests and responses at the following points:
•After CloudFront receives a request from a viewer (viewer request)
•Before CloudFront forwards the request to the origin (origin request)
•After CloudFront receives the response from the origin (origin response)
•Before CloudFront forwards the response to the viewer (viewer response)
Note
Lambda@Edge supports a limited set of runtimes and features. For details, see Requirements 
and restrictions on Lambda functions in the Amazon CloudFront developer guide.
You can also generate responses to viewers without ever sending the request to the origin.
Example CloudFront message event
{ 
  "Records": [ 
    { 
      "cf": { 
        "config": { 
          "distributionId": "EDFDVBD6EXAMPLE" 
        }, 
        "request": { 
          "clientIp": "2001:0db8:85a3:0:0:8a2e:0370:7334", 
          "method": "GET", 
          "uri": "/picture.jpg", 
          "headers": { 
            "host": [ 
              { 
                "key": "Host", 
                "value": "d111111abcdef8.cloudfront.net" 
              } 
            ], 
            "user-agent": [ 
              { 
                "key": "User-Agent", 
673AWS Lambda Developer Guide
CloudFront (Lambda@Edge)
                "value": "curl/7.51.0" 
              } 
            ] 
          } 
        } 
      } 
    } 
  ]
}
With Lambda@Edge, you can build a variety of solutions, for example:
•Inspect cookies to rewrite URLs to diﬀerent versions of a site for A/B testing.
•Send diﬀerent objects to your users based on the User-Agent  header, which contains information 
about the device that submitted the request. For example, you can send images in diﬀerent resolutions 
to users based on their devices.
•Inspect headers or authorized tokens, inserting a corresponding header and allowing access control 
before forwarding a request to the origin.
•Add, delete, and modify headers, and rewrite the URL path to direct users to diﬀerent objects in the 
cache.
•Generate new HTTP responses to do things like redirect unauthenticated users to login pages, or 
create and deliver static webpages right from the edge. For more information, see Using Lambda 
functions to generate HTTP responses to viewer and origin requests in the Amazon CloudFront 
Developer Guide .
For more information about using Lambda@Edge, see Using CloudFront with Lambda@Edge.
674AWS Lambda Developer Guide
CodeCommit
Using AWS Lambda with AWS CodeCommit
You can create a trigger for an AWS CodeCommit repository so that events in the repository will invoke 
a Lambda function. For example, you can invoke a Lambda function when a branch or tag is created or 
when a push is made to an existing branch.
Example AWS CodeCommit message event
{ 
    "Records": [ 
        { 
            "awsRegion": "us-east-2", 
            "codecommit": { 
                "references": [ 
                    { 
                        "commit": "5e493c6f3067653f3d04eca608b4901eb227078", 
                        "ref": "refs/heads/master" 
                    } 
                ] 
            }, 
            "eventId": "31ade2c7-f889-47c5-a937-1cf99e2790e9", 
            "eventName": "ReferenceChanges", 
            "eventPartNumber": 1, 
            "eventSource": "aws:codecommit", 
            "eventSourceARN": "arn:aws:codecommit:us-east-2:123456789012:lambda-pipeline-
repo", 
            "eventTime": "2019-03-12T20:58:25.400+0000", 
            "eventTotalParts": 1, 
            "eventTriggerConfigId": "0d17d6a4-efeb-46f3-b3ab-a63741badeb8", 
            "eventTriggerName": "index.handler", 
            "eventVersion": "1.0", 
            "userIdentityARN": "arn:aws:iam::123456789012:user/intern" 
        } 
    ]
}
For more information, see Manage triggers for an AWS CodeCommit repository.
675AWS Lambda Developer Guide
CodePipeline
Using AWS Lambda with AWS CodePipeline
AWS CodePipeline is a service that enables you to create continuous delivery pipelines for applications 
that run on AWS. You can create a pipeline to deploy your Lambda application. You can also conﬁgure 
a pipeline to invoke a Lambda function to perform a task when the pipeline runs. When you create a 
Lambda application  (p. 1066 ) in the Lambda console, Lambda creates a pipeline that includes source, 
build, and deploy stages.
CodePipeline invokes your function asynchronously with an event that contains details about the job. 
The following example shows an event from a pipeline that invoked a function named my-function .
Example CodePipeline event
{ 
    "CodePipeline.job": { 
        "id": "c0d76431-b0e7-xmpl-97e3-e8ee786eb6f6", 
        "accountId": "123456789012", 
        "data": { 
            "actionConfiguration": { 
                "configuration": { 
                    "FunctionName": "my-function", 
                    "UserParameters": "{\"KEY\": \"VALUE\"}" 
                } 
            }, 
            "inputArtifacts": [ 
                { 
                    "name": "my-pipeline-SourceArtifact", 
                    "revision": "e0c7xmpl2308ca3071aa7bab414de234ab52eea", 
                    "location": { 
                        "type": "S3", 
                        "s3Location": { 
                            "bucketName": "us-west-2-123456789012-my-pipeline", 
                            "objectKey": "my-pipeline/test-api-2/TdOSFRV" 
                        } 
                    } 
                } 
            ], 
            "outputArtifacts": [ 
                { 
                    "name": "invokeOutput", 
                    "revision": null, 
                    "location": { 
                        "type": "S3", 
                        "s3Location": { 
                            "bucketName": "us-west-2-123456789012-my-pipeline", 
                            "objectKey": "my-pipeline/invokeOutp/D0YHsJn" 
                        } 
                    } 
                } 
            ], 
            "artifactCredentials": { 
                "accessKeyId": "AKIAIOSFODNN7EXAMPLE", 
                "secretAccessKey": "6CGtmAa3lzWtV7a...", 
                "sessionToken": "IQoJb3JpZ2luX2VjEA...", 
                "expirationTime": 1575493418000 
            } 
        } 
    }
}
676AWS Lambda Developer Guide
Permissions
To complete the job, the function must call the CodePipeline API to signal success or failure. The 
following example Node.js function uses the PutJobSuccessResult  operation to signal success. It gets 
the job ID for the API call from the event object.
Example index.js
var AWS = require('aws-sdk')
var codepipeline = new AWS.CodePipeline()
exports.handler = async (event) => { 
    console.log(JSON.stringify(event, null, 2)) 
    var jobId = event["CodePipeline.job"].id 
    var params = { 
        jobId: jobId 
    } 
    return codepipeline.putJobSuccessResult(params).promise()
}
For asynchronous invocation, Lambda queues the message and retries (p. 181) if your function returns 
an error. Conﬁgure your function with a destination  (p. 144) to retain events that your function could not 
process.
For a tutorial on how to conﬁgure a pipeline to invoke a Lambda function, see Invoke an AWS Lambda 
function in a pipeline in the AWS CodePipeline User Guide.
You can use AWS CodePipeline to create a continuous delivery pipeline for your Lambda application. 
CodePipeline combines source control, build, and deployment resources to create a pipeline that runs 
whenever you make a change to your application's source code.
For an alternate method of creating a pipeline with AWS Serverless Application Model and AWS 
CloudFormation, watch Automate your serverless application deployments on the Amazon Web Services 
YouTube channel.
Permissions
To invoke a function, a CodePipeline pipeline needs permission to use the following API operations:
•ListFunctions (p. 1425 )
•InvokeFunction (p. 1399 )
The default pipeline service role includes these permissions.
To complete a job, the function needs the following permissions in its execution role (p. 913).
•codepipeline:PutJobSuccessResult
•codepipeline:PutJobFailureResult
These permissions are included in the AWSCodePipelineCustomActionAccess managed policy.
677AWS Lambda Developer Guide
CodeWhisperer
Working with Amazon CodeWhisperer in the 
Lambda console
Amazon CodeWhisperer is a general purpose, machine learning-powered code generator that provides 
you with code recommendations in real time. When activated in the Lambda console, CodeWhisperer 
automatically generates suggestions based on your existing code and comments. Your personalized 
recommendations can vary in size and scope, ranging from a single one-liner to fully formed functions.
For more information, see the Amazon CodeWhisperer User Guide.
678AWS Lambda Developer Guide
Cognito
Using AWS Lambda with Amazon Cognito
The Amazon Cognito Events feature enables you to run Lambda functions in response to events in 
Amazon Cognito. Amazon Cognito provides authentication, authorization, and user management 
for your web and mobile apps. You can invoke a Lambda function in response to important events in 
Amazon Cognito. For example, using the Sync Trigger events, you can invoke a Lambda function that 
is published each time a dataset is synchronized. To learn more and walk through an example, see
Introducing Amazon Cognito Events: Sync Triggers in the Mobile Development blog.
Example Amazon Cognito message event
{ 
  "datasetName": "datasetName", 
  "eventType": "SyncTrigger", 
  "region": "us-east-1", 
  "identityId": "identityId", 
  "datasetRecords": { 
    "SampleKey2": { 
      "newValue": "newValue2", 
      "oldValue": "oldValue2", 
      "op": "replace" 
    }, 
    "SampleKey1": { 
      "newValue": "newValue1", 
      "oldValue": "oldValue1", 
      "op": "replace" 
    } 
  }, 
  "identityPoolId": "identityPoolId", 
  "version": 2
}
You conﬁgure event source mapping using Amazon Cognito event subscription conﬁguration. For 
information about event source mapping and a sample event, see Amazon Cognito events in the Amazon 
Cognito Developer Guide .
679AWS Lambda Developer Guide
Conﬁg
Using AWS Lambda with AWS Conﬁg
You can use AWS Lambda functions to evaluate whether your AWS resource conﬁgurations comply 
with your custom Conﬁg rules. As resources are created, deleted, or changed, AWS Conﬁg records these 
changes and sends the information to your Lambda functions. Your Lambda functions then evaluate 
the changes and report results to AWS Conﬁg. You can then use AWS Conﬁg to assess overall resource 
compliance: you can learn which resources are noncompliant and which conﬁguration attributes are the 
cause of noncompliance.
Example AWS Conﬁg message event
{  
    "invokingEvent": "{\"configurationItem\":{\"configurationItemCaptureTime\":
\"2016-02-17T01:36:34.043Z\",\"awsAccountId\":\"000000000000\",\"configurationItemStatus\":
\"OK\",\"resourceId\":\"i-00000000\",\"ARN\":\"arn:aws:ec2:us-east-1:000000000000:instance/
i-00000000\",\"awsRegion\":\"us-east-1\",\"availabilityZone\":\"us-east-1a\",
\"resourceType\":\"AWS::EC2::Instance\",\"tags\":{\"Foo\":\"Bar\"},\"relationships\":
[{\"resourceId\":\"eipalloc-00000000\",\"resourceType\":\"AWS::EC2::EIP\",\"name\":
\"Is attached to ElasticIp\"}],\"configuration\":{\"foo\":\"bar\"}},\"messageType\":
\"ConfigurationItemChangeNotification\"}", 
    "ruleParameters": "{\"myParameterKey\":\"myParameterValue\"}", 
    "resultToken": "myResultToken", 
    "eventLeftScope": false, 
    "executionRoleArn": "arn:aws:iam::111122223333:role/config-role", 
    "configRuleArn": "arn:aws:config:us-east-1:111122223333:config-rule/config-
rule-0123456", 
    "configRuleName": "change-triggered-config-rule", 
    "configRuleId": "config-rule-0123456", 
    "accountId": "111122223333", 
    "version": "1.0"
}
For more information, see Evaluating resources with AWS Conﬁg rules.
680AWS Lambda Developer Guide
Connect
Using Lambda with Amazon Connect
You can use a Lambda function to process requests from Amazon Connect. You can use Amazon Connect 
to create a cloud contact center.
Amazon Connect invokes your Lambda function synchronously with an event that contains the request 
body and metadata.
Example Amazon Connect request event
{ 
  "Details": { 
      "ContactData": { 
          "Attributes": {}, 
          "Channel": "VOICE", 
          "ContactId": "4a573372-1f28-4e26-b97b-XXXXXXXXXXX", 
          "CustomerEndpoint": { 
              "Address": "+1234567890", 
              "Type": "TELEPHONE_NUMBER" 
          }, 
          "InitialContactId": "4a573372-1f28-4e26-b97b-XXXXXXXXXXX", 
          "InitiationMethod": "INBOUND | OUTBOUND | TRANSFER | CALLBACK", 
          "InstanceARN": "arn:aws:connect:aws-region:1234567890:instance/
c8c0e68d-2200-4265-82c0-XXXXXXXXXX", 
          "PreviousContactId": "4a573372-1f28-4e26-b97b-XXXXXXXXXXX", 
          "Queue": { 
             "ARN": "arn:aws:connect:eu-west-2:111111111111:instance/cccccccc-bbbb-dddd-
eeee-ffffffffffff/queue/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee", 
             "Name": "PasswordReset" 
           }, 
          "SystemEndpoint": { 
              "Address": "+1234567890", 
              "Type": "TELEPHONE_NUMBER" 
          } 
      }, 
      "Parameters": { 
          "sentAttributeKey": "sentAttributeValue" 
      } 
  }, 
  "Name": "ContactFlowEvent"
}
For information about how to use Amazon Connect with Lambda, see  Invoke Lambda functions in the
Amazon Connect administrator guide .
681AWS Lambda Developer Guide
DocumentDB
Using Lambda with Amazon DocumentDB
You can use a Lambda function to process events in an Amazon DocumentDB (with MongoDB 
compatibility) change stream by conﬁguring an Amazon DocumentDB cluster as an event source. Then, 
you can automate event-driven workloads by invoking your Lambda function each time that data 
changes with your Amazon DocumentDB cluster.
Note
Lambda supports version 4.0 of Amazon DocumentDB only. Lambda doesn't support versions 
3.6 and 5.0.
Also, for event source mappings, Lambda supports instance-based clusters and regional clusters 
only. Lambda doesn't support  elastic clusters  or  global clusters . This limitation doesn't apply 
when using Lambda as a client to connect to Amazon DocumentDB. Lambda can connect to all 
cluster types to perform CRUD operations.
Lambda processes events from Amazon DocumentDB change streams sequentially in the order in which 
they arrive. Because of this, your function can handle only one concurrent invocation from DocumentDB 
at a time. To monitor your function, you can track its concurrency metrics.
Topics
•Example Amazon DocumentDB event (p. 682)
•Prerequisites and permissions (p. 683)
•Network conﬁguration (p. 684)
•Creating an Amazon DocumentDB event source mapping (console) (p. 684)
•Creating an Amazon DocumentDB event source mapping (SDK or CLI) (p. 685)
•Monitoring your Amazon DocumentDB event source (p. 687)
•Tutorial: Using AWS Lambda with Amazon DocumentDB Streams (p. 688)
Example Amazon DocumentDB event
{ 
    "eventSourceArn": "arn:aws:rds:us-east-1:123456789012:cluster:canaryclusterb2a659a2-
qo5tcmqkcl03", 
    "events": [ 
        { 
            "event": { 
                "_id": { 
                    "_data": "0163eeb6e7000000090100000009000041e1" 
                }, 
                "clusterTime": { 
                    "$timestamp": { 
                        "t": 1676588775, 
                        "i": 9 
                    } 
                }, 
                "documentKey": { 
                    "_id": { 
                        "$oid": "63eeb6e7d418cd98afb1c1d7" 
                    } 
                }, 
                "fullDocument": { 
                    "_id": { 
                        "$oid": "63eeb6e7d418cd98afb1c1d7" 
                    }, 
                    "anyField": "sampleValue" 
                }, 
682AWS Lambda Developer Guide
Prerequisites and permissions
                "ns": { 
                    "db": "test_database", 
                    "coll": "test_collection" 
                }, 
                "operationType": "insert" 
            } 
        } 
    ], 
    "eventSource": "aws:docdb"
}
For more information about the events in this example and their shapes, see Change Events on the 
MongoDB Documentation website.
Prerequisites and permissions
Before you can use Amazon DocumentDB as an event source for your Lambda function, note the 
following prerequisites. You must:
•Have an existing Amazon DocumentDB cluster in the same AWS account and AWS Region as your 
function. If you don't have an existing cluster, you can create one by following the steps in Get Started 
with Amazon DocumentDB in the Amazon DocumentDB Developer Guide . Alternatively, the ﬁrst set of 
steps in Tutorial: Using AWS Lambda with Amazon DocumentDB Streams (p. 688) guide you through 
creating a DocumentDB cluster with all the necessary prerequisites.
•Allow Lambda to access the Amazon Virtual Private Cloud (Amazon VPC) resources associated with 
your Amazon DocumentDB cluster. For more information, see Network conﬁguration (p. 684).
•Enable TLS on your Amazon DocumentDB cluster. This is the default setting. If you disable TLS, then 
Lambda cannot communicate with your cluster.
•Activate change streams on your Amazon DocumentDB cluster. For more information, see Using 
Change Streams with Amazon DocumentDB in the Amazon DocumentDB Developer Guide .
•Provide Lambda with credentials to access your Amazon DocumentDB cluster. When setting up 
the event source, provide the AWS Secrets Manager key that contains the authentication details 
(username and password) required to access your cluster. To provide this key during setup, do either of 
the following:
•If you're using the Lambda console for setup, then provide the key in the Secrets manager key ﬁeld.
•If you're using the AWS Command Line Interface (AWS CLI) for setup, then provide this key in the
source-access-configurations  option. You can include this option with either the create-
event-source-mapping  command or the update-event-source-mapping  command. For 
example:
aws lambda create-event-source-mapping \ 
    ... 
    --source-access-configurations  
 '[{"Type":"BASIC_AUTH","URI":"arn:aws:secretsmanager:us-
west-2:123456789012:secret:DocDBSecret-AbC4E6"}]' \ 
    ...
•Grant Lambda permissions to manage resources related to your Amazon DocumentDB stream.
Manually add the following permissions to your function's execution role (p. 913):
•rds:DescribeDBClusters
•rds:DescribeDBClusterParameters
•rds:DescribeDBSubnetGroups
•ec2:CreateNetworkInterface
•ec2:DescribeNetworkInterfaces
•ec2:DescribeVpcs
683AWS Lambda Developer Guide
Network conﬁguration
•ec2:DeleteNetworkInterface
•ec2:DescribeSubnets
•ec2:DescribeSecurityGroups
•kms:Decrypt
•secretsmanager:GetSecretValue
•Keep the size of Amazon DocumentDB change stream events that you send to Lambda under 6 MB.
Lambda supports payload sizes of up to 6 MB. If your change stream tries to send Lambda an event 
larger than 6 MB, then Lambda drops the message and emits the OversizedRecordCount  metric. 
Lambda emits all metrics on a best-eﬀort basis.
Note
While Lambda functions typically have a maximum timeout limit of 15 minutes, event source 
mappings for Amazon MSK, self-managed Apache Kafka, Amazon DocumentDB, and Amazon 
MQ for ActiveMQ and RabbitMQ only support functions with maximum timeout limits of 14 
minutes. This constraint ensures that the event source mapping can properly handle function 
errors and retries.
Network conﬁguration
Lambda must have access to the Amazon VPC resources associated with your Amazon DocumentDB 
cluster. If you conﬁgured a secret in Secrets Manager to authenticate Lambda with the clusters, then also 
deploy a VPC endpoint for Secrets Manager.
Alternatively, ensure that the VPC associated with your Amazon DocumentDB cluster includes one NAT 
gateway per public subnet. For more information, see Internet and service access for VPC-connected 
functions (p. 91).
Conﬁgure your Amazon VPC security groups with the following rules (at minimum):
•Inbound rules
•For the security groups that you specify for your event source, allow all traﬃc on the Amazon 
DocumentDB cluster port (27017).
•(VPC endpoints only) For the security groups associated with your VPC endpoints, allow all traﬃc on 
port 443 from the security groups that you specify for your event source.
•Outbound rules
•For all destinations, allow all traﬃc on port 443.
•For the security groups that you specify for your event source, allow all traﬃc on the Amazon 
DocumentDB cluster port (27017).
Creating an Amazon DocumentDB event source 
mapping (console)
For a Lambda function to read from an Amazon DocumentDB cluster's change stream, create an event 
source mapping (p. 150). This section describes how to do this from the Lambda console. For AWS 
SDK and AWS CLI instructions, see the section called “Creating an Amazon DocumentDB event source 
mapping (SDK or CLI)”  (p. 685).
To create an Amazon DocumentDB event source mapping (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
684AWS Lambda Developer Guide
Creating an Amazon DocumentDB 
event source mapping (SDK or CLI)
3. Under Function overview, choose Add trigger .
4. Under Trigger conﬁguration, in the dropdown list, choose DocumentDB .
5. Conﬁgure the required options, and then choose Add.
Lambda supports the following options for Amazon DocumentDB event sources:
•DocumentDB cluster  – Select an Amazon DocumentDB cluster.
•Activate trigger – Choose whether you want to activate the trigger immediately. If you select 
this check box, then your function immediately starts receiving traﬃc from the speciﬁed Amazon 
DocumentDB change stream upon creation of the event source mapping. We recommend that you 
clear the check box to create the event source mapping in a deactivated state for testing. After 
creation, you can activate the event source mapping at any time.
•Database name  – Enter the name of a database within the cluster to consume.
•(Optional) Collection name – Enter the name of a collection within the database to consume. If you 
don't specify a collection, then Lambda listens to all events from each collection in the database.
•Batch size – Set the maximum number of messages to retrieve in a single batch, up to 10,000. The 
default batch size is 100.
•Starting position – Choose the position in the stream to start reading records from.
•Latest  – Process only new records that are added to the stream. Your function starts processing 
records only after Lambda ﬁnishes creating your event source. This means that some records may be 
dropped until your event source is created successfully.
•Trim horizon – Process all records in the stream. Lambda uses the log retention duration of your 
cluster to determine where to start reading events from. Speciﬁcally, Lambda starts reading from
current_time - log_retention_duration . Your change stream must already be active before 
this timestamp for Lambda to read all events properly.
•At timestamp  – Process records starting from a speciﬁc time. Your change stream must already be 
active before the speciﬁed timestamp for Lambda to read all events properly.
•Authentication  – Choose the authentication method for accessing the brokers in your cluster.
•BASIC_AUTH – With basic authentication, you must provide the Secrets Manager key that contains 
the credentials to access your cluster.
•Secrets Manager key – Choose the Secrets Manager key that contains the authentication details 
(username and password) required to access your Amazon DocumentDB cluster.
•(Optional) Batch window – Set the maximum amount of time in seconds to gather records before 
invoking your function, up to 300.
•(Optional) Full document conﬁguration – For document update operations, choose what you want 
to send to the stream. The default value is Default, which means that for each change stream event, 
Amazon DocumentDB sends only a delta describing the changes made. For more information about 
this ﬁeld, see FullDocument  in the MongoDB Javadoc API documentation.
•Default  – Lambda sends only a partial document describing the changes made.
•UpdateLookup  – Lambda sends a delta describing the changes, along with a copy of the entire 
document.
Creating an Amazon DocumentDB event source 
mapping (SDK or CLI)
To create or manage an Amazon DocumentDB event source mapping with an AWS SDK, you can use the 
following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
685AWS Lambda Developer Guide
Creating an Amazon DocumentDB 
event source mapping (SDK or CLI)
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
Note
When you update, disable, or delete an event source mapping for Amazon DocumentDB, it can 
take up to 15 minutes for your changes to take eﬀect. Before this period has elapsed, your event 
source mapping may continue to process events and invoke your function using your previous 
settings. This is true even when the status of the event source mapping displayed in the console 
indicates that your changes have been applied.
To create the event source mapping with the AWS CLI, use the create-event-source-mapping
command. The following example uses this command to map a function named my-function  to an 
Amazon DocumentDB change stream. The event source is speciﬁed by an Amazon Resource Name (ARN), 
with a batch size of 500, starting from the timestamp in Unix time. The command also speciﬁes the 
Secrets Manager key that Lambda uses to connect to Amazon DocumentDB. Additionally, it includes
document-db-event-source-config  parameters that specify the database and the collection to 
read from.
aws lambda create-event-source-mapping --function-name my-function \ 
    --event-source-arn arn:aws:rds:us-west-2:123456789012:cluster:privatecluster7de2-
epzcyvu4pjoy 
    --batch-size 500 \ 
    --starting-position AT_TIMESTAMP \ 
    --starting-position-timestamp 1541139109 \ 
    --source-access-configurations '[{"Type":"BASIC_AUTH","URI":"arn:aws:secretsmanager:us-
east-1:123456789012:secret:DocDBSecret-BAtjxi"}]' \ 
    --document-db-event-source-config '{"DatabaseName":"test_database", "CollectionName": 
 "test_collection"}' \
You should see output that looks like this:
{ 
    "UUID": "2b733gdc-8ac3-cdf5-af3a-1827b3b11284", 
    "BatchSize": 500, 
    "DocumentDBEventSourceConfig": { 
        "CollectionName": "test_collection", 
        "DatabaseName": "test_database", 
        "FullDocument": "Default" 
    }, 
    "MaximumBatchingWindowInSeconds": 0, 
    "EventSourceArn": "arn:aws:rds:us-west-2:123456789012:cluster:privatecluster7de2-
epzcyvu4pjoy", 
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function", 
    "LastModified": 1541348195.412, 
    "LastProcessingResult": "No records processed", 
    "State": "Creating", 
    "StateTransitionReason": "User action"
}
After creation, you can use the update-event-source-mapping  command to update the settings for 
your Amazon DocumentDB event source. The following example updates the batch size to 1,000 and the 
batch window to 10 seconds. For this command, you need the UUID of your event source mapping, which 
you can retrieve using the list-event-source-mapping  command or the Lambda console.
aws lambda update-event-source-mapping --function-name my-function \ 
    --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b \ 
    --batch-size 1000 \ 
686AWS Lambda Developer Guide
Monitoring your Amazon DocumentDB event source
    --batch-window 10
You should see this output that looks like this:
{ 
    "UUID": "2b733gdc-8ac3-cdf5-af3a-1827b3b11284", 
    "BatchSize": 500, 
    "DocumentDBEventSourceConfig": { 
        "CollectionName": "test_collection", 
        "DatabaseName": "test_database", 
        "FullDocument": "Default" 
    }, 
    "MaximumBatchingWindowInSeconds": 0, 
    "EventSourceArn": "arn:aws:rds:us-west-2:123456789012:cluster:privatecluster7de2-
epzcyvu4pjoy", 
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function", 
    "LastModified": 1541359182.919, 
    "LastProcessingResult": "OK", 
    "State": "Updating", 
    "StateTransitionReason": "User action"
}
Lambda updates settings asynchronously, so you may not see these changes in the output until the 
process completes. To view the current settings of your event source mapping, use the get-event-
source-mapping  command.
aws lambda get-event-source-mapping --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b
You should see this output that looks like this:
{ 
    "UUID": "2b733gdc-8ac3-cdf5-af3a-1827b3b11284", 
    "DocumentDBEventSourceConfig": { 
        "CollectionName": "test_collection", 
        "DatabaseName": "test_database", 
        "FullDocument": "Default" 
    }, 
    "BatchSize": 1000, 
    "MaximumBatchingWindowInSeconds": 10, 
    "EventSourceArn": "arn:aws:rds:us-west-2:123456789012:cluster:privatecluster7de2-
epzcyvu4pjoy", 
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function", 
    "LastModified": 1541359182.919, 
    "LastProcessingResult": "OK", 
    "State": "Enabled", 
    "StateTransitionReason": "User action"
}
To delete your Amazon DocumentDB event source mapping, use the delete-event-source-mapping
command.
aws lambda delete-event-source-mapping \ 
    --uuid 2b733gdc-8ac3-cdf5-af3a-1827b3b11284
Monitoring your Amazon DocumentDB event source
To help you monitor your Amazon DocumentDB event source, Lambda emits the IteratorAge  metric 
when your function ﬁnishes processing a batch of records. Iterator age  is the diﬀerence between the 
687AWS Lambda Developer Guide
Tutorial
timestamp of the most recent event and the current timestamp. Essentially, the IteratorAge  metric 
indicates how old the last processed record in the batch is. If your function is currently processing new 
events, then you can use the iterator age to estimate the latency between when a record is added and 
when your function processes it.
An increasing trend in IteratorAge  can indicate issues with your function. For more information, see
Working with Lambda function metrics (p. 965).
Lambda supports payloads of up to 6 MB. However, Amazon DocumentDB change stream events can 
be up to 16 MB in size. If your change stream tries to send Lambda a change stream event larger than 6 
MB, then Lambda drops the message and emits the OversizedRecordCount  metric. Lambda emits all 
metrics on a best-eﬀort basis.
Tutorial: Using AWS Lambda with Amazon 
DocumentDB Streams
In this tutorial, you create a basic Lambda function that consumes events from an Amazon DocumentDB 
(with MongoDB compatibility) change stream. To complete this tutorial, you will go through the 
following stages:
•Set up your Amazon DocumentDB cluster, connect to it, and activate change streams on it.
•Create your Lambda function, and conﬁgure your Amazon DocumentDB cluster as an event source for 
your function.
•Test the end-to-end setup by inserting items into your Amazon DocumentDB database.
Topics
•Prerequisites (p. 688)
•Create the AWS Cloud9 environment (p. 690)
•Create the EC2 security group (p. 691)
•Create the secret in Secrets Manager (p. 692)
•Create the DocumentDB cluster (p. 693)
•Install the mongo shell  (p. 694)
•Connect to the DocumentDB cluster (p. 695)
•Activate change streams (p. 696)
•Create interface VPC endpoints (p. 697)
•Create the execution role (p. 698)
•Create the Lambda function (p. 700)
•Create the Lambda event source mapping (p. 701)
•Test your function - manual invoke (p. 702)
•Test your function - insert a record (p. 703)
•Test your function - update a record (p. 704)
•Test your function - delete a record (p. 705)
•Clean up your resources (p. 705)
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
688AWS Lambda Developer Guide
Tutorial
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Install the AWS Command Line Interface
If you have not yet installed the AWS Command Line Interface, follow the steps at Installing or updating 
the latest version of the AWS CLI to install it.
The tutorial requires a command line terminal or shell to run commands. In Linux and macOS, use your 
preferred shell and package manager.
689AWS Lambda Developer Guide
Tutorial
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) are 
not supported by the operating system's built-in terminals. To get a Windows-integrated version 
of Ubuntu and Bash, install the Windows Subsystem for Linux.
Create the AWS Cloud9 environment
Before creating the Lambda function, you need to create and conﬁgure your Amazon DocumentDB 
cluster. The steps to set up your cluster in this tutorial is based on the procedure in Get Started with 
Amazon DocumentDB.
Note
If you already have a Amazon DocumentDB cluster set up, ensure that you activate change 
streams and create the necessary interface VPC endpoints. Then, you can skip directly to the 
function creation steps.
First, create an AWS Cloud9 environment. You’ll use this environment throughout this tutorial to connect 
to and query your DocumentDB cluster.
To create an AWS Cloud9 environment
1. Open the Cloud9 console and choose Create environment.
2. Create an environment with the following conﬁguration:
•Under Details :
•Name  – DocumentDBCloud9Environment
•Environment type – New EC2 instance
•Under New EC2 instance:
•Instance type – t2.micro  (1 GiB RAM + 1 vCPU)
•Platform – Amazon Linux 2
•Timeout  – 30 minutes
•Under Network settings:
•Connection – AWS Systems Manager (SSM)
•Expand the VPC settings dropdown.
690AWS Lambda Developer Guide
Tutorial
•Amazon Virtual Private Cloud (VPC) – Choose your default VPC .
•Subnet  – No preference
•Keep all other default settings.
3. Choose Create . Provisioning your new AWS Cloud9 environment can take several minutes.
Create the EC2 security group
Next, create a EC2 security group with rules that allow traﬃc between your DocumentDB cluster and 
your Cloud9 environment.
To create an EC2 security group
1. Open the EC2 console. Under Network and Security, choose Security groups.
2. Choose Create security group.
3. Create a security group with the following conﬁguration:
•Under Basic details :
•Security group name – DocDBTutorial
•Description  – Security group for traﬃc between Cloud9 and DocumentDB.
•VPC – Choose your default VPC .
•Under Inbound rules, choose Add rule. Create a rule with the following conﬁguration:
•Type – Custom TCP
•Port range – 27017
•Source – Custom
•In the search box next to Source, choose the security group for the AWS Cloud9 environment 
you created in the previous step. To see a list of available security groups, enter cloud9  in the 
search box. Choose the security group with the name aws-cloud9-<environment_name> .
•Keep all other default settings.
4. Choose Create security group.
691AWS Lambda Developer Guide
Tutorial
Create the secret in Secrets Manager
To access your DocumentDB cluster manually, you must provide username and password credentials. 
For Lambda to access your cluster, you must provide a Secrets Manager secret that contains these same 
access credentials when setting up your event source mapping. In this step, you’ll create this secret.
To create the secret in Secrets Manager
1. Open the Secrets Manager console and choose Store a new secret .
2. For Choose secret type, choose the following options:
•Under Basic details :
•Secret type – Credentials for Amazon DocumentDB database
•Under Credentials , enter the username and password you’ll use to access your DocumentDB 
cluster.
•Database  – Choose your DocumentDB cluster.
•Choose Next.
3. For Conﬁgure secret , choose the following options:
•Secret name  – DocumentDBSecret
•Choose Next.
4. Choose Next.
5. Choose Store .
6. Refresh the console to verify that you successfully stored the DocumentDBSecret  secret.
Note down the Secret ARN  of your secret. You’ll need it in a later step.
692AWS Lambda Developer Guide
Tutorial
Create the DocumentDB cluster
In this step, you’ll create a DocumentDB cluster using the security group from the previous step.
To create a DocumentDB cluster
1. Open the DocumentDB console. Under Clusters , choose Create .
2. Create a cluster with the following conﬁguration:
•For Cluster type, choose Instance Based Cluster.
•Under Conﬁguration :
•Engine version – 4.0.0
•Instance class – db.t3.medium
•Number of instances – 1.
•Under Authentication :
•Enter the Username  and Password needed to connect to your cluster (same credentials as you 
used to create the secret in the previous step). In Conﬁrm password, conﬁrm your password.
•Toggle on Show advanced settings.
•Under Network settings:
•Virtual Private Cloud (VPC) – Choose your default VPC .
•Subnet group  – default
•VPC security groups – In addition to default (VPC) , choose the DocDBTutorial (VPC)
security group you created in the previous step.
•Keep all other default settings.
3. Choose Create cluster . Provisioning your DocumentDB cluster can take several minutes.
693AWS Lambda Developer Guide
Tutorial
Install the mongo shell
In this step, you’ll install the mongo shell in your Cloud9 environment. The mongo shell is a command-
line utility that you use to connect to and query your DocumentDB cluster.
To install the mongo shell on your Cloud9 environment
1. Open the Cloud9 console. Next to the DocumentDBCloud9Environment  environment you created 
earlier, click on the Open  link under the Cloud9 IDE column.
2. In the terminal window, create the MongoDB repository ﬁle with the following command:
echo -e "[mongodb-org-4.0] \nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/
yum/amazon/2013.03/mongodb-org/4.0/x86_64/\ngpgcheck=1 \nenabled=1 \ngpgkey=https://
www.mongodb.org/static/pgp/server-4.0.asc" | sudo tee /etc/yum.repos.d/mongodb-
org-4.0.repo
3. Then, install the mongo shell with the following command:
sudo yum install -y mongodb-org-shell
4. To encrypt data in transit, download the public key for Amazon DocumentDB. The following 
command downloads a ﬁle named global-bundle.pem :
wget https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
694AWS Lambda Developer Guide
Tutorial
Connect to the DocumentDB cluster
You’re now ready to connect to your DocumentDB cluster using the mongo shell.
To connect to your DocumentDB cluster
1. Open the DocumentDB console. Under Clusters , choose your cluster by choosing its cluster 
identiﬁer.
2. In the Connectivity & security tab, under Connect to this cluster with the mongo shell, choose
Copy.
3. In your Cloud9 environment, paste this command into the terminal. Replace
<insertYourPassword>  with the correct password.
After entering this command, if the command prompt becomes rs0:PRIMARY> , then you’re connected 
to your Amazon DocumentDB cluster.
695AWS Lambda Developer Guide
Tutorial
Activate change streams
For this tutorial, you’ll track changes to the products  collection of the docdbdemo  database in your 
DocumentDB cluster. You do this by activating change streams. First, create the docdbdemo  database 
and test it by inserting a record.
To create a new database within your cluster
1. In your Cloud9 environment, ensure that you’re still connected to your DocumentDB 
cluster  (p. 695).
2. In the terminal window, use the following command to create a new database called docdbdemo :
use docdbdemo
3. Then, use the following command to insert a record into docdbdemo :
db.products.insert({"hello":"world"})
You should see output that looks like this:
WriteResult({ "nInserted" : 1 })
4. Use the following command to list all databases:
show dbs
Ensure that your output contains the docdbdemo  database:
docdbdemo  0.000GB
Next, activate change streams on the products  collection of the docdbdemo  database using the 
following command:
696AWS Lambda Developer Guide
Tutorial
db.adminCommand({modifyChangeStreams: 1, 
    database: "docdbdemo", 
    collection: "products",  
    enable: true});
You should see output that looks like this:
{ "ok" : 1, "operationTime" : Timestamp(1680126165, 1) }
Create interface VPC endpoints
Next, create interface VPC endpoints to ensure that Lambda and Secrets Manager (used later to store our 
cluster access credentials) can connect to your default VPC.
To create interface VPC endpoints
1. Open the VPC console. In the left menu, under Virtual private cloud, choose Endpoints .
2. Choose Create endpoint . Create an endpoint with the following conﬁguration:
•For Name tag , enter lambda-default-vpc .
•For Service category, choose AWS services.
•For Services, enter lambda in the search box. Choose the service with format
com.amazonaws.<region>.lambda .
•For VPC, choose your default VPC .
•For Subnets , check the boxes next to each availability zone. Choose the correct subnet ID for each 
availability zone.
•For IP address type, select IPv4.
•For Security groups, choose the default VPC security group (Group name of default ), and the 
security group you created earlier (Group name of DocDBTutorial ).
•Keep all other default settings.
•Choose Create endpoint .
3. Again, choose Create endpoint . Create an endpoint with the following conﬁguration:
697AWS Lambda Developer Guide
Tutorial
•For Name tag , enter secretsmanager-default-vpc .
•For Service category, choose AWS services.
•For Services, enter secretsmanager  in the search box. Choose the service with format
com.amazonaws.<region>.secretsmanager .
•For VPC, choose your default VPC .
•For Subnets , check the boxes next to each availability zone. Choose the correct subnet ID for each 
availability zone.
•For IP address type, select IPv4.
•For Security groups, choose the default VPC security group (Group name of default ), and the 
security group you created earlier (Group name of DocDBTutorial ).
•Keep all other default settings.
•Choose Create endpoint .
This completes the cluster setup portion of this tutorial.
Create the execution role
In the next set of steps, you’ll create your Lambda function. First, you need to create the execution role 
that gives your function permission to access your cluster. You do this by creating an IAM policy ﬁrst, 
then attaching this policy to an IAM role.
To create IAM policy
1. Open the Policies page in the IAM console and choose Create policy.
2. Choose the JSON tab. In the following policy, replace the Secrets Manager resource ARN in the ﬁnal 
line of the statement with your secret ARN from earlier, and copy the policy into the editor.
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "LambdaESMNetworkingAccess", 
698AWS Lambda Developer Guide
Tutorial
            "Effect": "Allow", 
            "Action": [ 
                "ec2:CreateNetworkInterface", 
                "ec2:DescribeNetworkInterfaces", 
                "ec2:DescribeVpcs", 
                "ec2:DeleteNetworkInterface", 
                "ec2:DescribeSubnets", 
                "ec2:DescribeSecurityGroups", 
                "kms:Decrypt" 
            ], 
            "Resource": "*" 
        }, 
        { 
            "Sid": "LambdaDocDBESMAccess", 
            "Effect": "Allow", 
            "Action": [ 
                "rds:DescribeDBClusters", 
                "rds:DescribeDBClusterParameters", 
                "rds:DescribeDBSubnetGroups" 
            ], 
            "Resource": "*" 
        }, 
        { 
            "Sid": "LambdaDocDBESMGetSecretValueAccess", 
            "Effect": "Allow", 
            "Action": [ 
                "secretsmanager:GetSecretValue" 
            ], 
            "Resource": "arn:aws:secretsmanager:us-
east-1:123456789012:secret:DocumentDBSecret" 
        } 
    ]
}
3. Choose Next: Tags, then choose Next: Review.
4. For Name , enter AWSDocumentDBLambdaPolicy .
5. Choose Create policy.
To create the IAM role
1. Open the Roles page in the IAM console and choose Create role.
2. For Select trusted entity, choose the following options:
•Trusted entity type – AWS service
•Use case  – Lambda
•Choose Next.
3. For Add permissions , choose the AWSDocumentDBLambdaPolicy  policy you just created, as well 
as the AWSLambdaBasicExecutionRole  to give your function permissions to write to Amazon 
CloudWatch Logs.
4. Choose Next.
5. For Role name, enter AWSDocumentDBLambdaExecutionRole .
6. Choose Create role.
699AWS Lambda Developer Guide
Tutorial
Create the Lambda function
The following example code receives a DocumentDB event input and processes the message that it 
contains.
console.log('Loading function');
exports.handler = async (event, context) =>  
{ 
    console.log('Received event:', JSON.stringify(event, null, 2)); 
    return 'OK';
};
To create the Lambda function
1. Copy the sample code into a ﬁle named index.js .
2. Create a deployment package with the following command.
zip function.zip index.js
3. Use the following CLI command to create the function. Replace us-east-1  with the region, and
123456789012  with your account ID.
aws lambda create-function --function-name ProcessDocumentDBRecords \ 
    --zip-file fileb://function.zip --handler index.handler --runtime nodejs16.x \ 
    --region us-east-1 \ 
    --role arn:aws:iam::123456789012:role/AWSDocumentDBLambdaExecutionRole
700AWS Lambda Developer Guide
Tutorial
Create the Lambda event source mapping
Create the event source mapping that associates your DocumentDB change stream with your Lambda 
function. After you create this event source mapping, AWS Lambda immediately starts polling the 
stream.
To create the event source mapping
1. Open the Functions page in the Lambda console.
2. Choose the ProcessDocumentDBRecords  function you created earlier.
3. Choose the Conﬁguration  tab, then choose Triggers in the left menu.
4. Choose Add trigger .
5. Under Trigger conﬁguration, for the source, select DocumentDB .
6. Create the event source mapping with the following conﬁguration:
•DocumentDB cluster  – Choose the cluster you created earlier.
•Database name  – docdbdemo
•Collection name – products
•Batch size – 1
•Starting position – Latest
•Authentication  – BASIC_AUTH
•Secrets Manager key – Choose the DocumentDBSecret  you just created.
•Batch window – 1
•Full document conﬁguration – UpdateLookup
7. Choose Add. Creating your event source mapping can take a few minutes.
701AWS Lambda Developer Guide
Tutorial
Test your function - manual invoke
To test that you created your function and event source mapping correctly, invoke your function using 
the invoke command. To do this, ﬁrst copy the following event JSON into a ﬁle called input.txt :
{ 
  "eventSourceArn": "arn:aws:rds:us-east-1:123456789012:cluster:canaryclusterb2a659a2-
qo5tcmqkcl03", 
  "events": [ 
    { 
      "event": { 
        "_id": { 
          "_data": "0163eeb6e7000000090100000009000041e1" 
        }, 
        "clusterTime": { 
          "$timestamp": { 
            "t": 1676588775, 
            "i": 9 
          } 
        }, 
        "documentKey": { 
          "_id": { 
            "$oid": "63eeb6e7d418cd98afb1c1d7" 
          } 
        }, 
        "fullDocument": { 
          "_id": { 
            "$oid": "63eeb6e7d418cd98afb1c1d7" 
          }, 
          "anyField": "sampleValue" 
        }, 
        "ns": { 
          "db": "docdbdemo", 
          "coll": "products" 
        }, 
        "operationType": "insert" 
      } 
    } 
  ], 
702AWS Lambda Developer Guide
Tutorial
  "eventSource": "aws:docdb"
}
Then, use the following command to invoke your function with this event:
aws lambda invoke --function-name ProcessDocumentDBRecords \ 
    --cli-binary-format raw-in-base64-out \ 
    --region us-east-1 \ 
    --payload file://input.txt out.txt
You should see a response that looks like the following:
{ 
   "StatusCode": 200, 
   "ExecutedVersion": "$LATEST"
}
You can verify that your function successfully processed the event by checking CloudWatch Logs.
To verify manual invocation via CloudWatch Logs
1. Open the Functions page in the Lambda console.
2. Choose the Monitor  tab, then choose View CloudWatch logs. This takes you to the speciﬁc log 
group associated with your function in the CloudWatch console.
3. Choose the most recent log stream. Within the log messages, you should see the event JSON.
Test your function - insert a record
Test your end-to-end setup by interacting directly with your DocumentDB database. In the next set of 
steps, you’ll insert a record, update it, then delete it.
To insert a record
1. Reconnect to your DocumentDB cluster (p. 695) in your Cloud9 environment.
703AWS Lambda Developer Guide
Tutorial
2. Use this command to ensure that you’re currently using the docdbdemo  database:
use docdbdemo
3. Insert a record into the products  collection of the docdbdemo  database:
db.products.insert({"name":"Pencil", "price": 1.00})
Test your function - update a record
Next, update the record you just inserted with the following command:
db.products.update( 
    { "name": "Pencil" }, 
    { $set: { "price": 0.50 }}
)
Verify that your function successfully processed this event by checking CloudWatch Logs.
704AWS Lambda Developer Guide
Tutorial
Test your function - delete a record
Finally, delete the record you just updated with the following command:
db.products.remove( { "name": "Pencil" } )
Verify that your function successfully processed this event by checking CloudWatch Logs.
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the VPC endpoints
1. Open the VPC console. In the left menu, under Virtual private cloud, choose Endpoints .
2. Select the endpoints you created.
705AWS Lambda Developer Guide
Tutorial
3. Choose Actions, Delete VPC endpoints.
4. Enter delete in the text input ﬁeld.
5. Choose Delete.
To delete the Amazon DocumentDB cluster
1. Open the DocumentDB console.
2. Choose the DocumentDB cluster you created for this tutorial, and disable deletion protection.
3. In the main Clusters  page, choose your DocumentDB cluster again.
4. Choose Actions, Delete.
5. For Create ﬁnal cluster snapshot , select No.
6. Enter delete in the text input ﬁeld.
7. Choose Delete.
To delete the secret in Secrets Manager
1. Open the Secrets Manager console.
2. Choose the secret you created for this tutorial.
3. Choose Actions, Delete secret.
4. Choose Schedule deletion.
To delete the Amazon EC2 security group
1. Open the EC2 console. Under Network and Security, choose Security groups.
2. Select the security group you created for this tutorial.
3. Choose Actions, Delete security groups.
4. Choose Delete.
To delete the Cloud9 environment
1. Open the Cloud9 console.
2. Select the environment you created for this tutorial.
3. Choose Delete.
4. Enter delete in the text input ﬁeld.
5. Choose Delete.
706AWS Lambda Developer Guide
DynamoDB
Using AWS Lambda with Amazon DynamoDB
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
You can use an AWS Lambda function to process records in an Amazon DynamoDB stream. With 
DynamoDB Streams, you can trigger a Lambda function to perform additional work each time a 
DynamoDB table is updated.
Lambda reads records from the stream and invokes your function synchronously (p. 139) with an event 
that contains stream records. Lambda reads records in batches and invokes your function to process 
records from the batch.
Sections
•Example event (p. 707)
•Polling and batching streams (p. 708)
•Simultaneous readers of a shard in DynamoDB Streams (p. 709)
•Execution role permissions (p. 709)
•Conﬁguring a stream as an event source (p. 709)
•Event source mapping APIs (p. 710)
•Error handling (p. 712)
•Amazon CloudWatch metrics (p. 713)
•Time windows (p. 713)
•Reporting batch item failures (p. 717)
•Amazon DynamoDB Streams conﬁguration parameters (p. 719)
•Tutorial: Using AWS Lambda with Amazon DynamoDB streams (p. 720)
•Sample function code (p. 725)
•AWS SAM template for a DynamoDB application (p. 728)
Example event
Example
{ 
  "Records": [ 
    { 
      "eventID": "1", 
      "eventVersion": "1.0", 
      "dynamodb": { 
        "Keys": { 
          "Id": { 
            "N": "101" 
          } 
        }, 
        "NewImage": { 
          "Message": { 
            "S": "New item!" 
          }, 
          "Id": { 
            "N": "101" 
          } 
        }, 
        "StreamViewType": "NEW_AND_OLD_IMAGES", 
707AWS Lambda Developer Guide
Polling and batching streams
        "SequenceNumber": "111", 
        "SizeBytes": 26 
      }, 
      "awsRegion": "us-west-2", 
      "eventName": "INSERT", 
      "eventSourceARN": "arn:aws:dynamodb:us-west-2:111122223333:table/TestTable/
stream/2015-05-11T21:21:33.291", 
      "eventSource": "aws:dynamodb" 
    }, 
    { 
      "eventID": "2", 
      "eventVersion": "1.0", 
      "dynamodb": { 
        "OldImage": { 
          "Message": { 
            "S": "New item!" 
          }, 
          "Id": { 
            "N": "101" 
          } 
        }, 
        "SequenceNumber": "222", 
        "Keys": { 
          "Id": { 
            "N": "101" 
          } 
        }, 
        "SizeBytes": 59, 
        "NewImage": { 
          "Message": { 
            "S": "This item has changed" 
          }, 
          "Id": { 
            "N": "101" 
          } 
        }, 
        "StreamViewType": "NEW_AND_OLD_IMAGES" 
      }, 
      "awsRegion": "us-west-2", 
      "eventName": "MODIFY", 
      "eventSourceARN": "arn:aws:dynamodb:us-west-2:111122223333:table/TestTable/
stream/2015-05-11T21:21:33.291", 
      "eventSource": "aws:dynamodb" 
    } 
  ]}
Polling and batching streams
Lambda polls shards in your DynamoDB stream for records at a base rate of 4 times per second. When 
records are available, Lambda invokes your function and waits for the result. If processing succeeds, 
Lambda resumes polling until it receives more records.
By default, Lambda invokes your function as soon as records are available. If the batch that Lambda 
reads from the event source has only one record in it, Lambda sends only one record to the function. 
To avoid invoking the function with a small number of records, you can tell the event source to 
buﬀer records for up to 5 minutes by conﬁguring a batching window . Before invoking the function, 
Lambda continues to read records from the event source until it has gathered a full batch, the batching 
window expires, or the batch reaches the payload limit of 6 MB. For more information, see Batching 
behavior (p. 151).
If your function returns an error, Lambda retries the batch until processing succeeds or the data expires. 
To avoid stalled shards, you can conﬁgure the event source mapping to retry with a smaller batch size, 
708AWS Lambda Developer Guide
Simultaneous readers
limit the number of retries, or discard records that are too old. To retain discarded events, you can 
conﬁgure the event source mapping to send details about failed batches to a standard SQS queue or 
standard SNS topic.
You can also increase concurrency by processing multiple batches from each shard in parallel. Lambda 
can process up to 10 batches in each shard simultaneously. If you increase the number of concurrent 
batches per shard, Lambda still ensures in-order processing at the partition key level.
Conﬁgure the ParallelizationFactor  setting to process one shard of a Kinesis or DynamoDB 
data stream with more than one Lambda invocation simultaneously. You can specify the number 
of concurrent batches that Lambda polls from a shard via a parallelization factor from 1 (default) 
to 10. For example, when you set ParallelizationFactor  to 2, you can have 200 concurrent 
Lambda invocations at maximum to process 100 Kinesis data shards. This helps scale up the processing 
throughput when the data volume is volatile and the IteratorAge  is high. Note that parallelization 
factor will not work if you are using Kinesis aggregation. For more information, see New AWS Lambda 
scaling controls for Kinesis and DynamoDB event sources. Also, see the Serverless Data Processing on 
AWS workshop for complete tutorials.
Simultaneous readers of a shard in DynamoDB 
Streams
For single-Region tables that are not global tables, you can design for up to two Lambda functions to 
read from the same DynamoDB Streams shard at the same time. Exceeding this limit can result in request 
throttling. For global tables, we recommend you limit the number of simultaneous functions to one to 
avoid request throttling.
Execution role permissions
Lambda needs the following permissions to manage resources related to your DynamoDB stream. Add 
them to your function's execution role.
•dynamodb:DescribeStream
•dynamodb:GetRecords
•dynamodb:GetShardIterator
•dynamodb:ListStreams
The AWSLambdaDynamoDBExecutionRole  managed policy includes these permissions. For more 
information, see Lambda execution role (p. 913).
To send records of failed batches to a standard SQS queue or standard SNS topic, your function needs 
additional permissions. Each destination service requires a diﬀerent permission, as follows:
•Amazon SQS – sqs:SendMessage
•Amazon SNS – sns:Publish
Conﬁguring a stream as an event source
Create an event source mapping to tell Lambda to send records from your stream to a Lambda function. 
You can create multiple event source mappings to process the same data with multiple Lambda 
functions, or to process items from multiple streams with a single function.
To conﬁgure your function to read from DynamoDB Streams in the Lambda console, create a DynamoDB
trigger.
709AWS Lambda Developer Guide
Event source mapping APIs
To create a trigger
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Under Function overview, choose Add trigger .
4. Choose a trigger type.
5. Conﬁgure the required options, and then choose Add.
Lambda supports the following options for DynamoDB event sources.
Event source options
•DynamoDB table – The DynamoDB table to read records from.
•Batch size – The number of records to send to the function in each batch, up to 10,000. Lambda 
passes all of the records in the batch to the function in a single call, as long as the total size of the 
events doesn't exceed the payload limit (p. 1269 ) for synchronous invocation (6 MB).
•Batch window – Specify the maximum amount of time to gather records before invoking the function, 
in seconds.
•Starting position – Process only new records, or all existing records.
•Latest  – Process new records that are added to the stream.
•Trim horizon – Process all records in the stream.
After processing any existing records, the function is caught up and continues to process new records.
•On-failure destination  – A standard SQS queue or standard SNS topic for records that can't be 
processed. When Lambda discards a batch of records that's too old or has exhausted all retries, 
Lambda sends details about the batch to the queue or topic.
•Retry attempts – The maximum number of times that Lambda retries when the function returns an 
error. This doesn't apply to service errors or throttles where the batch didn't reach the function.
•Maximum age of record – The maximum age of a record that Lambda sends to your function.
•Split batch on error  – When the function returns an error, split the batch into two before retrying. 
Your original batch size setting remains unchanged.
•Concurrent batches per shard  – Concurrently process multiple batches from the same shard.
•Enabled – Set to true to enable the event source mapping. Set to false to stop processing records. 
Lambda keeps track of the last record processed and resumes processing from that point when the 
mapping is reenabled.
Note
You are not charged for GetRecords API calls invoked by Lambda as part of DynamoDB triggers.
To manage the event source conﬁguration later, choose the trigger in the designer.
Event source mapping APIs
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
710AWS Lambda Developer Guide
Event source mapping APIs
The following example uses the AWS CLI to map a function named my-function  to a DynamoDB 
stream that its Amazon Resource Name (ARN) speciﬁes, with a batch size of 500.
aws lambda create-event-source-mapping --function-name my-function --batch-size 500 --
maximum-batching-window-in-seconds 5 --starting-position LATEST \
--event-source-arn arn:aws:dynamodb: us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525
You should see the following output:
{ 
    "UUID": "14e0db71-5d35-4eb5-b481-8945cf9d10c2", 
    "BatchSize": 500, 
    "MaximumBatchingWindowInSeconds": 5, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:dynamodb:us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1560209851.963, 
    "LastProcessingResult": "No records processed", 
    "State": "Creating", 
    "StateTransitionReason": "User action", 
    "DestinationConfig": {}, 
    "MaximumRecordAgeInSeconds": 604800, 
    "BisectBatchOnFunctionError": false, 
    "MaximumRetryAttempts": 10000
}
Conﬁgure additional options to customize how batches are processed and to specify when to discard 
records that can't be processed. The following example updates an event source mapping to send a 
failure record to a standard SQS queue after two retry attempts, or if the records are more than an hour 
old.
aws lambda update-event-source-mapping --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b \
--maximum-retry-attempts 2  --maximum-record-age-in-seconds 3600
--destination-config '{"OnFailure": {"Destination": "arn:aws:sqs:us-
east-2:123456789012:dlq"}}'
You should see this output:
{ 
    "UUID": "f89f8514-cdd9-4602-9e1f-01a5b77d449b", 
    "BatchSize": 100, 
    "MaximumBatchingWindowInSeconds": 0, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:dynamodb:us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1573243620.0, 
    "LastProcessingResult": "PROBLEM: Function call failed", 
     "State": "Updating", 
    "StateTransitionReason": "User action",
    "DestinationConfig": {}, 
    "MaximumRecordAgeInSeconds": 604800, 
    "BisectBatchOnFunctionError": false, 
    "MaximumRetryAttempts": 10000
}
Updated settings are applied asynchronously and aren't reﬂected in the output until the process 
completes. Use the get-event-source-mapping  command to view the current status.
711AWS Lambda Developer Guide
Error handling
aws lambda get-event-source-mapping --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b
You should see this output:
{ 
    "UUID": "f89f8514-cdd9-4602-9e1f-01a5b77d449b", 
    "BatchSize": 100, 
    "MaximumBatchingWindowInSeconds": 0, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:dynamodb:us-east-2:123456789012:table/my-table/
stream/2019-06-10T19:26:16.525", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1573244760.0, 
    "LastProcessingResult": "PROBLEM: Function call failed", 
    "State": "Enabled", 
    "StateTransitionReason": "User action", 
     "DestinationConfig": { 
        "OnFailure": { 
            "Destination": "arn:aws:sqs:us-east-2:123456789012:dlq" 
        } 
    }, 
    "MaximumRecordAgeInSeconds": 3600,
    "BisectBatchOnFunctionError": false, 
     "MaximumRetryAttempts": 2
}
To process multiple batches concurrently, use the --parallelization-factor  option.
aws lambda update-event-source-mapping --uuid 2b733gdc-8ac3-cdf5-af3a-1827b3b11284 \
--parallelization-factor 5
Error handling
The event source mapping that reads records from your DynamoDB stream, invokes your function 
synchronously, and retries on errors. If Lambda throttles the function or returns an error without 
invoking the function, Lambda retries until the records expire or exceed the maximum age that you 
conﬁgure on the event source mapping.
If the function receives the records but returns an error, Lambda retries until the records in the batch 
expire, exceed the maximum age, or reach the conﬁgured retry quota. For function errors, you can also 
conﬁgure the event source mapping to split a failed batch into two batches. Retrying with smaller 
batches isolates bad records and works around timeout issues. Splitting a batch does not count towards 
the retry quota.
If the error handling measures fail, Lambda discards the records and continues processing batches from 
the stream. With the default settings, this means that a bad record can block processing on the aﬀected 
shard for up to one day. To avoid this, conﬁgure your function's event source mapping with a reasonable 
number of retries and a maximum record age that ﬁts your use case.
To retain a record of discarded batches, conﬁgure a failed-event destination. Lambda sends a document 
to the destination queue or topic with details about the batch.
To conﬁgure a destination for failed-event records
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Under Function overview, choose Add destination .
4. For Source, choose Stream invocation.
712AWS Lambda Developer Guide
Amazon CloudWatch metrics
5. For Stream , choose a stream that is mapped to the function.
6. For Destination type, choose the type of resource that receives the invocation record.
7. For Destination , choose a resource.
8. Choose Save.
The following example shows an invocation record for a DynamoDB stream.
Example Invocation Record
{ 
    "requestContext": { 
        "requestId": "316aa6d0-8154-xmpl-9af7-85d5f4a6bc81", 
        "functionArn": "arn:aws:lambda:us-east-2:123456789012:function:myfunction", 
        "condition": "RetryAttemptsExhausted", 
        "approximateInvokeCount": 1 
    }, 
    "responseContext": { 
        "statusCode": 200, 
        "executedVersion": "$LATEST", 
        "functionError": "Unhandled" 
    }, 
    "version": "1.0", 
    "timestamp": "2019-11-14T00:13:49.717Z", 
    "DDBStreamBatchInfo": { 
        "shardId": "shardId-00000001573689847184-864758bb", 
        "startSequenceNumber": "800000000003126276362", 
        "endSequenceNumber": "800000000003126276362", 
        "approximateArrivalOfFirstRecord": "2019-11-14T00:13:19Z", 
        "approximateArrivalOfLastRecord": "2019-11-14T00:13:19Z", 
        "batchSize": 1, 
        "streamArn": "arn:aws:dynamodb:us-east-2:123456789012:table/mytable/
stream/2019-11-14T00:04:06.388" 
    }
}
You can use this information to retrieve the aﬀected records from the stream for troubleshooting. The 
actual records aren't included, so you must process this record and retrieve them from the stream before 
they expire and are lost.
Amazon CloudWatch metrics
Lambda emits the IteratorAge  metric when your function ﬁnishes processing a batch of records. The 
metric indicates how old the last record in the batch was when processing ﬁnished. If your function is 
processing new events, you can use the iterator age to estimate the latency between when a record is 
added and when the function processes it.
An increasing trend in iterator age can indicate issues with your function. For more information, see
Working with Lambda function metrics (p. 965).
Time windows
Lambda functions can run continuous stream processing applications. A stream represents unbounded 
data that ﬂows continuously through your application. To analyze information from this continuously 
updating input, you can bound the included records using a window deﬁned in terms of time.
Tumbling windows are distinct time windows that open and close at regular intervals. By default, 
Lambda invocations are stateless—you cannot use them for processing data across multiple continuous 
invocations without an external database. However, with tumbling windows, you can maintain your state 
713AWS Lambda Developer Guide
Time windows
across invocations. This state contains the aggregate result of the messages previously processed for 
the current window. Your state can be a maximum of 1 MB per shard. If it exceeds that size, Lambda 
terminates the window early.
Each record in a stream belongs to a speciﬁc window. Lambda will process each record at least once, but 
doesn't guarantee that each record will be processed only once. In rare cases, such as error handling, 
some records might be processed more than once. Records are always processed in order the ﬁrst time. If 
records are processed more than once, they might be processed out of order.
Aggregation and processing
Your user managed function is invoked both for aggregation and for processing the ﬁnal results of 
that aggregation. Lambda aggregates all records received in the window. You can receive these records 
in multiple batches, each as a separate invocation. Each invocation receives a state. Thus, when using 
tumbling windows, your Lambda function response must contain a state property. If the response does 
not contain a state property, Lambda considers this a failed invocation. To satisfy this condition, your 
function can return a TimeWindowEventResponse  object, which has the following JSON shape:
Example TimeWindowEventResponse  values
{ 
    "state": { 
        "1": 282, 
        "2": 715 
    }, 
    "batchItemFailures": []
}
Note
For Java functions, we recommend using a Map<String, String>  to represent the state.
At the end of the window, the ﬂag isFinalInvokeForWindow  is set to true  to indicate that this is 
the ﬁnal state and that it’s ready for processing. After processing, the window completes and your ﬁnal 
invocation completes, and then the state is dropped.
At the end of your window, Lambda uses ﬁnal processing for actions on the aggregation results. Your 
ﬁnal processing is synchronously invoked. After successful invocation, your function checkpoints the 
sequence number and stream processing continues. If invocation is unsuccessful, your Lambda function 
suspends further processing until a successful invocation.
Example DynamodbTimeWindowEvent
{ 
   "Records":[ 
      { 
         "eventID":"1", 
         "eventName":"INSERT", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "NewImage":{ 
               "Message":{ 
                  "S":"New item!" 
               }, 
714AWS Lambda Developer Guide
Time windows
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"111", 
            "SizeBytes":26, 
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      }, 
      { 
         "eventID":"2", 
         "eventName":"MODIFY", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "NewImage":{ 
               "Message":{ 
                  "S":"This item has changed" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "OldImage":{ 
               "Message":{ 
                  "S":"New item!" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"222", 
            "SizeBytes":59, 
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      }, 
      { 
         "eventID":"3", 
         "eventName":"REMOVE", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "OldImage":{ 
               "Message":{ 
                  "S":"This item has changed" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"333", 
            "SizeBytes":38, 
715AWS Lambda Developer Guide
Time windows
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      } 
   ], 
    "window": { 
        "start": "2020-07-30T17:00:00Z", 
        "end": "2020-07-30T17:05:00Z" 
    }, 
    "state": { 
        "1": "state1" 
    }, 
    "shardId": "shard123456789", 
    "eventSourceARN": "stream-ARN", 
    "isFinalInvokeForWindow": false, 
    "isWindowTerminatedEarly": false
}
Conﬁguration
You can conﬁgure tumbling windows when you create or update an event source mapping (p. 150). To 
conﬁgure a tumbling window, specify the window in seconds. The following example AWS Command 
Line Interface (AWS CLI) command creates a streaming event source mapping that has a tumbling 
window of 120 seconds. The Lambda function deﬁned for aggregation and processing is named
tumbling-window-example-function .
aws lambda create-event-source-mapping --event-source-arn arn:aws:dynamodb:us-
east-1:123456789012:stream/lambda-stream --function-name "arn:aws:lambda:us-
east-1:123456789018:function:tumbling-window-example-function" --region us-east-1 --
starting-position TRIM_HORIZON --tumbling-window-in-seconds 120
Lambda determines tumbling window boundaries based on the time when records were inserted 
into the stream. All records have an approximate timestamp available that Lambda uses in boundary 
determinations.
Tumbling window aggregations do not support resharding. When the shard ends, Lambda considers the 
window closed, and the child shards start their own window in a fresh state.
Tumbling windows fully support the existing retry policies maxRetryAttempts  and maxRecordAge .
Example Handler.py – Aggregation and processing
The following Python function demonstrates how to aggregate and then process your ﬁnal state:
def lambda_handler(event, context): 
    print('Incoming event: ', event) 
    print('Incoming state: ', event['state'])
#Check if this is the end of the window to either aggregate or process. 
    if event['isFinalInvokeForWindow']: 
        # logic to handle final state of the window 
        print('Destination invoke') 
    else: 
        print('Aggregate invoke')
#Check for early terminations 
    if event['isWindowTerminatedEarly']: 
        print('Window terminated early') 
    #Aggregation logic 
    state = event['state'] 
    for record in event['Records']: 
716AWS Lambda Developer Guide
Reporting batch item failures
        state[record['dynamodb']['NewImage']['Id']] = state.get(record['dynamodb']
['NewImage']['Id'], 0) + 1 
    print('Returning state: ', state) 
    return {'state': state}
Reporting batch item failures
When consuming and processing streaming data from an event source, by default Lambda checkpoints 
to the highest sequence number of a batch only when the batch is a complete success. Lambda treats 
all other results as a complete failure and retries processing the batch up to the retry limit. To allow 
for partial successes while processing batches from a stream, turn on ReportBatchItemFailures . 
Allowing partial successes can help to reduce the number of retries on a record, though it doesn’t 
entirely prevent the possibility of retries in a successful record.
To turn on ReportBatchItemFailures , include the enum value ReportBatchItemFailures  in the
FunctionResponseTypes  list. This list indicates which response types are enabled for your function. 
You can conﬁgure this list when you create or update an event source mapping (p. 150).
Report syntax
When conﬁguring reporting on batch item failures, the StreamsEventResponse  class is returned with 
a list of batch item failures. You can use a StreamsEventResponse  object to return the sequence 
number of the ﬁrst failed record in the batch. You can also create your own custom class using the 
correct response syntax. The following JSON structure shows the required response syntax:
{  
  "batchItemFailures": [  
        { 
            "itemIdentifier": "<id>" 
        } 
    ]
}
Note
If the batchItemFailures  array contains multiple items, Lambda uses the record with the 
lowest sequence number as the checkpoint. Lambda then retries all records starting from that 
checkpoint.
Success and failure conditions
Lambda treats a batch as a complete success if you return any of the following:
•An empty batchItemFailure  list
•A null batchItemFailure  list
•An empty EventResponse
•A null EventResponse
Lambda treats a batch as a complete failure if you return any of the following:
•An empty string itemIdentifier
•A null itemIdentifier
•An itemIdentifier  with a bad key name
Lambda retries failures based on your retry strategy.
717AWS Lambda Developer Guide
Reporting batch item failures
Bisecting a batch
If your invocation fails and BisectBatchOnFunctionError  is turned on, the batch is bisected 
regardless of your ReportBatchItemFailures  setting.
When a partial batch success response is received and both BisectBatchOnFunctionError  and
ReportBatchItemFailures  are turned on, the batch is bisected at the returned sequence number and 
Lambda retries only the remaining records.
Java
Example Handler.java – return new StreamsEventResponse()
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.DynamodbEvent;
import com.amazonaws.services.lambda.runtime.events.StreamsEventResponse;
import com.amazonaws.services.lambda.runtime.events.models.dynamodb.StreamRecord;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
public class ProcessDynamodbRecords implements RequestHandler<DynamodbEvent, 
 Serializable> { 
    @Override 
    public StreamsEventResponse handleRequest(DynamodbEvent input, Context context) { 
        List<StreamsEventResponse.BatchItemFailure> batchItemFailures = new 
 ArrayList<>(); 
        String curRecordSequenceNumber = ""; 
        for (DynamodbEvent.DynamodbStreamRecord dynamodbStreamRecord : 
 input.getRecords()) { 
          try { 
                //Process your record 
                StreamRecord dynamodbRecord = dynamodbStreamRecord.getDynamodb(); 
                curRecordSequenceNumber = dynamodbRecord.getSequenceNumber(); 
                 
            } catch (Exception e) { 
                /* Since we are working with streams, we can return the failed item 
 immediately. 
                   Lambda will immediately begin to retry processing from this failed 
 item onwards. */ 
                batchItemFailures.add(new 
 StreamsEventResponse.BatchItemFailure(curRecordSequenceNumber)); 
                return new StreamsEventResponse(batchItemFailures); 
            } 
        } 
        
       return new StreamsEventResponse();    
    }
}
Python
Example Handler.py – return batchItemFailures[]
def handler(event, context): 
    records = event.get("Records") 
    curRecordSequenceNumber = ""; 
718AWS Lambda Developer Guide
Amazon DynamoDB Streams conﬁguration parameters
    
    for record in records: 
        try: 
            # Process your record 
            curRecordSequenceNumber = record["dynamodb"]["SequenceNumber"] 
        except Exception as e: 
            # Return failed record's sequence number 
            return {"batchItemFailures":[{"itemIdentifier": curRecordSequenceNumber}]} 
    return {"batchItemFailures":[]}
Amazon DynamoDB Streams conﬁguration 
parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
DynamoDB Streams.
Event source parameters that apply to DynamoDB Streams
Parameter Required Default Notes
BatchSize N 100 Maximum: 10,000
BisectBatchOnFunctionErrorN false
DestinationConﬁg N Standard Amazon SQS 
queue or standard 
Amazon SNS topic 
destination for 
discarded records
Enabled N true
EventSourceArn Y   ARN of the data stream 
or a stream consumer
FilterCriteria N
FunctionName Y
MaximumBatchingWindowInSeconds N 0
MaximumRecordAgeInSecondsN -1 -1 means inﬁnite: failed 
records are retried until 
the record expires
Minimum: -1
Maximum: 604800
MaximumRetryAttemptsN -1 -1 means inﬁnite: failed 
records are retried until 
the record expires
Minimum: -1
Maximum: 604800
719AWS Lambda Developer Guide
Tutorial
ParameterRequired Default Notes
ParallelizationFactor N 1 Maximum: 10
StartingPosition Y TRIM_HORIZON or 
LATEST
TumblingWindowInSecondsN Minimum: 0
Maximum: 900
Tutorial: Using AWS Lambda with Amazon 
DynamoDB streams
In this tutorial, you create a Lambda function to consume events from an Amazon DynamoDB stream.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role
Create the execution role (p. 913) that gives your function permission to access AWS resources.
To create an execution role
1. Open the roles page in the IAM console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – Lambda.
•Permissions – AWSLambdaDynamoDBExecutionRole.
720AWS Lambda Developer Guide
Tutorial
•Role name – lambda-dynamodb-role .
The AWSLambdaDynamoDBExecutionRole has the permissions that the function needs to read items 
from DynamoDB and write logs to CloudWatch Logs.
Create the function
The following example code receives a DynamoDB event input and processes the messages that it 
contains. For illustration, the code writes some of the incoming event data to CloudWatch Logs.
Note
For sample code in other languages, see Sample function code (p. 725).
Example index.mjs
console.log('Loading function');
export const handler = (event, context, callback) => { 
    console.log(JSON.stringify(event, null, 2)); 
    event.Records.forEach(record => { 
        console.log(record.eventID); 
        console.log(record.eventName); 
        console.log(`DynamoDB Record: ${JSON.stringify(record.dynamodb)}`); 
    }); 
    callback(null, "message");
};
To create the function
1. Copy the sample code into a ﬁle named index.mjs .
2. Create a deployment package.
zip function.zip index.mjs
3. Create a Lambda function with the create-function  command.
aws lambda create-function --function-name ProcessDynamoDBRecords \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: 111122223333 :role/lambda-dynamodb-role
Test the Lambda function
In this step, you invoke your Lambda function manually using the invoke AWS Lambda CLI command 
and the following sample DynamoDB event.
Example input.txt
{ 
   "Records":[ 
      { 
         "eventID":"1", 
         "eventName":"INSERT", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
721AWS Lambda Developer Guide
Tutorial
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "NewImage":{ 
               "Message":{ 
                  "S":"New item!" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"111", 
            "SizeBytes":26, 
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      }, 
      { 
         "eventID":"2", 
         "eventName":"MODIFY", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "NewImage":{ 
               "Message":{ 
                  "S":"This item has changed" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "OldImage":{ 
               "Message":{ 
                  "S":"New item!" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"222", 
            "SizeBytes":59, 
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      }, 
      { 
         "eventID":"3", 
         "eventName":"REMOVE", 
         "eventVersion":"1.0", 
         "eventSource":"aws:dynamodb", 
         "awsRegion":"us-east-1", 
         "dynamodb":{ 
            "Keys":{ 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "OldImage":{ 
               "Message":{ 
722AWS Lambda Developer Guide
Tutorial
                  "S":"This item has changed" 
               }, 
               "Id":{ 
                  "N":"101" 
               } 
            }, 
            "SequenceNumber":"333", 
            "SizeBytes":38, 
            "StreamViewType":"NEW_AND_OLD_IMAGES" 
         }, 
         "eventSourceARN":"stream-ARN" 
      } 
   ]
}
Run the following invoke command.
aws lambda invoke --function-name ProcessDynamoDBRecords \
--cli-binary-format raw-in-base64-out \
--payload file://input.txt outputfile.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
The function returns the string message in the response body.
Verify the output in the outputfile.txt  ﬁle.
Create a DynamoDB table with a stream enabled
Create an Amazon DynamoDB table with a stream enabled.
To create a DynamoDB table
1. Open the DynamoDB console.
2. Choose Create table.
3. Create a table with the following settings.
•Table name – lambda-dynamodb-stream
•Primary key – id (string)
4. Choose Create .
To enable streams
1. Open the DynamoDB console.
2. Choose Tables.
3. Choose the lambda-dynamodb-stream  table.
4. Under Exports and streams, choose DynamoDB stream details .
5. Choose Enable.
6. Choose Enable stream.
Write down the stream ARN. You need this in the next step when you associate the stream with 
your Lambda function. For more information on enabling streams, see Capturing table activity with 
DynamoDB Streams.
723AWS Lambda Developer Guide
Tutorial
Add an event source in AWS Lambda
Create an event source mapping in AWS Lambda. This event source mapping associates the DynamoDB 
stream with your Lambda function. After you create this event source mapping, AWS Lambda starts 
polling the stream.
Run the following AWS CLI create-event-source-mapping  command. After the command runs, 
note down the UUID. You'll need this UUID to refer to the event source mapping in any commands, for 
example, when deleting the event source mapping.
aws lambda create-event-source-mapping --function-name ProcessDynamoDBRecords \ 
 --batch-size 100 --starting-position LATEST --event-source DynamoDB-stream-arn
This creates a mapping between the speciﬁed DynamoDB stream and the Lambda function. You can 
associate a DynamoDB stream with multiple Lambda functions, and associate the same Lambda function 
with multiple streams. However, the Lambda functions will share the read throughput for the stream 
they share.
You can get the list of event source mappings by running the following command.
aws lambda list-event-source-mappings
The list returns all of the event source mappings you created, and for each mapping it shows the
LastProcessingResult , among other things. This ﬁeld is used to provide an informative message if 
there are any problems. Values such as No records processed  (indicates that AWS Lambda has not 
started polling or that there are no records in the stream) and OK (indicates AWS Lambda successfully 
read records from the stream and invoked your Lambda function) indicate that there are no issues. If 
there are issues, you receive an error message.
If you have a lot of event source mappings, use the function name parameter to narrow down the results.
aws lambda list-event-source-mappings --function-name ProcessDynamoDBRecords
Test the setup
Test the end-to-end experience. As you perform table updates, DynamoDB writes event records to the 
stream. As AWS Lambda polls the stream, it detects new records in the stream and invokes your Lambda 
function on your behalf by passing events to the function.
1.In the DynamoDB console, add, update, and delete items to the table. DynamoDB writes records of 
these actions to the stream.
2.AWS Lambda polls the stream and when it detects updates to the stream, it invokes your Lambda 
function by passing in the event data it ﬁnds in the stream.
3.Your function runs and creates logs in Amazon CloudWatch. You can verify the logs reported in the 
Amazon CloudWatch console.
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
724AWS Lambda Developer Guide
Sample code
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the DynamoDB table
1. Open the Tables page of the DynamoDB console.
2. Select the table you created.
3. Choose Delete.
4. Enter delete in the text box.
5. Choose Delete table.
Sample function code
Sample code is available for the following languages.
Topics
•Node.js  (p. 725)
•Java 11 (p. 726)
•C# (p. 726)
•Python 3 (p. 727)
•Go (p. 727)
Node.js
The following example processes messages from DynamoDB, and logs their contents.
Example ProcessDynamoDBStream.js
console.log('Loading function');
exports.lambda_handler = function(event, context, callback) { 
    console.log(JSON.stringify(event, null, 2)); 
    event.Records.forEach(function(record) { 
        console.log(record.eventID); 
        console.log(record.eventName); 
        console.log('DynamoDB Record: %j', record.dynamodb); 
    }); 
    callback(null, "message");
};
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
725AWS Lambda Developer Guide
Sample code
Java 11
The following example processes messages from DynamoDB, and logs their contents. handleRequest
is the handler that AWS Lambda invokes and provides event data. The handler uses the predeﬁned
DynamodbEvent  class, which is deﬁned in the aws-lambda-java-events  library.
Example DDBEventProcessor.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler2;
import com.amazonaws.services.lambda.runtime.events.DynamodbEvent;
import com.amazonaws.services.lambda.runtime.events.DynamodbEvent.DynamodbStreamRecord;
public class DDBEventProcessor implements 
        RequestHandler2<DynamodbEvent, String> { 
    public String handleRequest(DynamodbEvent ddbEvent, Context context) { 
        for (DynamodbStreamRecord record : ddbEvent.getRecords()){ 
           System.out.println(record.getEventID()); 
           System.out.println(record.getEventName()); 
           System.out.println(record.getDynamodb().toString()); 
        } 
        return "Successfully processed " + ddbEvent.getRecords().size() + " records."; 
    }
}
If the handler returns normally without exceptions, Lambda considers the input batch of records as 
processed successfully and begins reading new records in the stream. If the handler throws an exception, 
Lambda considers the input batch of records as not processed and invokes the function with the same 
batch of records again.
Dependencies
•aws-lambda-java-core
•aws-lambda-java-events
Build the code with the Lambda library dependencies to create a deployment package. For instructions, 
see Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446).
C#
The following example processes messages from DynamoDB, and logs their contents.
ProcessDynamoEvent  is the handler that AWS Lambda invokes and provides event data. The handler 
uses the predeﬁned DynamoDbEvent  class, which is deﬁned in the Amazon.Lambda.DynamoDBEvents
library.
Example ProcessingDynamoDBStreams.cs
using System;
using System.IO;
using System.Text;
using Amazon.Lambda.Core;
using Amazon.Lambda.DynamoDBEvents;
726AWS Lambda Developer Guide
Sample code
using Amazon.Lambda.Serialization.Json;
namespace DynamoDBStreams
{ 
    public class DdbSample 
    { 
        private static readonly JsonSerializer _jsonSerializer = new JsonSerializer(); 
        public void ProcessDynamoEvent(DynamoDBEvent dynamoEvent) 
        { 
            Console.WriteLine($"Beginning to process {dynamoEvent.Records.Count} 
 records..."); 
            foreach (var record in dynamoEvent.Records) 
            { 
                Console.WriteLine($"Event ID: {record.EventID}"); 
                Console.WriteLine($"Event Name: {record.EventName}"); 
                string streamRecordJson = SerializeObject(record.Dynamodb); 
                Console.WriteLine($"DynamoDB Record:"); 
                Console.WriteLine(streamRecordJson); 
            } 
            Console.WriteLine("Stream processing complete."); 
        } 
        private string SerializeObject(object streamRecord) 
        { 
            using (var ms = new MemoryStream()) 
            { 
                _jsonSerializer.Serialize(streamRecord, ms); 
                return Encoding.UTF8.GetString(ms.ToArray()); 
            } 
        } 
    }
}
Replace the Program.cs  in a .NET Core project with the above sample. For instructions, see Deploy C# 
Lambda functions with .zip ﬁle archives (p. 566).
Python 3
The following example processes messages from DynamoDB, and logs their contents.
Example ProcessDynamoDBStream.py
from __future__ import print_function
def lambda_handler(event, context): 
    for record in event['Records']: 
        print(record['eventID']) 
        print(record['eventName']) 
    print('Successfully processed %s records.' % str(len(event['Records'])))
Zip up the sample code to create a deployment package. For instructions, see Working with .zip ﬁle 
archives for Python Lambda functions (p. 352).
Go
The following example processes messages from DynamoDB, and logs their contents.
727AWS Lambda Developer Guide
Sample template
Example
import ( 
    "strings" 
    "github.com/aws/aws-lambda-go/events"
)
func handleRequest(ctx context.Context, e events.DynamoDBEvent) { 
    for _, record := range e.Records { 
        fmt.Printf("Processing request data for event ID %s, type %s.\n", record.EventID, 
 record.EventName) 
        // Print new values for attributes of type String 
        for name, value := range record.Change.NewImage { 
            if value.DataType() == events.DataTypeString { 
                fmt.Printf("Attribute name: %s, value: %s\n", name, value.String()) 
            } 
        } 
    }
}
Build the executable with go build  and create a deployment package. For instructions, see Deploy Go 
Lambda functions with .zip ﬁle archives (p. 520).
AWS SAM template for a DynamoDB application
You can build this application using AWS SAM. To learn more about creating AWS SAM templates, see
AWS SAM template basics in the AWS Serverless Application Model Developer Guide.
Below is a sample AWS SAM template for the tutorial application  (p. 720). Copy the text below to 
a .yaml ﬁle and save it next to the ZIP package you created previously. Note that the Handler  and
Runtime parameter values should match the ones you used when you created the function in the 
previous section.
Example template.yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Resources: 
  ProcessDynamoDBStream: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: handler
      Runtime: runtime
      Policies: AWSLambdaDynamoDBExecutionRole 
      Events: 
        Stream: 
          Type: DynamoDB 
          Properties: 
            Stream: !GetAtt DynamoDBTable.StreamArn 
            BatchSize: 100 
            StartingPosition: TRIM_HORIZON 
  DynamoDBTable: 
    Type: AWS::DynamoDB::Table 
    Properties:  
      AttributeDefinitions:  
        - AttributeName: id 
          AttributeType: S 
728AWS Lambda Developer Guide
Sample template
      KeySchema:  
        - AttributeName: id 
          KeyType: HASH 
      ProvisionedThroughput:  
        ReadCapacityUnits: 5 
        WriteCapacityUnits: 5 
      StreamSpecification: 
        StreamViewType: NEW_IMAGE
For information on how to package and deploy your serverless application using the package and deploy 
commands, see Deploying serverless applications in the AWS Serverless Application Model Developer 
Guide .
729AWS Lambda Developer Guide
EC2
Using AWS Lambda with Amazon EC2
You can use AWS Lambda to process lifecycle events from Amazon Elastic Compute Cloud and manage 
Amazon EC2 resources. Amazon EC2 sends events to Amazon EventBridge (CloudWatch Events) for 
lifecycle events such as when an instance changes state, when an Amazon Elastic Block Store volume 
snapshot completes, or when a spot instance is scheduled to be terminated. You conﬁgure EventBridge 
(CloudWatch Events) to forward those events to a Lambda function for processing.
EventBridge (CloudWatch Events) invokes your Lambda function asynchronously with the event 
document from Amazon EC2.
Example instance lifecycle event
{ 
    "version": "0", 
    "id": "b6ba298a-7732-2226-xmpl-976312c1a050", 
    "detail-type": "EC2 Instance State-change Notification", 
    "source": "aws.ec2", 
    "account": "111122223333", 
    "time": "2019-10-02T17:59:30Z", 
    "region": "us-east-1", 
    "resources": [ 
        "arn:aws:ec2:us-east-1:111122223333:instance/i-0c314xmplcd5b8173" 
    ], 
    "detail": { 
        "instance-id": "i-0c314xmplcd5b8173", 
        "state": "running" 
    }
}
For details on conﬁguring events in EventBridge (CloudWatch Events), see Using AWS Lambda with 
Amazon EventBridge (CloudWatch Events) (p. 663). For an example function that processes Amazon EBS 
snapshot notiﬁcations, see Amazon EventBridge (CloudWatch Events) for Amazon EBS in the Amazon 
EC2 User Guide for Linux Instances.
You can also use the AWS SDK to manage instances and other resources with the Amazon EC2 API.
Permissions
To process lifecycle events from Amazon EC2, EventBridge (CloudWatch Events) needs permission to 
invoke your function. This permission comes from the function's resource-based policy (p. 929). If you 
use the EventBridge (CloudWatch Events) console to conﬁgure an event trigger, the console updates the 
resource-based policy on your behalf. Otherwise, add a statement like the following:
Example resource-based policy statement for Amazon EC2 lifecycle notiﬁcations
{ 
  "Sid": "ec2-events", 
  "Effect": "Allow", 
  "Principal": { 
    "Service": "events.amazonaws.com" 
  }, 
  "Action": "lambda:InvokeFunction", 
  "Resource": "arn:aws:lambda:us-east-1:12456789012:function:my-function", 
  "Condition": { 
    "ArnLike": { 
      "AWS:SourceArn": "arn:aws:events:us-east-1:12456789012:rule/*" 
    } 
  }
730AWS Lambda Developer Guide
Permissions
}
To add a statement, use the add-permission  AWS CLI command.
aws lambda add-permission --action lambda:InvokeFunction --statement-id ec2-events \
--principal events.amazonaws.com --function-name my-function  --source-arn 
 'arn:aws:events:us-east-1: 12456789012 :rule/*'
If your function uses the AWS SDK to manage Amazon EC2 resources, add Amazon EC2 permissions to 
the function's execution role (p. 913).
731AWS Lambda Developer Guide
ElastiCache
Tutorial: Conﬁguring a Lambda function to access 
Amazon ElastiCache in an Amazon VPC
In this tutorial, you do the following:
•Create an Amazon ElastiCache cluster in your default Amazon Virtual Private Cloud. For more 
information about Amazon ElastiCache, see Amazon ElastiCache.
•Create a Lambda function to access the ElastiCache cluster. When you create the Lambda function, 
you provide subnet IDs in your Amazon VPC and a VPC security group to allow the Lambda function 
to access resources in your VPC. For illustration in this tutorial, the Lambda function generates a UUID, 
writes it to the cache, and retrieves it from the cache.
•Invoke the Lambda function and verify that it accessed the ElastiCache cluster in your VPC.
For details on using Lambda with Amazon VPC, see Connecting outbound networking to resources in a 
VPC (p. 85).
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role
Create the execution role (p. 913) that gives your function permission to access AWS resources.
To create an execution role
1. Open the roles page in the IAM console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – Lambda.
732AWS Lambda Developer Guide
Create an ElastiCache cluster
•Permissions – AWSLambdaVPCAccessExecutionRole.
•Role name – lambda-vpc-role .
The AWSLambdaVPCAccessExecutionRole has the permissions that the function needs to manage 
network connections to a VPC.
Create an ElastiCache cluster
Create an ElastiCache cluster in your default VPC.
1. Run the following AWS CLI command to create a Memcached cluster.
aws elasticache create-cache-cluster --cache-cluster-id ClusterForLambdaTest --cache-
node-type cache.t3.medium --engine memcached --num-cache-nodes 1 --security-group-
ids sg-0123a1b123456c1de
You can look up the default VPC security group in the VPC console under Security Groups. Your 
example Lambda function will add and retrieve an item from this cluster.
2. Write down the conﬁguration endpoint for the cache cluster that you launched. You can get this 
from the Amazon ElastiCache console. You will specify this value in your Lambda function code in 
the next section.
Create a deployment package
The following example Python code reads and writes an item to your ElastiCache cluster.
Example app.py
from __future__ import print_function
import time
import uuid
import sys
import socket
import elasticache_auto_discovery
from pymemcache.client.hash import HashClient
#elasticache settings
elasticache_config_endpoint = " your-elasticache-cluster-endpoint:port "
nodes = elasticache_auto_discovery.discover(elasticache_config_endpoint)
nodes = map(lambda x: (x[1], int(x[2])), nodes)
memcache_client = HashClient(nodes)
def handler(event, context): 
    """ 
    This function puts into memcache and get from it. 
    Memcache is hosted using elasticache 
    """ 
    #Create a random UUID... this will be the sample element we add to the cache. 
    uuid_inserted = uuid.uuid4().hex 
    #Put the UUID to the cache. 
    memcache_client.set('uuid', uuid_inserted) 
    #Get item (UUID) from the cache. 
    uuid_obtained = memcache_client.get('uuid') 
    if uuid_obtained.decode("utf-8") == uuid_inserted: 
        # this print should go to the CloudWatch Logs and Lambda console. 
        print ("Success: Fetched value %s from memcache" %(uuid_inserted)) 
733AWS Lambda Developer Guide
Create the Lambda function
    else: 
        raise Exception("Value is not the same as we put :(. Expected %s got %s" 
 %(uuid_inserted, uuid_obtained)) 
    return "Fetched value from memcache: " + uuid_obtained.decode("utf-8")
Dependencies
•pymemcache – The Lambda function code uses this library to create a HashClient  object to set and 
get items from memcache.
•elasticache-auto-discovery – The Lambda function uses this library to get the nodes in your Amazon 
ElastiCache cluster.
Install dependencies with Pip and create a deployment package. For instructions, see Working with .zip 
ﬁle archives for Python Lambda functions (p. 352).
Create the Lambda function
Create the Lambda function with the create-function  command.
aws lambda create-function --function-name AccessMemCache --timeout 30 --memory-size 1024 \
--zip-file fileb://function.zip --handler app.handler --runtime python3.8 \
--role arn:aws:iam:: 123456789012 :role/lambda-vpc-role \
--vpc-config SubnetIds= subnet-0532bb6758ce7c71f,subnet-
d6b7fda068036e11f ,SecurityGroupIds= sg-0897d5f549934c2fb
You can ﬁnd the subnet IDs and the default security group ID of your VPC from the VPC console.
Test the Lambda function
In this step, you invoke the Lambda function manually using the invoke command. When the Lambda 
function runs, it generates a UUID and writes it to the ElastiCache cluster that you speciﬁed in your 
Lambda code. The Lambda function then retrieves the item from the cache.
1. Invoke the Lambda function with the invoke command.
aws lambda invoke --function-name AccessMemCache output.txt
2. Verify that the Lambda function executed successfully as follows:
•Review the output.txt ﬁle.
•Review the results in the AWS Lambda console.
•Verify the results in CloudWatch Logs.
Now that you have created a Lambda function that accesses an ElastiCache cluster in your VPC, you can 
have the function invoked in response to events. For information about conﬁguring event sources and 
examples, see Using AWS Lambda with other services (p. 628).
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
734AWS Lambda Developer Guide
Clean up your resources
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the ElastiCache cluster
1. Open the Memcached page  of the ElastiCache console.
2. Select the cluster you created.
3. Choose Actions, Delete.
4. Choose Delete.
735AWS Lambda Developer Guide
Elastic Load Balancing
Using AWS Lambda with an Application Load 
Balancer
You can use a Lambda function to process requests from an Application Load Balancer. Elastic Load 
Balancing supports Lambda functions as a target for an Application Load Balancer. Use load balancer 
rules to route HTTP requests to a function, based on path or header values. Process the request and 
return an HTTP response from your Lambda function.
Elastic Load Balancing invokes your Lambda function synchronously with an event that contains the 
request body and metadata.
Example Application Load Balancer request event
{ 
    "requestContext": { 
        "elb": { 
            "targetGroupArn": "arn:aws:elasticloadbalancing:us-
east-1:123456789012:targetgroup/lambda-279XGJDqGZ5rsrHC2Fjr/49e9d65c45c6791a" 
        } 
    }, 
    "httpMethod": "GET", 
    "path": "/lambda", 
    "queryStringParameters": { 
        "query": "1234ABCD" 
    }, 
    "headers": { 
        "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/
apng,*/*;q=0.8", 
        "accept-encoding": "gzip", 
        "accept-language": "en-US,en;q=0.9", 
        "connection": "keep-alive", 
        "host": "lambda-alb-123578498.us-east-1.elb.amazonaws.com", 
        "upgrade-insecure-requests": "1", 
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, 
 like Gecko) Chrome/71.0.3578.98 Safari/537.36", 
        "x-amzn-trace-id": "Root=1-5c536348-3d683b8b04734faae651f476", 
        "x-forwarded-for": "72.12.164.125", 
        "x-forwarded-port": "80", 
        "x-forwarded-proto": "http", 
        "x-imforwards": "20" 
    }, 
    "body": "", 
    "isBase64Encoded": false
}
Your function processes the event and returns a response document to the load balancer in JSON. Elastic 
Load Balancing converts the document to an HTTP success or error response and returns it to the user.
Example response document format
{ 
    "statusCode": 200, 
    "statusDescription": "200 OK", 
    "isBase64Encoded": False, 
    "headers": { 
        "Content-Type": "text/html" 
    }, 
    "body": "<h1>Hello from Lambda!</h1>"
}
736AWS Lambda Developer Guide
Elastic Load Balancing
To conﬁgure an Application Load Balancer as a function trigger, grant Elastic Load Balancing permission 
to run the function, create a target group that routes requests to the function, and add a rule to the load 
balancer that sends requests to the target group.
Use the add-permission  command to add a permission statement to your function's resource-based 
policy.
aws lambda add-permission --function-name alb-function  \
--statement-id load-balancer --action "lambda:InvokeFunction" \
--principal elasticloadbalancing.amazonaws.com
You should see the following output:
{ 
    "Statement": "{\"Sid\":\"load-balancer\",\"Effect\":\"Allow\",\"Principal\":{\"Service
\":\"elasticloadbalancing.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource
\":\"arn:aws:lambda:us-west-2:123456789012:function:alb-function\"}"
}
For instructions on conﬁguring the Application Load Balancer listener and target group, see Lambda 
functions as a target in the User Guide for Application Load Balancers .
737AWS Lambda Developer Guide
EFS
Using Amazon EFS with Lambda
Lambda integrates with Amazon Elastic File System (Amazon EFS) to support secure, shared ﬁle system 
access for Lambda applications. You can conﬁgure functions to mount a ﬁle system during initialization 
with the NFS protocol over the local network within a VPC. Lambda manages the connection and 
encrypts all traﬃc to and from the ﬁle system.
The ﬁle system and the Lambda function must be in the same region. A Lambda function in one account 
can mount a ﬁle system in a diﬀerent account. For this scenario, you conﬁgure VPC peering between the 
function VPC and the ﬁle system VPC.
Note
To conﬁgure a function to connect to a ﬁle system, see Conﬁguring ﬁle system access for 
Lambda functions (p. 99).
Amazon EFS supports ﬁle locking  to prevent corruption if multiple functions try to write to the same ﬁle 
system at the same time. Locking in Amazon EFS follows the NFS v4.1 protocol for advisory locking, and 
enables your applications to use both whole ﬁle and byte range locks.
Amazon EFS provides options to customize your ﬁle system based on your application's need to maintain 
high performance at scale. There are three primary factors to consider: the number of connections, 
throughput (in MiB per second), and IOPS.
Quotas
For detail on ﬁle system quotas and limits, see Quotas for Amazon EFS ﬁle systems in the
Amazon Elastic File System User Guide.
To avoid issues with scaling, throughput, and IOPS, monitor the metrics  that Amazon EFS sends to 
Amazon CloudWatch. For an overview of monitoring in Amazon EFS, see Monitoring Amazon EFS in the
Amazon Elastic File System User Guide.
Sections
•Connections (p. 738)
•Throughput (p. 739)
•IOPS  (p. 739)
Connections
Amazon EFS supports up to 25,000 connections per ﬁle system. During initialization, each instance of a 
function creates a single connection to its ﬁle system that persists across invocations. This means that 
you can reach 25,000 concurrency across one or more functions connected to a ﬁle system. To limit the 
number of connections a function creates, use reserved concurrency (p. 234).
However, when you make changes to your function's code or conﬁguration at scale, there is a temporary 
increase in the number of function instances beyond the current concurrency. Lambda provisions new 
instances to handle new requests and there is some delay before old instances close their connections 
to the ﬁle system. To avoid hitting the maximum connections limit during a deployment, use rolling 
deployments (p. 1079 ). With rolling deployments, you gradually shift traﬃc to the new version each 
time you make a change.
If you connect to the same ﬁle system from other services such as Amazon EC2, you should also be aware 
of the scaling behavior of connections in Amazon EFS. A ﬁle system supports the creation of up to 3,000 
connections in a burst, after which it supports 500 new connections per minute. This matches  burst 
scaling  (p. 243) behavior in Lambda, which applies across all functions in a Region. But if you are creating 
connections outside of Lambda, your functions may not be able to scale at full speed.
To monitor and trigger an alarm on connections, use the ClientConnections  metric.
738AWS Lambda Developer Guide
Throughput
Throughput
At scale, it is also possible to exceed the maximum throughput  for a ﬁle system. In bursting mode  (the 
default), a ﬁle system has a low baseline throughput that scales linearly with its size. To allow for bursts 
of activity, the ﬁle system is granted burst credits that allow it to use 100 MiB/s or more of throughput. 
Credits accumulate continually and are expended with every read and write operation. If the ﬁle system 
runs out of credits, it throttles read and write operations beyond the baseline throughput, which can 
cause invocations to time out.
Note
If you use provisioned concurrency (p. 237), your function can consume burst credits even when 
idle. With provisioned concurrency, Lambda initializes instances of your function before it is 
invoked, and recycles instances every few hours. If you use ﬁles on an attached ﬁle system 
during initialization, this activity can use all of your burst credits.
To monitor and trigger an alarm on throughput, use the BurstCreditBalance  metric. It should 
increase when your function's concurrency is low and decrease when it is high. If it always decreases 
or does not accumulate enough during low activity to cover peak traﬃc, you may need to limit your 
function's concurrency or enable provisioned throughput.
IOPS
Input/output operations per second (IOPS) is a measurement of the number of read and write operations 
processed by the ﬁle system. In general purpose mode, IOPS is limited in favor of lower latency, which is 
beneﬁcial for most applications.
To monitor and alarm on IOPS in general purpose mode, use the PercentIOLimit  metric. If this metric 
reaches 100%, your function can time out waiting for read and write operations to complete.
739AWS Lambda Developer Guide
IoT
Using AWS Lambda with AWS IoT
AWS IoT provides secure communication between internet-connected devices (such as sensors) and the 
AWS Cloud. This makes it possible for you to collect, store, and analyze telemetry data from multiple 
devices.
You can create AWS IoT rules for your devices to interact with AWS services. The AWS IoT Rules Engine
provides a SQL-based language to select data from message payloads and send the data to other 
services, such as Amazon S3, Amazon DynamoDB, and AWS Lambda. You deﬁne a rule to invoke a 
Lambda function when you want to invoke another AWS service or a third-party service.
When an incoming IoT message triggers the rule, AWS IoT invokes your Lambda function
asynchronously (p. 142) and passes data from the IoT message to the function.
The following example shows a moisture reading from a greenhouse sensor. The row and pos values 
identify the location of the sensor. This example event is based on the greenhouse type in the AWS IoT 
Rules tutorials .
Example AWS IoT message event
{ 
    "row" : "10", 
    "pos" : "23", 
    "moisture" : "75"
}
For asynchronous invocation, Lambda queues the message and retries (p. 181) if your function returns 
an error. Conﬁgure your function with a destination  (p. 144) to retain events that your function could not 
process.
You need to grant permission for the AWS IoT service to invoke your Lambda function. Use the add-
permission  command to add a permission statement to your function's resource-based policy.
aws lambda add-permission --function-name my-function  \
--statement-id iot-events --action "lambda:InvokeFunction" --principal iot.amazonaws.com
You should see the following output:
{ 
    "Statement": "{\"Sid\":\"iot-events\",\"Effect\":\"Allow\",\"Principal\":
{\"Service\":\"iot.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":
\"arn:aws:lambda:us-east-1:123456789012:function:my-function\"}"
}
 
For more information about how to use Lambda with AWS IoT, see Creating an AWS Lambda rule.
740AWS Lambda Developer Guide
IoT Events
Using AWS Lambda with AWS IoT Events
AWS IoT Events monitors the inputs from multiple IoT sensors and applications to recognize event 
patterns. Then it takes appropriate actions when events occur. AWS IoT Events receives its inputs as 
JSON payloads from many sources. AWS IoT Events supports simple events (where each input triggers an 
event) and complex events (where multiple inputs must occur to trigger the event).
To use AWS IoT Events, you deﬁne a detector model, which is a state-machine model of your equipment 
or process. In addition to states, you deﬁne inputs and events for the model. You also deﬁne the actions 
to take when an event occurs. Use a Lambda function for an action when you want to invoke another 
AWS service (such as Amazon Connect), or take actions in an external application (such as your enterprise 
resource planning (ERP) application).
When the event occurs, AWS IoT Events invokes your Lambda function asynchronously. It provides 
information about the detector model and the event that triggered the action. The following example 
message event is based on the deﬁnitions in the AWS IoT Events simple step-by-step example.
Example AWS IoT Events message event
{ 
  "event":{ 
    "eventName": "myChargedEvent", 
    "eventTime": 1567797571647, 
    "payload":{ 
      "detector":{ 
         "detectorModelName": "AWS_IoTEvents_Hello_World1567793458261", 
         "detectorModelVersion": "4", 
         "keyValue": "100009" 
      }, 
      "eventTriggerDetails":{ 
         "triggerType": "Message", 
         "inputName": "AWS_IoTEvents_HelloWorld_VoltageInput", 
         "messageId": "64c75a34-068b-4a1d-ae58-c16215dc4efd" 
      }, 
      "actionExecutionId": "49f0f32f-1209-38a7-8a76-d6ca49dd0bc4", 
      "state":{ 
         "variables": {}, 
         "stateName": "Charged", 
         "timers": {} 
      } 
    } 
  }
} 
       
The event that is passed into the Lambda function includes the following ﬁelds:
•eventName  – The name for this event in the detector model.
•eventTime  – The time that the event occurred.
•detector  – The name and version of the detector model.
•eventTriggerDetails  – A description of the input that triggered the event.
•actionExecutionId  – The unique execution identiﬁer of the action.
•state – The state of the detector model when the event occurred.
•stateName  – The name of the state in the detector model.
•timers – Any timers that are set in this state.
•variables  – Any variable values that are set in this state.
741AWS Lambda Developer Guide
IoT Events
You need to grant permission for the AWS IoT Events service to invoke your Lambda function. Use the
add-permission  command to add a permission statement to your function's resource-based policy.
aws lambda add-permission --function-name my-function  \
--statement-id iot-events --action "lambda:InvokeFunction" --principal 
 iotevents.amazonaws.com
You should see the following output:
{ 
    "Statement": "{\"Sid\":\"iot-events\",\"Effect\":\"Allow\",\"Principal\":{\"Service
\":\"iotevents.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":
\"arn:aws:lambda:us-east-1:123456789012:function:my-function\"}"
}
 
For more information about using Lambda with AWS IoT Events, see Using AWS IoT Events with other 
services.
742AWS Lambda Developer Guide
Apache Kafka
Using Lambda with self-managed Apache Kafka
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
Lambda supports Apache Kafka  as an event source (p. 150). Apache Kafka is a an open-source event 
streaming platform that supports workloads such as data pipelines and streaming analytics.
You can use the AWS managed Kafka service Amazon Managed Streaming for Apache Kafka (Amazon 
MSK), or a self-managed Kafka cluster. For details about using Lambda with Amazon MSK, see Using 
Lambda with Amazon MSK (p. 789).
This topic describes how to use Lambda with a self-managed Kafka cluster. In AWS terminology, a self-
managed cluster includes non-AWS hosted Kafka clusters. For example, you can host your Kafka cluster 
with a cloud provider such as Conﬂuent Cloud .
Apache Kafka as an event source operates similarly to using Amazon Simple Queue Service (Amazon 
SQS) or Amazon Kinesis. Lambda internally polls for new messages from the event source and then 
synchronously invokes the target Lambda function. Lambda reads the messages in batches and provides 
these to your function as an event payload. The maximum batch size is conﬁgurable. (The default is 100 
messages.)
For Kafka-based event sources, Lambda supports processing control parameters, such as batching 
windows and batch size. For more information, see Batching behavior (p. 151).
For an example of how to use self-managed Kafka as an event source, see Using self-hosted Apache 
Kafka as an event source for AWS Lambda on the AWS Compute Blog.
Topics
•Example event (p. 743)
•Kafka cluster authentication  (p. 744)
•Managing API access and permissions (p. 746)
•Authentication and authorization errors (p. 748)
•Network conﬁguration (p. 749)
•Adding a Kafka cluster as an event source (p. 749)
•Using a Kafka cluster as an event source (p. 752)
•Auto scaling of the Kafka event source (p. 752)
•Event source API operations (p. 753)
•Event source mapping errors (p. 753)
•Amazon CloudWatch metrics (p. 753)
•Self-managed Apache Kafka conﬁguration parameters (p. 754)
Example event
Lambda sends the batch of messages in the event parameter when it invokes your Lambda function. The 
event payload contains an array of messages. Each array item contains details of the Kafka topic and 
Kafka partition identiﬁer, together with a timestamp and a base64-encoded message.
{ 
   "eventSource": "SelfManagedKafka", 
   "bootstrapServers":"b-2.demo-cluster-1.a1bcde.c1.kafka.us-
east-1.amazonaws.com:9092,b-1.demo-cluster-1.a1bcde.c1.kafka.us-east-1.amazonaws.com:9092", 
   "records":{ 
743AWS Lambda Developer Guide
Kafka cluster authentication
      "mytopic-0":[ 
         { 
            "topic":"mytopic", 
            "partition":0, 
            "offset":15, 
            "timestamp":1545084650987, 
            "timestampType":"CREATE_TIME", 
            "key":"abcDEFghiJKLmnoPQRstuVWXyz1234==", 
            "value":"SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
            "headers":[ 
               { 
                  "headerKey":[ 
                     104, 
                     101, 
                     97, 
                     100, 
                     101, 
                     114, 
                     86, 
                     97, 
                     108, 
                     117, 
                     101 
                  ] 
               } 
            ] 
         } 
      ] 
   }
}
Kafka cluster authentication
Lambda supports several methods to authenticate with your self-managed Apache Kafka cluster. Make 
sure that you conﬁgure the Kafka cluster to use one of these supported authentication methods. For 
more information about Kafka security, see the Security section of the Kafka documentation.
VPC access
If only Kafka users within your VPC access your Kafka brokers, you must conﬁgure the Kafka event source 
for Amazon Virtual Private Cloud (Amazon VPC) access.
SASL/SCRAM authentication
Lambda supports Simple Authentication and Security Layer/Salted Challenge Response Authentication 
Mechanism (SASL/SCRAM) authentication with Transport Layer Security (TLS) encryption (SASL_SSL ). 
Lambda sends the encrypted credentials to authenticate with the cluster. Lambda doesn't support SASL/
SCRAM with plaintext (SASL_PLAINTEXT ). For more information about SASL/SCRAM authentication, see
RFC 5802.
Lambda also supports SASL/PLAIN authentication. Because this mechanism uses clear text credentials, 
the connection to the server must use TLS encryption to ensure that the credentials are protected.
For SASL authentication, you store the sign-in credentials as a secret in AWS Secrets Manager. For more 
information about using Secrets Manager, see Tutorial: Create and retrieve a secret in the AWS Secrets 
Manager User Guide .
Important
To use Secrets Manager for authentication, secrets must be stored in the same AWS region as 
your Lambda function.
744AWS Lambda Developer Guide
Kafka cluster authentication
Mutual TLS authentication
Mutual TLS (mTLS) provides two-way authentication between the client and server. The client sends a 
certiﬁcate to the server for the server to verify the client, and the server sends a certiﬁcate to the client 
for the client to verify the server.
In self-managed Apache Kafka, Lambda acts as the client. You conﬁgure a client certiﬁcate (as a secret in 
Secrets Manager) to authenticate Lambda with your Kafka brokers. The client certiﬁcate must be signed 
by a CA in the server's trust store.
The Kafka cluster sends a server certiﬁcate to Lambda to authenticate the Kafka brokers with Lambda. 
The server certiﬁcate can be a public CA certiﬁcate or a private CA/self-signed certiﬁcate. The public CA 
certiﬁcate must be signed by a certiﬁcate authority (CA) that's in the Lambda trust store. For a private 
CA/self-signed certiﬁcate, you conﬁgure the server root CA certiﬁcate (as a secret in Secrets Manager). 
Lambda uses the root certiﬁcate to verify the Kafka brokers.
For more information about mTLS, see  Introducing mutual TLS authentication for Amazon MSK as an 
event source.
Conﬁguring the client certiﬁcate secret
The CLIENT_CERTIFICATE_TLS_AUTH secret requires a certiﬁcate ﬁeld and a private key ﬁeld. For an 
encrypted private key, the secret requires a private key password. Both the certiﬁcate and private key 
must be in PEM format.
Note
Lambda supports the PBES1  (but not PBES2) private key encryption algorithms.
The certiﬁcate ﬁeld must contain a list of certiﬁcates, beginning with the client certiﬁcate, followed by 
any intermediate certiﬁcates, and ending with the root certiﬁcate. Each certiﬁcate must start on a new 
line with the following structure:
-----BEGIN CERTIFICATE-----   
        <certificate contents>
-----END CERTIFICATE-----       
Secrets Manager supports secrets up to 65,536 bytes, which is enough space for long certiﬁcate chains.
The private key must be in PKCS #8 format, with the following structure:
-----BEGIN PRIVATE KEY-----   
         <private key contents>
-----END PRIVATE KEY-----             
For an encrypted private key, use the following structure:
-----BEGIN ENCRYPTED PRIVATE KEY-----   
          <private key contents>
-----END ENCRYPTED PRIVATE KEY-----            
The following example shows the contents of a secret for mTLS authentication using an encrypted 
private key. For an encrypted private key, include the private key password in the secret.
{ 
 "privateKeyPassword": "testpassword", 
 "certificate": "-----BEGIN CERTIFICATE-----
745AWS Lambda Developer Guide
Managing API access and permissions
MIIE5DCCAsygAwIBAgIRAPJdwaFaNRrytHBto0j5BA0wDQYJKoZIhvcNAQELBQAw
...
j0Lh4/+1HfgyE2KlmII36dg4IMzNjAFEBZiCRoPimO40s1cRqtFHXoal0QQbIlxk
cmUuiAii9R0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFgjCCA2qgAwIBAgIQdjNZd6uFf9hbNC5RdfmHrzANBgkqhkiG9w0BAQsFADBb
...
rQoiowbbk5wXCheYSANQIfTZ6weQTgiCHCCbuuMKNVS95FkXm0vqVD/YpXKwA/no
c8PH3PSoAaRwMMgOSA2ALJvbRz8mpg==
-----END CERTIFICATE-----", 
 "privateKey": "-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIFKzBVBgkqhkiG9w0BBQ0wSDAnBgkqhkiG9w0BBQwwGgQUiAFcK5hT/X7Kjmgp
...
QrSekqF+kWzmB6nAfSzgO9IaoAaytLvNgGTckWeUkWn/V0Ck+LdGUXzAC4RxZnoQ
zp2mwJn2NYB7AZ7+imp0azDZb+8YG2aUCiyqb6PnnA==
-----END ENCRYPTED PRIVATE KEY-----"
}   
Conﬁguring the server root CA certiﬁcate secret
You create this secret if your Kafka brokers use TLS encryption with certiﬁcates signed by a private CA. 
You can use TLS encryption for VPC, SASL/SCRAM, SASL/PLAIN, or mTLS authentication.
The server root CA certiﬁcate secret requires a ﬁeld that contains the Kafka broker's root CA certiﬁcate in 
PEM format. The following example shows the structure of the secret.
{ 
     "certificate": "-----BEGIN CERTIFICATE-----        
  MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx 
  EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT 
  HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs 
  ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dG... 
  -----END CERTIFICATE-----"       
Managing API access and permissions
In addition to accessing your self-managed Kafka cluster, your Lambda function needs permissions to 
perform various API actions. You add these permissions to the function's execution role (p. 913). If your 
users need access to any API actions, add the required permissions to the identity policy for the AWS 
Identity and Access Management (IAM) user or role.
Required Lambda function permissions
To create and store logs in a log group in Amazon CloudWatch Logs, your Lambda function must have 
the following permissions in its execution role:
•logs:CreateLogGroup
•logs:CreateLogStream
•logs:PutLogEvents
Optional Lambda function permissions
Your Lambda function might also need permissions to:
•Describe your Secrets Manager secret.
746AWS Lambda Developer Guide
Managing API access and permissions
•Access your AWS Key Management Service (AWS KMS) customer managed key.
•Access your Amazon VPC.
Secrets Manager and AWS KMS permissions
Depending on the type of access control that you're conﬁguring for your Kafka brokers, your Lambda 
function might need permission to access your Secrets Manager secret or to decrypt your AWS KMS 
customer managed key. To access these resources, your function's execution role must have the following 
permissions:
•secretsmanager:GetSecretValue
•kms:Decrypt
VPC permissions
If only users within a VPC can access your self-managed Apache Kafka cluster, your Lambda function 
must have permission to access your Amazon VPC resources. These resources include your VPC, subnets, 
security groups, and network interfaces. To access these resources, your function's execution role must 
have the following permissions:
•ec2:CreateNetworkInterface
•ec2:DescribeNetworkInterfaces
•ec2:DescribeVpcs
•ec2:DeleteNetworkInterface
•ec2:DescribeSubnets
•ec2:DescribeSecurityGroups
Adding permissions to your execution role
To access other AWS services that your self-managed Apache Kafka cluster uses, Lambda uses the 
permissions policies that you deﬁne in your Lambda function's execution role (p. 913).
By default, Lambda is not permitted to perform the required or optional actions for a self-managed 
Apache Kafka cluster. You must create and deﬁne these actions in an IAM trust policy, and then attach 
the policy to your execution role. This example shows how you might create a policy that allows Lambda 
to access your Amazon VPC resources.
{ 
        "Version":"2012-10-17", 
        "Statement":[ 
           { 
              "Effect":"Allow", 
              "Action":[ 
                 "ec2:CreateNetworkInterface", 
                 "ec2:DescribeNetworkInterfaces", 
                 "ec2:DescribeVpcs", 
                 "ec2:DeleteNetworkInterface", 
                 "ec2:DescribeSubnets", 
                 "ec2:DescribeSecurityGroups" 
              ], 
              "Resource":"*" 
           } 
        ] 
     }
747AWS Lambda Developer Guide
Authentication and authorization errors
For information about creating a JSON policy document in the IAM console, see Creating policies on the 
JSON tab in the IAM User Guide .
Granting users access with an IAM policy
By default, users and roles don't have permission to perform event source API operations (p. 753). To 
grant access to users in your organization or account, you create or update an identity-based policy. For 
more information, see Controlling access to AWS resources using policies in the IAM User Guide .
Authentication and authorization errors
If any of the permissions required to consume data from the Kafka cluster are missing, Lambda displays 
one of the following error messages in the event source mapping under LastProcessingResult.
Error messages
•Cluster failed to authorize Lambda (p. 748)
•SASL authentication failed  (p. 748)
•Server failed to authenticate Lambda (p. 748)
•Lambda failed to authenticate server (p. 749)
•Provided certiﬁcate or private key is invalid (p. 749)
Cluster failed to authorize Lambda
For SASL/SCRAM or mTLS, this error indicates that the provided user doesn't have all of the following 
required Kafka access control list (ACL) permissions:
•DescribeConﬁgs Cluster
•Describe Group
•Read Group
•Describe Topic
•Read Topic
When you create Kafka ACLs with the required kafka-cluster  permissions, specify the topic and group 
as resources. The topic name must match the topic in the event source mapping. The group name must 
match the event source mapping's UUID.
After you add the required permissions to the execution role, it might take several minutes for the 
changes to take eﬀect.
SASL authentication failed
For SASL/SCRAM or SASL/PLAIN, this error indicates that the provided sign-in credentials aren't valid.
Server failed to authenticate Lambda
This error indicates that the Kafka broker failed to authenticate Lambda. This can occur for any of the 
following reasons:
•You didn't provide a client certiﬁcate for mTLS authentication.
•You provided a client certiﬁcate, but the Kafka brokers aren't conﬁgured to use mTLS authentication.
•A client certiﬁcate isn't trusted by the Kafka brokers.
748AWS Lambda Developer Guide
Network conﬁguration
Lambda failed to authenticate server
This error indicates that Lambda failed to authenticate the Kafka broker. This can occur for any of the 
following reasons:
•The Kafka brokers use self-signed certiﬁcates or a private CA, but didn't provide the server root CA 
certiﬁcate.
•The server root CA certiﬁcate doesn't match the root CA that signed the broker's certiﬁcate.
•Hostname validation failed because the broker's certiﬁcate doesn't contain the broker's DNS name or 
IP address as a subject alternative name.
Provided certiﬁcate or private key is invalid
This error indicates that the Kafka consumer couldn't use the provided certiﬁcate or private key. Make 
sure that the certiﬁcate and key use PEM format, and that the private key encryption uses a PBES1 
algorithm.
Network conﬁguration
If you conﬁgure Amazon VPC access to your Kafka brokers, Lambda must have access to the Amazon 
VPC resources associated with your Kafka cluster. We recommend that you deploy AWS PrivateLink VPC 
endpoints  for Lambda and AWS Security Token Service (AWS STS). If the broker uses authentication, also 
deploy a VPC endpoint for Secrets Manager.
Alternatively, ensure that the VPC associated with your Kafka cluster includes one NAT gateway per 
public subnet. For more information, see Internet and service access for VPC-connected functions (p. 91).
Conﬁgure your Amazon VPC security groups with the following rules (at minimum):
•Inbound rules – Allow all traﬃc on the Kafka broker port for the security groups speciﬁed for your 
event source. Kafka uses port 9092 by default.
•Outbound rules – Allow all traﬃc on port 443 for all destinations. Allow all traﬃc on the Kafka broker 
port for the security groups speciﬁed for your event source. Kafka uses port 9092 by default.
•If you are using VPC endpoints instead of a NAT gateway, the security groups associated with the VPC 
endpoints must allow all inbound traﬃc on port 443 from the event source's security groups.
For more information about conﬁguring the network, see Setting up AWS Lambda with an Apache Kafka 
cluster within a VPC  on the AWS Compute Blog.
Adding a Kafka cluster as an event source
To create an event source mapping (p. 150), add your Kafka cluster as a Lambda function trigger  (p. 9)
using the Lambda console, an AWS SDK, or the AWS Command Line Interface (AWS CLI).
This section describes how to create an event source mapping using the Lambda console and the AWS 
CLI.
Note
When you update, disable, or delete an event source mapping for self-managed Apache Kafka, 
it can take up to 15 minutes for your changes to take eﬀect. Before this period has elapsed, 
your event source mapping may continue to process events and invoke your function using your 
previous settings. This is true even when the status of the event source mapping displayed in the 
console indicates that your changes have been applied.
749AWS Lambda Developer Guide
Adding a Kafka cluster as an event source
Prerequisites
•A self-managed Apache Kafka cluster. Lambda supports Apache Kafka version 0.10.0.0 and later.
•An execution role (p. 913) with permission to access the AWS resources that your self-managed Kafka 
cluster uses.
Customizable consumer group ID
When setting up Kafka as an event source, you can specify a consumer group ID. This consumer group 
ID is an existing identiﬁer for the Kafka consumer group that you want your Lambda function to join. 
You can use this feature to seamlessly migrate any ongoing Kafka record processing setups from other 
consumers to Lambda.
If you specify a consumer group ID and there are other active pollers within that consumer group, Kafka 
distributes messages across all consumers. In other words, Lambda doesn't receive all message for the 
Kafka topic. If you want Lambda to handle all messages in the topic, turn oﬀ any other pollers in that 
consumer group.
Additionally, if you specify a consumer group ID, and Kafka ﬁnds a valid existing consumer group with 
the same ID, Lambda ignores the StartingPosition  parameter for your event source mapping. 
Instead, Lambda begins processing records according to the committed oﬀset of the consumer group. 
If you specify a consumer group ID, and Kafka cannot ﬁnd an existing consumer group, then Lambda 
conﬁgures your event source with the speciﬁed StartingPosition .
The consumer group ID that you specify must be unique among all your Kafka event sources. After 
creating a Kafka event source mapping with the consumer group ID speciﬁed, you cannot update this 
value.
Adding a self-managed Kafka cluster (console)
Follow these steps to add your self-managed Apache Kafka cluster and a Kafka topic as a trigger for your 
Lambda function.
To add an Apache Kafka trigger to your Lambda function (console)
1. Open the Functions page of the Lambda console.
2. Choose the name of your Lambda function.
3. Under Function overview, choose Add trigger .
4. Under Trigger conﬁguration, do the following:
a. Choose the Apache Kafka  trigger type.
b. For Bootstrap servers, enter the host and port pair address of a Kafka broker in your cluster, 
and then choose Add. Repeat for each Kafka broker in the cluster.
c. For Topic name, enter the name of the Kafka topic used to store records in the cluster.
d. (Optional) For Batch size, enter the maximum number of records to receive in a single batch.
e. For Batch window, enter the maximum amount of seconds that Lambda spends gathering 
records before invoking the function.
f.(Optional) For Consumer group ID , enter the ID of a Kafka consumer group to join.
g. (Optional) For Starting position, choose Latest  to start reading the stream from the latest 
record, Trim horizon to start at the earliest available record, or At timestamp  to specify a 
timestamp to start reading from.
Note
At timestamp  can only be used be used with Kafka broker versions equal to or greater 
than 0.10.1.0.
750AWS Lambda Developer Guide
Adding a Kafka cluster as an event source
h. (Optional) For VPC, choose the Amazon VPC for your Kafka cluster. Then, choose the VPC 
subnets  and VPC security groups.
This setting is required if only users within your VPC access your brokers.
i. (Optional) For Authentication , choose Add, and then do the following:
i. Choose the access or authentication protocol of the Kafka brokers in your cluster.
• If your Kafka broker uses SASL/PLAIN authentication, choose BASIC_AUTH.
• If your broker uses SASL/SCRAM authentication, choose one of the SASL_SCRAM
protocols.
• If you're conﬁguring mTLS authentication, choose the
CLIENT_CERTIFICATE_TLS_AUTH protocol.
ii. For SASL/SCRAM or mTLS authentication, choose the Secrets Manager secret key that 
contains the credentials for your Kafka cluster.
j. (Optional) For Encryption, choose the Secrets Manager secret containing the root CA certiﬁcate 
that your Kafka brokers use for TLS encryption, if your Kafka brokers use certiﬁcates signed by a 
private CA.
This setting applies to TLS encryption for SASL/SCRAM or SASL/PLAIN, and to mTLS 
authentication.
k. To create the trigger in a disabled state for testing (recommended), clear Enable trigger. Or, to 
enable the trigger immediately, select Enable trigger.
5. To create the trigger, choose Add.
Adding a self-managed Kafka cluster (AWS CLI)
Use the following example AWS CLI commands to create and view a self-managed Apache Kafka trigger 
for your Lambda function.
Using SASL/SCRAM
If Kafka users access your Kafka brokers over the internet, specify the Secrets Manager secret that you 
created for SASL/SCRAM authentication. The following example uses the create-event-source-
mapping AWS CLI command to map a Lambda function named my-kafka-function  to a Kafka topic 
named AWSKafkaTopic .
aws lambda create-event-source-mapping --topics AWSKafkaTopic
          --source-access-configuration 
 Type=SASL_SCRAM_512_AUTH,URI=arn:aws:secretsmanager:us-
east-1:01234567890 :secret: MyBrokerSecretName
          --function-name arn:aws:lambda:us-east-1: 01234567890 :function: my-kafka-function
          --self-managed-event-source '{"Endpoints":{"KAFKA_BOOTSTRAP_SERVERS":
["abc3.xyz.com:9092 ", "abc2.xyz.com:9092 "]}}'
        
Using a VPC
If only Kafka users within your VPC access your Kafka brokers, you must specify your VPC, subnets, 
and VPC security group. The following example uses the create-event-source-mapping  AWS 
CLI command to map a Lambda function named my-kafka-function  to a Kafka topic named
AWSKafkaTopic .
aws lambda create-event-source-mapping 
          --topics AWSKafkaTopic
751AWS Lambda Developer Guide
Using a Kafka cluster as an event source
          --source-access-configuration '[{"Type": "VPC_SUBNET", "URI": 
 "subnet: subnet-0011001100 "}, 
          {"Type": "VPC_SUBNET", "URI": "subnet: subnet-0022002200 "}, 
          {"Type": "VPC_SECURITY_GROUP", "URI": "security_group: sg-0123456789 "}]' 
          --function-name arn:aws:lambda:us-east-1: 01234567890 :function: my-kafka-function
          --self-managed-event-source '{"Endpoints":{"KAFKA_BOOTSTRAP_SERVERS":
["abc3.xyz.com:9092 ", 
          " abc2.xyz.com:9092 "]}}'
Viewing the status using the AWS CLI
The following example uses the get-event-source-mapping  AWS CLI command to describe the 
status of the event source mapping that you created.
aws lambda get-event-source-mapping 
          --uuid dh38738e-992b-343a-1077-3478934hjkfd7
Using a Kafka cluster as an event source
When you add your Apache Kafka cluster as a trigger for your Lambda function, the cluster is used as an
event source (p. 150).
Lambda reads event data from the Kafka topics that you specify as Topics  in a
CreateEventSourceMapping (p. 1292 ) request, based on the StartingPosition  that you specify. After 
successful processing, your Kafka topic is committed to your Kafka cluster.
If you specify the StartingPosition  as LATEST, Lambda starts reading from the latest message in 
each partition belonging to the topic. Because there can be some delay after trigger conﬁguration before 
Lambda starts reading the messages, Lambda doesn't read any messages produced during this window.
Lambda processes records from one or more Kafka topic partitions that you specify and sends a JSON 
payload to your function. When more records are available, Lambda continues processing records in 
batches, based on the BatchSize  value that you specify in a CreateEventSourceMapping (p. 1292 )
request, until your function catches up with the topic.
If your function returns an error for any of the messages in a batch, Lambda retries the whole batch of 
messages until processing succeeds or the messages expire.
Note
While Lambda functions typically have a maximum timeout limit of 15 minutes, event source 
mappings for Amazon MSK, self-managed Apache Kafka, Amazon DocumentDB, and Amazon 
MQ for ActiveMQ and RabbitMQ only support functions with maximum timeout limits of 14 
minutes. This constraint ensures that the event source mapping can properly handle function 
errors and retries.
Auto scaling of the Kafka event source
When you initially create an an Apache Kafka event source (p. 150), Lambda allocates one consumer 
to process all partitions in the Kafka topic. Each consumer has multiple processors running in parallel 
to handle increased workloads. Additionally, Lambda automatically scales up or down the number of 
consumers, based on workload. To preserve message ordering in each partition, the maximum number of 
consumers is one consumer per partition in the topic.
In one-minute intervals, Lambda evaluates the consumer oﬀset lag of all the partitions in the topic. If 
the lag is too high, the partition is receiving messages faster than Lambda can process them. If necessary, 
Lambda adds or removes consumers from the topic. The scaling process of adding or removing 
consumers occurs within three minutes of evaluation.
752AWS Lambda Developer Guide
Event source API operations
If your target Lambda function is overloaded, Lambda reduces the number of consumers. This action 
reduces the workload on the function by reducing the number of messages that consumers can retrieve 
and send to the function.
To monitor the throughput of your Kafka topic, you can view the Apache Kafka consumer metrics, such 
as consumer_lag  and consumer_offset . To check how many function invocations occur in parallel, 
you can also monitor the concurrency metrics (p. 967) for your function.
Event source API operations
When you add your Kafka cluster as an event source (p. 150) for your Lambda function using the Lambda 
console, an AWS SDK, or the AWS CLI, Lambda uses APIs to process your request.
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
Event source mapping errors
When you add your Apache Kafka cluster as an event source (p. 150) for your Lambda function, if your 
function encounters an error, your Kafka consumer stops processing records. Consumers of a topic 
partition are those that subscribe to, read, and process your records. Your other Kafka consumers can 
continue processing records, provided they don't encounter the same error.
To determine the cause of a stopped consumer, check the StateTransitionReason  ﬁeld in the 
response of EventSourceMapping . The following list describes the event source errors that you can 
receive:
ESM_CONFIG_NOT_VALID
The event source mapping conﬁguration isn't valid.
EVENT_SOURCE_AUTHN_ERROR
Lambda couldn't authenticate the event source.
EVENT_SOURCE_AUTHZ_ERROR
Lambda doesn't have the required permissions to access the event source.
FUNCTION_CONFIG_NOT_VALID
The function conﬁguration isn't valid.
Note
If your Lambda event records exceed the allowed size limit of 6 MB, they can go unprocessed.
Amazon CloudWatch metrics
Lambda emits the OffsetLag  metric while your function processes records. The value of this metric 
is the diﬀerence in oﬀset between the last record written to the Kafka event source topic and the last 
record that your function's consumer group processed. You can use OffsetLag  to estimate the latency 
between when a record is added and when your consumer group processes it.
753AWS Lambda Developer Guide
Self-managed Apache Kafka conﬁguration parameters
An increasing trend in OffsetLag  can indicate issues with pollers in your function's consumer group. For 
more information, see Working with Lambda function metrics (p. 965).
Self-managed Apache Kafka conﬁguration 
parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
Apache Kafka.
Event source parameters that apply to self-managed Apache Kafka
Parameter Required Default Notes
BatchSize N 100 Maximum: 10,000
Enabled N Enabled
FunctionName Y
FilterCriteria N Lambda event 
ﬁltering  (p. 155)
MaximumBatchingWindowInSeconds N 500 ms Batching 
behavior (p. 151)
SelfManagedEventSourceY   List of Kafka Brokers. 
Can set only on Create
SelfManagedKafkaEventSourceConﬁg N Contains the 
ConsumerGroupId ﬁeld 
which defaults to a 
unique value.Can set only on Create
SourceAccessConﬁgurationsN No credentials VPC information 
or authentication 
credentials for the 
cluster
For SASL_PLAIN, set to 
BASIC_AUTH
StartingPosition Y AT_TIMESTAMP, 
TRIM_HORIZON, or 
LATEST
Can set only on Create
StartingPositionTimestampN Required if 
StartingPosition is set 
to AT_TIMESTAMP
Topics Y Topic name
Can set only on Create
754AWS Lambda Developer Guide
Kinesis Firehose
Using AWS Lambda with Amazon Kinesis Data 
Firehose
Amazon Kinesis Data Firehose captures, transforms, and loads streaming data into downstream services 
such as Kinesis Data Analytics or Amazon S3. You can write Lambda functions to request additional, 
customized processing of the data before it is sent downstream.
Example Amazon Kinesis Data Firehose message event
{ 
  "invocationId": "invoked123", 
  "deliveryStreamArn": "aws:lambda:events", 
  "region": "us-west-2", 
  "records": [ 
    { 
      "data": "SGVsbG8gV29ybGQ=", 
      "recordId": "record1", 
      "approximateArrivalTimestamp": 1510772160000, 
      "kinesisRecordMetadata": { 
        "shardId": "shardId-000000000000", 
        "partitionKey": "4d1ad2b9-24f8-4b9d-a088-76e9947c317a", 
        "approximateArrivalTimestamp": "2012-04-23T18:25:43.511Z", 
        "sequenceNumber": "49546986683135544286507457936321625675700192471156785154", 
        "subsequenceNumber": "" 
      } 
    }, 
    { 
      "data": "SGVsbG8gV29ybGQ=", 
      "recordId": "record2", 
      "approximateArrivalTimestamp": 151077216000, 
      "kinesisRecordMetadata": { 
        "shardId": "shardId-000000000001", 
        "partitionKey": "4d1ad2b9-24f8-4b9d-a088-76e9947c318a", 
        "approximateArrivalTimestamp": "2012-04-23T19:25:43.511Z", 
        "sequenceNumber": "49546986683135544286507457936321625675700192471156785155", 
        "subsequenceNumber": "" 
      } 
    } 
  ]
}
For more information, see Amazon Kinesis Data Firehose data transformation  in the Kinesis Data 
Firehose Developer Guide.
755AWS Lambda Developer Guide
Kinesis Streams
Using AWS Lambda with Amazon Kinesis
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
You can use an AWS Lambda function to process records in an Amazon Kinesis data stream.
A Kinesis data stream is a set of shards. Each shard contains a sequence of data records. A consumer is 
an application that processes the data from a Kinesis data stream. You can map a Lambda function to a 
shared-throughput consumer (standard iterator), or to a dedicated-throughput consumer with enhanced 
fan-out .
For standard iterators, Lambda polls each shard in your Kinesis stream for records using HTTP protocol. 
The event source mapping shares read throughput with other consumers of the shard.
To minimize latency and maximize read throughput, you can create a data stream consumer with 
enhanced fan-out. Stream consumers get a dedicated connection to each shard that doesn't impact 
other applications reading from the stream. The dedicated throughput can help if you have many 
applications reading the same data, or if you're reprocessing a stream with large records. Kinesis pushes 
records to Lambda over HTTP/2.
For details about Kinesis data streams, see Reading Data from Amazon Kinesis Data Streams.
Sections
•Example event (p. 756)
•Polling and batching streams (p. 757)
•Conﬁguring your data stream and function (p. 758)
•Execution role permissions (p. 758)
•Conﬁguring a stream as an event source (p. 759)
•Filtering Kinesis events (p. 760)
•Event source mapping API (p. 760)
•Error handling (p. 762)
•Amazon CloudWatch metrics (p. 763)
•Time windows (p. 763)
•Reporting batch item failures (p. 765)
•Amazon Kinesis conﬁguration parameters (p. 767)
•Tutorial: Using AWS Lambda with Amazon Kinesis (p. 768)
•Sample function code (p. 773)
•AWS SAM template for a Kinesis application (p. 776)
Example event
Example
{ 
    "Records": [ 
        { 
            "kinesis": { 
                "kinesisSchemaVersion": "1.0", 
                "partitionKey": "1", 
                "sequenceNumber": 
 "49590338271490256608559692538361571095921575989136588898", 
756AWS Lambda Developer Guide
Polling and batching streams
                "data": "SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
                "approximateArrivalTimestamp": 1545084650.987 
            }, 
            "eventSource": "aws:kinesis", 
            "eventVersion": "1.0", 
            "eventID": 
 "shardId-000000000006:49590338271490256608559692538361571095921575989136588898", 
            "eventName": "aws:kinesis:record", 
            "invokeIdentityArn": "arn:aws:iam::123456789012:role/lambda-role", 
            "awsRegion": "us-east-2", 
            "eventSourceARN": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream" 
        }, 
        { 
            "kinesis": { 
                "kinesisSchemaVersion": "1.0", 
                "partitionKey": "1", 
                "sequenceNumber": 
 "49590338271490256608559692540925702759324208523137515618", 
                "data": "VGhpcyBpcyBvbmx5IGEgdGVzdC4=", 
                "approximateArrivalTimestamp": 1545084711.166 
            }, 
            "eventSource": "aws:kinesis", 
            "eventVersion": "1.0", 
            "eventID": 
 "shardId-000000000006:49590338271490256608559692540925702759324208523137515618", 
            "eventName": "aws:kinesis:record", 
            "invokeIdentityArn": "arn:aws:iam::123456789012:role/lambda-role", 
            "awsRegion": "us-east-2", 
            "eventSourceARN": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream" 
        } 
    ]
}
Polling and batching streams
Lambda reads records from the data stream and invokes your function synchronously (p. 139) with 
an event that contains stream records. Lambda reads records in batches and invokes your function to 
process records from the batch. Each batch contains records from a single shard/data stream.
By default, Lambda invokes your function as soon as records are available. If the batch that Lambda 
reads from the event source has only one record in it, Lambda sends only one record to the function. 
To avoid invoking the function with a small number of records, you can tell the event source to 
buﬀer records for up to 5 minutes by conﬁguring a batching window . Before invoking the function, 
Lambda continues to read records from the event source until it has gathered a full batch, the batching 
window expires, or the batch reaches the payload limit of 6 MB. For more information, see Batching 
behavior (p. 151).
If your function returns an error, Lambda retries the batch until processing succeeds or the data expires. 
To avoid stalled shards, you can conﬁgure the event source mapping to retry with a smaller batch size, 
limit the number of retries, or discard records that are too old. To retain discarded events, you can 
conﬁgure the event source mapping to send details about failed batches to a standard SQS queue or 
standard SNS topic.
You can also increase concurrency by processing multiple batches from each shard in parallel. Lambda 
can process up to 10 batches in each shard simultaneously. If you increase the number of concurrent 
batches per shard, Lambda still ensures in-order processing at the partition key level.
Conﬁgure the ParallelizationFactor  setting to process one shard of a Kinesis or DynamoDB 
data stream with more than one Lambda invocation simultaneously. You can specify the number 
of concurrent batches that Lambda polls from a shard via a parallelization factor from 1 (default) 
to 10. For example, when you set ParallelizationFactor  to 2, you can have 200 concurrent 
757AWS Lambda Developer Guide
Conﬁguring your data stream and function
Lambda invocations at maximum to process 100 Kinesis data shards. This helps scale up the processing 
throughput when the data volume is volatile and the IteratorAge  is high. Note that parallelization 
factor will not work if you are using Kinesis aggregation. For more information, see New AWS Lambda 
scaling controls for Kinesis and DynamoDB event sources. Also, see the Serverless Data Processing on 
AWS workshop for complete tutorials.
Conﬁguring your data stream and function
Your Lambda function is a consumer application for your data stream. It processes one batch of records 
at a time from each shard. You can map a Lambda function to a data stream (standard iterator), or to a 
consumer of a stream (enhanced fan-out).
For standard iterators, Lambda polls each shard in your Kinesis stream for records at a base rate of 
once per second. When more records are available, Lambda keeps processing batches until the function 
catches up with the stream. The event source mapping shares read throughput with other consumers of 
the shard.
To minimize latency and maximize read throughput, create a data stream consumer with enhanced fan-
out. Enhanced fan-out consumers get a dedicated connection to each shard that doesn't impact other 
applications reading from the stream. Stream consumers use HTTP/2 to reduce latency by pushing 
records to Lambda over a long-lived connection and by compressing request headers. You can create a 
stream consumer with the Kinesis RegisterStreamConsumer API.
aws kinesis register-stream-consumer --consumer-name con1 \
--stream-arn arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream
You should see the following output:
{ 
    "Consumer": { 
        "ConsumerName": "con1", 
        "ConsumerARN": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream/
consumer/con1:1540591608", 
        "ConsumerStatus": "CREATING", 
        "ConsumerCreationTimestamp": 1540591608.0 
    }
}
To increase the speed at which your function processes records, add shards to your data stream. Lambda 
processes records in each shard in order. It stops processing additional records in a shard if your function 
returns an error. With more shards, there are more batches being processed at once, which lowers the 
impact of errors on concurrency.
If your function can't scale up to handle the total number of concurrent batches, request a quota 
increase (p. 1269 ) or reserve concurrency (p. 234) for your function.
Execution role permissions
Lambda needs the following permissions to manage resources that are related to your Kinesis data 
stream. Add them to your function's execution role (p. 913).
•kinesis:DescribeStream
•kinesis:DescribeStreamSummary
•kinesis:GetRecords
•kinesis:GetShardIterator
758AWS Lambda Developer Guide
Conﬁguring a stream as an event source
•kinesis:ListShards
•kinesis:ListStreams
•kinesis:SubscribeToShard
The AWSLambdaKinesisExecutionRole  managed policy includes these permissions. For more 
information, see Lambda execution role (p. 913).
To send records of failed batches to a standard SQS queue or standard SNS topic, your function needs 
additional permissions. Each destination service requires a diﬀerent permission, as follows:
•Amazon SQS – sqs:SendMessage
•Amazon SNS – sns:Publish
Conﬁguring a stream as an event source
Create an event source mapping to tell Lambda to send records from your data stream to a Lambda 
function. You can create multiple event source mappings to process the same data with multiple Lambda 
functions, or to process items from multiple data streams with a single function. When processing items 
from multiple data streams, each batch will only contain records from a single shard/stream.
To conﬁgure your function to read from Kinesis in the Lambda console, create a Kinesis  trigger.
To create a trigger
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Under Function overview, choose Add trigger .
4. Choose a trigger type.
5. Conﬁgure the required options, and then choose Add.
Lambda supports the following options for Kinesis event sources.
Event source options
•Kinesis stream  – The Kinesis stream to read records from.
•Consumer  (optional) – Use a stream consumer to read from the stream over a dedicated connection.
•Batch size – The number of records to send to the function in each batch, up to 10,000. Lambda 
passes all of the records in the batch to the function in a single call, as long as the total size of the 
events doesn't exceed the payload limit (p. 1269 ) for synchronous invocation (6 MB).
•Batch window – Specify the maximum amount of time to gather records before invoking the function, 
in seconds.
•Starting position – Process only new records, all existing records, or records created after a certain 
date.
•Latest  – Process new records that are added to the stream.
•Trim horizon – Process all records in the stream.
•At timestamp  – Process records starting from a speciﬁc time.
After processing any existing records, the function is caught up and continues to process new records.
•On-failure destination  – A standard SQS queue or standard SNS topic for records that can't be 
processed. When Lambda discards a batch of records that's too old or has exhausted all retries, 
Lambda sends details about the batch to the queue or topic.
759AWS Lambda Developer Guide
Filtering Kinesis events
•Retry attempts – The maximum number of times that Lambda retries when the function returns an 
error. This doesn't apply to service errors or throttles where the batch didn't reach the function.
•Maximum age of record – The maximum age of a record that Lambda sends to your function.
•Split batch on error  – When the function returns an error, split the batch into two before retrying. 
Your original batch size setting remains unchanged.
•Concurrent batches per shard  – Concurrently process multiple batches from the same shard.
•Enabled – Set to true to enable the event source mapping. Set to false to stop processing records. 
Lambda keeps track of the last record processed and resumes processing from that point when it's 
reenabled.
Note
Kinesis charges for each shard and, for enhanced fan-out, data read from the stream. For pricing 
details, see Amazon Kinesis pricing.
To manage the event source conﬁguration later, choose the trigger in the designer.
Filtering Kinesis events
When you conﬁgure Kinesis as an event source for Lambda, you can use event ﬁltering to control which 
records from your stream Lambda sends to your function for processing. To learn more about using 
Lambda event ﬁltering with Kinesis, see Filtering with Kinesis .
Event source mapping API
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
To create the event source mapping with the AWS CLI, use the create-event-source-mapping
command. The following example uses the AWS CLI to map a function named my-function  to a Kinesis 
data stream. The data stream is speciﬁed by an Amazon Resource Name (ARN), with a batch size of 500, 
starting from the timestamp in Unix time.
aws lambda create-event-source-mapping --function-name my-function \
--batch-size 500 --starting-position AT_TIMESTAMP --starting-position-timestamp 1541139109 
 \
--event-source-arn arn:aws:kinesis: us-east-2:123456789012:stream/lambda-stream
You should see the following output:
{ 
    "UUID": "2b733gdc-8ac3-cdf5-af3a-1827b3b11284", 
    "BatchSize": 500, 
    "MaximumBatchingWindowInSeconds": 0, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1541139209.351, 
760AWS Lambda Developer Guide
Event source mapping API
    "LastProcessingResult": "No records processed", 
    "State": "Creating", 
    "StateTransitionReason": "User action", 
    "DestinationConfig": {}, 
    "MaximumRecordAgeInSeconds": 604800, 
    "BisectBatchOnFunctionError": false, 
    "MaximumRetryAttempts": 10000
}
To use a consumer, specify the consumer's ARN instead of the stream's ARN.
Conﬁgure additional options to customize how batches are processed and to specify when to discard 
records that can't be processed. The following example updates an event source mapping to send a 
failure record to a standard SQS queue after two retry attempts, or if the records are more than an hour 
old.
aws lambda update-event-source-mapping --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b \
--maximum-retry-attempts 2  --maximum-record-age-in-seconds 3600
--destination-config '{"OnFailure": {"Destination": "arn:aws:sqs:us-
east-2:123456789012:dlq"}}'
You should see this output:
{ 
    "UUID": "f89f8514-cdd9-4602-9e1f-01a5b77d449b", 
    "BatchSize": 100, 
    "MaximumBatchingWindowInSeconds": 0, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1573243620.0, 
    "LastProcessingResult": "PROBLEM: Function call failed", 
     "State": "Updating", 
    "StateTransitionReason": "User action",
    "DestinationConfig": {}, 
    "MaximumRecordAgeInSeconds": 604800, 
    "BisectBatchOnFunctionError": false, 
    "MaximumRetryAttempts": 10000
}
Updated settings are applied asynchronously and aren't reﬂected in the output until the process 
completes. Use the get-event-source-mapping  command to view the current status.
aws lambda get-event-source-mapping --uuid f89f8514-cdd9-4602-9e1f-01a5b77d449b
You should see this output:
{ 
    "UUID": "f89f8514-cdd9-4602-9e1f-01a5b77d449b", 
    "BatchSize": 100, 
    "MaximumBatchingWindowInSeconds": 0, 
    "ParallelizationFactor": 1, 
    "EventSourceArn": "arn:aws:kinesis:us-east-2:123456789012:stream/lambda-stream", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1573244760.0, 
    "LastProcessingResult": "PROBLEM: Function call failed", 
    "State": "Enabled", 
    "StateTransitionReason": "User action", 
     "DestinationConfig": { 
        "OnFailure": { 
761AWS Lambda Developer Guide
Error handling
            "Destination": "arn:aws:sqs:us-east-2:123456789012:dlq" 
        } 
    }, 
    "MaximumRecordAgeInSeconds": 3600,
    "BisectBatchOnFunctionError": false, 
     "MaximumRetryAttempts": 2
}
To process multiple batches concurrently, use the --parallelization-factor  option.
aws lambda update-event-source-mapping --uuid 2b733gdc-8ac3-cdf5-af3a-1827b3b11284 \
--parallelization-factor 5
Error handling
The event source mapping that reads records from your Kinesis stream, invokes your function 
synchronously, and retries on errors. If Lambda throttles the function or returns an error without 
invoking the function, Lambda retries until the records expire or exceed the maximum age that you 
conﬁgure on the event source mapping.
If the function receives the records but returns an error, Lambda retries until the records in the batch 
expire, exceed the maximum age, or reach the conﬁgured retry quota. For function errors, you can also 
conﬁgure the event source mapping to split a failed batch into two batches. Retrying with smaller 
batches isolates bad records and works around timeout issues. Splitting a batch does not count towards 
the retry quota.
If the error handling measures fail, Lambda discards the records and continues processing batches 
from the stream. With the default settings, this means that a bad record can block processing on the 
aﬀected shard for up to one week. To avoid this, conﬁgure your function's event source mapping with a 
reasonable number of retries and a maximum record age that ﬁts your use case.
To retain a record of discarded batches, conﬁgure a failed-event destination. Lambda sends a document 
to the destination queue or topic with details about the batch.
To conﬁgure a destination for failed-event records
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Under Function overview, choose Add destination .
4. For Source, choose Stream invocation.
5. For Stream , choose a stream that is mapped to the function.
6. For Destination type, choose the type of resource that receives the invocation record.
7. For Destination , choose a resource.
8. Choose Save.
The following example shows an invocation record for a Kinesis stream.
Example invocation record
{ 
    "requestContext": { 
        "requestId": "c9b8fa9f-5a7f-xmpl-af9c-0c604cde93a5", 
        "functionArn": "arn:aws:lambda:us-east-2:123456789012:function:myfunction", 
        "condition": "RetryAttemptsExhausted", 
762AWS Lambda Developer Guide
Amazon CloudWatch metrics
        "approximateInvokeCount": 1 
    }, 
    "responseContext": { 
        "statusCode": 200, 
        "executedVersion": "$LATEST", 
        "functionError": "Unhandled" 
    }, 
    "version": "1.0", 
    "timestamp": "2019-11-14T00:38:06.021Z", 
    "KinesisBatchInfo": { 
        "shardId": "shardId-000000000001", 
        "startSequenceNumber": "49601189658422359378836298521827638475320189012309704722", 
        "endSequenceNumber": "49601189658422359378836298522902373528957594348623495186", 
        "approximateArrivalOfFirstRecord": "2019-11-14T00:38:04.835Z", 
        "approximateArrivalOfLastRecord": "2019-11-14T00:38:05.580Z", 
        "batchSize": 500, 
        "streamArn": "arn:aws:kinesis:us-east-2:123456789012:stream/mystream" 
    }
}
You can use this information to retrieve the aﬀected records from the stream for troubleshooting. The 
actual records aren't included, so you must process this record and retrieve them from the stream before 
they expire and are lost.
Amazon CloudWatch metrics
Lambda emits the IteratorAge  metric when your function ﬁnishes processing a batch of records. The 
metric indicates how old the last record in the batch was when processing ﬁnished. If your function is 
processing new events, you can use the iterator age to estimate the latency between when a record is 
added and when the function processes it.
An increasing trend in iterator age can indicate issues with your function. For more information, see
Working with Lambda function metrics (p. 965).
Time windows
Lambda functions can run continuous stream processing applications. A stream represents unbounded 
data that ﬂows continuously through your application. To analyze information from this continuously 
updating input, you can bound the included records using a window deﬁned in terms of time.
Tumbling windows are distinct time windows that open and close at regular intervals. By default, 
Lambda invocations are stateless—you cannot use them for processing data across multiple continuous 
invocations without an external database. However, with tumbling windows, you can maintain your state 
across invocations. This state contains the aggregate result of the messages previously processed for 
the current window. Your state can be a maximum of 1 MB per shard. If it exceeds that size, Lambda 
terminates the window early.
Each record in a stream belongs to a speciﬁc window. Lambda will process each record at least once, but 
doesn't guarantee that each record will be processed only once. In rare cases, such as error handling, 
some records might be processed more than once. Records are always processed in order the ﬁrst time. If 
records are processed more than once, they might be processed out of order.
Aggregation and processing
Your user managed function is invoked both for aggregation and for processing the ﬁnal results of 
that aggregation. Lambda aggregates all records received in the window. You can receive these records 
in multiple batches, each as a separate invocation. Each invocation receives a state. Thus, when using 
tumbling windows, your Lambda function response must contain a state property. If the response does 
763AWS Lambda Developer Guide
Time windows
not contain a state property, Lambda considers this a failed invocation. To satisfy this condition, your 
function can return a TimeWindowEventResponse  object, which has the following JSON shape:
Example TimeWindowEventResponse  values
{ 
    "state": { 
        "1": 282, 
        "2": 715 
    }, 
    "batchItemFailures": []
}
Note
For Java functions, we recommend using a Map<String, String>  to represent the state.
At the end of the window, the ﬂag isFinalInvokeForWindow  is set to true  to indicate that this is 
the ﬁnal state and that it’s ready for processing. After processing, the window completes and your ﬁnal 
invocation completes, and then the state is dropped.
At the end of your window, Lambda uses ﬁnal processing for actions on the aggregation results. Your 
ﬁnal processing is synchronously invoked. After successful invocation, your function checkpoints the 
sequence number and stream processing continues. If invocation is unsuccessful, your Lambda function 
suspends further processing until a successful invocation.
Example KinesisTimeWindowEvent
{ 
    "Records": [ 
        { 
            "kinesis": { 
                "kinesisSchemaVersion": "1.0", 
                "partitionKey": "1", 
                "sequenceNumber": 
 "49590338271490256608559692538361571095921575989136588898", 
                "data": "SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
                "approximateArrivalTimestamp": 1607497475.000 
            }, 
            "eventSource": "aws:kinesis", 
            "eventVersion": "1.0", 
            "eventID": 
 "shardId-000000000006:49590338271490256608559692538361571095921575989136588898", 
            "eventName": "aws:kinesis:record", 
            "invokeIdentityArn": "arn:aws:iam::123456789012:role/lambda-kinesis-role", 
            "awsRegion": "us-east-1", 
            "eventSourceARN": "arn:aws:kinesis:us-east-1:123456789012:stream/lambda-stream" 
        } 
    ], 
    "window": { 
        "start": "2020-12-09T07:04:00Z", 
        "end": "2020-12-09T07:06:00Z" 
    }, 
    "state": { 
        "1": 282, 
        "2": 715 
    }, 
    "shardId": "shardId-000000000006", 
    "eventSourceARN": "arn:aws:kinesis:us-east-1:123456789012:stream/lambda-stream", 
    "isFinalInvokeForWindow": false, 
    "isWindowTerminatedEarly": false
}
764AWS Lambda Developer Guide
Reporting batch item failures
Conﬁguration
You can conﬁgure tumbling windows when you create or update an event source mapping (p. 150). To 
conﬁgure a tumbling window, specify the window in seconds. The following example AWS Command 
Line Interface (AWS CLI) command creates a streaming event source mapping that has a tumbling 
window of 120 seconds. The Lambda function deﬁned for aggregation and processing is named
tumbling-window-example-function .
aws lambda create-event-source-mapping --event-source-arn arn:aws:kinesis:us-
east-1:123456789012:stream/lambda-stream --function-name "arn:aws:lambda:us-
east-1:123456789018:function:tumbling-window-example-function" --region us-east-1 --
starting-position TRIM_HORIZON --tumbling-window-in-seconds 120
Lambda determines tumbling window boundaries based on the time when records were inserted 
into the stream. All records have an approximate timestamp available that Lambda uses in boundary 
determinations.
Tumbling window aggregations do not support resharding. When the shard ends, Lambda considers the 
window closed, and the child shards start their own window in a fresh state.
Tumbling windows fully support the existing retry policies maxRetryAttempts  and maxRecordAge .
Example Handler.py – Aggregation and processing
The following Python function demonstrates how to aggregate and then process your ﬁnal state:
def lambda_handler(event, context): 
    print('Incoming event: ', event) 
    print('Incoming state: ', event['state'])
#Check if this is the end of the window to either aggregate or process. 
    if event['isFinalInvokeForWindow']: 
        # logic to handle final state of the window 
        print('Destination invoke') 
    else: 
        print('Aggregate invoke')
#Check for early terminations 
    if event['isWindowTerminatedEarly']: 
        print('Window terminated early') 
    #Aggregation logic 
    state = event['state'] 
    for record in event['Records']: 
        state[record['kinesis']['partitionKey']] = state.get(record['kinesis']
['partitionKey'], 0) + 1 
    print('Returning state: ', state) 
    return {'state': state}
Reporting batch item failures
When consuming and processing streaming data from an event source, by default Lambda checkpoints 
to the highest sequence number of a batch only when the batch is a complete success. Lambda treats 
all other results as a complete failure and retries processing the batch up to the retry limit. To allow 
for partial successes while processing batches from a stream, turn on ReportBatchItemFailures . 
Allowing partial successes can help to reduce the number of retries on a record, though it doesn’t 
entirely prevent the possibility of retries in a successful record.
765AWS Lambda Developer Guide
Reporting batch item failures
To turn on ReportBatchItemFailures , include the enum value ReportBatchItemFailures  in the
FunctionResponseTypes  list. This list indicates which response types are enabled for your function. 
You can conﬁgure this list when you create or update an event source mapping (p. 150).
Report syntax
When conﬁguring reporting on batch item failures, the StreamsEventResponse  class is returned with 
a list of batch item failures. You can use a StreamsEventResponse  object to return the sequence 
number of the ﬁrst failed record in the batch. You can also create your own custom class using the 
correct response syntax. The following JSON structure shows the required response syntax:
{  
  "batchItemFailures": [  
        { 
            "itemIdentifier": "<id>" 
        } 
    ]
}
Note
If the batchItemFailures  array contains multiple items, Lambda uses the record with the 
lowest sequence number as the checkpoint. Lambda then retries all records starting from that 
checkpoint.
Success and failure conditions
Lambda treats a batch as a complete success if you return any of the following:
•An empty batchItemFailure  list
•A null batchItemFailure  list
•An empty EventResponse
•A null EventResponse
Lambda treats a batch as a complete failure if you return any of the following:
•An empty string itemIdentifier
•A null itemIdentifier
•An itemIdentifier  with a bad key name
Lambda retries failures based on your retry strategy.
Bisecting a batch
If your invocation fails and BisectBatchOnFunctionError  is turned on, the batch is bisected 
regardless of your ReportBatchItemFailures  setting.
When a partial batch success response is received and both BisectBatchOnFunctionError  and
ReportBatchItemFailures  are turned on, the batch is bisected at the returned sequence number and 
Lambda retries only the remaining records.
Java
Example Handler.java – return new StreamsEventResponse()
import com.amazonaws.services.lambda.runtime.Context;
766AWS Lambda Developer Guide
Amazon Kinesis conﬁguration parameters
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.KinesisEvent;
import com.amazonaws.services.lambda.runtime.events.StreamsEventResponse;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
public class ProcessKinesisRecords implements RequestHandler<KinesisEvent, 
 StreamsEventResponse> { 
    @Override 
    public StreamsEventResponse handleRequest(KinesisEvent input, Context context) { 
        List<StreamsEventResponse.BatchItemFailure> batchItemFailures = new 
 ArrayList<>(); 
        String curRecordSequenceNumber = ""; 
        for (KinesisEvent.KinesisEventRecord kinesisEventRecord : input.getRecords()) { 
            try { 
                //Process your record 
                KinesisEvent.Record kinesisRecord = kinesisEventRecord.getKinesis(); 
                curRecordSequenceNumber = kinesisRecord.getSequenceNumber(); 
            } catch (Exception e) { 
                /* Since we are working with streams, we can return the failed item 
 immediately. 
                   Lambda will immediately begin to retry processing from this failed 
 item onwards. */ 
                batchItemFailures.add(new 
 StreamsEventResponse.BatchItemFailure(curRecordSequenceNumber)); 
                return new StreamsEventResponse(batchItemFailures); 
            } 
        } 
        
       return new StreamsEventResponse(batchItemFailures);    
    }
}
Python
Example Handler.py – return batchItemFailures[]
def handler(event, context): 
    records = event.get("Records") 
    curRecordSequenceNumber = "" 
     
    for record in records: 
        try: 
            # Process your record 
            curRecordSequenceNumber = record["kinesis"]["sequenceNumber"] 
        except Exception as e: 
            # Return failed record's sequence number 
            return {"batchItemFailures":[{"itemIdentifier": curRecordSequenceNumber}]} 
    return {"batchItemFailures":[]}
Amazon Kinesis conﬁguration parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
Kinesis.
767AWS Lambda Developer Guide
Tutorial
Event source parameters that apply to Kinesis
Parameter Required Default Notes
BatchSize N 100 Maximum: 10,000
BisectBatchOnFunctionErrorN false
DestinationConﬁg N standard Amazon SQS 
queue or standard 
Amazon SNS topic 
destination for 
discarded records
Enabled N true
EventSourceArn Y   ARN of the data stream 
or a stream consumer
FunctionName Y
MaximumBatchingWindowInSeconds N 0
MaximumRecordAgeInSecondsN -1 -1 means inﬁnite: 
Lambda doesn't discard 
records
Minimum: -1
Maximum: 604,800
MaximumRetryAttemptsN -1 -1 means inﬁnite: failed 
records are retried until 
the record expires
Minimum: -1
Maximum: 10,000
ParallelizationFactor N 1 Maximum: 10
StartingPosition Y AT_TIMESTAMP, 
TRIM_HORIZON, or 
LATEST
StartingPositionTimestampN Only valid if 
StartingPosition is set 
to AT_TIMESTAMP. The 
time from which to 
start reading, in Unix 
time seconds
TumblingWindowInSecondsN Minimum: 0
Maximum: 900
Tutorial: Using AWS Lambda with Amazon Kinesis
In this tutorial, you create a Lambda function to consume events from a Kinesis stream.
768AWS Lambda Developer Guide
Tutorial
1.Custom app writes records to the stream.
2.AWS Lambda polls the stream and, when it detects new records in the stream, invokes your Lambda 
function.
3.AWS Lambda runs the Lambda function by assuming the execution role you speciﬁed at the time you 
created the Lambda function.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role
Create the execution role (p. 913) that gives your function permission to access AWS resources.
To create an execution role
1. Open the roles page in the IAM console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – AWS Lambda.
•Permissions – AWSLambdaKinesisExecutionRole.
•Role name – lambda-kinesis-role .
The AWSLambdaKinesisExecutionRole policy has the permissions that the function needs to read items 
from Kinesis and write logs to CloudWatch Logs.
Create the function
The following example code receives a Kinesis event input and processes the messages that it contains. 
For illustration, the code writes some of the incoming event data to CloudWatch Logs.
769AWS Lambda Developer Guide
Tutorial
Note
For sample code in other languages, see Sample function code (p. 773).
Example index.mjs
console.log('Loading function');
export const handler = (event, context) => { 
    //console.log(JSON.stringify(event, null, 2)); 
    event.Records.forEach(record => { 
        // Kinesis data is base64 encoded so decode here 
        let payload = Buffer.from(record.kinesis.data, 'base64').toString('ascii'); 
        console.log('Decoded payload:', payload); 
    });
};
To create the function
1. Copy the sample code into a ﬁle named index.mjs .
2. Create a deployment package.
zip function.zip index.mjs
3. Create a Lambda function with the create-function  command.
aws lambda create-function --function-name ProcessKinesisRecords \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: 111122223333 :role/lambda-kinesis-role
Test the Lambda function
Invoke your Lambda function manually using the invoke AWS Lambda CLI command and a sample 
Kinesis event.
To test the Lambda function
1. Copy the following JSON into a ﬁle and save it as input.txt .
{ 
    "Records": [ 
        { 
            "kinesis": { 
                "kinesisSchemaVersion": "1.0", 
                "partitionKey": "1", 
                "sequenceNumber": 
 "49590338271490256608559692538361571095921575989136588898", 
                "data": "SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
                "approximateArrivalTimestamp": 1545084650.987 
            }, 
            "eventSource": "aws:kinesis", 
            "eventVersion": "1.0", 
            "eventID": 
 "shardId-000000000006:49590338271490256608559692538361571095921575989136588898", 
            "eventName": "aws:kinesis:record", 
            "invokeIdentityArn": "arn:aws:iam::111122223333:role/lambda-kinesis-role", 
            "awsRegion": "us-east-2", 
            "eventSourceARN": "arn:aws:kinesis:us-east-2:111122223333:stream/lambda-
stream" 
770AWS Lambda Developer Guide
Tutorial
        } 
    ]
}
2. Use the invoke command to send the event to the function.
aws lambda invoke --function-name ProcessKinesisRecords \
--cli-binary-format raw-in-base64-out \
--payload file://input.txt outputfile.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
The response is saved to out.txt .
Create a Kinesis stream
Use the create-stream  command to create a stream.
aws kinesis create-stream --stream-name lambda-stream --shard-count 1
Run the following describe-stream  command to get the stream ARN.
aws kinesis describe-stream --stream-name lambda-stream
You should see the following output:
{ 
    "StreamDescription": { 
        "Shards": [ 
            { 
                "ShardId": "shardId-000000000000", 
                "HashKeyRange": { 
                    "StartingHashKey": "0", 
                    "EndingHashKey": "340282366920746074317682119384634633455" 
                }, 
                "SequenceNumberRange": { 
                    "StartingSequenceNumber": 
 "49591073947768692513481539594623130411957558361251844610" 
                } 
            } 
        ], 
        "StreamARN": "arn:aws:kinesis:us-east-1:111122223333:stream/lambda-stream", 
        "StreamName": "lambda-stream", 
        "StreamStatus": "ACTIVE", 
        "RetentionPeriodHours": 24, 
        "EnhancedMonitoring": [ 
            { 
                "ShardLevelMetrics": [] 
            } 
        ], 
        "EncryptionType": "NONE", 
        "KeyId": null, 
        "StreamCreationTimestamp": 1544828156.0 
    }
}
You use the stream ARN in the next step to associate the stream with your Lambda function.
771AWS Lambda Developer Guide
Tutorial
Add an event source in AWS Lambda
Run the following AWS CLI add-event-source  command.
aws lambda create-event-source-mapping --function-name ProcessKinesisRecords \
--event-source  arn:aws:kinesis:us-east-1:111122223333:stream/lambda-stream \
--batch-size 100 --starting-position LATEST
Note the mapping ID for later use. You can get a list of event source mappings by running the list-
event-source-mappings  command.
aws lambda list-event-source-mappings --function-name ProcessKinesisRecords \
--event-source arn:aws:kinesis:us-east-1:111122223333:stream/lambda-stream
In the response, you can verify the status value is enabled. Event source mappings can be disabled to 
pause polling temporarily without losing any records.
Test the setup
To test the event source mapping, add event records to your Kinesis stream. The --data  value is a string 
that the CLI encodes to base64 prior to sending it to Kinesis. You can run the same command more than 
once to add multiple records to the stream.
aws kinesis put-record --stream-name lambda-stream --partition-key 1 \
--data "Hello, this is a test."
Lambda uses the execution role to read records from the stream. Then it invokes your Lambda function, 
passing in batches of records. The function decodes data from each record and logs it, sending the 
output to CloudWatch Logs. View the logs in the CloudWatch console.
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the Kinesis stream
1. Sign in to the AWS Management Console and open the Kinesis console at https:// 
console.aws.amazon.com/kinesis.
772AWS Lambda Developer Guide
Sample code
2. Select the stream you created.
3. Choose Actions, Delete.
4. Enter delete in the text input ﬁeld.
5. Choose Delete.
Sample function code
To process events from Amazon Kinesis, iterate through the records included in the event object and 
decode the Base64-encoded data included in each.
Note
The code on this page does not support aggregated records. You can disable aggregation in 
the Kinesis Producer Library conﬁguration, or use the Kinesis Record Aggregation library to 
deaggregate records.
Sample code is available for the following languages.
Topics
•Node.js 12.x  (p. 773)
•Java 11 (p. 773)
•C# (p. 774)
•Python 3 (p. 775)
•Go (p. 775)
Node.js 12.x
The following example code receives a Kinesis event input and processes the messages that it contains. 
For illustration, the code writes some of the incoming event data to CloudWatch Logs.
Example index.js
console.log('Loading function');
exports.handler = function(event, context) { 
    //console.log(JSON.stringify(event, null, 2)); 
    event.Records.forEach(function(record) { 
        // Kinesis data is base64 encoded so decode here 
        var payload = Buffer.from(record.kinesis.data, 'base64').toString('ascii'); 
        console.log('Decoded payload:', payload); 
    });
};
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
Java 11
The following is example Java code that receives Kinesis event record data as input and processes it. For 
illustration, the code writes some of the incoming event data to CloudWatch Logs.
In the code, recordHandler  is the handler. The handler uses the predeﬁned KinesisEvent  class that 
is deﬁned in the aws-lambda-java-events  library.
773AWS Lambda Developer Guide
Sample code
Example ProcessKinesisEvents.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.KinesisEvent;
import com.amazonaws.services.lambda.runtime.events.KinesisEvent.KinesisEventRecord;
public class ProcessKinesisRecords implements RequestHandler<KinesisEvent, Void>{ 
  @Override 
  public Void handleRequest(KinesisEvent event, Context context) 
  { 
    for(KinesisEventRecord rec : event.getRecords()) { 
      System.out.println(new String(rec.getKinesis().getData().array())); 
  } 
  return null; 
  }
}
If the handler returns normally without exceptions, Lambda considers the input batch of records as 
processed successfully and begins reading new records in the stream. If the handler throws an exception, 
Lambda considers the input batch of records as not processed and invokes the function with the same 
batch of records again.
Dependencies
•aws-lambda-java-core
•aws-lambda-java-events
•aws-java-sdk
Build the code with the Lambda library dependencies to create a deployment package. For instructions, 
see Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446).
C#
The following is example C# code that receives Kinesis event record data as input and processes it. For 
illustration, the code writes some of the incoming event data to CloudWatch Logs.
In the code, HandleKinesisRecord  is the handler. The handler uses the predeﬁned KinesisEvent
class that is deﬁned in the Amazon.Lambda.KinesisEvents  library.
Example ProcessingKinesisEvents.cs
using System;
using System.IO;
using System.Text;
using Amazon.Lambda.Core;
using Amazon.Lambda.KinesisEvents;
namespace KinesisStreams
{ 
    public class KinesisSample 
    { 
     [LambdaSerializer(typeof(JsonSerializer))] 
        public void HandleKinesisRecord(KinesisEvent kinesisEvent) 
        { 
            Console.WriteLine($"Beginning to process {kinesisEvent.Records.Count} 
 records..."); 
774AWS Lambda Developer Guide
Sample code
            foreach (var record in kinesisEvent.Records) 
            { 
                Console.WriteLine($"Event ID: {record.EventId}"); 
                Console.WriteLine($"Event Name: {record.EventName}"); 
                string recordData = GetRecordContents(record.Kinesis); 
                Console.WriteLine($"Record Data:"); 
                Console.WriteLine(recordData); 
            } 
            Console.WriteLine("Stream processing complete."); 
        } 
        private string GetRecordContents(KinesisEvent.Record streamRecord) 
        { 
            using (var reader = new StreamReader(streamRecord.Data, Encoding.ASCII)) 
            { 
                return reader.ReadToEnd(); 
            } 
        } 
    }
}
Replace the Program.cs  in a .NET Core project with the above sample. For instructions, see Deploy C# 
Lambda functions with .zip ﬁle archives (p. 566).
Python 3
The following is example Python code that receives Kinesis event record data as input and processes it. 
For illustration, the code writes to some of the incoming event data to CloudWatch Logs.
Example ProcessKinesisRecords.py
from __future__ import print_function
#import json
import base64
def lambda_handler(event, context): 
    for record in event['Records']: 
       #Kinesis data is base64 encoded so decode here 
       payload=base64.b64decode(record["kinesis"]["data"]) 
       print("Decoded payload: " + str(payload))
Zip up the sample code to create a deployment package. For instructions, see Working with .zip ﬁle 
archives for Python Lambda functions (p. 352).
Go
The following is example Go code that receives Kinesis event record data as input and processes it. For 
illustration, the code writes to some of the incoming event data to CloudWatch Logs.
Example ProcessKinesisRecords.go
import ( 
    "strings" 
    "github.com/aws/aws-lambda-go/events"
)
func handler(ctx context.Context, kinesisEvent events.KinesisEvent) { 
    for _, record := range kinesisEvent.Records { 
        kinesisRecord := record.Kinesis 
775AWS Lambda Developer Guide
Sample template
        dataBytes := kinesisRecord.Data 
        dataText := string(dataBytes) 
        fmt.Printf("%s Data = %s \n", record.EventName, dataText) 
    }
}
Build the executable with go build  and create a deployment package. For instructions, see Deploy Go 
Lambda functions with .zip ﬁle archives (p. 520).
AWS SAM template for a Kinesis application
You can build this application using AWS SAM. To learn more about creating AWS SAM templates, see
AWS SAM template basics in the AWS Serverless Application Model Developer Guide.
Below is a sample AWS SAM template for the Lambda application from the tutorial  (p. 768). The 
function and handler in the template are for the Node.js code. If you use a diﬀerent code sample, update 
the values accordingly.
Example template.yaml - Kinesis stream
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Resources: 
  LambdaFunction: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler
      Runtime: nodejs18.x
      Timeout: 10 
      Tracing: Active 
      Events: 
        Stream: 
          Type: Kinesis 
          Properties: 
            Stream: !GetAtt stream.Arn 
            BatchSize: 100 
            StartingPosition: LATEST 
  stream: 
    Type: AWS::Kinesis::Stream 
    Properties: 
      ShardCount: 1
Outputs: 
  FunctionName: 
    Description: "Function name" 
    Value: !Ref LambdaFunction 
  StreamARN: 
    Description: "Stream ARN" 
    Value: !GetAtt stream.Arn
The template creates a Lambda function, a Kinesis stream, and an event source mapping. The event 
source mapping reads from the stream and invokes the function.
To use an HTTP/2 stream consumer (p. 758), create the consumer in the template and conﬁgure the 
event source mapping to read from the consumer instead of from the stream.
Example template.yaml - Kinesis stream consumer
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
776AWS Lambda Developer Guide
Sample template
Description: A function that processes data from a Kinesis stream.
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler
      Runtime: nodejs12.x
      Timeout: 10 
      Tracing: Active 
      Events: 
        Stream: 
          Type: Kinesis 
          Properties: 
            Stream: !GetAtt streamConsumer.ConsumerARN
            StartingPosition: LATEST 
            BatchSize: 100 
  stream: 
    Type: "AWS::Kinesis::Stream" 
    Properties: 
      ShardCount: 1 
   streamConsumer: 
    Type: "AWS::Kinesis::StreamConsumer" 
    Properties: 
      StreamARN: !GetAtt stream.Arn 
      ConsumerName: "TestConsumer"
Outputs: 
  FunctionName: 
    Description: "Function name" 
    Value: !Ref function 
  StreamARN: 
    Description: "Stream ARN" 
    Value: !GetAtt stream.Arn 
  ConsumerARN: 
    Description: "Stream consumer ARN" 
    Value: !GetAtt streamConsumer.ConsumerARN
For information on how to package and deploy your serverless application using the package and deploy 
commands, see Deploying serverless applications in the AWS Serverless Application Model Developer 
Guide .
777AWS Lambda Developer Guide
Lex
Using AWS Lambda with Amazon Lex
You can use Amazon Lex to integrate a conversation bot into your application. The Amazon Lex bot 
provides a conversational interface with your users. Amazon Lex provides prebuilt integration with 
Lambda, which enables you to use a Lambda function with your Amazon Lex bot.
When you conﬁgure an Amazon Lex bot, you can specify a Lambda function to perform validation, 
fulﬁllment, or both. For validation, Amazon Lex invokes the Lambda function after each response from 
the user. The Lambda function can validate the response and provide corrective feedback to the user, if 
necessary. For fulﬁllment, Amazon Lex invokes the Lambda function to fulﬁll the user request after the 
bot successfully collects all of the required information and receives conﬁrmation from the user.
You can manage the concurrency (p. 220) of your Lambda function to control the maximum number of 
simultaneous bot conversations that you serve. The Amazon Lex API returns an HTTP 429 status code 
(Too Many Requests) if the function is at maximum concurrency.
The API returns an HTTP 424 status code (Dependency Failed Exception) if the Lambda function throws 
an exception.
The Amazon Lex bot invokes your Lambda function synchronously (p. 139). The event parameter 
contains information about the bot and the value of each slot in the dialog. For deﬁnitions of the event 
and response ﬁelds, see Lambda event and response format in the Amazon Lex Developer Guide . The
invocationSource  parameter in the Amazon Lex message event indicates whether the Lambda 
function should validate the inputs (DialogCodeHook) or fulﬁll the intent (FulﬁllmentCodeHook).
For an example tutorial that shows how to use Lambda with Amazon Lex, see Exercise 1: Create Amazon 
Lex bot using a blueprint  in the Amazon Lex Developer Guide .
Roles and permissions
You need to conﬁgure a service-linked role as your function's execution role (p. 913). Amazon Lex 
deﬁnes the service-linked role with predeﬁned permissions. When you create an Amazon Lex bot using 
the console, the service-linked role is created automatically. To create a service-linked role with the AWS 
CLI, use the create-service-linked-role  command.
aws iam create-service-linked-role --aws-service-name lex.amazonaws.com
This command creates the following role.
{ 
  "Role": { 
      "AssumeRolePolicyDocument": { 
          "Version": "2012-10-17",  
          "Statement": [ 
              { 
                  "Action": "sts:AssumeRole",  
                  "Effect": "Allow",  
                  "Principal": { 
                      "Service": "lex.amazonaws.com" 
                  } 
              } 
          ] 
      }, 
      "RoleName": "AWSServiceRoleForLexBots",  
      "Path": "/aws-service-role/lex.amazonaws.com/",  
      "Arn": "arn:aws:iam::account-id:role/aws-service-role/lex.amazonaws.com/
AWSServiceRoleForLexBots"
} 
778AWS Lambda Developer Guide
Roles and permissions
    
If your Lambda function uses other AWS services, you need to add the corresponding permissions to the 
service-linked role.
You use a resource-based permissions policy to allow the Amazon Lex intent to invoke your Lambda 
function. If you use the Amazon Lex console, the permissions policy is created automatically. From the 
AWS CLI, use the Lambda add-permission  command to set the permission. The following example sets 
permission for the OrderFlowers  intent.
aws lambda add-permission \ 
    --function-name OrderFlowersCodeHook \ 
    --statement-id LexGettingStarted-OrderFlowersBot \ 
    --action lambda:InvokeFunction \ 
    --principal lex.amazonaws.com \ 
    --source-arn "arn:aws:lex:us-east-1:123456789012 ID:intent:OrderFlowers:*" 
     
779AWS Lambda Developer Guide
MQ
Using Lambda with Amazon MQ
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
Amazon MQ is a managed message broker service for Apache ActiveMQ and RabbitMQ . A message broker
enables software applications and components to communicate using various programming languages, 
operating systems, and formal messaging protocols through either topic or queue event destinations.
Amazon MQ can also manage Amazon Elastic Compute Cloud (Amazon EC2) instances on your behalf 
by installing ActiveMQ or RabbitMQ brokers and by providing diﬀerent network topologies and other 
infrastructure needs.
You can use a Lambda function to process records from your Amazon MQ message broker. Lambda 
invokes your function through an event source mapping (p. 150), a Lambda resource that reads messages 
from your broker and invokes the function synchronously (p. 139).
The Amazon MQ event source mapping has the following conﬁguration restrictions:
•Cross account – Lambda does not support cross-account processing. You cannot use Lambda to 
process records from an Amazon MQ message broker that is in a diﬀerent AWSaccount.
•Authentication – For ActiveMQ, only the ActiveMQ SimpleAuthenticationPlugin  is supported. For 
RabbitMQ, only the PLAIN authentication mechanism is supported. Users must use AWS Secrets 
Manager to manage their credentials. For more information about ActiveMQ authentication, see
Integrating ActiveMQ brokers with LDAP in the Amazon MQ Developer Guide .
•Connection quota – Brokers have a maximum number of allowed connections per wire-level protocol. 
This quota is based on the broker instance type. For more information, see the Brokers section of
Quotas in Amazon MQ in the Amazon MQ Developer Guide .
•Connectivity – You can create brokers in a public or private virtual private cloud (VPC). For private 
VPCs, your Lambda function needs access to the VPC to receive messages. For more information, see
the section called “Network conﬁguration” (p. 784) later in this topic.
•Event destinations – Only queue destinations are supported. However, you can use a virtual topic, 
which behaves as a topic internally while interacting with Lambda as a queue. For more information, 
see Virtual Destinations on the Apache ActiveMQ website, and Virtual Hosts on the RabbitMQ website.
•Network topology – For ActiveMQ, only one single-instance or standby broker is supported per event 
source mapping. For RabbitMQ, only one single-instance broker or cluster deployment is supported 
per event source mapping. Single-instance brokers require a failover endpoint. For more information 
about these broker deployment modes, see Active MQ Broker Architecture and Rabbit MQ Broker 
Architecturein the Amazon MQ Developer Guide .
•Protocols – Supported protocols depend on the type of Amazon MQ integration.
•For ActiveMQ integrations, Lambda consumes messages using the OpenWire/Java Message 
Service (JMS) protocol. No other protocols are supported for consuming messages. Within the JMS 
protocol, only TextMessage  and BytesMessage  are supported. Lambda also supports JMS custom 
properties. For more information about the OpenWire protocol, see OpenWire on the Apache 
ActiveMQ website.
•For RabbitMQ integrations, Lambda consumes messages using the AMQP 0-9-1 protocol. No 
other protocols are supported for consuming messages. For more information about RabbitMQ's 
implementation of the AMQP 0-9-1 protocol, see AMQP 0-9-1 Complete Reference Guide on the 
RabbitMQ website.
Lambda automatically supports the latest versions of ActiveMQ and RabbitMQ that Amazon MQ 
supports. For the latest supported versions, see Amazon MQ release notes in the Amazon MQ Developer 
Guide .
780AWS Lambda Developer Guide
Lambda consumer group
Note
By default, Amazon MQ has a weekly maintenance window for brokers. During that window 
of time, brokers are unavailable. For brokers without standby, Lambda cannot process any 
messages during that window.
Sections
•Lambda consumer group (p. 781)
•Execution role permissions (p. 783)
•Network conﬁguration (p. 784)
•Conﬁguring a broker as an event source (p. 784)
•Event source mapping API (p. 785)
•Event source mapping errors (p. 787)
•Amazon MQ and RabbitMQ conﬁguration parameters (p. 787)
Lambda consumer group
To interact with Amazon MQ, Lambda creates a consumer group which can read from your Amazon MQ 
brokers. The consumer group is created with the same ID as the event source mapping UUID.
For Amazon MQ event sources, Lambda batches records together and sends them to your function in 
a single payload. To control behavior, you can conﬁgure the batching window and batch size. Lambda 
pulls messages until it processes the payload size maximum of 6 MB, the batching window expires, or the 
number of records reaches the full batch size. For more information, see Batching behavior (p. 151).
The consumer group retrieves the messages as a BLOB of bytes, base64-encodes them into a single JSON 
payload, and then invokes your function. If your function returns an error for any of the messages in a 
batch, Lambda retries the whole batch of messages until processing succeeds or the messages expire.
Note
While Lambda functions typically have a maximum timeout limit of 15 minutes, event source 
mappings for Amazon MSK, self-managed Apache Kafka, Amazon DocumentDB, and Amazon 
MQ for ActiveMQ and RabbitMQ only support functions with maximum timeout limits of 14 
minutes. This constraint ensures that the event source mapping can properly handle function 
errors and retries.
You can monitor a given function's concurrency usage using the ConcurrentExecutions  metric in 
Amazon CloudWatch. For more information about concurrency, see the section called “Conﬁguring 
reserved concurrency” (p. 234).
Example Amazon MQ record events
ActiveMQ
{ 
   "eventSource": "aws:mq", 
   "eventSourceArn": "arn:aws:mq:us-
west-2:111122223333:broker:test:b-9bcfa592-423a-4942-879d-eb284b418fc8", 
   "messages": [ 
      {  
        "messageID": "ID:b-9bcfa592-423a-4942-879d-eb284b418fc8-1.mq.us-
west-2.amazonaws.com-37557-1234520418293-4:1:1:1:1",  
        "messageType": "jms/text-message", 
        "deliveryMode": 1, 
        "replyTo": null, 
        "type": null, 
781AWS Lambda Developer Guide
Lambda consumer group
        "expiration": "60000", 
        "priority": 1, 
        "correlationId": "myJMSCoID", 
        "redelivered": false, 
        "destination": {  
          "physicalName": "testQueue"  
        }, 
        "data":"QUJDOkFBQUE=", 
        "timestamp": 1598827811958, 
        "brokerInTime": 1598827811958,  
        "brokerOutTime": 1598827811959,  
        "properties": { 
          "index": "1", 
          "doAlarm": "false", 
          "myCustomProperty": "value" 
        } 
      }, 
      {  
        "messageID": "ID:b-9bcfa592-423a-4942-879d-eb284b418fc8-1.mq.us-
west-2.amazonaws.com-37557-1234520418293-4:1:1:1:1", 
        "messageType": "jms/bytes-message", 
        "deliveryMode": 1, 
        "replyTo": null, 
        "type": null, 
        "expiration": "60000", 
        "priority": 2, 
        "correlationId": "myJMSCoID1", 
        "redelivered": false, 
        "destination": {  
          "physicalName": "testQueue"  
        }, 
        "data":"LQaGQ82S48k=", 
        "timestamp": 1598827811958, 
        "brokerInTime": 1598827811958,  
        "brokerOutTime": 1598827811959,  
        "properties": { 
          "index": "1", 
          "doAlarm": "false", 
          "myCustomProperty": "value" 
        } 
      } 
   ]
}
RabbitMQ
{ 
  "eventSource": "aws:rmq", 
  "eventSourceArn": "arn:aws:mq:us-
west-2:111122223333:broker:pizzaBroker:b-9bcfa592-423a-4942-879d-eb284b418fc8", 
  "rmqMessagesByQueue": { 
    "pizzaQueue::/": [ 
      { 
        "basicProperties": { 
          "contentType": "text/plain", 
          "contentEncoding": null, 
          "headers": { 
            "header1": { 
              "bytes": [ 
                118, 
                97, 
                108, 
                117, 
                101, 
782AWS Lambda Developer Guide
Execution role permissions
                49 
              ] 
            }, 
            "header2": { 
              "bytes": [ 
                118, 
                97, 
                108, 
                117, 
                101, 
                50 
              ] 
            }, 
            "numberInHeader": 10 
          }, 
          "deliveryMode": 1, 
          "priority": 34, 
          "correlationId": null, 
          "replyTo": null, 
          "expiration": "60000", 
          "messageId": null, 
          "timestamp": "Jan 1, 1970, 12:33:41 AM", 
          "type": null, 
          "userId": "AIDACKCEVSQ6C2EXAMPLE", 
          "appId": null, 
          "clusterId": null, 
          "bodySize": 80 
        }, 
        "redelivered": false, 
        "data": "eyJ0aW1lb3V0IjowLCJkYXRhIjoiQ1pybWYwR3c4T3Y0YnFMUXhENEUifQ==" 
      } 
    ] 
  }
} 
             
Note
In the RabbitMQ example, pizzaQueue  is the name of the RabbitMQ queue, and / is the 
name of the virtual host. When receiving messages, the event source lists messages under
pizzaQueue::/ .
Execution role permissions
To read records from an Amazon MQ broker, your Lambda function needs the following permissions 
added to its execution role (p. 913):
•mq:DescribeBroker
•secretsmanager:GetSecretValue
•ec2:CreateNetworkInterface
•ec2:DeleteNetworkInterface
•ec2:DescribeNetworkInterfaces
•ec2:DescribeSecurityGroups
•ec2:DescribeSubnets
•ec2:DescribeVpcs
•logs:CreateLogGroup
•logs:CreateLogStream
•logs:PutLogEvents
783AWS Lambda Developer Guide
Network conﬁguration
Note
When using an encrypted customer managed key, add the kms:Decrypt  permission as well.
Network conﬁguration
By default, when you create an Amazon MQ broker, the PubliclyAccessible  ﬂag is set to false. For 
your broker to receive a public IP address, you must set the PubliclyAccessible  ﬂag to true.
To give Lambda full access to your broker through your event source mapping, either your broker must 
use a public endpoint (public IP address), or you must provide access to the Amazon VPC you created 
the broker in. Best practice for using Amazon MQ with Lambda is to use private endpoints and to give 
your Lambda function access to your broker's VPC. See Prefer brokers without public accessibility in the
Amazon MQ Developer Guide  for more information.
Note that when you add Amazon MQ as a trigger, Lambda assumes the VPC settings of the Amazon MQ 
broker, not the Lambda function's VPC settings. For your Lambda function to access the VPC with your 
Amazon MQ broker, do one of the following:
•Conﬁgure a NAT gateway on each public subnet in the VPC containing your Amazon MQ broker. 
For more information, see the section called “Internet and service access for VPC-connected 
functions” (p. 91).
•Create a connection between the Amazon VPC containing your Amazon MQ broker and a Lambda VPC 
endpoint. Your Amazon VPC must also connect to AWS Security Token Service (AWS STS) and Secrets 
Manager endpoints. For more information, see the section called “Inbound networking” (p. 92).
You must also conﬁgure the following Amazon VPC security group rules on your VPC:
•Inbound rules – Allow all traﬃc on the broker port for the security group speciﬁed for your event 
source from within its own security group. ActiveMQ uses port 61617 by default and RabbitMQ uses 
port 5671 by default.
•Outbound rules – Allow all traﬃc on port 443 for all destinations. Allow all traﬃc on the broker port 
for within its own security group. ActiveMQ uses port 61617 by default and RabbitMQ uses port 5671 
by default.
If you use VPC endpoints instead of a NAT gateway, the security groups associated with the VPC 
endpoints must allow all inbound traﬃc on port 443 from the event source's security groups.
Conﬁguring a broker as an event source
Create an event source mapping (p. 150) to tell Lambda to send records from an Amazon MQ broker to a 
Lambda function. You can create multiple event source mappings to process the same data with multiple 
functions, or to process items from multiple sources with a single function.
To conﬁgure your function to read from Amazon MQ, create an MQ trigger in the Lambda console.
To create a trigger
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Under Function overview, choose Add trigger .
4. Choose a trigger type.
5. Conﬁgure the required options, and then choose Add.
784AWS Lambda Developer Guide
Event source mapping API
Lambda supports the following options for Amazon MQ event sources:
•MQ broker – Select an Amazon MQ broker.
•Batch size – Set the maximum number of messages to retrieve in a single batch.
•Queue name  – Enter the Amazon MQ queue to consume.
•Source access conﬁguration – Enter virtual host information and the Secrets Manager secret that 
stores your broker credentials.
•Enable trigger – Disable the trigger to stop processing records.
To enable or disable the trigger (or delete it), choose the MQ trigger in the designer. To reconﬁgure the 
trigger, use the event source mapping API operations.
Event source mapping API
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
Note
When you update, disable, or delete an event source mapping for Amazon MQ, it can take up 
to 15 minutes for your changes to take eﬀect. Before this period has elapsed, your event source 
mapping may continue to process events and invoke your function using your previous settings. 
This is true even when the status of the event source mapping displayed in the console indicates 
that your changes have been applied.
To create the event source mapping with the AWS Command Line Interface (AWS CLI), use the create-
event-source-mapping  command.
The following example AWS CLI command creates an event source which maps a Lambda function 
named MQ-Example-Function  to an Amazon MQ RabbitMQ-based broker named ExampleMQBroker . 
The command also provides the virtual host name and a Secrets Manager secret ARN that stores the 
broker credentials.
aws lambda create-event-source-mapping \
--event-source-arn arn:aws:mq: us-east-1:123456789012:broker:ExampleMQBroker:b-24cacbb4-
b295-49b7-8543-7ce7ce9dfb98  \
--function-name arn:aws:lambda: us-east-1:123456789012:function:MQ-Example-Function  \
--queues ExampleQueue  \
--source-access-configuration Type=VIRTUAL_HOST,URI="/" 
 Type=BASIC_AUTH,URI=arn:aws:secretsmanager: us-
east-1:123456789012:secret:ExampleMQBrokerUserPassword-xPBMTt  \
You should see the following output:
{ 
    "UUID": "91eaeb7e-c976-1234-9451-8709db01f137", 
    "BatchSize": 100, 
    "EventSourceArn": "arn:aws:mq:us-east-1:123456789012:broker:ExampleMQBroker:b-b4d492ef-
bdc3-45e3-a781-cd1a3102ecca", 
785AWS Lambda Developer Guide
Event source mapping API
    "FunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:MQ-Example-Function", 
    "LastModified": 1601927898.741, 
    "LastProcessingResult": "No records processed", 
    "State": "Creating", 
    "StateTransitionReason": "USER_INITIATED", 
    "Queues": [ 
        "ExampleQueue" 
    ], 
    "SourceAccessConfigurations": [ 
        { 
            "Type": "BASIC_AUTH", 
            "URI": "arn:aws:secretsmanager:us-
east-1:123456789012:secret:ExampleMQBrokerUserPassword-xPBMTt" 
        } 
    ]
}
Using the update-event-source-mapping  command, you can conﬁgure additional options such as 
how Lambda processes batches and to specify when to discard records that cannot be processed. The 
following example command updates an event source mapping to have a batch size of 2.
aws lambda update-event-source-mapping \
--uuid 91eaeb7e-c976-1234-9451-8709db01f137  \
--batch-size 2
You should see the following output:
{ 
    "UUID": "91eaeb7e-c976-1234-9451-8709db01f137", 
    "BatchSize": 2, 
    "EventSourceArn": "arn:aws:mq:us-east-1:123456789012:broker:ExampleMQBroker:b-b4d492ef-
bdc3-45e3-a781-cd1a3102ecca", 
    "FunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:MQ-Example-Function", 
    "LastModified": 1601928393.531, 
    "LastProcessingResult": "No records processed", 
    "State": "Updating", 
    "StateTransitionReason": "USER_INITIATED"
} 
Lambda updates these settings asynchronously. The output will not reﬂect changes until this process 
completes. To view the current status of your resource, use the get-event-source-mapping
command.
aws lambda get-event-source-mapping \
--uuid 91eaeb7e-c976-4939-9451-8709db01f137
You should see the following output:
{ 
    "UUID": "91eaeb7e-c976-4939-9451-8709db01f137", 
    "BatchSize": 2, 
    "EventSourceArn": "arn:aws:mq:us-east-1:123456789012:broker:ExampleMQBroker:b-b4d492ef-
bdc3-45e3-a781-cd1a3102ecca", 
    "FunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:MQ-Example-Function", 
    "LastModified": 1601928393.531, 
    "LastProcessingResult": "No records processed", 
    "State": "Enabled", 
    "StateTransitionReason": "USER_INITIATED"
}
786AWS Lambda Developer Guide
Event source mapping errors
Event source mapping errors
When a Lambda function encounters an unrecoverable error, your Amazon MQ consumer stops 
processing records. Any other consumers can continue processing, provided that they do not 
encounter the same error. To determine the potential cause of a stopped consumer, check the
StateTransitionReason  ﬁeld in the return details of your EventSourceMapping  for one of the 
following codes:
ESM_CONFIG_NOT_VALID
The event source mapping conﬁguration is not valid.
EVENT_SOURCE_AUTHN_ERROR
Lambda failed to authenticate the event source.
EVENT_SOURCE_AUTHZ_ERROR
Lambda does not have the required permissions to access the event source.
FUNCTION_CONFIG_NOT_VALID
The function's conﬁguration is not valid.
Records also go unprocessed if Lambda drops them due to their size. The size limit for Lambda records 
is 6 MB. To redeliver messages upon function error, you can use a dead-letter queue (DLQ). For more 
information, see Message Redelivery and DLQ Handling on the Apache ActiveMQ website and Reliability 
Guide  on the RabbitMQ website.
Note
Lambda does not support custom redelivery policies. Instead, Lambda uses a policy with 
the default values from the Redelivery Policy page on the Apache ActiveMQ website, with
maximumRedeliveries  set to 5.
Amazon MQ and RabbitMQ conﬁguration parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
Amazon MQ and RabbitMQ.
Event source parameters that apply to Amazon MQ and RabbitMQ
Parameter Required Default Notes
BatchSize N 100 Maximum: 10,000
Enabled N true
FunctionName Y
FilterCriteria N Lambda event 
ﬁltering  (p. 155)
MaximumBatchingWindowInSeconds N 500 ms Batching 
behavior (p. 151)
Queues N The name of the 
Amazon MQ broker 
destination queue to 
consume.
787AWS Lambda Developer Guide
Amazon MQ and RabbitMQ conﬁguration parameters
ParameterRequired Default Notes
SourceAccessConﬁgurationsN For ActiveMQ, 
BASIC_AUTH 
credentials. For 
RabbitMQ, can contain 
both BASIC_AUTH 
credentials and 
VIRTUAL_HOST 
information.
788AWS Lambda Developer Guide
MSK
Using Lambda with Amazon MSK
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
Amazon Managed Streaming for Apache Kafka (Amazon MSK) is a fully managed service that you can use 
to build and run applications that use Apache Kafka to process streaming data. Amazon MSK simpliﬁes 
the setup, scaling, and management of clusters running Kafka. Amazon MSK also makes it easier to 
conﬁgure your application for multiple Availability Zones and for security with AWS Identity and Access 
Management (IAM). Amazon MSK supports multiple open-source versions of Kafka.
Amazon MSK as an event source operates similarly to using Amazon Simple Queue Service (Amazon 
SQS) or Amazon Kinesis. Lambda internally polls for new messages from the event source and then 
synchronously invokes the target Lambda function. Lambda reads the messages in batches and provides 
these to your function as an event payload. The maximum batch size is conﬁgurable (the default is 100 
messages). For more information, see Batching behavior (p. 151).
Lambda reads the messages sequentially for each partition. A single Lambda payload can contain 
messages from multiple partitions. After Lambda processes each batch, it commits the oﬀsets of the 
messages in that batch. If your function returns an error for any of the messages in a batch, Lambda 
retries the whole batch of messages until processing succeeds or the messages expire.
Note
While Lambda functions typically have a maximum timeout limit of 15 minutes, event source 
mappings for Amazon MSK, self-managed Apache Kafka, Amazon DocumentDB, and Amazon 
MQ for ActiveMQ and RabbitMQ only support functions with maximum timeout limits of 14 
minutes. This constraint ensures that the event source mapping can properly handle function 
errors and retries.
Lambda doesn't currently support consuming messages from multi-VPC serverless-type MSK clusters.
For an example of how to conﬁgure Amazon MSK as an event source, see Using Amazon MSK as an event 
source for AWS Lambda on the AWS Compute Blog. For a complete tutorial, see  Amazon MSK Lambda 
Integration  in the Amazon MSK Labs.
Topics
•Example event (p. 789)
•MSK cluster authentication  (p. 790)
•Managing API access and permissions (p. 793)
•Authentication and authorization errors (p. 795)
•Network conﬁguration (p. 796)
•Adding Amazon MSK as an event source (p. 797)
•Auto scaling of the Amazon MSK event source (p. 798)
•Amazon CloudWatch metrics (p. 799)
•Amazon MSK conﬁguration parameters (p. 799)
Example event
Lambda sends the batch of messages in the event parameter when it invokes your function. The event 
payload contains an array of messages. Each array item contains details of the Amazon MSK topic and 
partition identiﬁer, together with a timestamp and a base64-encoded message.
{ 
789AWS Lambda Developer Guide
MSK cluster authentication
   "eventSource":"aws:kafka", 
   "eventSourceArn":"arn:aws:kafka:sa-east-1:123456789012:cluster/vpc-2priv-2pub/751d2973-
a626-431c-9d4e-d7975eb44dd7-2", 
   "bootstrapServers":"b-2.demo-cluster-1.a1bcde.c1.kafka.us-
east-1.amazonaws.com:9092,b-1.demo-cluster-1.a1bcde.c1.kafka.us-east-1.amazonaws.com:9092", 
   "records":{ 
      "mytopic-0":[ 
         { 
            "topic":"mytopic", 
            "partition":0, 
            "offset":15, 
            "timestamp":1545084650987, 
            "timestampType":"CREATE_TIME", 
            "key":"abcDEFghiJKLmnoPQRstuVWXyz1234==", 
            "value":"SGVsbG8sIHRoaXMgaXMgYSB0ZXN0Lg==", 
            "headers":[ 
               { 
                  "headerKey":[ 
                     104, 
                     101, 
                     97, 
                     100, 
                     101, 
                     114, 
                     86, 
                     97, 
                     108, 
                     117, 
                     101 
                  ] 
               } 
            ] 
         } 
      ] 
   }
}
MSK cluster authentication
Lambda needs permission to access the Amazon MSK cluster, retrieve records, and perform other tasks. 
Amazon MSK supports several options for controlling client access to the MSK cluster.
Cluster access options
•Unauthenticated access (p. 790)
•SASL/SCRAM authentication (p. 790)
•IAM role-based authentication (p. 791)
•Mutual TLS authentication  (p. 791)
•Conﬁguring the mTLS secret (p. 745)
•How Lambda chooses a bootstrap broker (p. 793)
Unauthenticated access
If no clients access the cluster over the internet, you can use unauthenticated access.
SASL/SCRAM authentication
Amazon MSK supports Simple Authentication and Security Layer/Salted Challenge Response 
Authentication Mechanism (SASL/SCRAM) authentication with Transport Layer Security (TLS) encryption. 
790AWS Lambda Developer Guide
MSK cluster authentication
For Lambda to connect to the cluster, you store the authentication credentials (user name and password) 
in an AWS Secrets Manager secret.
For more information about using Secrets Manager, see User name and password authentication with 
AWS Secrets Manager in the Amazon Managed Streaming for Apache Kafka Developer Guide.
Amazon MSK doesn't support SASL/PLAIN authentication.
IAM role-based authentication
You can use IAM to authenticate the identity of clients that connect to the MSK cluster. If IAM auth is 
active on your MSK cluster, and you don't provide a secret for auth, Lambda automatically defaults to 
using IAM auth. To create and deploy user or role-based policies, use the IAM console or API. For more 
information, see IAM access control in the Amazon Managed Streaming for Apache Kafka Developer Guide.
To allow Lambda to connect to the MSK cluster, read records, and perform other required actions, add 
the following permissions to your function's execution role (p. 913).
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "kafka-cluster:Connect", 
                "kafka-cluster:DescribeGroup", 
                "kafka-cluster:AlterGroup", 
                "kafka-cluster:DescribeTopic", 
                "kafka-cluster:ReadData", 
                "kafka-cluster:DescribeClusterDynamicConfiguration" 
            ], 
            "Resource": [ 
                "arn:aws:kafka: region:account-id :cluster/ cluster-name /cluster-uuid ", 
                "arn:aws:kafka: region:account-id :topic/cluster-name /cluster-uuid /topic-
name", 
                "arn:aws:kafka: region:account-id :group/cluster-name /cluster-uuid /consumer-
group-id " 
            ] 
        } 
    ]
}        
You can scope these permissions to a speciﬁc cluster, topic, and group. For more information, see the
Amazon MSK Kafka actions in the Amazon Managed Streaming for Apache Kafka Developer Guide.
Mutual TLS authentication
Mutual TLS (mTLS) provides two-way authentication between the client and server. The client sends a 
certiﬁcate to the server for the server to verify the client, and the server sends a certiﬁcate to the client 
for the client to verify the server.
For Amazon MSK, Lambda acts as the client. You conﬁgure a client certiﬁcate (as a secret in Secrets 
Manager) to authenticate Lambda with the brokers in your MSK cluster. The client certiﬁcate must 
be signed by a CA in the server's trust store. The MSK cluster sends a server certiﬁcate to Lambda to 
authenticate the brokers with Lambda. The server certiﬁcate must be signed by a certiﬁcate authority 
(CA) that's in the AWS trust store.
For instructions on how to generate a client certiﬁcate, see  Introducing mutual TLS authentication for 
Amazon MSK as an event source.
791AWS Lambda Developer Guide
MSK cluster authentication
Amazon MSK doesn't support self-signed server certiﬁcates, because all brokers in Amazon MSK use
public certiﬁcates signed by Amazon Trust Services CAs, which Lambda trusts by default.
For more information about mTLS for Amazon MSK, see Mutual TLS Authentication  in the Amazon 
Managed Streaming for Apache Kafka Developer Guide.
Conﬁguring the mTLS secret
The CLIENT_CERTIFICATE_TLS_AUTH secret requires a certiﬁcate ﬁeld and a private key ﬁeld. For an 
encrypted private key, the secret requires a private key password. Both the certiﬁcate and private key 
must be in PEM format.
Note
Lambda supports the PBES1  (but not PBES2) private key encryption algorithms.
The certiﬁcate ﬁeld must contain a list of certiﬁcates, beginning with the client certiﬁcate, followed by 
any intermediate certiﬁcates, and ending with the root certiﬁcate. Each certiﬁcate must start on a new 
line with the following structure:
-----BEGIN CERTIFICATE-----   
        <certificate contents>
-----END CERTIFICATE-----       
Secrets Manager supports secrets up to 65,536 bytes, which is enough space for long certiﬁcate chains.
The private key must be in PKCS #8 format, with the following structure:
-----BEGIN PRIVATE KEY-----   
         <private key contents>
-----END PRIVATE KEY-----             
For an encrypted private key, use the following structure:
-----BEGIN ENCRYPTED PRIVATE KEY-----   
          <private key contents>
-----END ENCRYPTED PRIVATE KEY-----            
The following example shows the contents of a secret for mTLS authentication using an encrypted 
private key. For an encrypted private key, you include the private key password in the secret.
{ 
 "privateKeyPassword": "testpassword", 
 "certificate": "-----BEGIN CERTIFICATE-----
MIIE5DCCAsygAwIBAgIRAPJdwaFaNRrytHBto0j5BA0wDQYJKoZIhvcNAQELBQAw
...
j0Lh4/+1HfgyE2KlmII36dg4IMzNjAFEBZiCRoPimO40s1cRqtFHXoal0QQbIlxk
cmUuiAii9R0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFgjCCA2qgAwIBAgIQdjNZd6uFf9hbNC5RdfmHrzANBgkqhkiG9w0BAQsFADBb
...
rQoiowbbk5wXCheYSANQIfTZ6weQTgiCHCCbuuMKNVS95FkXm0vqVD/YpXKwA/no
c8PH3PSoAaRwMMgOSA2ALJvbRz8mpg==
-----END CERTIFICATE-----", 
 "privateKey": "-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIFKzBVBgkqhkiG9w0BBQ0wSDAnBgkqhkiG9w0BBQwwGgQUiAFcK5hT/X7Kjmgp
792AWS Lambda Developer Guide
Managing API access and permissions
...
QrSekqF+kWzmB6nAfSzgO9IaoAaytLvNgGTckWeUkWn/V0Ck+LdGUXzAC4RxZnoQ
zp2mwJn2NYB7AZ7+imp0azDZb+8YG2aUCiyqb6PnnA==
-----END ENCRYPTED PRIVATE KEY-----"
} 
How Lambda chooses a bootstrap broker
Lambda chooses a  bootstrap broker based on the authentication methods available on your cluster, 
and whether you provide a secret for authentication. If you provide a secret for mTLS or SASL/SCRAM, 
Lambda automatically chooses that auth method. If you don't provide a secret, Lambda selects the 
strongest auth method that's active on your cluster. The following is the order of priority in which 
Lambda selects a broker, from strongest to weakest auth:
•mTLS (secret provided for mTLS)
•SASL/SCRAM (secret provided for SASL/SCRAM)
•SASL IAM (no secret provided, and IAM auth active)
•Unauthenticated TLS (no secret provided, and IAM auth not active)
•Plaintext (no secret provided, and both IAM auth and unauthenticated TLS are not active)
Note
If Lambda can't connect to the most secure broker type, Lambda doesn't attempt to connect to 
a diﬀerent (weaker) broker type. If you want Lambda to choose a weaker broker type, deactivate 
all stronger auth methods on your cluster.
Managing API access and permissions
In addition to accessing the Amazon MSK cluster, your function needs permissions to perform various 
Amazon MSK API actions. You add these permissions to the function's execution role. If your users need 
access to any of the Amazon MSK API actions, add the required permissions to the identity policy for the 
user or role.
You can add each of the following permissions to your execution role manually. Alternatively, you 
can attach the AWS managed policy AWSLambdaMSKExecutionRole  to your execution role. The
AWSLambdaMSKExecutionRole  policy contains all required API actions and VPC permissions listed 
below.
Required Lambda function execution role permissions
To create and store logs in a log group in Amazon CloudWatch Logs, your Lambda function must have 
the following permissions in its execution role:
•logs:CreateLogGroup
•logs:CreateLogStream
•logs:PutLogEvents
For Lambda to access your Amazon MSK cluster on your behalf, your Lambda function must have the 
following permissions in its execution role:
•kafka:DescribeCluster
•kafka:DescribeClusterV2
•kafka:GetBootstrapBrokers
793AWS Lambda Developer Guide
Managing API access and permissions
You only need to add one of either kafka:DescribeCluster  or kafka:DescribeClusterV2 . 
For provisioned MSK clusters, either permission works. For serverless MSK clusters, you must use
kafka:DescribeClusterV2 .
Note
Lambda eventually plans to remove the kafka:DescribeCluster  permission 
from the associated AWSLambdaMSKExecutionRole  managed policy. If you use this 
policy, you should migrate any applications using kafka:DescribeCluster  to use
kafka:DescribeClusterV2  instead.
VPC permissions
If only users within a VPC can access your Amazon MSK cluster, your Lambda function must have 
permission to access your Amazon VPC resources. These resources include your VPC, subnets, security 
groups, and network interfaces. To access these resources, your function's execution role must have the 
following permissions:
•ec2:CreateNetworkInterface
•ec2:DescribeNetworkInterfaces
•ec2:DescribeVpcs
•ec2:DeleteNetworkInterface
•ec2:DescribeSubnets
•ec2:DescribeSecurityGroups
Optional Lambda function permissions
Your Lambda function might also need permissions to:
•Access your SCRAM secret, if using SASL/SCRAM authentication.
•Describe your Secrets Manager secret.
•Access your AWS Key Management Service (AWS KMS) customer managed key.
Secrets Manager and AWS KMS permissions
Depending on the type of access control that you're conﬁguring for your Amazon MSK brokers, 
your Lambda function might need permission to access your SCRAM secret (if using SASL/SCRAM 
authentcation), or Secrets Manager secret to decrypt your AWS KMS customer managed key. To access 
these resources, your function's execution role must have the following permissions:
•kafka:ListScramSecrets
•secretsmanager:GetSecretValue
•kms:Decrypt
Adding permissions to your execution role
Follow these steps to add the AWS managed policy AWSLambdaMSKExecutionRole  to your execution 
role using the IAM console.
To add an AWS managed policy
1. Open the Policies page of the IAM console.
2. In the search box, enter the policy name (AWSLambdaMSKExecutionRole ).
3. Select the policy from the list, and then choose Policy actions, Attach.
794AWS Lambda Developer Guide
Authentication and authorization errors
4. On the Attach policy page, select your execution role from the list, and then choose Attach policy.
Granting users access with an IAM policy
By default, users and roles don't have permission to perform Amazon MSK API operations. To grant 
access to users in your organization or account, you can add or update an identity-based policy. For more 
information, see Amazon MSK Identity-Based Policy Examples in the Amazon Managed Streaming for 
Apache Kafka Developer Guide.
Using SASL/SCRAM authentication
Amazon MSK supports Simple Authentication and Security Layer/Salted Challenge Response 
Authentication Mechanism (SASL/SCRAM) authentication with TLS encryption. You can control access to 
your Amazon MSK clusters by setting up user name and password authentication using an AWS Secrets 
Manager secret. For more information, see Username and password authentication with AWS Secrets 
Manager  in the Amazon Managed Streaming for Apache Kafka Developer Guide. For more information 
about SASL/SCRAM authentication, see RFC 5802.
Note that Amazon MSK does not support SASL/PLAIN authentication.
Authentication and authorization errors
If any of the permissions required to consume data from the Amazon MSK cluster are missing, Lambda 
displays one of the following error messages in the event source mapping under LastProcessingResult.
Error messages
•Cluster failed to authorize Lambda (p. 795)
•SASL authentication failed  (p. 796)
•Server failed to authenticate Lambda (p. 796)
•Provided certiﬁcate or private key is invalid (p. 796)
Cluster failed to authorize Lambda
For SASL/SCRAM or mTLS, this error indicates that the provided user doesn't have all of the following 
required Kafka access control list (ACL) permissions:
•DescribeConﬁgs Cluster
•Describe Group
•Read Group
•Describe Topic
•Read Topic
For IAM access control, your function's execution role is missing one or more of the permissions required 
to access the group or topic. Review the list of required permissions in the section called “ IAM role-based 
authentication”  (p. 791).
When you create either Kafka ACLs or an IAM policy with the required Kafka cluster permissions, specify 
the topic and group as resources. The topic name must match the topic in the event source mapping. The 
group name must match the event source mapping's UUID.
After you add the required permissions to the execution role, it might take several minutes for the 
changes to take eﬀect.
795AWS Lambda Developer Guide
Network conﬁguration
SASL authentication failed
For SASL/SCRAM, this error indicates that the provided user name and password aren't valid.
For IAM access control, the execution role is missing the kafka-cluster:Connect  permission for the 
MSK cluster. Add this permission to the role and specify the cluster's Amazon Resource Name (ARN) as a 
resource.
You might see this error occurring intermittently. The cluster rejects connections after the number of TCP 
connections exceeds the Amazon MSK service quota. Lambda backs oﬀ and retries until a connection is 
successful. After Lambda connects to the cluster and polls for records, the last processing result changes 
to OK.
Server failed to authenticate Lambda
This error indicates that the Amazon MSK Kafka brokers failed to authenticate with Lambda. This can 
occur for any of the following reasons:
•You didn't provide a client certiﬁcate for mTLS authentication.
•You provided a client certiﬁcate, but the brokers aren't conﬁgured to use mTLS.
•A client certiﬁcate isn't trusted by the brokers.
Provided certiﬁcate or private key is invalid
This error indicates that the Amazon MSK consumer couldn't use the provided certiﬁcate or private key. 
Make sure that the certiﬁcate and key use PEM format, and that the private key encryption uses a PBES1 
algorithm.
Network conﬁguration
Lambda must have access to the Amazon Virtual Private Cloud (Amazon VPC) resources associated with 
your Amazon MSK cluster. We recommend that you deploy AWS PrivateLink VPC endpoints for Lambda 
and AWS Security Token Service (AWS STS). The poller needs access to AWS STS to assume the execution 
role associated with the Lambda function. Lambda must have access to the Lambda VPC endpoint to 
invoke the function. If you conﬁgured a secret in Secrets Manager to authenticate Lambda with the 
brokers, also deploy a VPC endpoint for Secrets Manager.
Alternatively, ensure that the VPC associated with your MSK cluster includes one NAT gateway per public 
subnet. For more information, see Internet and service access for VPC-connected functions (p. 91).
Conﬁgure your Amazon VPC security groups with the following rules (at minimum):
•Inbound rules – Allow all traﬃc on the Amazon MSK broker port (9092 for plaintext, 9094 for TLS, 
9096 for SASL, 9098 for IAM) for the security groups speciﬁed for your event source.
•Outbound rules – Allow all traﬃc on port 443 for all destinations. Allow all traﬃc on the Amazon MSK 
broker port (9092 for plaintext, 9094 for TLS, 9096 for SASL, 9098 for IAM) for the security groups 
speciﬁed for your event source.
•If you are using VPC endpoints instead of a NAT gateway, the security groups associated with the VPC 
endpoints must allow all inbound traﬃc on port 443 from the event source's security groups.
Note
Your Amazon VPC conﬁguration is discoverable through the Amazon MSK API. You don't need to 
conﬁgure it during setup using the create-event-source-mapping command.
796AWS Lambda Developer Guide
Adding Amazon MSK as an event source
For more information about conﬁguring the network, see Setting up AWS Lambda with an Apache Kafka 
cluster within a VPC  on the AWS Compute Blog.
Adding Amazon MSK as an event source
To create an event source mapping (p. 150), add Amazon MSK as a Lambda function trigger  (p. 9) using 
the Lambda console, an AWS SDK, or the AWS Command Line Interface (AWS CLI). Note that when you 
add Amazon MSK as a trigger, Lambda assumes the VPC settings of the Amazon MSK cluster, not the 
Lambda function's VPC settings.
This section describes how to create an event source mapping using the Lambda console and the AWS 
CLI.
Note
When you update, disable, or delete an event source mapping for Amazon MSK, it can take up 
to 15 minutes for your changes to take eﬀect. Before this period has elapsed, your event source 
mapping may continue to process events and invoke your function using your previous settings. 
This is true even when the status of the event source mapping displayed in the console indicates 
that your changes have been applied.
Prerequisites
•An Amazon MSK cluster and a Kafka topic. For more information, see Getting Started Using Amazon 
MSK  in the Amazon Managed Streaming for Apache Kafka Developer Guide.
•An execution role (p. 913) with permission to access the AWS resources that your MSK cluster uses.
Customizable consumer group ID
When setting up Kafka as an event source, you can specify a consumer group ID. This consumer group 
ID is an existing identiﬁer for the Kafka consumer group that you want your Lambda function to join. 
You can use this feature to seamlessly migrate any ongoing Kafka record processing setups from other 
consumers to Lambda.
If you specify a consumer group ID and there are other active pollers within that consumer group, Kafka 
distributes messages across all consumers. In other words, Lambda doesn't receive all message for the 
Kafka topic. If you want Lambda to handle all messages in the topic, turn oﬀ any other pollers in that 
consumer group.
Additionally, if you specify a consumer group ID, and Kafka ﬁnds a valid existing consumer group with 
the same ID, Lambda ignores the StartingPosition  parameter for your event source mapping. 
Instead, Lambda begins processing records according to the committed oﬀset of the consumer group. 
If you specify a consumer group ID, and Kafka cannot ﬁnd an existing consumer group, then Lambda 
conﬁgures your event source with the speciﬁed StartingPosition .
The consumer group ID that you specify must be unique among all your Kafka event sources. After 
creating a Kafka event source mapping with the consumer group ID speciﬁed, you cannot update this 
value.
Adding an Amazon MSK trigger (console)
Follow these steps to add your Amazon MSK cluster and a Kafka topic as a trigger for your Lambda 
function.
To add an Amazon MSK trigger to your Lambda function (console)
1. Open the Functions page of the Lambda console.
797AWS Lambda Developer Guide
Auto scaling of the Amazon MSK event source
2. Choose the name of your Lambda function.
3. Under Function overview, choose Add trigger .
4. Under Trigger conﬁguration, do the following:
a. Choose the MSK  trigger type.
b. For MSK cluster , select your cluster.
c. For Batch size, enter the maximum number of messages to receive in a single batch.
d. For Batch window, enter the maximum amount of seconds that Lambda spends gathering 
records before invoking the function.
e. For Topic name, enter the name of a Kafka topic.
f.(Optional) For Consumer group ID , enter the ID of a Kafka consumer group to join.
g. (Optional) For Starting position, choose Latest  to start reading the stream from the latest 
record, Trim horizon to start at the earliest available record, or At timestamp  to specify a 
timestamp to start reading from.
h. (Optional) For Authentication , choose the secret key for authenticating with the brokers in your 
MSK cluster.
i. To create the trigger in a disabled state for testing (recommended), clear Enable trigger. Or, to 
enable the trigger immediately, select Enable trigger.
5. To create the trigger, choose Add.
Adding an Amazon MSK trigger (AWS CLI)
Use the following example AWS CLI commands to create and view an Amazon MSK trigger for your 
Lambda function.
Creating a trigger using the AWS CLI
The following example uses the create-event-source-mapping  AWS CLI command to map a 
Lambda function named my-kafka-function  to a Kafka topic named AWSKafkaTopic . The topic's 
starting position is set to LATEST .
aws lambda create-event-source-mapping \ 
  --event-source-arn arn:aws:kafka:us-west-2:111111111111:cluster/my-cluster/fc2f5bdf-
fd1b-45ad-85dd-15b4a5a6247e-2  \ 
  --topics AWSKafkaTopic  \ 
  --starting-position LATEST \ 
  --function-name my-kafka-function
For more information, see the CreateEventSourceMapping (p. 1292 ) API reference documentation.
Viewing the status using the AWS CLI
The following example uses the get-event-source-mapping  AWS CLI command to describe the 
status of the event source mapping that you created.
aws lambda get-event-source-mapping \ 
  --uuid 6d9bce8e-836b-442c-8070-74e77903c815
Auto scaling of the Amazon MSK event source
When you initially create an Amazon MSK event source, Lambda allocates one consumer to process 
all partitions in the Kafka topic. Each consumer has multiple processors running in parallel to handle 
798AWS Lambda Developer Guide
Amazon CloudWatch metrics
increased workloads. Additionally, Lambda automatically scales up or down the number of consumers, 
based on workload. To preserve message ordering in each partition, the maximum number of consumers 
is one consumer per partition in the topic.
In one-minute intervals, Lambda evaluates the consumer oﬀset lag of all the partitions in the topic. If 
the lag is too high, the partition is receiving messages faster than Lambda can process them. If necessary, 
Lambda adds or removes consumers from the topic. The scaling process of adding or removing 
consumers occurs within three minutes of evaluation.
If your target Lambda function is throttled, Lambda reduces the number of consumers. This action 
reduces the workload on the function by reducing the number of messages that consumers can retrieve 
and send to the function.
To monitor the throughput of your Kafka topic, view the Oﬀset lag metric  (p. 799) Lambda emits while 
your function processes records.
To check how many function invocations occur in parallel, you can also monitor the concurrency 
metrics  (p. 967) for your function.
Amazon CloudWatch metrics
Lambda emits the OffsetLag  metric while your function processes records. The value of this metric 
is the diﬀerence in oﬀset between the last record written to the Kafka event source topic and the last 
record that your function's consumer group processed. You can use OffsetLag  to estimate the latency 
between when a record is added and when your consumer group processes it.
An increasing trend in OffsetLag  can indicate issues with pollers in your function's consumer group. For 
more information, see Working with Lambda function metrics (p. 965).
Amazon MSK conﬁguration parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
Amazon MSK.
Event source parameters that apply to Amazon MSK
Parameter Required Default Notes
AmazonManagedKafkaEventSourceConﬁg N Contains the 
ConsumerGroupId ﬁeld, 
which defaults to a 
unique value.Can set only on Create
BatchSize N 100 Maximum: 10,000
Enabled N Enabled
EventSourceArn Y   Can set only on Create
FunctionName Y
FilterCriteria N Lambda event 
ﬁltering  (p. 155)
MaximumBatchingWindowInSeconds N 500 ms Batching 
behavior (p. 151)
799AWS Lambda Developer Guide
Amazon MSK conﬁguration parameters
ParameterRequired Default Notes
SourceAccessConﬁgurationsN No credentialsSASL/SCRAM or 
CLIENT_CERTIFICATE_TLS_AUTH 
(MutualTLS) 
authentication 
credentials for your 
event source
StartingPosition Y AT_TIMESTAMP, 
TRIM_HORIZON, or 
LATEST
Can set only on Create
StartingPositionTimestampN Required if 
StartingPosition is set 
to AT_TIMESTAMP
Topics Y Kafka topic name
Can set only on Create
800AWS Lambda Developer Guide
RDS
Using AWS Lambda with Amazon RDS
You can use AWS Lambda to process event notiﬁcations from an Amazon Relational Database Service 
(Amazon RDS) database. Amazon RDS sends notiﬁcations to an Amazon Simple Notiﬁcation Service 
(Amazon SNS) topic, which you can conﬁgure to invoke a Lambda function. Amazon SNS wraps the 
message from Amazon RDS in its own event document and sends it to your function.
Example Amazon RDS message in an Amazon SNS event
{ 
      "Records": [ 
        { 
          "EventVersion": "1.0", 
          "EventSubscriptionArn": "arn:aws:sns:us-east-2:123456789012:rds-lambda:21be56ed-
a058-49f5-8c98-aedd2564c486", 
          "EventSource": "aws:sns", 
          "Sns": { 
            "SignatureVersion": "1", 
            "Timestamp": "2019-01-02T12:45:07.000Z", 
            "Signature": "tcc6faL2yUC6dgZdmrwh1Y4cGa/ebXEkAi6RibDsvpi+tE/1+82j...65r==", 
            "SigningCertUrl": "https://sns.us-east-2.amazonaws.com/
SimpleNotificationService-ac565b8b1a6c5d002d285f9598aa1d9b.pem", 
            "MessageId": "95df01b4-ee98-5cb9-9903-4c221d41eb5e", 
            "Message": "{\"Event Source\":\"db-instance\",\"Event Time\":\"2019-01-02 
 12:45:06.000\",\"Identifier Link\":\"https://console.aws.amazon.com/rds/home?region=eu-
west-1#dbinstance:id=dbinstanceid\",\"Source ID\":\"dbinstanceid\",\"Event ID\":\"http://
docs.amazonwebservices.com/AmazonRDS/latest/UserGuide/USER_Events.html#RDS-EVENT-0002\",
\"Event Message\":\"Finished DB Instance backup\"}",
            "MessageAttributes": {}, 
            "Type": "Notification", 
            "UnsubscribeUrl": "https://sns.us-east-2.amazonaws.com/?
Action=Unsubscribe&amp;SubscriptionArn=arn:aws:sns:us-east-2:123456789012:test-
lambda:21be56ed-a058-49f5-8c98-aedd2564c486", 
            "TopicArn":"arn:aws:sns:us-east-2:123456789012:sns-lambda", 
            "Subject": "RDS Notification Message" 
          } 
        } 
      ] 
    }
Topics
•Tutorial: Using a Lambda function to access Amazon RDS in an Amazon VPC (p. 801)
•Conﬁguring the function (p. 814)
Tutorial: Using a Lambda function to access Amazon 
RDS in an Amazon VPC
In this tutorial, you use a Lambda function to write data to an Amazon Relational Database Service
(Amazon RDS) database. Your Lambda function reads records from an Amazon Simple Queue Service 
(Amazon SQS) queue and writes a new item to a table in your database whenever a message is added. 
In this example, you use the AWS Management Console to manually add messages to your queue. The 
following diagram shows the AWS resources you use to complete the tutorial.
801AWS Lambda Developer Guide
RDS Tutorial
With Amazon RDS, you can run a managed relational database in the cloud using common database 
products like Microsoft SQL Server, MySQL, and PostgresQL. By using Lambda to access your database, 
you can read and write data in response to events, such as a new customer registering with your website. 
Your function and database instance also scale automatically to meet periods of high demand.
To complete this tutorial, you carry out the following tasks:
1.Launch an Amazon RDS MySQL database instance in your AWS account's default Amazon Virtual 
Private Cloud (Amazon VPC).
2.Create and test a Lambda function that creates a new table in your database and writes data to it.
3.Create an Amazon SQS queue and conﬁgure it to invoke your Lambda function whenever a new 
message is added.
4.Test the complete set-up by adding messages to your queue using the AWS Management Console and 
monitoring the results using CloudWatch Logs.
By completing these steps, you learn:
•How to use Lambda to open a connection to an Amazon RDS database instance
•How to use Lambda to perform create and read operations on an Amazon RDS database
•How to use Amazon SQS to invoke a Lambda function
You can complete this tutorial using the AWS Management Console or the AWS Command Line Interface 
(AWS CLI).
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
802AWS Lambda Developer Guide
RDS Tutorial
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
803AWS Lambda Developer Guide
RDS Tutorial
Create an Amazon RDS database instance
An Amazon RDS database instance is an isolated database environment running in the AWS Cloud. An 
instance can contain one or more user-created databases. Unless you specify otherwise, Amazon RDS 
creates new database instances in the default Amazon VPC included in your AWS account. For more 
information about Amazon VPCs, see the Amazon Virtual Private Cloud User Guide.
In this tutorial, you create a new instance in your AWS account's default VPC and create a database 
named ExampleDB  in that instance. You can create your Amazon RDS instance and database using either 
the AWS Management Console or the AWS CLI.
AWS Management Console
To create a database instance and database (console)
1. Open the Databases page  of the Amazon RDS console and choose Create database .
2. Leave the Standard create  option selected, then in Engine options , choose MySQL.
3. In Templates, choose Free tier.
4. In Settings, for DB instance identiﬁer, enter MySQLForLambda .
5. Set your username and password by doing the following:
a. In Credentials settings, leave Master username  set to admin
b. For Master password, enter and conﬁrm a password to access your database.
6. Specify the database name by doing the following:
a. Leave all the remaining default options selected and scroll down to the Additional 
conﬁguration pane.
b. Expand this pane and enter ExampleDB  as the Initial database name .
7. Leave all the remaining default options selected and choose Create database .
AWS CLI
To create a database instance and database (CLI)
• To create your database instance and database using the AWS CLI, choose your own password 
and run the following command. Lambda uses this password to access the database.
aws rds create-db-instance --db-name ExampleDB --engine MySQL \
--db-instance-identifier MySQLForLambda \
--db-instance-class db.t2.micro --allocated-storage 5 --no-publicly-accessible \
--master-username admin --master-user-password password
804AWS Lambda Developer Guide
RDS Tutorial
For Lambda to connect to your database, you need to know its host address (endpoint) and VPC 
conﬁguration.
To ﬁnd the database host address and VPC conﬁguration
1. Open the Databases page  of the Amazon RDS console.
2. Choose the database instance you just created (mysqlforlambda ), and select the Connectivity and 
security pane.
3. Record the values of the endpoint, VPC subnets, and VPC security group.
Note
The host endpoint will not be available until your database instance has ﬁnished initializing and 
the status displayed in the console has changed from Creating  to Backing up . This can take 
several minutes.
Create a function execution role
Before you create your Lambda function, you create an execution role to give your function the 
necessary permissions. For this tutorial, Lambda needs permission to manage the network connection to 
the Amazon VPC containing your database instance and to poll messages from an Amazon SQS queue.
To give your Lambda function the permissions it needs, this tutorial uses IAM managed policies. These 
are policies that grant permissions for many common use cases and are available in your AWS account. 
For more information about using managed policies, see Policy best practices (p. 950).
To create the Lambda execution role
1. Open the Roles page of the IAM console and choose Create role.
2. For the Trusted entity type, choose AWS Service, and for the Use case , choose Lambda.
3. Choose Next.
4. Add the IAM managed policies by doing the following:
a. Using the policy search box, search for AWSLambdaVPCAccessExecutionRole .
b. In the results list, select the check box next to the role, then choose Clear ﬁlters.
c. Using the policy search box, search for AWSLambdaSQSQueueExecutionRole .
d. In the results list, select the check box next to the role, then choose Next.
5. For the Role name, enter lambda-vpc-sqs-role , then choose Create role.
Later in the tutorial, you need the Amazon Resource Name (ARN) of the execution role you just created.
805AWS Lambda Developer Guide
RDS Tutorial
To ﬁnd the execution role ARN
1. Open the Roles page of the IAM console and choose your role (lambda-vpc-sqs-role )
2. Copy the Role ARN displayed in the Summary section.
Create a Lambda deployment package
The following example Python code uses the PyMySQL package to open a connection to your database. 
The ﬁrst time you invoke your function, it also creates a new table called Customer . The table uses the 
following schema, where CustID is the primary key:
Customer(CustID, Name)
The function also uses PyMySQL to add records to this table. The function adds records using customer 
IDs and names speciﬁed in messages you will add to your Amazon SQS queue.
Note that the code creates the connection to your database outside of the handler function. Creating 
the connection in the initialization code allows the connection to be re-used by subsequent invocations 
of your function and improves performance. In a production application, you can also use provisioned 
concurrency to initialize a requested number of database connections. These connections are available as 
soon as your function is invoked.
import sys
import logging
import pymysql
import json
import os
# rds settings
user_name = os.environ['USER_NAME']
password = os.environ['PASSWORD']
rds_host = os.environ['RDS_HOST']
db_name = os.environ['DB_NAME']
logger = logging.getLogger()
logger.setLevel(logging.INFO)
# create the database connection outside of the handler to allow connections to be
# re-used by subsequent function invocations.
try: 
    conn = pymysql.connect(host=rds_host, user=user_name, passwd=password, db=db_name, 
 connect_timeout=5)
except pymysql.MySQLError as e: 
    logger.error("ERROR: Unexpected error: Could not connect to MySQL instance.") 
    logger.error(e) 
    sys.exit()
806AWS Lambda Developer Guide
RDS Tutorial
logger.info("SUCCESS: Connection to RDS MySQL instance succeeded")
def lambda_handler(event, context): 
    """ 
    This function creates a new RDS database table and writes records to it 
    """ 
    message = event['Records'][0]['body'] 
    data = json.loads(message) 
    CustID = data['CustID'] 
    Name = data['Name'] 
    item_count = 0 
    sql_string = f"insert into Customer (CustID, Name) values({CustID}, '{Name}')" 
    with conn.cursor() as cur: 
        cur.execute("create table if not exists Customer ( CustID  int NOT NULL, Name 
 varchar(255) NOT NULL, PRIMARY KEY (CustID))") 
        cur.execute(sql_string) 
        conn.commit() 
        cur.execute("select * from Customer") 
        logger.info("The following items have been added to the database:") 
        for row in cur: 
            item_count += 1 
            logger.info(row) 
    conn.commit() 
    return "Added %d items to RDS MySQL table" %(item_count) 
     
Note
In this example, your database access credentials are stored as environment variables. In 
production applications, we recommend that you use AWS Secrets Manager as a more secure 
option. For more information, see the section called “Database proxy” (p. 95). Note that if your 
Lambda function is in an Amazon VPC, to connect to Secrets Manager you need to create a VPC 
endpoint. See How to connect to Secrets Manager service within a Virtual Private Cloud to learn 
more.
To include the PyMySQL dependency with your function code, create a .zip deployment package.
To create a .zip deployment package
1. Save the example code as a ﬁle named lambda_function.py . Use your own Amazon RDS host 
endpoint and replace the password in the example code with the password you chose when you 
created your database instance.
2. In the same directory in which you created your lambda_function.py  ﬁle, create a new directory 
named package and install the PyMySQL library.
mkdir package
pip install --target package pymysql
3. Create a zip ﬁle containing your application code and the PyMySQL library. In Linux or MacOS, 
run the following CLI commands. In Windows, use your preferred zip tool to create the
lambda_function.zip  ﬁle. Your lambda_function.py  source code ﬁle and the folders 
containing your dependencies must be installed at the root of the .zip ﬁle.
cd package
zip -r ../lambda_function.zip .
cd ..
zip lambda_function.zip lambda_function.py
807AWS Lambda Developer Guide
RDS Tutorial
You can also create your deployment package using a Python virtual environment. See Deploy 
Python Lambda functions with .zip ﬁle archives.
Create the Lambda function
Using the .zip package you just created, you now create a Lambda function using either the AWS CLI 
or the Lambda console. To enable your function to access your database, you also need to conﬁgure 
environment variables with your access credentials.
AWS Management Console
To create the function (console)
1. Open the Functions page of the Lambda console and choose Create function.
2. Leave Author from scratch  selected, and in Basic information , enter
LambdaFunctionWithRDS  for the function name.
3. Select Python3.10 as the runtime.
4. Choose Create function.
5. In the Code  pane, choose Upload from and then .zip ﬁle.
6. Select the lambda_function.zip  ﬁle you created in the previous stage and choose Save.
Now conﬁgure the function with the execution role you created earlier and your VPC settings. This 
grants the function the permissions it needs to access your database instance and poll an Amazon 
SQS queue.
To conﬁgure the function's execution role and VPC settings (console)
1. In the Functions page of the Lambda console, select the Conﬁguration  tab, then choose
Permissions.
2. In the Execution role pane, choose Edit.
3. In Existing role, choose your execution role (lambda-vpc-sqs-role ) from the dropdown list.
4. Choose Save.
5. Conﬁgure the VPC settings by doing the following:
a. In the Conﬁguration  tab, choose VPC, then select Edit.
b. In VPC, choose your AWS account's default VPC from the dropdown list.
c. In Subnets , select the checkboxes for the VPC subnets you noted earlier.
d. In Security groups, select the checkboxes for the VPC security groups you noted earlier, 
then choose Save.
808AWS Lambda Developer Guide
RDS Tutorial
To conﬁgure your function's environment variables (console)
1. In the Functions page of the Lambda console, select the Conﬁguration  tab, then choose
Environment variables.
2. Choose Edit.
3. To add your database access credentials, do the following:
a. Choose Add environment variable, then for Key enter USER_NAME  and for Value enter
admin .
b. Choose Add environment variable, then for Key enter DB_NAME  and for Value enter
ExampleDB .
c. Choose Add environment variable, then for Key enter PASSWORD  and for Value enter the 
password you chose when you created your database.
d. Choose Add environment variable, then for Key enter RDS_HOST  and for Value enter the 
host endpoint for your database you noted earlier.
e. Choose Save.
AWS CLI
To create the function (CLI)
• Run the following command with your own role ARN, VPC subnet IDs and VPC security group 
values.
aws lambda create-function --function-name LambdaFunctionWithRDS --runtime 
 python3.10 \
--zip-file fileb://lambda_function.zip --handler lambda_function.lambda_handler \
--role arn:aws:iam::111122223333:role/lambda-vpc-sqs-role  \
--vpc-config SubnetIds= subnet-1234567890abcdef0 ,subnet-abcdef01234567890 ,\
subnet-021345abcdef6789 ,subnet-1234abcdef567890 ,SecurityGroupIds= sg-1234567890abcdef0
To conﬁgure your function's environment variables (CLI)
1. Create a ﬁle named EnvVars.json  and paste the following JSON into it. Be sure to replace the 
RDS host endpoint with the host endpoint for your own database and use your own password.
{ 
  "Variables": { 
  "USER_NAME": "admin", 
  "DB_NAME": "ExampleDB", 
  "PASSWORD": "EXAMPLE_PASSWORD" , 
  "RDS_HOST": "mysqlforlambda.cdipnbm2csku.us-west-2.rds.amazonaws.com"
 }
}
2. From the directory you saved your EnvVars.json  ﬁle in, run the following CLI command.
aws lambda update-function-configuration --function-name LambdaFunctionWithRDS \
--environment file://EnvVars.json
809AWS Lambda Developer Guide
RDS Tutorial
Test your Lambda function in the console
You can now use the Lambda console to test your function. You create a test event which mimics the 
data your function will receive when you invoke it using Amazon SQS in the ﬁnal stage of the tutorial. 
Your test event contains a JSON object specifying a customer ID and customer name to add to the
Customer  table your function creates.
To test the Lambda function
1. Open the Functions page of the Lambda console and choose your function.
2. Choose the Code  tab.
3. In the Code source pane, choose Test and enter myTestEvent  for the event name.
4. Copy the following code into Event JSON and choose Save.
{ 
  "Records": [ 
    { 
      "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
      "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
      "body": "{\n     \"CustID\": 1021,\n     \"Name\": \"Martha Rivera\"\n}", 
      "attributes": { 
        "ApproximateReceiveCount": "1", 
        "SentTimestamp": "1545082649183", 
        "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
        "ApproximateFirstReceiveTimestamp": "1545082649185" 
      }, 
      "messageAttributes": {}, 
      "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
      "eventSource": "aws:sqs", 
      "eventSourceARN": "arn:aws:sqs:us-west-2:123456789012:my-queue", 
      "awsRegion": "us-west-2" 
    } 
  ]
}
5. Choose Test.
In the Execution results tab, you should see results similar to the following displayed in the Function 
Logs:
[INFO] 2023-02-14T19:31:35.149Z bdd06682-00c7-4d6f-9abb-89f4bbb4a27f The following items 
 have been added to the database:
[INFO] 2023-02-14T19:31:35.149Z bdd06682-00c7-4d6f-9abb-89f4bbb4a27f (1021, 'Martha 
 Rivera')
810AWS Lambda Developer Guide
RDS Tutorial
Create an Amazon SQS queue
You have successfully tested the integration of your Lambda function and Amazon RDS database 
instance. Now you create the Amazon SQS queue you will use to invoke your Lambda function in the 
ﬁnal stage of the tutorial.
AWS Management Console
To create the Amazon SQS queue (console)
1. Open the Queues  page of the Amazon SQS console and select Create queue .
2. Leave the Type as Standard  and enter LambdaRDSQueue  for the name of your queue.
3. Leave all the default options selected and choose Create queue .
AWS CLI
To create the Amazon SQS queue (CLI)
• Run the following command and record the URL the AWS CLI returns:
aws sqs create-queue --queue-name LambdaRDSQueue
In the next part of the tutorial, you will need the Amazon Resource Name (ARN) of the queue you 
just created.
To ﬁnd the queue ARN
• Using the URL you recorded in the previous step, run the following command and record the 
ARN the AWS CLI returns:
aws sqs get-queue-attributes \
--queue-url https://sqs.us-west-2.amazonaws.com/111122223333/LambdaRDSQueue  \
--attribute-names QueueArn
811AWS Lambda Developer Guide
RDS Tutorial
Create an event source mapping to invoke your Lambda 
function
An event source mapping is a Lambda resource which reads items from a stream or queue and invokes 
a Lambda function. When you conﬁgure an event source mapping, you can specify a batch size so that 
records from your stream or queue are batched together into a single payload. In this example, you 
set the batch size to 1 so that your Lambda function is invoked every time you send a message to your 
queue. You can conﬁgure the event source mapping using either the AWS CLI or the Lambda console.
AWS Management Console
To create an event source mapping (console)
1. Open the Functions page of the Lambda console and select your function 
(LambdaFunctionWithRDS ).
2. In the Function overview pane, choose Add trigger .
3. For the source, select Amazon SQS, then select the name of your queue (LambdaRDSQueue ).
4. For Batch size, enter 1.
5. Leave all the other options set to the default values and choose Add.
AWS CLI
To create an event source mapping (CLI)
• To create an event source mapping using the AWS CLI, run the following command using the 
ARN for your own Amazon SQS queue:
aws lambda create-event-source-mapping --function-name LambdaFunctionWithRDS --
batch-size 1 \
--event-source-arn arn:aws:sqs:us-west-2:111122223333:LambdaRDSQueue
You are now ready to test your complete setup by adding a message to your Amazon SQS queue.
812AWS Lambda Developer Guide
RDS Tutorial
Test and monitor your setup
To test your complete setup, add messages to your Amazon SQS queue using the console. You then use 
CloudWatch Logs to conﬁrm that your Lambda function is writing records to your database as expected.
To test and monitor your setup
1. Open the Queues  page of the Amazon SQS console and select your queue (LambdaRDSQueue ).
2. Choose Send and receive messages and paste the following JSON into the Message body  in the
Send message  pane.
{
    "CustID": 1054,
    "Name": "Richard Roe"
}
3. Choose Send message .
Sending your message to the queue will cause Lambda to invoke your function through your event 
source mapping. To conﬁrm that Lambda has invoked your function as expected, use CloudWatch 
Logs to verify that the function has written the customer name and ID to your database table:
4. Open the Log groups page of the CloudWatch console and select the log group for your function 
(aws/lambda/LambdaFunctionWithRDS ).
5. In the Log streams  pane, choose the most recent log stream.
Your table should contain two customer records, one from each invocation of your function. In the 
log stream, you should see messages similar to the following:
[INFO] 2023-02-14T19:06:43.873Z 45368126-3eee-47f7-88ca-3086ae6d3a77 The following 
 items have been added to the database:
[INFO] 2023-02-14T19:06:43.873Z 45368126-3eee-47f7-88ca-3086ae6d3a77 (1021, 'Martha 
 Rivera')
[INFO] 2023-02-14T19:06:43.873Z 45368126-3eee-47f7-88ca-3086ae6d3a77 (1054, 'Richard 
 Roe')
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
813AWS Lambda Developer Guide
Conﬁguring the function
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the MySQL DB instance
1. Open the Databases page  of the Amazon RDS console.
2. Select the database you created.
3. Choose Actions, Delete.
4. Clear the Create ﬁnal snapshot  check box.
5. Enter delete me  in the text box.
6. Choose Delete.
To delete the Amazon SQS queue
1. Sign in to the AWS Management Console and open the Amazon SQS console at https:// 
console.aws.amazon.com/sqs/.
2. Select the queue you created.
3. Choose Delete.
4. Enter confirm in the text input ﬁeld.
5. Choose Delete.
Conﬁguring the function
The following section shows additional conﬁgurations and topics we recommend as part of this tutorial.
•If too many function instances run concurrently, one or more instances may fail to obtain a database 
connection. You can use reserved concurrency to limit the maximum concurrency of the function. Set 
the reserved concurrency to be less than the number of database connections. Reserved concurrency 
also reserves those instances for this function, which may not be ideal. If you are invoking the Lambda 
functions from your application, we recommend you write code that limits the number of concurrent 
instances. For more information, see Managing concurrency for a Lambda function.
•For more information on conﬁguring an Amazon RDS database to send notiﬁcations, see Using 
Amazon RDS event notiﬁcations.
•For more information on using Amazon SNS as trigger, see Using AWS Lambda with Amazon 
SNS (p. 863).
814AWS Lambda Developer Guide
S3
Using AWS Lambda with Amazon S3
You can use Lambda to process event notiﬁcations from Amazon Simple Storage Service. Amazon S3 
can send an event to a Lambda function when an object is created or deleted. You conﬁgure notiﬁcation 
settings on a bucket, and grant Amazon S3 permission to invoke a function on the function's resource-
based permissions policy.
Warning
If your Lambda function uses the same bucket that triggers it, it could cause the function to 
run in a loop. For example, if the bucket triggers a function each time an object is uploaded, 
and the function uploads an object to the bucket, then the function indirectly triggers itself. To 
avoid this, use two buckets, or conﬁgure the trigger to only apply to a preﬁx used for incoming 
objects.
Amazon S3 invokes your function asynchronously (p. 142) with an event that contains details about the 
object. The following example shows an event that Amazon S3 sent when a deployment package was 
uploaded to Amazon S3.
Example Amazon S3 notiﬁcation event
{ 
  "Records": [ 
    { 
      "eventVersion": "2.1", 
      "eventSource": "aws:s3", 
      "awsRegion": "us-east-2", 
      "eventTime": "2019-09-03T19:37:27.192Z", 
      "eventName": "ObjectCreated:Put", 
      "userIdentity": { 
        "principalId": "AWS:AIDAINPONIXQXHT3IKHL2" 
      }, 
      "requestParameters": { 
        "sourceIPAddress": "205.255.255.255" 
      }, 
      "responseElements": { 
        "x-amz-request-id": "D82B88E5F771F645", 
        "x-amz-id-2": 
 "vlR7PnpV2Ce81l0PRw6jlUpck7Jo5ZsQjryTjKlc5aLWGVHPZLj5NeC6qMa0emYBDXOo6QBU0Wo=" 
      }, 
      "s3": { 
        "s3SchemaVersion": "1.0", 
        "configurationId": "828aa6fc-f7b5-4305-8584-487c791949c1", 
        "bucket": { 
          "name": " DOC-EXAMPLE-BUCKET ", 
          "ownerIdentity": { 
            "principalId": "A3I5XTEXAMAI3E" 
          }, 
          "arn": "arn:aws:s3:::lambda-artifacts-deafc19498e3f2df" 
        }, 
        "object": { 
          "key": " b21b84d653bb07b05b1e6b33684dc11b ", 
          "size": 1305107, 
          "eTag": "b21b84d653bb07b05b1e6b33684dc11b", 
          "sequencer": "0C0F6F405D6ED209E1" 
        } 
      } 
    } 
  ]
}
To invoke your function, Amazon S3 needs permission from the function's resource-based 
policy (p. 929). When you conﬁgure an Amazon S3 trigger in the Lambda console, the console modiﬁes 
815AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
the resource-based policy to allow Amazon S3 to invoke the function if the bucket name and account 
ID match. If you conﬁgure the notiﬁcation in Amazon S3, you use the Lambda API to update the policy. 
You can also use the Lambda API to grant permission to another account, or restrict permission to a 
designated alias.
If your function uses the AWS SDK to manage Amazon S3 resources, it also needs Amazon S3 
permissions in its execution role (p. 913).
Topics
•Tutorial: Using an Amazon S3 trigger to invoke a Lambda function (p. 816)
•Tutorial: Using an Amazon S3 trigger to create thumbnail images (p. 831)
Tutorial: Using an Amazon S3 trigger to invoke a 
Lambda function
In this tutorial, you use the console to create a Lambda function and conﬁgure a trigger for an Amazon 
Simple Storage Service (Amazon S3) bucket. Every time that you add an object to your Amazon S3 
bucket, your function runs and outputs the object type to Amazon CloudWatch Logs.
You can use a Lambda function with an Amazon S3 trigger to perform many types of ﬁle processing 
tasks. For example, you can use a Lambda function to create a thumbnail whenever an image ﬁle is 
uploaded to your Amazon S3 bucket, or to convert uploaded documents into diﬀerent formats. After 
you’ve completed this tutorial, you can try the Using an Amazon S3 trigger to create thumbnail images
tutorial to perform an image processing task.
To complete this tutorial, you carry out the following steps:
1.Create an Amazon S3 bucket.
2.Create a Lambda function that returns the object type of objects in an Amazon S3 bucket.
816AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
3.Conﬁgure a Lambda trigger that invokes your function when objects are uploaded to your bucket.
4.Test your function, ﬁrst with a dummy event, and then using the trigger.
By completing these steps, you’ll learn how to conﬁgure a Lambda function to run whenever objects 
are added to or deleted from an Amazon S3 bucket. You can complete this tutorial using only the AWS 
Management Console.
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
817AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Create an Amazon S3 bucket
First create an Amazon S3 bucket using the AWS Management Console.
To create an Amazon S3 bucket
1. Open the Amazon S3 console and select the Buckets page.
2. Choose Create bucket.
3. Under General conﬁguration, do the following:
a. For Bucket name, enter a globally unique name that meets the Amazon S3 Bucket naming rules. 
Bucket names can contain only lower case letters, numbers, dots (.), and hyphens (-).
b. For AWS Region, choose a Region. Later in the tutorial, you must create your Lambda function 
in the same Region.
4. Leave all other options set to their default values and choose Create bucket.
Upload a test object to your bucket
Later in the tutorial, you’ll test your Lambda function in the Lambda console. To conﬁrm that your 
function’s code is working correctly, your Amazon S3 bucket needs to contain a test object. This object 
can be any ﬁle you choose (for example HappyFace.jpg ).
818AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
To upload a test object
1. Open the Buckets page of the Amazon S3 console and choose the bucket you created during the 
previous step.
2. Choose Upload.
3. Choose Add ﬁles and use the ﬁle selector to choose the object you want to upload.
4. Choose Open , then choose Upload.
When you test your function code later in the tutorial, you pass it data containing the ﬁle name of the 
object you uploaded, so make a note of it now.
Create a permissions policy
Before you can create an execution role for you Lambda function, you ﬁrst create a permissions policy to 
give your function permission to access the required AWS resources. For this tutorial, the policy allows 
Lambda to get objects from an Amazon S3 bucket and to write to Amazon CloudWatch Logs.
To create the policy
1. Open the Policies page of the IAM console.
2. Choose Create Policy.
3. Choose the JSON tab, and then paste the following custom policy into the JSON editor.
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "logs:PutLogEvents", 
                "logs:CreateLogGroup", 
                "logs:CreateLogStream" 
            ], 
            "Resource": "arn:aws:logs:*:*:*" 
        }, 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "s3:GetObject" 
            ], 
            "Resource": "arn:aws:s3:::*/*" 
        } 
    ]
}
819AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
4. Choose Next: Tags.
5. Choose Next: Review.
6. Under Review policy, for the policy Name , enter s3-trigger-tutorial .
7. Choose Create policy.
Create an execution role
An execution role (p. 913) is an AWS Identity and Access Management (IAM) role that grants a Lambda 
function permission to access AWS services and resources. To enable your function to get objects from an 
Amazon S3 bucket, you attach the permissions policy you created in the previous step.
To create an execution role and attach your custom permissions policy
1. Open the Roles page of the IAM console.
2. Choose Create role.
3. For the type of trusted entity, choose AWS service, then for the use case, choose Lambda .
4. Choose Next.
5. In the policy search box, enter s3-trigger-tutorial .
6. In the search results, select the policy that you created (s3-trigger-tutorial ), and then choose
Next.
7. Under Role details, for the Role name, enter lambda-s3-trigger-role , then choose Create role.
Create the Lambda function
In this example, you create a Lambda function in the console using the Node.js 16.x runtime. The 
function you create in the console contains some basic ‘Hello World’ code. In the next step, you’ll replace 
this with the function code to get an object from your Amazon S3 bucket.
820AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
To create the Lambda function
1. Open the Functions page of the Lambda console.
2. Make sure you're working in the same AWS Region you created your Amazon S3 bucket in. You can 
change your Region using the drop-down list at the top of the screen.
3. Choose Create function.
4. Choose Author from scratch
5. Under Basic information , do the following:
a. For Function name, enter s3-trigger-tutorial
b. For Runtime , choose Node.js 16.x .
c. For Architecture, choose x86_64 .
6. In the Change default execution role tab, do the following:
a. Expand the tab, then choose Use an existing role.
b. Select the lambda-s3-trigger-role  you created earlier.
7. Choose Create function.
Deploy the function code
Your Lambda function will retrieve the key name of the uploaded object and the name of the bucket 
from the event parameter it receives from Amazon S3. The function then uses the HeadObject  API call 
in the AWS SDK for JavaScript to get the object type for the uploaded object.
This tutorial uses the Node.js 16.x runtime, but we’ve also provided example code ﬁles for other 
runtimes. You can select the tab in the following box to see the code for the runtime you’re interested in. 
The JavaScript code you’ll deploy is the ﬁrst example shown in the tab labeled JavaScript.
821AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using .NET.
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Amazon.S3;
using System;
using Amazon.Lambda.S3Events;
using System.Web;
// Assembly attribute to enable the Lambda function's JSON input to be converted 
 into a .NET class.
[assembly: 
 LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]
namespace S3Integration
{ 
    public class Function 
    { 
        private static AmazonS3Client _s3Client; 
        public Function() : this(null) 
        { 
        } 
        internal Function(AmazonS3Client s3Client) 
        { 
            _s3Client = s3Client ?? new AmazonS3Client(); 
        } 
        public async Task<string> Handler(S3Event evt, ILambdaContext context) 
        { 
            try 
            { 
                if (evt.Records.Count <= 0) 
                { 
                    context.Logger.LogLine("Empty S3 Event received"); 
                    return string.Empty; 
                } 
                var bucket = evt.Records[0].S3.Bucket.Name; 
                var key = HttpUtility.UrlDecode(evt.Records[0].S3.Object.Key); 
                context.Logger.LogLine($"Request is for {bucket} and {key}"); 
                var objectResult = await _s3Client.GetObjectAsync(bucket, key); 
                context.Logger.LogLine($"Returning {objectResult.Key}"); 
                return objectResult.Key; 
            } 
            catch (Exception e) 
            { 
                context.Logger.LogLine($"Error processing request - {e.Message}"); 
                return string.Empty; 
            } 
        } 
    }
822AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
}
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Go.
package main
import ( 
 "context" 
 "log" 
 "github.com/aws/aws-lambda-go/events" 
 "github.com/aws/aws-lambda-go/lambda" 
 "github.com/aws/aws-sdk-go-v2/config" 
 "github.com/aws/aws-sdk-go-v2/service/s3"
)
func handler(ctx context.Context, s3Event events.S3Event) error { 
 sdkConfig, err := config.LoadDefaultConfig(ctx) 
 if err != nil { 
  log.Printf("failed to load default config: %s", err) 
  return err 
 } 
 s3Client := s3.NewFromConfig(sdkConfig) 
 for _, record := range s3Event.Records { 
  bucket := record.S3.Bucket.Name 
  key := record.S3.Object.URLDecodedKey 
  headOutput, err := s3Client.HeadObject(ctx, &s3.HeadObjectInput{ 
   Bucket: &bucket, 
   Key:    &key, 
  }) 
  if err != nil { 
   log.Printf("error getting head of object %s/%s: %s", bucket, key, err) 
   return err 
  } 
  log.Printf("successfully retrieved %s/%s of type %s", bucket, key, 
 *headOutput.ContentType) 
 } 
 return nil
}
func main() { 
 lambda.Start(handler)
}
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
823AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
Consuming an S3 event with Lambda using Java.
package example;
import software.amazon.awssdk.services.s3.model.HeadObjectRequest;
import software.amazon.awssdk.services.s3.model.HeadObjectResponse;
import software.amazon.awssdk.services.s3.S3Client;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.S3Event;
import 
 com.amazonaws.services.lambda.runtime.events.models.s3.S3EventNotification.S3EventNotificationRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Handler implements RequestHandler<S3Event, String> { 
    private static final Logger logger = LoggerFactory.getLogger(Handler.class); 
    @Override 
    public String handleRequest(S3Event s3event, Context context) { 
        try { 
          S3EventNotificationRecord record = s3event.getRecords().get(0); 
          String srcBucket = record.getS3().getBucket().getName(); 
          String srcKey = record.getS3().getObject().getUrlDecodedKey(); 
          S3Client s3Client = S3Client.builder().build(); 
          HeadObjectResponse headObject = getHeadObject(s3Client, srcBucket, 
 srcKey); 
          logger.info("Successfully retrieved " + srcBucket + "/" + srcKey + " of 
 type " + headObject.contentType()); 
          return "Ok"; 
        } catch (Exception e) { 
          throw new RuntimeException(e); 
        } 
    } 
    private HeadObjectResponse getHeadObject(S3Client s3Client, String bucket, 
 String key) { 
        HeadObjectRequest headObjectRequest = HeadObjectRequest.builder() 
                .bucket(bucket) 
                .key(key) 
                .build(); 
        return s3Client.headObject(headObjectRequest); 
    }
}
JavaScript
SDK for JavaScript (v2)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using JavaScript.
const aws = require('aws-sdk');
const s3 = new aws.S3({ apiVersion: '2006-03-01' });
824AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
exports.handler = async (event, context) => { 
    // Get the object from the event and show its content type 
    const bucket = event.Records[0].s3.bucket.name; 
    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' 
 ')); 
    const params = { 
        Bucket: bucket, 
        Key: key, 
    };  
    try { 
        const { ContentType } = await s3.headObject(params).promise(); 
        console.log('CONTENT TYPE:', ContentType); 
        return ContentType; 
    } catch (err) { 
        console.log(err); 
        const message = `Error getting object ${key} from bucket ${bucket}. Make 
 sure they exist and your bucket is in the same region as this function.`; 
        console.log(message); 
        throw new Error(message); 
    }
};
Consuming an S3 event with Lambda using TypeScript.
import { S3Event } from 'aws-lambda';
import { S3Client, HeadObjectCommand } from '@aws-sdk/client-s3';
const s3 = new S3Client({ region: process.env.AWS_REGION });
export const handler = async (event: S3Event): Promise<string | undefined> => { 
  // Get the object from the event and show its content type 
  const bucket = event.Records[0].s3.bucket.name; 
  const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' 
 ')); 
  const params = { 
    Bucket: bucket, 
    Key: key, 
  }; 
  try { 
    const { ContentType } = await s3.send(new HeadObjectCommand(params)); 
    console.log('CONTENT TYPE:', ContentType); 
    return ContentType; 
  } catch (err) { 
    console.log(err); 
    const message = `Error getting object ${key} from bucket ${bucket}. Make sure 
 they exist and your bucket is in the same region as this function.`; 
    console.log(message); 
    throw new Error(message); 
  }
};
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Python.
import json
825AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
import urllib.parse
import boto3
print('Loading function')
s3 = boto3.client('s3')
def lambda_handler(event, context): 
    #print("Received event: " + json.dumps(event, indent=2)) 
    # Get the object from the event and show its content type 
    bucket = event['Records'][0]['s3']['bucket']['name'] 
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], 
 encoding='utf-8') 
    try: 
        response = s3.get_object(Bucket=bucket, Key=key) 
        print("CONTENT TYPE: " + response['ContentType']) 
        return response['ContentType'] 
    except Exception as e: 
        print(e) 
        print('Error getting object {} from bucket {}. Make sure they exist and 
 your bucket is in the same region as this function.'.format(key, bucket)) 
        raise e 
               
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Rust.
use aws_lambda_events::event::s3::S3Event;
use aws_sdk_s3::{Client};
use lambda_runtime::{run, service_fn, Error, LambdaEvent};
/// Main function
#[tokio::main]
async fn main() -> Result<(), Error> { 
    tracing_subscriber::fmt() 
        .with_max_level(tracing::Level::INFO) 
        .with_target(false) 
        .without_time() 
        .init(); 
    // Initialize the AWS SDK for Rust 
    let config = aws_config::load_from_env().await; 
    let s3_client = Client::new(&config); 
    let res = run(service_fn(|request: LambdaEvent<S3Event>| { 
        function_handler(&s3_client, request) 
    })).await; 
    res
826AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
}
async fn function_handler( 
    s3_client: &Client, 
    evt: LambdaEvent<S3Event>
) -> Result<(), Error> { 
    tracing::info!(records = ?evt.payload.records.len(), "Received request from 
 SQS"); 
    if evt.payload.records.len() == 0 { 
        tracing::info!("Empty S3 event received"); 
    } 
    let bucket = evt.payload.records[0].s3.bucket.name.as_ref().expect("Bucket name 
 to exist"); 
    let key = evt.payload.records[0].s3.object.key.as_ref().expect("Object key to 
 exist"); 
    tracing::info!("Request is for {} and object {}", bucket, key); 
    let s3_get_object_result = s3_client 
        .get_object() 
        .bucket(bucket) 
        .key(key) 
        .send() 
        .await; 
    match s3_get_object_result { 
        Ok(_) => tracing::info!("S3 Get Object success, the s3GetObjectResult 
 contains a 'body' property of type ByteStream"), 
        Err(_) => tracing::info!("Failure with S3 Get Object request") 
    } 
    Ok(())
}
To deploy the function code
1. Open the Functions page of the Lambda console.
2. Choose the function you created in the previous step (s3-trigger-tutorial ).
3. Choose the Code  tab.
4. Copy and paste the provided JavaScript code into the index.js  tab in the Code source pane.
5. Choose Deploy.
Create the Amazon S3 trigger
827AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
Now you’ve deployed your function code, you create the Amazon S3 trigger that will invoke your 
function.
To create the Amazon S3 trigger
1. In the Function overview pane of your function’s console page, choose Add trigger .
2. Select S3.
3. Under Bucket, select the bucket you created earlier in the tutorial.
4. Under Event types, select All object create events. You can also conﬁgure a trigger to invoke 
Lambda when an object is deleted, but we won’t be using that option in this tutorial.
5. Under Recursive invocation, select the check box to acknowledge that using the same Amazon S3 
bucket for input and output is not recommended. You can learn more about recursive invocation 
patterns in Lambda by reading Recursive patterns that cause run-away Lambda functions in 
Serverless Land.
6. Choose Add.
Test your Lambda function with a dummy event
Now that you’ve created and conﬁgured your Lambda function, you’re ready to test it. You ﬁrst test your 
function by sending it a dummy Amazon S3 event to conﬁrm it’s working correctly.
To test the Lambda function with a dummy event
1. In the Lambda console page for your function, choose the Code  tab.
2. In the Code source pane, choose Test.
3. In the Conﬁgure test event box, do the following:
a. For Event name, enter MyTestEvent .
b. For Template, choose S3 Put .
c. In the Event JSON, replace the following values:
•Replace us-east-1  with the region you created your Amazon S3 bucket in.
•Replace both instances of example-bucket  with the name of your own Amazon S3 bucket.
•Replace test%2FKey  with the name of the test object you uploaded to your bucket earlier 
(for example, HappyFace.jpg ).
{ 
  "Records": [ 
    { 
      "eventVersion": "2.0", 
      "eventSource": "aws:s3", 
828AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
      "awsRegion": " us-east-1 ", 
      "eventTime": "1970-01-01T00:00:00.000Z", 
      "eventName": "ObjectCreated:Put", 
      "userIdentity": { 
        "principalId": "EXAMPLE" 
      }, 
      "requestParameters": { 
        "sourceIPAddress": "127.0.0.1" 
      }, 
      "responseElements": { 
        "x-amz-request-id": "EXAMPLE123456789", 
        "x-amz-id-2": "EXAMPLE123/5678abcdefghijklambdaisawesome/
mnopqrstuvwxyzABCDEFGH" 
      }, 
      "s3": { 
        "s3SchemaVersion": "1.0", 
        "configurationId": "testConfigRule", 
        "bucket": { 
          "name": " example-bucket ", 
          "ownerIdentity": { 
            "principalId": "EXAMPLE" 
          }, 
          "arn": "arn:aws:s3::: example-bucket " 
        }, 
        "object": { 
          "key": " test%2Fkey ", 
          "size": 1024, 
          "eTag": "0123456789abcdef0123456789abcdef", 
          "sequencer": "0A1B2C3D4E5F678901" 
        } 
      } 
    } 
  ]
}
d. Choose Save.
4. In the Code source pane, choose Test.
5. If your function runs successfully, you’ll see output similar to the following in the Execution results
tab.
Response
"image/jpeg"
Function Logs
START RequestId: 12b3cae7-5f4e-415e-93e6-416b8f8b66e6 Version: $LATEST
2021-02-18T21:40:59.280Z    12b3cae7-5f4e-415e-93e6-416b8f8b66e6    INFO    INPUT 
 BUCKET AND KEY:  { Bucket: 'my-s3-bucket', Key: 'HappyFace.jpg' }
2021-02-18T21:41:00.215Z    12b3cae7-5f4e-415e-93e6-416b8f8b66e6    INFO    CONTENT 
 TYPE: image/jpeg
END RequestId: 12b3cae7-5f4e-415e-93e6-416b8f8b66e6
REPORT RequestId: 12b3cae7-5f4e-415e-93e6-416b8f8b66e6    Duration: 976.25 ms    Billed 
 Duration: 977 ms    Memory Size: 128 MB    Max Memory Used: 90 MB    Init Duration: 
 430.47 ms         
Request ID
12b3cae7-5f4e-415e-93e6-416b8f8b66e6
829AWS Lambda Developer Guide
Tutorial: Use an S3 trigger
Test the Lambda function with the Amazon S3 trigger
To test your function with the conﬁgured trigger, you upload an object to your Amazon S3 bucket using 
the console. To verify that your Lambda function has been invoked correctly, you then use CloudWatch 
Logs to view your function’s output.
To upload an object to your Amazon S3 bucket
1. Open the Buckets page of the Amazon S3 console and choose the bucket you created earlier.
2. Choose Upload.
3. Choose Add ﬁles and use the ﬁle selector to choose an object you want to upload. This object can be 
any ﬁle you choose.
4. Choose Open , then choose Upload.
To verify correct operation using CloudWatch Logs
1. Open the CloudWatch console.
2. Make sure you're working in the same AWS Region you created your Lambda function in. You can 
change your Region using the drop-down list at the top of the screen.
3. Choose Logs , then choose Log groups .
4. Choose the log group for your function (/aws/lambda/s3-trigger-tutorial ).
5. Under Log streams , choose the most recent log stream.
6. If your function has been invoked correctly in response to your Amazon S3 trigger, you’ll see output 
similar to the following. The CONTENT TYPE  you see depends on the type of ﬁle you uploaded to 
your bucket.
830AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
2022-05-09T23:17:28.702Z 0cae7f5a-b0af-4c73-8563-a3430333cc10 INFO CONTENT TYPE: image/
jpeg
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the S3 bucket
1. Open the Amazon S3 console.
2. Select the bucket you created.
3. Choose Delete.
4. Enter the name of the bucket in the text input ﬁeld.
5. Choose Delete bucket.
Next steps
Try the more advanced tutorial. In this tutorial, the Amazon S3 trigger invokes a function to create a 
thumbnail image  (p. 831) for each image ﬁle that is uploaded to your bucket. This tutorial requires a 
moderate level of AWS and Lambda domain knowledge. You use the AWS Command Line Interface (AWS 
CLI) to create resources, and you create a .zip ﬁle archive deployment package for your function and its 
dependencies.
Tutorial: Using an Amazon S3 trigger to create 
thumbnail images
In this tutorial, you create and conﬁgure a Lambda function that resizes images added to an Amazon 
Simple Storage Service (Amazon S3) bucket. When you add an image ﬁle to your bucket, Amazon S3 
invokes your Lambda function. The function then creates a thumbnail version of the image and outputs 
it to a diﬀerent Amazon S3 bucket.
831AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
To complete this tutorial, you carry out the following steps:
1.Create source and destination Amazon S3 buckets and upload a sample image.
2.Create a Lambda function that resizes an image and outputs a thumbnail to an Amazon S3 bucket.
3.Conﬁgure a Lambda trigger that invokes your function when objects are uploaded to your source 
bucket.
4.Test your function, ﬁrst with a dummy event, and then by uploading an image to your source bucket.
By completing these steps, you’ll learn how to use Lambda to carry out a ﬁle processing task on objects 
added to an Amazon S3 bucket. You can complete this tutorial using the AWS Command Line Interface 
(AWS CLI) or the AWS Management Console.
If you're looking for a simpler example to learn how to conﬁgure an Amazon S3 trigger for Lambda, you 
can try Tutorial: Using an Amazon S3 trigger to invoke a Lambda function.
Topics
•Prerequisites (p. 817)
•Create two Amazon S3 buckets (p. 834)
•Upload a test image to your source bucket (p. 835)
•Create a permissions policy (p. 836)
•Create an execution role (p. 837)
•Create the function deployment package (p. 839)
•Create the Lambda function (p. 847)
•Conﬁgure Amazon S3 to invoke the function (p. 849)
•Test your Lambda function with a dummy event (p. 851)
•Test your function using the Amazon S3 trigger (p. 854)
•Clean up your resources (p. 855)
832AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
833AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
If you want to use the AWS CLI to complete the tutorial, install the latest version of the AWS Command 
Line Interface.
For your Lambda function code, you can use Python, Node.js or Java. Install the language support tools 
and a package manager for the language that you want to use. For Java, the example commands to 
create your deployment package use the Apache Maven build automation tool.
Create two Amazon S3 buckets
First create two Amazon S3 buckets. The ﬁrst bucket is the source bucket you will upload your images to. 
The second bucket is used by Lambda to save the resized thumbnail when you invoke your function.
AWS Management Console
To create the Amazon S3 buckets (console)
1. Open the Buckets page of the Amazon S3 console.
2. Choose Create bucket.
3. Under General conﬁguration, do the following:
a. For Bucket name, enter a globally unique name that meets the Amazon S3 Bucket naming 
rules . Bucket names can contain only lower case letters, numbers, dots (.), and hyphens (-).
b. For AWS Region, choose the AWS Region closest to your geographical location. Later in the 
tutorial, you must create your Lambda function in the same AWS Region, so make a note of 
the region you chose.
4. Leave all other options set to their default values and choose Create bucket.
5. Repeat steps 1 to 4 to create your destination bucket. For Bucket name, enter SOURCEBUCKET-
resized, where SOURCEBUCKET  is the name of the source bucket you just created.
AWS CLI
To create the Amazon S3 buckets (AWS CLI)
1. Run the following CLI command to create your source bucket. The name you choose for your 
bucket must be globally unique and follow the Amazon S3 Bucket naming rules. Names 
can only contain lower case letters, numbers, dots (.), and hyphens (-). For region  and
LocationConstraint , choose the AWS Region closest to your geographical location.
aws s3api create-bucket --bucket SOURCEBUCKET  --region us-west-2  \
--create-bucket-configuration LocationConstraint= us-west-2
Later in the tutorial, you must create your Lambda function in the same AWS Region as your 
source bucket, so make a note of the region you chose.
834AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
2. Run the following command to create your destination bucket. For the bucket name, you must 
use SOURCEBUCKET-resized , where SOURCEBUCKET  is the name of the source bucket you 
created in step 1. For region  and LocationConstraint , choose the same AWS Region you 
used to create your source bucket.
aws s3api create-bucket --bucket SOURCEBUCKET-resized  --region us-west-2  \
--create-bucket-configuration LocationConstraint= us-west-2
Upload a test image to your source bucket
Later in the tutorial, you’ll test your Lambda function by invoking it using the AWS CLI or the Lambda 
console. To conﬁrm that your function is operating correctly, your source bucket needs to contain a test 
image. This image can be any JPG or PNG ﬁle you choose.
AWS Management Console
To upload a test image to your source bucket (console)
1. Open the Buckets page of the Amazon S3 console.
2. Choose Upload.
3. Choose Add ﬁle and use the ﬁle selector to choose the object you want to upload.
4. Choose Open , then choose Upload.
AWS CLI
To upload a test image to your source bucket (AWS CLI)
• From the directory containing the image you want to upload, run the following CLI command. 
Replace the --bucket  parameter with the name of your source bucket. For the --key  and --
body parameters, use the ﬁlename of your test image.
aws s3api put-object --bucket SOURCEBUCKET  --key HappyFace.jpg  --body ./
HappyFace.jpg
835AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
Create a permissions policy
The ﬁrst step in creating your Lambda function is to create a permissions policy. This policy gives your 
function the permissions it needs to access other AWS resources. For this tutorial, the policy gives 
Lambda read and write permissions for Amazon S3 buckets and allows it to write to Amazon CloudWatch 
Logs logs.
AWS Management Console
To create the policy (console)
1. Open the Policies page of the AWS Identity and Access Management (IAM) console.
2. Choose Create policy.
3. Choose the JSON tab, and then paste the following custom policy into the JSON editor.
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "logs:PutLogEvents", 
                "logs:CreateLogGroup", 
                "logs:CreateLogStream" 
            ], 
            "Resource": "arn:aws:logs:*:*:*" 
        }, 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "s3:GetObject" 
            ], 
            "Resource": "arn:aws:s3:::*/*" 
        }, 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "s3:PutObject" 
            ], 
            "Resource": "arn:aws:s3:::*/*" 
        } 
    ]
}
4. Choose Next: Tags.
5. Choose Next: Review.
6. Under Review policy, for Name , enter LambdaS3Policy .
836AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
7. Choose Create policy.
AWS CLI
To create the policy (AWS CLI)
1. Save the following JSON in a ﬁle named policy.json .
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "logs:PutLogEvents", 
                "logs:CreateLogGroup", 
                "logs:CreateLogStream" 
            ], 
            "Resource": "arn:aws:logs:*:*:*" 
        }, 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "s3:GetObject" 
            ], 
            "Resource": "arn:aws:s3:::*/*" 
        }, 
        { 
            "Effect": "Allow", 
            "Action": [ 
                "s3:PutObject" 
            ], 
            "Resource": "arn:aws:s3:::*/*" 
        } 
    ]
}
2. From the directory you saved the JSON policy document in, run the following CLI command.
aws iam create-policy --policy-name LambdaS3Policy --policy-document file://
policy.json
Create an execution role
837AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
An execution role is an IAM role that grants a Lambda function permission to access AWS services 
and resources. To give your function read and write access to an Amazon S3 bucket, you attach the 
permissions policy you created in the previous step.
AWS Management Console
To create an execution role and attach your permissions policy (console)
1. Open the Roles page of the (IAM) console.
2. Choose Create role.
3. For Trusted entity type, select AWS service, and for Use case , select Lambda .
4. Choose Next.
5. Add the permissions policy you created in the previous step by doing the following:
a. In the policy search box, enter LambdaS3Policy .
b. In the search results, select the check box for LambdaS3Policy .
c. Choose Next.
6. Under Role details, for the Role name enter LambdaS3Role .
7. Choose Create role.
AWS CLI
To create an execution role and attach your permissions policy (AWS CLI)
1. Save the following JSON in a ﬁle named trust-policy.json . This trust policy allows 
Lambda to use the role’s permissions by giving the service principal lambda.amazonaws.com
permission to call the AWS Security Token Service (AWS STS) AssumeRole  action.
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Principal": { 
        "Service": "lambda.amazonaws.com" 
      }, 
      "Action": "sts:AssumeRole" 
    } 
  ]
}
2. From the directory you saved the JSON trust policy document in, run the following CLI 
command to create the execution role.
aws iam create-role --role-name LambdaS3Role --assume-role-policy-document file://
trust-policy.json
3. To attach the permissions policy you created in the previous step, run the following CLI 
command. Replace the AWS account number in the policy’s ARN with your own account number.
aws iam attach-role-policy --role-name LambdaS3Role --policy-arn 
 arn:aws:iam:: 123456789012 :policy/LambdaS3Policy
838AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
Create the function deployment package
To create your function, you create a deployment package  containing your function code and its 
dependencies. For this CreateThumbnail  function, your function code uses a separate library for 
the image resizing. Follow the instructions for your chosen language to create a deployment package 
containing the required library.
Node.js
To create the deployment package (Node.js)
1. Create a directory named lambda-s3  for your function code and dependencies and navigate 
into it.
mkdir lambda-s3
cd lambda-s3
2. Save the following function code in a ﬁle named index.mjs .
// dependencies
import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3';
import { Readable } from 'stream';
import sharp from 'sharp';
import util from 'util';
// create S3 client
const s3 = new S3Client({region: 'us-west-2'});
// define the handler function
export const handler = async (event, context) => {
// Read options from the event parameter and get the source bucket
console.log("Reading options from event:\n", util.inspect(event, {depth: 5})); 
  const srcBucket = event.Records[0].s3.bucket.name; 
   
// Object key may have spaces or unicode non-ASCII characters
const srcKey    = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, 
 " "));
const dstBucket = srcBucket + "-resized";
const dstKey    = "resized-" + srcKey;
// Infer the image type from the file suffix
const typeMatch = srcKey.match(/\.([^.]*)$/);
if (!typeMatch) { 
  console.log("Could not determine the image type."); 
839AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
  return;
}
// Check that the image type is supported
const imageType = typeMatch[1].toLowerCase();
if (imageType != "jpg" && imageType != "png") { 
  console.log(`Unsupported image type: ${imageType}`); 
  return;
}
// Get the image from the source bucket. GetObjectCommand returns a stream.
try { 
  const params = { 
    Bucket: srcBucket, 
    Key: srcKey 
  }; 
  var response = await s3.send(new GetObjectCommand(params)); 
  var stream = response.Body; 
   
// Convert stream to buffer to pass to sharp resize function. 
  if (stream instanceof Readable) { 
    var content_buffer = Buffer.concat(await stream.toArray()); 
     
  } else { 
    throw new Error('Unknown object stream type'); 
  }
} catch (error) { 
  console.log(error); 
  return;
} 
   
// set thumbnail width. Resize will set the height automatically to maintain aspect 
 ratio.
const width  = 200;
// Use the sharp module to resize the image and save in a buffer.
try {     
  var output_buffer = await sharp(content_buffer).resize(width).toBuffer();
} catch (error) { 
  console.log(error); 
  return;
}
// Upload the thumbnail image to the destination bucket
try { 
  const destparams = { 
    Bucket: dstBucket, 
    Key: dstKey, 
    Body: output_buffer, 
    ContentType: "image" 
  }; 
  const putResult = await s3.send(new PutObjectCommand(destparams)); 
  } catch (error) { 
    console.log(error); 
    return; 
  } 
  console.log('Successfully resized ' + srcBucket + '/' + srcKey + 
    ' and uploaded to ' + dstBucket + '/' + dstKey); 
840AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
  };
3. In your lambda-s3  directory, install the sharp library using npm.
npm install sharp
The npm install command creates a node_modules  directory for your modules. After this 
step, your directory structure should look like the following.
lambda-s3
|- index.mjs
|- node_modules
|  |- base64js
|  |- bl
|  |- buffer
...
|- package-lock.json
|- package.json
4. Create a .zip deployment package containing your function code and its dependencies. In 
MacOS and Linux, run the following command.
zip -r function.zip .
In Windows, use your preferred zip utility to create a .zip ﬁle. Ensure that your index.mjs ,
package.json , and package-lock.json  ﬁles and your node_modules  directory are all at 
the root of your .zip ﬁle.
Python
To create the deployment package (Python)
1. Save the example code as a ﬁle named lambda_function.py .
import boto3
import os
import sys
import uuid
from urllib.parse import unquote_plus
from PIL import Image
import PIL.Image 
             
s3_client = boto3.client('s3') 
             
def resize_image(image_path, resized_path): 
  with Image.open(image_path) as image: 
    image.thumbnail(tuple(x / 2 for x in image.size)) 
    image.save(resized_path) 
             
def lambda_handler(event, context): 
  for record in event['Records']: 
    bucket = record['s3']['bucket']['name'] 
    key = unquote_plus(record['s3']['object']['key']) 
    tmpkey = key.replace('/', '') 
    download_path = '/tmp/{}{}'.format(uuid.uuid4(), tmpkey) 
    upload_path = '/tmp/resized-{}'.format(tmpkey) 
    s3_client.download_file(bucket, key, download_path) 
    resize_image(download_path, upload_path) 
841AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
    s3_client.upload_file(upload_path, '{}-resized'.format(bucket), 'resized-
{}'.format(key))
2. In the same directory in which you created your lambda_function.py  ﬁle, create a new 
directory named package  and install the Pillow (PIL) library and the AWS SDK for Python 
(Boto3). Although the Lambda Python runtime includes a version of the Boto3 SDK, we 
recommend that you add all of your function's dependencies to your deployment package, even 
if they are included in the runtime. For more information, see Runtime dependencies in Python.
mkdir package
pip install \
--platform manylinux2014_x86_64 \
--target=package \
--implementation cp \
--python-version 3.9 \
--only-binary=:all: --upgrade \
pillow boto3
The Pillow library contains C/C++ code. By using the --platform manylinux_2014_x86_64
and --only-binary=:all:  options, pip will download and install a version of Pillow that 
contains pre-compiled binaries compatible with the Amazon Linux 2 operating system. This 
ensures that your deployment package will work in the Lambda execution environment, 
regardless of the operating system and architecture of your local build machine.
3. Create a .zip ﬁle containing your application code and the Pillow and Boto3 libraries. In Linux or 
MacOS, run the following commands from your command line interface.
cd package
zip -r ../lambda_function.zip .
cd ..
zip lambda_function.zip lambda_function.py
In Windows, use your preferred zip tool to create the lambda_function.zip  ﬁle. Make sure 
that your lambda_function.py  ﬁle and the folders containing your dependencies are all at 
the root of the .zip ﬁle.
You can also create your deployment package using a Python virtual environment. See Working 
with .zip ﬁle archives for Python Lambda functions (p. 352)
Java
Prerequisites
Make sure that Java 11 and Apache Maven are installed in your development environment.
•For Java, use Oracle Java SE Development Kit, Amazon Corretto, Red Hat OpenJDK, or
AdoptOpenJDK.
•For Maven, go to https://maven.apache.org/.
To create the deployment package (Java)
1. Use the following command to create a new directory called create-thumbnail  with a project 
conﬁguration ﬁle (pom.xml) and a basic Java class.
mvn -B archetype:generate \ 
 -DarchetypeGroupId=org.apache.maven.archetypes \ 
 -DgroupId=com.example.CreateThumbnail \ 
 -DartifactId=create-thumbnail
842AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
2. In the create-thumbnail  directory that you created in the previous step,open the pom.xml . 
Replace its contents with the following code, and then save your changes.
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://
www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/
maven-v4_0_0.xsd">
<modelVersion>4.0.0</modelVersion>
<groupId>com.example.CreateThumbnail</groupId>
<artifactId>create-thumbnail</artifactId>
<packaging>jar</packaging>
<version>1.0-SNAPSHOT</version>
<name>create-thumbnail-function</name>
<properties> 
  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> 
  <maven.compiler.release>11</maven.compiler.release>
</properties>
<dependencyManagement> 
  <dependencies> 
    <dependency> 
      <groupId>software.amazon.awssdk</groupId> 
      <artifactId>bom</artifactId> 
      <version>2.17.201</version> 
      <type>pom</type> 
      <scope>import</scope> 
    </dependency> 
  </dependencies>
</dependencyManagement>
<dependencies> 
  <dependency> 
    <groupId>software.amazon.awssdk</groupId> 
    <artifactId>s3</artifactId> 
  </dependency> 
  <dependency> 
    <groupId>com.amazonaws</groupId> 
    <artifactId>aws-lambda-java-core</artifactId> 
    <version>1.2.2</version> 
  </dependency> 
  <dependency> 
    <groupId>com.amazonaws</groupId> 
    <artifactId>aws-lambda-java-events</artifactId> 
    <version>3.11.0</version> 
  </dependency> 
  <dependency> 
    <groupId>com.google.code.gson</groupId> 
    <artifactId>gson</artifactId> 
    <version>[2.8.9,)</version> 
  </dependency>
</dependencies>
<build> 
  <plugins> 
    <plugin> 
      <artifactId>maven-surefire-plugin</artifactId> 
      <version>2.22.2</version> 
    </plugin> 
    <plugin> 
      <groupId>org.apache.maven.plugins</groupId> 
      <artifactId>maven-shade-plugin</artifactId> 
      <version>3.3.0</version> 
      <configuration> 
        <createDependencyReducedPom>false</createDependencyReducedPom> 
      </configuration> 
      <executions> 
        <execution> 
843AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
          <phase>package</phase> 
          <goals> 
            <goal>shade</goal> 
          </goals> 
          <configuration> 
            <filters> 
              <filter> 
                 <artifact>*</artifact> 
                 <excludes> 
                    <exclude>META-INF/*</exclude> 
                    <exclude>**/module-info.class</exclude> 
                 </excludes> 
              </filter> 
           </filters> 
          </configuration> 
        </execution> 
      </executions> 
    </plugin> 
    <plugin> 
      <groupId>org.apache.maven.plugins</groupId> 
      <artifactId>maven-compiler-plugin</artifactId> 
      <version>3.8.1</version> 
      <configuration> 
         <source>11</source> 
         <target>11</target> 
      </configuration> 
    </plugin> 
  </plugins>
</build>
</project>
•The dependencyManagement  section contains a dependency to the AWS SDK for Java.
•The dependencies  section has a dependency for Amazon S3.
•The build section includes the Maven Shade plugin. This plugin creates a JAR ﬁle that 
contains the compiled function code and all of its dependencies. The Apache Maven Compiler 
Plugin is conﬁgured to use Java 11.
3. In the /create-thumbnail/src/main/java/com/example/CreateThumbnail  directory, 
change the name of the App.java  ﬁle to Handler.java .
4. Open Handler.java  and replace its contents with the following code and save the ﬁle.
Example Handler.java
package com.example.CreateThumbnail;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.imageio.ImageIO;
import software.amazon.awssdk.awscore.exception.AwsServiceException;
import software.amazon.awssdk.core.sync.RequestBody;
import software.amazon.awssdk.services.s3.model.GetObjectRequest;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;
844AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
import software.amazon.awssdk.services.s3.S3Client;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.LambdaLogger;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.S3Event;
import 
 com.amazonaws.services.lambda.runtime.events.models.s3.S3EventNotification.S3EventNotificationRecord;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
// Handler value: com.example.CreateThumbnail.Handler
public class Handler implements RequestHandler<S3Event, String> { 
  Gson gson = new GsonBuilder().setPrettyPrinting().create(); 
  private static final float MAX_DIMENSION = 100; 
  private final String REGEX = ".*\\.([^\\.]*)"; 
  private final String JPG_TYPE = "jpg"; 
  private final String JPG_MIME = "image/jpeg"; 
  private final String PNG_TYPE = "png"; 
  private final String PNG_MIME = "image/png"; 
  @Override 
  public String handleRequest(S3Event s3event, Context context) { 
    final LambdaLogger logger = context.getLogger(); 
    try { 
      logger.log("EVENT: " + gson.toJson(s3event)); 
      S3EventNotificationRecord record = s3event.getRecords().get(0); 
       
      String srcBucket = record.getS3().getBucket().getName(); 
      // Object key may have spaces or unicode non-ASCII characters. 
      String srcKey = record.getS3().getObject().getUrlDecodedKey(); 
      String dstBucket = srcBucket + "-resized"; 
      String dstKey = "resized-" + srcKey; 
      // Infer the image type. 
      Matcher matcher = Pattern.compile(REGEX).matcher(srcKey); 
      if (!matcher.matches()) { 
          logger.log("Unable to infer image type for key " + srcKey); 
          return ""; 
      } 
      String imageType = matcher.group(1); 
      if (!(JPG_TYPE.equals(imageType)) && !(PNG_TYPE.equals(imageType))) { 
          logger.log("Skipping non-image " + srcKey); 
          return ""; 
      } 
      // Download the image from S3 into a stream 
      S3Client s3Client = S3Client.builder().build(); 
      InputStream s3Object = getObject(s3Client, srcBucket, srcKey); 
      // Read the source image and resize it 
      BufferedImage srcImage = ImageIO.read(s3Object); 
      BufferedImage newImage = resizeImage(srcImage); 
      // Re-encode image to target format 
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); 
      ImageIO.write(newImage, imageType, outputStream); 
      // Upload new image to S3 
      putObject(s3Client, outputStream, dstBucket, dstKey, imageType, logger); 
      logger.log("Successfully resized " + srcBucket + "/" 
              + srcKey + " and uploaded to " + dstBucket + "/" + dstKey); 
      return "Ok"; 
845AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
    } catch (IOException e) { 
      throw new RuntimeException(e); 
    } 
  } 
  private InputStream getObject(S3Client s3Client, String bucket, String key) { 
    GetObjectRequest getObjectRequest = GetObjectRequest.builder() 
      .bucket(bucket) 
      .key(key) 
      .build(); 
    return s3Client.getObject(getObjectRequest); 
  } 
  private void putObject(S3Client s3Client, ByteArrayOutputStream outputStream, 
    String bucket, String key, String imageType, LambdaLogger logger) { 
      Map<String, String> metadata = new HashMap<>(); 
      metadata.put("Content-Length", Integer.toString(outputStream.size())); 
      if (JPG_TYPE.equals(imageType)) { 
        metadata.put("Content-Type", JPG_MIME); 
      } else if (PNG_TYPE.equals(imageType)) { 
        metadata.put("Content-Type", PNG_MIME); 
      } 
      PutObjectRequest putObjectRequest = PutObjectRequest.builder() 
        .bucket(bucket) 
        .key(key) 
        .metadata(metadata) 
        .build(); 
      // Uploading to S3 destination bucket 
      logger.log("Writing to: " + bucket + "/" + key); 
      try { 
        s3Client.putObject(putObjectRequest, 
          RequestBody.fromBytes(outputStream.toByteArray())); 
      } 
      catch(AwsServiceException e) 
      { 
        logger.log(e.awsErrorDetails().errorMessage()); 
        System.exit(1); 
      } 
  } 
  /** 
   * Resizes (shrinks) an image into a small, thumbnail-sized image. 
   *  
   * The new image is scaled down proportionally based on the source 
   * image. The scaling factor is determined based on the value of 
   * MAX_DIMENSION. The resulting new image has max(height, width) 
   * = MAX_DIMENSION. 
   *  
   * @param srcImage BufferedImage to resize. 
   * @return New BufferedImage that is scaled down to thumbnail size. 
   */ 
  private BufferedImage resizeImage(BufferedImage srcImage) { 
    int srcHeight = srcImage.getHeight(); 
    int srcWidth = srcImage.getWidth(); 
    // Infer scaling factor to avoid stretching image unnaturally 
    float scalingFactor = Math.min( 
      MAX_DIMENSION / srcWidth, MAX_DIMENSION / srcHeight); 
    int width = (int) (scalingFactor * srcWidth); 
    int height = (int) (scalingFactor * srcHeight); 
    BufferedImage resizedImage = new BufferedImage(width, height, 
            BufferedImage.TYPE_INT_RGB); 
    Graphics2D graphics = resizedImage.createGraphics(); 
    // Fill with white before applying semi-transparent (alpha) images 
846AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
    graphics.setPaint(Color.white); 
    graphics.fillRect(0, 0, width, height); 
    // Simple bilinear resize 
    graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, 
            RenderingHints.VALUE_INTERPOLATION_BILINEAR); 
    graphics.drawImage(srcImage, 0, 0, width, height, null); 
    graphics.dispose(); 
    return resizedImage; 
  }
}
5. The mvn -B archetype:generate  command from step 1 also generated a dummy test case 
in the src/test  directory. For the purposes of this tutorial, skip over running tests by deleting 
this entire generated /test directory.
Note
As a best practice, always thoroughly test your code. For a working example of how you 
might unit test this application, see  the s3-java example on GitHub.
6. Use the following command to build your project.
mvn package
This command generates a JAR ﬁle in the target directory.
Create the Lambda function
You can create your Lambda function using either the AWS CLI or the Lambda console. Follow the 
instructions for your chosen language to create the function.
AWS Management Console
To create the function (console)
To create your Lambda function using the console, you ﬁrst create a basic function containing some 
‘Hello world’ code. You then replace this code with your own function code by uploading the.zip or 
JAR ﬁle you created in the previous step.
1. Open the Functions page of the Lambda console.
2. Make sure you're working in the same AWS Region you created your Amazon S3 bucket in. You 
can change your region using the drop-down list at the top of the screen.
847AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
3. Choose Create function.
4. Choose Author from scratch .
5. Under Basic information , do the following:
a. For Function name, enter CreateThumbnail .
b. For Runtime choose either Node.js 18.x , Python 3.9, or Java 11 according to the language 
you chose for your function.
c. For Architecture, choose x86_64 .
6. In the Change default execution role tab, do the following:
a. Expand the tab, then choose Use an existing role.
b. Select the LambdaS3Role  you created earlier.
7. Choose Create function.
To upload the function code (console)
1. In the Code source pane, choose Upload from.
2. For the Python and Node.js runtimes, choose .zip ﬁle. For the Java runtime, choose .zip or .jar 
ﬁle.
3. Choose Upload.
4. In the ﬁle selector, select your .zip or JAR ﬁle and choose Open .
5. Choose Save.
AWS CLI
To create the function (AWS CLI)
• Run the CLI command for the language you chose. For the role parameter, make sure to 
replace 123456789012  with your own AWS account ID. For the region parameter, replace us-
west-2 with the region you created your Amazon S3 buckets in.
•For Node.js , run the following command from the directory containing your function.zip
ﬁle.
aws lambda create-function --function-name CreateThumbnail \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--timeout 10 --memory-size 1024 \
--role arn:aws:iam:: 123456789012 :role/LambdaS3Role --region us-west-2
848AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
•For Python, run the following command from the directory containing your
lambda_function.zip  ﬁle.
aws lambda create-function --function-name CreateThumbnail \
--zip-file fileb://lambda_function.zip --handler lambda_function.lambda_handler \
--runtime python3.9 --timeout 10 --memory-size 1024 \
--role arn:aws:iam:: 123456789012 :role/LambdaS3Role --region us-west-2
•For Java, run the following command from the target directory of your project.
aws lambda create-function --function-name CreateThumbnail \
--zip-file fileb://create-thumbnail-1.0-SNAPSHOT.jar \
--handler com.example.CreateThumbnail.Handler \
--runtime java11 --timeout 10 --memory-size 1024 \
--role arn:aws:iam:: 123456789012 :role/LambdaS3Role --region us-west-2
Conﬁgure Amazon S3 to invoke the function
For your Lambda function to run when you upload an image to your source bucket, you need to 
conﬁgure a trigger for your function. You can conﬁgure the Amazon S3 trigger using either the console 
or the AWS CLI.
Important
This procedure conﬁgures the Amazon S3 bucket to invoke your function every time that an 
object is created in the bucket. Be sure to conﬁgure this only on the source bucket. If your 
Lambda function creates objects in the same bucket that invokes it, your function can be
invoked continuously in a loop. This can result in un expected charges being billed to your AWS 
account.
AWS Management Console
To conﬁgure the Amazon S3 trigger (console)
1. Open the Functions page of the Lambda console and choose your function 
(CreateThumbnail ).
2. Choose Add trigger .
3. Select S3.
4. Under Bucket, select your source bucket.
5. Under Event types, select All object create events.
6. Under Recursive invocation, select the check box to acknowledge that using the same Amazon 
S3 bucket for input and output is not recommended. You can learn more about recursive 
invocation patterns in Lambda by reading Recursive patterns that cause run-away Lambda 
functions in Serverless Land.
849AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
7. Choose Add.
When you create a trigger using the Lambda console, Lambda automatically creates a resource 
based policy to give the service you select permission to invoke your function.
AWS CLI
To conﬁgure the Amazon S3 trigger (AWS CLI)
1. For your Amazon S3 source bucket to invoke your function when you add an image ﬁle, you ﬁrst 
need to conﬁgure permissions for your function using a resource based policy. A resource-based 
policy statement gives other AWS services permission to invoke your function. To give Amazon 
S3 permission to invoke your function, run the following CLI command. Be sure to replace the
source-account  parameter with your own AWS account ID and to use your own source bucket 
name.
aws lambda add-permission --function-name CreateThumbnail \
--principal s3.amazonaws.com --statement-id s3invoke --action 
 "lambda:InvokeFunction" \
--source-arn arn:aws:s3::: SOURCEBUCKET  \
--source-account 123456789012
The policy you deﬁne with this command allows Amazon S3 to invoke your function only when 
an action takes place on your source bucket.
Note
Although Amazon S3 bucket names are globally unique, when using resource-based 
policies it is best practice to specify that the bucket must belong to your account. This is 
because if you delete a bucket, it is possible for another AWS account to create a bucket 
with the same Amazon Resource Name (ARN).
2. Save the following JSON in a ﬁle named notification.json . When applied to your source 
bucket, this JSON conﬁgures the bucket to send a notiﬁcation to your Lambda function every 
time a new object is added. Replace the AWS account number and AWS Region in the Lambda 
function ARN with your own account number and region.
{
"LambdaFunctionConfigurations": [ 
    { 
      "Id": "CreateThumbnailEventConfiguration", 
      "LambdaFunctionArn": "arn:aws:lambda: us-
west-2:123456789012 :function:CreateThumbnail", 
      "Events": [ "s3:ObjectCreated:Put" ] 
    } 
  ]
}
3. Run the following CLI command to apply the notiﬁcation settings in the JSON ﬁle you created 
to your source bucket. Replace SOURCEBUCKET  with the name of your own source bucket.
aws s3api put-bucket-notification-configuration --bucket SOURCEBUCKET  \
--notification-configuration file://notification.json
850AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
Test your Lambda function with a dummy event
Before you test your whole setup by adding an image ﬁle to your Amazon S3 source bucket, you test 
that your Lambda function is working correctly by invoking it with a dummy event. An event in Lambda 
is a JSON-formatted document that contains data for your function to process. When your function is 
invoked by Amazon S3, the event sent to your function contains information such as the bucket name, 
bucket ARN, and object key.
AWS Management Console
To test your Lambda function with a dummy event (console)
1. Open the Functions page of the Lambda console and choose your function 
(CreateThumbnail ).
2. Choose the Test tab.
3. To create your test event, in the Test event pane, do the following:
a. Under Test event action, select Create new event.
b. For Event name, enter myTestEvent .
c. For Template, select S3 Put .
d. Replace the values for the following parameters with your own values.
•For awsRegion , replace us-east-1  with the AWS Region you created your Amazon S3 
buckets in.
•For name, replace example-bucket  with the name of your own Amazon S3 source 
bucket.
•For key, replace test%2Fkey  with the ﬁlename of the test object you uploaded to your 
source bucket in the step Upload a test image to your source bucket (p. 835).
{ 
  "Records": [ 
    { 
      "eventVersion": "2.0", 
      "eventSource": "aws:s3", 
      "awsRegion": "us-east-1" , 
      "eventTime": "1970-01-01T00:00:00.000Z", 
      "eventName": "ObjectCreated:Put", 
      "userIdentity": { 
        "principalId": "EXAMPLE" 
      }, 
      "requestParameters": { 
        "sourceIPAddress": "127.0.0.1" 
      }, 
      "responseElements": { 
851AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
        "x-amz-request-id": "EXAMPLE123456789", 
        "x-amz-id-2": "EXAMPLE123/5678abcdefghijklambdaisawesome/
mnopqrstuvwxyzABCDEFGH" 
      }, 
      "s3": { 
        "s3SchemaVersion": "1.0", 
        "configurationId": "testConfigRule", 
        "bucket": { 
          "name": "example-bucket" , 
          "ownerIdentity": { 
            "principalId": "EXAMPLE" 
          }, 
          "arn": "arn:aws:s3:::example-bucket" 
        }, 
        "object": { 
          "key": "test%2Fkey" , 
          "size": 1024, 
          "eTag": "0123456789abcdef0123456789abcdef", 
          "sequencer": "0A1B2C3D4E5F678901" 
        } 
      } 
    } 
  ]
}
e. Choose Save.
4. In the Test event pane, choose Test.
5. To check the your function has created a resized verison of your image and stored it in your 
target Amazon S3 bucket, do the following:
a. Open the Buckets page of the Amazon S3 console.
b. Choose your target bucket and conﬁrm that your resized ﬁle is listed in the Objects pane.
AWS CLI
To test your Lambda function with a dummy event (AWS CLI)
1. Save the following JSON in a ﬁle named dummyS3Event.json . Replace the values for the 
following parameters with your own values:
1.For awsRegion , replace us-west-2  with the AWS Region you created your Amazon S3 
buckets in.
2.For name, replace SOURCEBUCKET  with the name of your own Amazon S3 source bucket.
3.For key, replace HappyFace.jpg  with the ﬁlename of the test object you uploaded to your 
source bucket in the step Upload a test image to your source bucket (p. 835).
{ 
  "Records":[ 
    { 
      "eventVersion":"2.0", 
      "eventSource":"aws:s3", 
      "awsRegion": "us-west-2" , 
      "eventTime":"1970-01-01T00:00:00.000Z", 
      "eventName":"ObjectCreated:Put", 
      "userIdentity":{ 
        "principalId":"AIDAJDPLRKLG7UEXAMPLE" 
      }, 
      "requestParameters":{ 
        "sourceIPAddress":"127.0.0.1" 
852AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
      }, 
      "responseElements":{ 
        "x-amz-request-id":"C3D13FE58DE4C810", 
        "x-amz-id-2":"FMyUVURIY8/IgAtTv8xRjskZQpcIZ9KG4V5Wp6S7S/
JRWeUWerMUE5JgHvANOjpD" 
      }, 
      "s3":{ 
        "s3SchemaVersion":"1.0", 
        "configurationId":"testConfigRule", 
        "bucket":{ 
          "name": "SOURCEBUCKET" , 
          "ownerIdentity":{ 
            "principalId":"A3NL1KOZZKExample" 
          }, 
          "arn":"arn:aws:s3:::SOURCEBUCKET" 
        }, 
        "object":{ 
          "key": "HappyFace.jpg" , 
          "size":1024, 
          "eTag":"d41d8cd98f00b204e9800998ecf8427e", 
          "versionId":"096fKKXTRTtl3on89fVO.nfljtsv6qko" 
        } 
      } 
    } 
  ]
}
2. From the directory you saved your dummyS3Event.json  ﬁle in, invoke the function by running 
the following CLI command. This command invokes your Lambda function synchronously by 
specifying RequestResponse  as the value of the invocation-type parameter. To learn more 
about synchronous and asynchronous invocation, see Invoking Lambda functions.
aws lambda invoke --function-name CreateThumbnail \
--invocation-type RequestResponse --cli-binary-format raw-in-base64-out \
--payload file://dummyS3Event.json outputfile.txt
The cli-binary-format option is required if you are using version 2 of the AWS CLI. To make this 
the default setting, run aws configure set cli-binary-format raw-in-base64-out . 
For more information, see AWS CLI supported global command line options.
3. Verify that your function has created a thumbnail version of your image and saved it to your 
target Amazon S3 bucket. Run the following CLI command, replacing SOURCEBUCKET-resized
with the name of your own destination bucket.
aws s3api list-objects-v2 --bucket SOURCEBUCKET-resized
You should see output similar to the following. The Key parameter shows the ﬁlename of your 
resized image ﬁle.
{ 
    "Contents": [ 
        { 
            "Key": "resized-HappyFace.jpg", 
            "LastModified": "2023-06-06T21:40:07+00:00", 
            "ETag": "\"d8ca652ffe83ba6b721ffc20d9d7174a\"", 
            "Size": 2633, 
            "StorageClass": "STANDARD" 
        } 
    ]
}
853AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
Test your function using the Amazon S3 trigger
Now that you’ve conﬁrmed your Lambda function is operating correctly, you’re ready to test your 
complete setup by adding an image ﬁle to your Amazon S3 source bucket. When you add your image 
to the source bucket, your Lambda function should be automatically invoked. Your function creates a 
resized version of the ﬁle and stores it in your target bucket.
AWS Management Console
To test your Lambda function using the Amazon S3 trigger (console)
1. To upload an image to your Amazon S3 bucket, do the following:
a. Open the Buckets page of the Amazon S3 console and choose your source bucket.
b. Choose Upload.
c. Choose Add ﬁles and use the ﬁle selector to choose the image ﬁle you want to upload. Your 
image object can be any .jpg or .png ﬁle.
d. Choose Open , then choose Upload.
2. Verify that Lambda has saved a resized version of your image ﬁle in your target bucket by doing 
the following:
a. Navigate back to the Buckets page of the Amazon S3 console and choose your destination 
bucket.
b. In the Objects pane, you should now see two resized image ﬁles, one from each test of your 
Lambda function. To download your resized image, select the ﬁle, then choose Download.
AWS CLI
To test your Lambda function using the Amazon S3 trigger (AWS CLI)
1. From the directory containing the image you want to upload, run the following CLI command. 
Replace the --bucket  parameter with the name of your source bucket. For the --key  and --
body parameters, use the ﬁlename of your test image. Your test image can be any .jpg or .png 
ﬁle.
aws s3api put-object --bucket SOURCEBUCKET  --key SmileyFace.jpg  --body ./
SmileyFace.jpg
2. Verify that your function has created a thumbnail version of your image and saved it to your 
target Amazon S3 bucket. Run the following CLI command, replacing SOURCEBUCKET-resized
with the name of your own destination bucket.
aws s3api list-objects-v2 --bucket SOURCEBUCKET-resized
854AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
If your function runs successfully, you’ll see output similar to the following. Your target bucket 
should now contain two resized ﬁles.
{ 
    "Contents": [ 
        { 
            "Key": "resized-HappyFace.jpg", 
            "LastModified": "2023-06-07T00:15:50+00:00", 
            "ETag": "\"7781a43e765a8301713f533d70968a1e\"", 
            "Size": 2763, 
            "StorageClass": "STANDARD" 
        }, 
        { 
            "Key": "resized-SmileyFace.jpg", 
            "LastModified": "2023-06-07T00:13:18+00:00", 
            "ETag": "\"ca536e5a1b9e32b22cd549e18792cdbc\"", 
            "Size": 1245, 
            "StorageClass": "STANDARD" 
        } 
    ]
}
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the policy that you created
1. Open the Policies page of the IAM console.
2. Select the policy that you created (AWSLambdaS3Policy).
3. Choose Policy actions, Delete.
4. Choose Delete.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the S3 bucket
1. Open the Amazon S3 console.
855AWS Lambda Developer Guide
Tutorial: Use an Amazon S3 trigger to create thumbnails
2. Select the bucket you created.
3. Choose Delete.
4. Enter the name of the bucket in the text input ﬁeld.
5. Choose Delete bucket.
856AWS Lambda Developer Guide
S3 Batch
Using AWS Lambda with Amazon S3 batch 
operations
You can use Amazon S3 batch operations to invoke a Lambda function on a large set of Amazon S3 
objects. Amazon S3 tracks the progress of batch operations, sends notiﬁcations, and stores a completion 
report that shows the status of each action.
To run a batch operation, you create an Amazon S3 batch operations job . When you create the job, you 
provide a manifest (the list of objects) and conﬁgure the action to perform on those objects.
When the batch job starts, Amazon S3 invokes the Lambda function synchronously (p. 139) for each 
object in the manifest. The event parameter includes the names of the bucket and the object.
The following example shows the event that Amazon S3 sends to the Lambda function for an object that 
is named customerImage1.jpg  in the examplebucket bucket.
Example Amazon S3 batch request event
{
"invocationSchemaVersion": "1.0", 
    "invocationId": "YXNkbGZqYWRmaiBhc2RmdW9hZHNmZGpmaGFzbGtkaGZza2RmaAo", 
    "job": { 
        "id": "f3cc4f60-61f6-4a2b-8a21-d07600c373ce" 
    }, 
    "tasks": [ 
        { 
            "taskId": "dGFza2lkZ29lc2hlcmUK", 
            "s3Key": "customerImage1.jpg", 
            "s3VersionId": "1", 
            "s3BucketArn": "arn:aws:s3:::examplebucket" 
        } 
    ]   
}
Your Lambda function must return a JSON object with the ﬁelds as shown in the following example. 
You can copy the invocationId  and taskId from the event parameter. You can return a string in the
resultString . Amazon S3 saves the resultString  values in the completion report.
Example Amazon S3 batch request response
{ 
  "invocationSchemaVersion": "1.0", 
  "treatMissingKeysAs" : "PermanentFailure", 
  "invocationId" : "YXNkbGZqYWRmaiBhc2RmdW9hZHNmZGpmaGFzbGtkaGZza2RmaAo", 
  "results": [ 
    { 
      "taskId": "dGFza2lkZ29lc2hlcmUK", 
      "resultCode": "Succeeded", 
      "resultString": "["Alice", "Bob"]" 
    } 
  ]
} 
   
857AWS Lambda Developer Guide
Invoking Lambda functions from 
Amazon S3 batch operations 
Invoking Lambda functions from Amazon S3 batch 
operations
You can invoke the Lambda function with an unqualiﬁed or qualiﬁed function ARN. If you want to 
use the same function version for the entire batch job, conﬁgure a speciﬁc function version in the
FunctionARN  parameter when you create your job. If you conﬁgure an alias or the $LATEST qualiﬁer, 
the batch job immediately starts calling the new version of the function if the alias or $LATEST is 
updated during the job execution.
Note that you can't reuse an existing Amazon S3 event-based function for batch operations. This is 
because the Amazon S3 batch operation passes a diﬀerent event parameter to the Lambda function and 
expects a return message with a speciﬁc JSON structure.
In the resource-based policy (p. 929) that you create for the Amazon S3 batch job, ensure that you set 
permission for the job to invoke your Lambda function.
In the execution role for the function, set a trust policy for Amazon S3 to assume the role when it runs 
your function.
If your function uses the AWS SDK to manage Amazon S3 resources, you need to add Amazon S3 
permissions in the execution role.
When the job runs, Amazon S3 starts multiple function instances to process the Amazon S3 objects in 
parallel, up to the concurrency limit (p. 220) of the function. Amazon S3 limits the initial ramp-up of 
instances to avoid excess cost for smaller jobs.
If the Lambda function returns a TemporaryFailure  response code, Amazon S3 retries the operation.
For more information about Amazon S3 batch operations, see Performing batch operations in the
Amazon S3 Developer Guide .
For an example of how to use a Lambda function in Amazon S3 batch operations, see Invoking a Lambda 
function from Amazon S3 batch operations in the Amazon S3 Developer Guide .
858AWS Lambda Developer Guide
S3 Object Lambda
Transforming S3 Objects with S3 Object Lambda
With S3 Object Lambda you can add your own code to Amazon S3 GET, HEAD, and LIST requests to 
modify and process data before it is returned to an application. You can use custom code to modify 
the data returned by standard S3 GET, HEAD, or LIST requests to ﬁlter rows, dynamically resize images, 
redact conﬁdential data, and more. Powered by AWS Lambda functions, your code runs on infrastructure 
that is fully managed by AWS, eliminating the need to create and store derivative copies of your data or 
to run proxies, all with no changes required to applications.
For more information, see Transforming objects with S3 Object Lambda.
Tutorials
•Transforming data for your application with Amazon S3 Object Lambda
•Detecting and redacting PII data with Amazon S3 Object Lambda and Amazon Comprehend
•Using Amazon S3 Object Lambda to Dynamically Watermark Images as They Are Retrieved
859AWS Lambda Developer Guide
Secrets Manager
Using AWS Lambda with Secrets Manager
Your AWS Lambda function can interact with AWS Secrets Manager using the Secrets Manager API or 
any of the AWS Software Development Kits (SDKs). You can also use the AWS Parameters and Secrets 
Lambda Extension to retrieve and cache AWS Secrets Manager secrets in Lambda functions without using 
an SDK. See  Use AWS Secrets Manager secrets in AWS Lambda functions for more information.
860AWS Lambda Developer Guide
SES
Using AWS Lambda with Amazon SES
When you use Amazon SES to receive messages, you can conﬁgure Amazon SES to call your Lambda 
function when messages arrive. The service can then invoke your Lambda function by passing in 
the incoming email event, which in reality is an Amazon SES message in an Amazon SNS event, as a 
parameter.
Example Amazon SES message event
{ 
  "Records": [ 
    { 
      "eventVersion": "1.0", 
      "ses": { 
        "mail": { 
          "commonHeaders": { 
            "from": [ 
              "Jane Doe <janedoe@example.com>" 
            ], 
            "to": [ 
              "johndoe@example.com" 
            ], 
            "returnPath": "janedoe@example.com", 
            "messageId": "<0123456789example.com>", 
            "date": "Wed, 7 Oct 2015 12:34:56 -0700", 
            "subject": "Test Subject" 
          }, 
          "source": "janedoe@example.com", 
          "timestamp": "1970-01-01T00:00:00.000Z", 
          "destination": [ 
            "johndoe@example.com" 
          ], 
          "headers": [ 
            { 
              "name": "Return-Path", 
              "value": "<janedoe@example.com>" 
            }, 
            { 
              "name": "Received", 
              "value": "from mailer.example.com (mailer.example.com [203.0.113.1]) by 
 inbound-smtp.us-west-2.amazonaws.com with SMTP id o3vrnil0e2ic for johndoe@example.com; 
 Wed, 07 Oct 2015 12:34:56 +0000 (UTC)" 
            }, 
            { 
              "name": "DKIM-Signature", 
              "value": "v=1; a=rsa-sha256; c=relaxed/relaxed; d=example.com; 
 s=example; h=mime-version:from:date:message-id:subject:to:content-type; 
 bh=jX3F0bCAI7sIbkHyy3mLYO28ieDQz2R0P8HwQkklFj4=; b=sQwJ+LMe9RjkesGu+vqU56asvMhrLRRYrWCbV" 
            }, 
            { 
              "name": "MIME-Version", 
              "value": "1.0" 
            }, 
            { 
              "name": "From", 
              "value": "Jane Doe <janedoe@example.com>" 
            }, 
            { 
              "name": "Date", 
              "value": "Wed, 7 Oct 2015 12:34:56 -0700" 
            }, 
            { 
              "name": "Message-ID", 
861AWS Lambda Developer Guide
SES
              "value": "<0123456789example.com>" 
            }, 
            { 
              "name": "Subject", 
              "value": "Test Subject" 
            }, 
            { 
              "name": "To", 
              "value": "johndoe@example.com" 
            }, 
            { 
              "name": "Content-Type", 
              "value": "text/plain; charset=UTF-8" 
            } 
          ], 
          "headersTruncated": false, 
          "messageId": "o3vrnil0e2ic28tr" 
        }, 
        "receipt": { 
          "recipients": [ 
            "johndoe@example.com" 
          ], 
          "timestamp": "1970-01-01T00:00:00.000Z", 
          "spamVerdict": { 
            "status": "PASS" 
          }, 
          "dkimVerdict": { 
            "status": "PASS" 
          }, 
          "processingTimeMillis": 574, 
          "action": { 
            "type": "Lambda", 
            "invocationType": "Event", 
            "functionArn": "arn:aws:lambda:us-west-2:111122223333:function:Example" 
          }, 
          "spfVerdict": { 
            "status": "PASS" 
          }, 
          "virusVerdict": { 
            "status": "PASS" 
          } 
        } 
      }, 
      "eventSource": "aws:ses" 
    } 
  ]
}
For more information, see Lambda action in the Amazon SES Developer Guide .
862AWS Lambda Developer Guide
SNS
Using AWS Lambda with Amazon SNS
You can use a Lambda function to process Amazon Simple Notiﬁcation Service (Amazon SNS) 
notiﬁcations. Amazon SNS supports Lambda functions as a target for messages sent to a topic. You can 
subscribe your function to topics in the same account or in other AWS accounts.
Amazon SNS invokes your function asynchronously (p. 142) with an event that contains a message and 
metadata.
Example Amazon SNS message event
{ 
  "Records": [ 
    { 
      "EventVersion": "1.0", 
      "EventSubscriptionArn": "arn:aws:sns:us-east-1:123456789012:sns-lambda:21be56ed-
a058-49f5-8c98-aedd2564c486", 
      "EventSource": "aws:sns", 
      "Sns": { 
        "SignatureVersion": "1", 
        "Timestamp": "2019-01-02T12:45:07.000Z", 
        "Signature": "tcc6faL2yUC6dgZdmrwh1Y4cGa/ebXEkAi6RibDsvpi+tE/1+82j...65r==", 
        "SigningCertUrl": "https://sns.us-east-1.amazonaws.com/SimpleNotificationService-
ac565b8b1a6c5d002d285f9598aa1d9b.pem", 
        "MessageId": "95df01b4-ee98-5cb9-9903-4c221d41eb5e", 
        "Message": "Hello from SNS!", 
        "MessageAttributes": { 
          "Test": { 
            "Type": "String", 
            "Value": "TestString" 
          }, 
          "TestBinary": { 
            "Type": "Binary", 
            "Value": "TestBinary" 
          } 
        }, 
        "Type": "Notification", 
        "UnsubscribeUrl": "https://sns.us-east-1.amazonaws.com/?
Action=Unsubscribe&amp;SubscriptionArn=arn:aws:sns:us-east-1:123456789012:test-
lambda:21be56ed-a058-49f5-8c98-aedd2564c486", 
        "TopicArn":"arn:aws:sns:us-east-1:123456789012:sns-lambda", 
        "Subject": "TestInvoke" 
      } 
    } 
  ]
}
For asynchronous invocation, Lambda queues the message and handles retries. If Amazon SNS can't 
reach Lambda or the message is rejected, Amazon SNS retries at increasing intervals over several hours. 
For details, see Reliability in the Amazon SNS FAQs.
To perform cross-account Amazon SNS deliveries to Lambda, you must authorize Amazon SNS to invoke 
your Lambda function. In turn, Amazon SNS must allow the AWS account with the Lambda function 
to subscribe to the Amazon SNS topic. For example, if the Amazon SNS topic is in account A and the 
Lambda function is in account B, both accounts must grant permissions to the other to access their 
respective resources. Since not all the options for setting up cross-account permissions are available from 
the AWS Management Console, you must use the AWS Command Line Interface (AWS CLI) for setup.
For more information, see Fanout to Lambda functions in the Amazon Simple Notiﬁcation Service 
Developer Guide .
863AWS Lambda Developer Guide
Tutorial
Input types for Amazon SNS events
For input type examples for Amazon SNS events in Java, .NET, and Go, see the following on the AWS 
GitHub repository:
•SNSEvent.java
•SNSEvent.cs
•sns.go
Topics
•Tutorial: Using AWS Lambda with Amazon Simple Notiﬁcation Service (p. 864)
•Sample function code (p. 872)
Tutorial: Using AWS Lambda with Amazon Simple 
Notiﬁcation Service
In this tutorial, you use a Lambda function in one AWS account to subscribe to an Amazon Simple 
Notiﬁcation Service (Amazon SNS) topic in a separate AWS account. When you publish messages to your 
Amazon SNS topic, your Lambda function reads the contents of the message and outputs it to Amazon 
CloudWatch Logs. To complete this tutorial, you use the AWS Command Line Interface (AWS CLI).
To complete this tutorial, you perform the following steps:
•In account A, create an Amazon SNS topic.
•In account B, create a Lambda function that will read messages from the topic.
•In account B, create a subscription to the topic.
•Publish messages to the Amazon SNS topic in account A and conﬁrm that the Lambda function in
account B outputs them to CloudWatch Logs.
864AWS Lambda Developer Guide
Tutorial
By completing these steps, you will learn how to conﬁgure an Amazon SNS topic to invoke a Lambda 
function. You will also learn how to create an AWS Identity and Access Management (IAM) policy that 
gives permission for a resource in another AWS account to invoke Lambda.
In the tutorial, you use two separate AWS accounts. The AWS CLI commands illustrate this by using two 
named proﬁles called accountA  and accountB , each conﬁgured for use with a diﬀerent AWS account. 
To learn how to conﬁgure the AWS CLI to use diﬀerent proﬁles, see Conﬁguration and credential ﬁle 
settings in the AWS Command Line Interface User Guide for Version 2. Be sure to conﬁgure the same 
default AWS Region for both proﬁles.
If the AWS CLI proﬁles you create for the two AWS accounts use diﬀerent names, or if you use the default 
proﬁle and one named proﬁle, modify the AWS CLI commands in the following steps as needed.
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
865AWS Lambda Developer Guide
Tutorial
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Install the AWS Command Line Interface
If you have not yet installed the AWS Command Line Interface, follow the steps at Installing or updating 
the latest version of the AWS CLI to install it.
The tutorial requires a command line terminal or shell to run commands. In Linux and macOS, use your 
preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) are 
not supported by the operating system's built-in terminals. To get a Windows-integrated version 
of Ubuntu and Bash, install the Windows Subsystem for Linux.
Create an Amazon SNS topic (account A)
To create the topic
• In account A, create an Amazon SNS standard topic using the following AWS CLI command.
aws sns create-topic --name sns-topic-for-lambda --profile accountA
You should see output similar to the following.
{ 
    "TopicArn": "arn:aws:sns:us-west-2:123456789012:sns-topic-for-lambda"
}
Make a note of the Amazon Resource Name (ARN) of your topic. You’ll need it later in the tutorial 
when you add permissions to your Lambda function to subscribe to the topic.
866AWS Lambda Developer Guide
Tutorial
Create a function execution role (account B)
An execution role is an IAM role that grants a Lambda function permission to access AWS services and 
resources. Before you create your function in account B, you create a role that gives the function basic 
permissions to write logs to CloudWatch Logs. We’ll add the permissions to read from your Amazon SNS 
topic in a later step.
To create an execution role
1. In account B open the roles page in the IAM console.
2. Choose Create role.
3. For Trusted entity type, choose AWS service.
4. For Use case , choose Lambda .
5. Choose Next.
6. Add a basic permissions policy to the role by doing the following:
a. In the Permissions policies search box, enter AWSLambdaBasicExecutionRole .
b. Choose Next.
7. Finalize the role creation by doing the following:
a. Under Role details, enter lambda-sns-role  for Role name.
b. Choose Create role.
Create a Lambda function (account B)
The following example code receives an Amazon SNS event and processes the message it contains by 
writing some of the event data to CloudWatch Logs.
Note
For sample code in other languages, see Sample function code (p. 872).
Example index.mjs
console.log('Loading function');
867AWS Lambda Developer Guide
Tutorial
export const handler= async (event, context) => { 
    console.log('Received event:', JSON.stringify(event, null, 4)); 
    var message = event.Records[0].Sns.Message; 
    console.log('Message received from SNS:', message);
};
To create the function
1. Copy the sample code into a ﬁle named index.mjs .
2. In MacOS or Linux, use the following command to create a .zip deployment package. In Windows, 
use your preferred zip tool to create a .zip ﬁle with your index.mjs  ﬁle at the root. If this ﬁle is not 
at the root of the .zip ﬁle, Lambda won’t be able to run your code.
zip function.zip index.mjs
3. Run the following AWS CLI command to create your Lambda function in account B.
aws lambda create-function --function-name Function-With-SNS \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: <AccountB_ID> :role/lambda-sns-role  \
--timeout 60 --profile accountB
You should see output similar to the following.
{ 
    "FunctionName": "Function-With-SNS", 
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:Function-With-SNS", 
    "Runtime": "nodejs18.x", 
    "Role": "arn:aws:iam::123456789012:role/lambda_basic_role", 
    "Handler": "index.handler", 
    ... 
    "RuntimeVersionConfig": { 
        "RuntimeVersionArn": "arn:aws:lambda:us-
west-2::runtime:7d5f06b69c951da8a48b926ce280a9daf2e8bb1a74fc4a2672580c787d608206" 
    }
}
4. Record the Amazon Resource Name (ARN) of your function. You’ll need it later in the tutorial when 
you add permissions to allow Amazon SNS to invoke your function.
Add permissions to function (account B)
For Amazon SNS to invoke your function, you need to grant it permission in a statement on a resource-
based policy (p. 929). You add this statement using the AWS CLI add-permission  command.
868AWS Lambda Developer Guide
Tutorial
To grant Amazon SNS permission to invoke your function
• In account B, run the following AWS CLI command using the ARN for your Amazon SNS topic you 
recorded earlier.
aws lambda add-permission --function-name Function-With-SNS \
--source-arn arn:aws:sns: us-east-1:<AccountA_ID> :sns-topic-for-lambda \
--statement-id function-with-sns --action "lambda:InvokeFunction" \
--principal sns.amazonaws.com --profile accountB
You should see output similar to the following.
{ 
    "Statement": "{\"Condition\":{\"ArnLike\":{\"AWS:SourceArn\": 
      \"arn:aws:sns:us-east-1:<AccountA_ID>:sns-topic-for-lambda\"}}, 
      \"Action\":[\"lambda:InvokeFunction\"], 
      \"Resource\":\"arn:aws:lambda:us-east-1:<AccountB_ID>:function:Function-With-SNS
\", 
      \"Effect\":\"Allow\",\"Principal\":{\"Service\":\"sns.amazonaws.com\"}, 
      \"Sid\":\"function-with-sns\"}"
}
Note
If the account with the Amazon SNS topic is hosted in an opt-in AWS Region, you need to 
specify the region in the principal. For example, if you're working with an Amazon SNS topic in 
the Asia Paciﬁc (Hong Kong) region, you need to specify sns.ap-east-1.amazonaws.com
instead of sns.amazonaws.com  for the principal.
Grant cross-account permission for Amazon SNS subscription 
(account A)
For your Lambda function in account B to subscribe to the Amazon SNS topic you created in account A, 
you need to grant permission for account B to subscribe to your topic. You grant this permission using 
the AWS CLI add-permission  command.
To grant permission for account B to subscribe to the topic
• In account A, run the following AWS CLI command. Use the ARN for the Amazon SNS topic you 
recorded earlier.
aws sns add-permission --label lambda-access --aws-account-id <AccountB_ID>  \
--topic-arn arn:aws:sns: us-east-1:<AccountA_ID> :sns-topic-for-lambda \   
--action-name Subscribe ListSubscriptionsByTopic --profile accountA
869AWS Lambda Developer Guide
Tutorial
Create a subscription (account B)
In account B, you now subscribe your Lambda function to the Amazon SNS topic you created at the 
beginning of the tutorial in account A. When a message is sent to this topic ( sns-topic-for-lambda ), 
Amazon SNS invokes your Lambda function Function-With-SNS  in account B.
To create a subscription
• In account B, run the following AWS CLI command. Use your default region you created your topic in 
and the ARNs for your topic and Lambda function.
aws sns subscribe --protocol lambda \
--region us-east-1  \
--topic-arn arn:aws:sns: us-east-1:<AccountA_ID> :sns-topic-for-lambda \
--notification-endpoint arn:aws:lambda: us-east-1:<AccountB_ID> :function:Function-With-
SNS \
--profile accountB
You should see output similar to the following.
{ 
    "SubscriptionArn": "arn:aws:sns:us-east-1:<AccountA_ID>:sns-topic-for-
lambda:5d906xxxx-7c8x-45dx-a9dx-0484e31c98xx"
}
Publish messages to topic (account A and account B)
Now that your Lambda function in account B is subscribed to your Amazon SNS topic in account A, it’s 
time to test your setup by publishing messages to your topic. To conﬁrm that Amazon SNS has invoked 
your Lambda function, you use CloudWatch Logs to view your function’s output.
To publish a message to your topic and view your function's output
1. Enter Hello World  into a text ﬁle and save it as message.txt .
870AWS Lambda Developer Guide
Tutorial
2. From the same directory you saved your text ﬁle in, run the following AWS CLI command in account 
A. Use the ARN for your own topic.
aws sns publish --message file://message.txt --subject Test \
--topic-arn arn:aws:sns: us-east-1:<AccountA_ID> :sns-topic-for-lambda \
--profile accountA
This will return a message ID with a unique identiﬁer, indicating that Amazon SNS has accepted the 
message. Amazon SNS then attempts to deliver the message to the topic’s subscribers. To conﬁrm 
that Amazon SNS has invoked your Lambda function, use CloudWatch Logs to view your function’s 
output:
3. In account B, open the Log groups page of the Amazon CloudWatch console.
4. Choose the log group for your function (/aws/lambda/Function-With-SNS ).
5. Choose the most recent log stream.
6. If your function was correctly invoked, you’ll see output similar to the following showing the 
contents of the message you published to your topic.
2023-07-31T21:42:51.250Z c1cba6b8-ade9-4380-aa32-d1a225da0e48 INFO Message received 
 from SNS: Hello World 
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
In Account A, clean up your Amazon SNS topic.
To delete the Amazon SNS topic
1. Open the Topics page of the Amazon SNS console.
2. Select the topic you created.
3. Choose Delete.
4. Enter delete me  in the text input ﬁeld.
5. Choose Delete.
In Account B, clean up your execution role, Lambda function, and Amazon SNS subscription.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
871AWS Lambda Developer Guide
Sample code
To delete the Amazon SNS subscription
1. Open the Subscriptions page  of the Amazon SNS console.
2. Select the subscription you created.
3. Choose Delete, Delete.
Sample function code
Sample code is available for the following languages.
Topics
•Node.js 12.x  (p. 872)
•Java 11 (p. 872)
•Go (p. 873)
•Python 3 (p. 873)
Node.js 12.x
The following example processes a message from Amazon SNS and sends the content of that message to 
the logs.
Example index.js
console.log('Loading function');
exports.handler = function(event, context, callback) {
// console.log('Received event:', JSON.stringify(event, null, 4)); 
    var message = event.Records[0].Sns.Message; 
    console.log('Message received from SNS:', message); 
    callback(null, "Success");
};
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
Java 11
The following example processes a message from Amazon SNS and sends the content of that message to 
the logs.
Example LogEvent.java
package example;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.events.SNSEvent;
public class LogEvent implements RequestHandler<SNSEvent, Object> { 
    public Object handleRequest(SNSEvent request, Context context){ 
872AWS Lambda Developer Guide
Sample code
    String timeStamp = new SimpleDateFormat("yyyy-MM-
dd_HH:mm:ss").format(Calendar.getInstance().getTime()); 
    context.getLogger().log("Invocation started: " + timeStamp); 
    context.getLogger().log(request.getRecords().get(0).getSNS().getMessage()); 
    timeStamp = new SimpleDateFormat("yyyy-MM-
dd_HH:mm:ss").format(Calendar.getInstance().getTime()); 
    context.getLogger().log("Invocation completed: " + timeStamp); 
           return null; 
     }
} 
Dependencies
•aws-lambda-java-core
•aws-lambda-java-events
Build the code with the Lambda library dependencies to create a deployment package. For instructions, 
see Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446).
Go
The following example processes a message from Amazon SNS and sends the content of that message to 
the logs.
Example lambda_handler.go
package main
import ( 
    "context" 
    "fmt" 
    "github.com/aws/aws-lambda-go/lambda" 
    "github.com/aws/aws-lambda-go/events"
)
func handler(ctx context.Context, snsEvent events.SNSEvent) { 
    for _, record := range snsEvent.Records { 
        snsRecord := record.SNS 
        fmt.Printf("[%s %s] Message = %s \n", record.EventSource, snsRecord.Timestamp, 
 snsRecord.Message) 
    }
}
func main() { 
    lambda.Start(handler)
}
Build the executable with go build  and create a deployment package. For instructions, see Deploy Go 
Lambda functions with .zip ﬁle archives (p. 520).
Python 3
The following example processes a message from Amazon SNS and sends the content of that message to 
the logs.
Example lambda_handler.py
from __future__ import print_function
873AWS Lambda Developer Guide
Sample code
import json
print('Loading function')
def lambda_handler(event, context): 
    #print("Received event: " + json.dumps(event, indent=2)) 
    message = event['Records'][0]['Sns']['Message'] 
    print("From SNS: " + message) 
    return message
Zip up the sample code to create a deployment package. For instructions, see Working with .zip ﬁle 
archives for Python Lambda functions (p. 352).
874AWS Lambda Developer Guide
SQS
Using Lambda with Amazon SQS
Note
If you want to send data to a target other than a Lambda function or enrich the data before 
sending it, see  Amazon EventBridge Pipes.
You can use a Lambda function to process messages in an Amazon Simple Queue Service (Amazon SQS) 
queue. Lambda event source mappings (p. 150) support standard queues and ﬁrst-in, ﬁrst-out (FIFO) 
queues . With Amazon SQS, you can oﬄoad tasks from one component of your application by sending 
them to a queue and processing them asynchronously.
Lambda polls the queue and invokes your Lambda function synchronously (p. 139) with an event that 
contains queue messages. Lambda reads messages in batches and invokes your function once for each 
batch. When your function successfully processes a batch, Lambda deletes its messages from the queue.
When Lambda reads a batch, the messages stay in the queue but are hidden for the length of the queue's
visibility timeout. If your function successfully processes the batch, Lambda deletes the messages from 
the queue. By default, if your function encounters an error while processing a batch, all messages in that 
batch become visible in the queue again. For this reason, your function code must be able to process the 
same message multiple times without unintended side eﬀects.
To prevent Lambda from processing a message multiple times, you can either conﬁgure your event 
source mapping to include batch item failures (p. 881) in your function response, or you can use the 
Amazon SQS API action DeleteMessage  to remove messages from the queue as your Lambda function 
successfully processes them. For more information on using the Amazon SQS API, see the Amazon 
Simple Queue Service API Reference
Sections
•Example standard queue message event  (p. 875)
•Example FIFO queue message event (p. 876)
•Conﬁguring a queue to use with Lambda  (p. 877)
•Execution role permissions (p. 877)
•Conﬁguring a queue as an event source (p. 877)
•Scaling and processing (p. 879)
•Conﬁguring maximum concurrency for Amazon SQS event sources (p. 879)
•Event source mapping APIs (p. 880)
•Backoﬀ strategy for failed invocations (p. 881)
•Implementing partial batch responses (p. 881)
•Amazon SQS conﬁguration parameters (p. 883)
•Tutorial: Using Lambda with Amazon SQS (p. 884)
•Tutorial: Using a cross-account Amazon SQS queue as an event source (p. 892)
•Sample Amazon SQS function code (p. 896)
•AWS SAM template for an Amazon SQS application (p. 899)
Example standard queue message event
Example Amazon SQS message event (standard queue)
{ 
    "Records": [ 
        { 
            "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
            "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
875AWS Lambda Developer Guide
Example FIFO queue message event
            "body": "Test message.", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1545082649183", 
                "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
                "ApproximateFirstReceiveTimestamp": "1545082649185" 
            }, 
            "messageAttributes": {}, 
            "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
            "eventSource": "aws:sqs", 
            "eventSourceARN": "arn:aws:sqs:us-east-2:123456789012:my-queue", 
            "awsRegion": "us-east-2" 
        }, 
        { 
            "messageId": "2e1424d4-f796-459a-8184-9c92662be6da", 
            "receiptHandle": "AQEBzWwaftRI0KuVm4tP+/7q1rGgNqicHq...", 
            "body": "Test message.", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1545082650636", 
                "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
                "ApproximateFirstReceiveTimestamp": "1545082650649" 
            }, 
            "messageAttributes": {}, 
            "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
            "eventSource": "aws:sqs", 
            "eventSourceARN": "arn:aws:sqs:us-east-2:123456789012:my-queue", 
            "awsRegion": "us-east-2" 
        } 
    ]
}
By default, Lambda polls up to 10 messages in your queue at once and sends that batch to your function. 
To avoid invoking the function with a small number of records, you can tell the event source to buﬀer 
records for up to 5 minutes by conﬁguring a batch window. Before invoking the function, Lambda 
continues to poll messages from the SQS standard queue until the batch window expires, the invocation 
payload size quota (p. 1269 ) is reached, or the conﬁgured maximum batch size is reached.
Note
If you're using a batch window and your SQS queue contains very low traﬃc, Lambda might wait 
for up to 20 seconds before invoking your function. This is true even if you set a batch window 
lower than 20 seconds.
Example FIFO queue message event
For FIFO queues, records contain additional attributes that are related to deduplication and sequencing.
Example Amazon SQS message event (FIFO queue)
{ 
    "Records": [ 
        { 
            "messageId": "11d6ee51-4cc7-4302-9e22-7cd8afdaadf5", 
            "receiptHandle": "AQEBBX8nesZEXmkhsmZeyIE8iQAMig7qw...", 
            "body": "Test message.", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1573251510774", 
                 "SequenceNumber": "18849496460467696128", 
                "MessageGroupId": "1",
                "SenderId": "AIDAIO23YVJENQZJOL4VO", 
                 "MessageDeduplicationId": "1",
876AWS Lambda Developer Guide
Conﬁguring a queue to use with Lambda
                "ApproximateFirstReceiveTimestamp": "1573251510774" 
            }, 
            "messageAttributes": {}, 
            "md5OfBody": "e4e68fb7bd0e697a0ae8f1bb342846b3", 
            "eventSource": "aws:sqs", 
            "eventSourceARN": "arn:aws:sqs:us-east-2:123456789012:fifo.fifo", 
            "awsRegion": "us-east-2" 
        } 
    ]
}
Conﬁguring a queue to use with Lambda
Create an SQS queue to serve as an event source for your Lambda function. Then conﬁgure the queue 
to allow time for your Lambda function to process each batch of events—and for Lambda to retry in 
response to throttling errors as it scales up.
To allow your function time to process each batch of records, set the source queue's visibility timeout
to at least six times the timeout that you conﬁgure (p. 73) on your function. The extra time allows for 
Lambda to retry if your function is throttled while processing a previous batch.
If your function fails to process a message multiple times, Amazon SQS can send it to a dead-letter 
queue . If your function returns an error, all items in the batch return to the queue. After the visibility 
timeout  occurs, Lambda receives the message again. To send messages to a second queue after a number 
of receives, conﬁgure a dead-letter queue on your source queue.
Note
Make sure that you conﬁgure the dead-letter queue on the source queue, not on the Lambda 
function. The dead-letter queue that you conﬁgure on a function is used for the function's
asynchronous invocation queue (p. 142), not for event source queues.
If your function returns an error, or can't be invoked because it's at maximum concurrency, processing 
might succeed with additional attempts. To give messages a better chance to be processed before 
sending them to the dead-letter queue, set the maxReceiveCount  on the source queue's redrive policy 
to at least 5.
Execution role permissions
Lambda needs the following permissions to manage messages in your Amazon SQS queue. Add them to 
your function's execution role (p. 913).
•sqs:ReceiveMessage
•sqs:DeleteMessage
•sqs:GetQueueAttributes
Optionally, if you're using an encrypted queue, you also need to add the following permission to your 
execution role:
•kms:Decrypt
Conﬁguring a queue as an event source
Create an event source mapping to tell Lambda to send items from your queue to a Lambda function. 
You can create multiple event source mappings to process items from multiple queues with a single 
function. When Lambda invokes the target function, the event can contain multiple items, up to a 
conﬁgurable maximum batch size .
877AWS Lambda Developer Guide
Conﬁguring a queue as an event source
To conﬁgure your function to read from Amazon SQS in the Lambda console, create an SQS trigger.
To create a trigger
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Under Function overview, choose Add trigger .
4. Choose the SQS trigger type.
5. Conﬁgure the required options, and then choose Add.
Lambda supports the following options for Amazon SQS event sources:
SQS queue
The Amazon SQS queue to read records from.
Enable trigger
The status of the event source mapping. Enable trigger is selected by default.
Batch size
The number of records to send to the function in each batch. For a standard queue, this can be up to 
10,000 records. For a FIFO queue, the maximum is 10. For a batch size over 10, you must also set the 
batch window (MaximumBatchingWindowInSeconds ) to at least 1 second.
Conﬁgure your function timeout to allow enough time to process an entire batch of items. If items 
take a long time to process, choose a smaller batch size. A large batch size can improve eﬃciency for 
workloads that are very fast or have a lot of overhead. If you conﬁgure reserved concurrency (p. 234)
on your function, set a minimum of ﬁve concurrent executions to reduce the chance of throttling 
errors when Lambda invokes your function.
Lambda passes all of the records in the batch to the function in a single call, as long as the total size 
of the events doesn't exceed the invocation payload size quota (p. 1269 ) for synchronous invocation 
(6 MB). Both Lambda and Amazon SQS generate metadata for each record. This additional metadata 
is counted towards the total payload size and can cause the total number of records sent in a 
batch to be lower than your conﬁgured batch size. The metadata ﬁelds that Amazon SQS sends 
can be variable in length. For more information about the Amazon SQS metadata ﬁelds, see the
ReceiveMessage API operation documentation in the Amazon Simple Queue Service API Reference.
Batch window
The maximum amount of time to gather records before invoking the function, in seconds. This 
applies only to standard queues.
If you're using a batch window greater than 0 seconds, you must account for the 
increased processing time in your queue's visibility timeout. We recommend setting your 
queue's visibility timeout to six times your function timeout (p. 73), plus the value of
MaximumBatchingWindowInSeconds . This allows time for your Lambda function to process each 
batch of events and to retry in the event of a throttling error.
Note
If your batch window is greater than 0, and (batch window) + (function timeout) 
> (queue visibility timeout) , then your eﬀective queue visibility timeout is (batch 
window) + (function timeout) + 30s .
When messages become available, Lambda starts processing messages in batches. Lambda starts 
processing ﬁve batches at a time with ﬁve concurrent invocations of your function. If messages are 
still available, Lambda adds up to 60 more instances of your function a minute, up to a maximum 
of 1,000 function instances. To learn more about function scaling and concurrency, see Lambda 
function scaling.
878AWS Lambda Developer Guide
Scaling and processing
To process more messages, you can optimize your Lambda function for higher throughput. See
Understanding how AWS Lambda scales with Amazon SQS standard queues.
Maximum concurrency
The maximum number of concurrent functions that the event source can invoke. For more 
information, see Conﬁguring maximum concurrency for Amazon SQS event sources (p. 879).
Filter criteria
Add ﬁlter criteria to control which events Lambda sends to your function for processing. For more 
information, see Lambda event ﬁltering (p. 155).
Scaling and processing
For standard queues, Lambda uses long polling  to poll a queue until it becomes active. When messages 
are available, Lambda starts processing ﬁve batches at a time with ﬁve concurrent invocations of your 
function. If messages are still available, Lambda increases the number of processes that are reading 
batches by up to 60 more instances per minute. The maximum number of batches that an event source 
mapping can process simultaneously is 1,000.
For FIFO queues, Lambda sends messages to your function in the order that it receives them. When you 
send a message to a FIFO queue, you specify a message group ID. Amazon SQS ensures that messages in 
the same group are delivered to Lambda in order. Lambda sorts the messages into groups and sends only 
one batch at a time for a group. If your function returns an error, the function attempts all retries on the 
aﬀected messages before Lambda receives additional messages from the same group.
Your function can scale in concurrency to the number of active message groups. For more information, 
see SQS FIFO as an event source on the AWS Compute Blog.
Conﬁguring maximum concurrency for Amazon SQS 
event sources
The maximum concurrency setting limits the number of concurrent instances of the function that an 
Amazon SQS event source can invoke. Maximum concurrency is an event source-level setting. If you have 
multiple Amazon SQS event sources mapped to one function, each event source can have a separate 
maximum concurrency setting. You can use maximum concurrency to prevent one queue from using all 
of the function's reserved concurrency (p. 234) or the rest of the account's concurrency quota (p. 1269 ). 
You can use maximum concurrency and reserved concurrency together or independently.
Note
You can't set maximum concurrency higher than the function's reserved concurrency. After 
conﬁguring maximum concurrency, make sure that you don't reduce the function's reserved 
concurrency to less than the total maximum concurrency for all Amazon SQS event sources on 
the function. Otherwise, Lambda might throttle your messages.
For FIFO queues, concurrent invocations are capped either by the number of message group IDs
(messageGroupId ) or the maximum concurrency setting—whichever is lower. For example, if 
you have six message group IDs and maximum concurrency is set to 10, your function can have a 
maximum of six concurrent invocations.
There is no charge for conﬁguring maximum concurrency on an Amazon SQS event source.
You can conﬁgure maximum concurrency on new and existing Amazon SQS event source mappings.
Conﬁgure maximum concurrency using the Lambda console
1. Open the Functions page of the Lambda console.
879AWS Lambda Developer Guide
Event source mapping APIs
2. Choose the name of a function.
3. Under Function overview, choose SQS. This opens the Conﬁguration  tab.
4. Select the Amazon SQS trigger and choose Edit.
5. For Maximum concurrency, enter a number between 2 and 1,000. To turn oﬀ maximum 
concurrency, leave the box empty.
6. Choose Save.
Conﬁgure maximum concurrency using the AWS Command Line Interface (AWS CLI)
Use the update-event-source-mapping command with the --scaling-config  option. Example:
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --scaling-config '{"MaximumConcurrency":5}'
To turn oﬀ maximum concurrency, enter an empty value for --scaling-config :
aws lambda update-event-source-mapping \ 
    --uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \ 
    --scaling-config "{}"
Conﬁgure maximum concurrency using the Lambda API
Use the CreateEventSourceMapping (p. 1292 ) or UpdateEventSourceMapping (p. 1495 ) action with a
ScalingConﬁg  (p. 1597 ) object.
Event source mapping APIs
To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can 
use the following API operations:
•CreateEventSourceMapping (p. 1292 )
•ListEventSourceMappings (p. 1418 )
•GetEventSourceMapping (p. 1353 )
•UpdateEventSourceMapping (p. 1495 )
•DeleteEventSourceMapping (p. 1325 )
The following example uses the AWS CLI to map a function named my-function  to an Amazon SQS 
queue that is speciﬁed by its Amazon Resource Name (ARN), with a batch size of 5 and a batch window of 
60 seconds.
aws lambda create-event-source-mapping --function-name my-function --batch-size 5 \
--maximum-batching-window-in-seconds 60 \
--event-source-arn arn:aws:sqs: us-east-2:123456789012:my-queue
You should see the following output:
{ 
    "UUID": "2b733gdc-8ac3-cdf5-af3a-1827b3b11284", 
    "BatchSize": 5, 
    "MaximumBatchingWindowInSeconds": 60, 
    "EventSourceArn": "arn:aws:sqs:us-east-2:123456789012:my-queue", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "LastModified": 1541139209.351, 
880AWS Lambda Developer Guide
Backoﬀ strategy for failed invocations
    "State": "Creating", 
    "StateTransitionReason": "USER_INITIATED"
}
Backoﬀ strategy for failed invocations
When an invocation fails, Lambda attempts to retry the invocation while implementing a backoﬀ 
strategy. The backoﬀ strategy diﬀers slightly depending on whether Lambda encountered the failure due 
to an error in your function code, or due to throttling.
•If your function code caused the error, Lambda gradually backs oﬀ retries by reducing the amount 
of concurrency allocated to your Amazon SQS event source mapping. If invocations continue to fail, 
Lambda eventually drops the message without retrying.
•If the invocation fails due to throttling, Lambda gradually backs oﬀ retries by reducing the amount 
of concurrency allocated to your Amazon SQS event source mapping. Lambda continues to retry the 
message until the message's timestamp exceeds your queue's visibility timeout, at which point Lambda 
drops the message.
Implementing partial batch responses
When your Lambda function encounters an error while processing a batch, all messages in that batch 
become visible in the queue again by default, including messages that Lambda processed successfully. As 
a result, your function can end up processing the same message several times.
To avoid reprocessing successfully processed messages in a failed batch, you can conﬁgure your 
event source mapping to make only the failed messages visible again. This is called a partial 
batch response. To turn on partial batch responses, specify ReportBatchItemFailures  for the
FunctionResponseTypes (p. 1498 ) action when conﬁguring your event source mapping. This lets your 
function return a partial success, which can help reduce the number of unnecessary retries on records.
When ReportBatchItemFailures  is activated, Lambda doesn't scale down message polling (p. 881)
when function invocations fail. If you expect some messages to fail—and you don't want those failures to 
impact the message processing rate—use ReportBatchItemFailures .
Note
Keep the following in mind when using partial batch responses:
•If your function throws an exception, the entire batch is considered a complete failure.
•If you're using this feature with a FIFO queue, your function should stop processing 
messages after the ﬁrst failure and return all failed and unprocessed messages in
batchItemFailures . This helps preserve the ordering of messages in your queue.
To activate partial batch reporting
1. Review the Best practices for implementing partial batch responses.
2. Run the following command to activate ReportBatchItemFailures  for your function. To retrieve 
your event source mapping's UUID, run the list-event-source-mappings AWS CLI command.
aws lambda update-event-source-mapping \
--uuid "a1b2c3d4-5678-90ab-cdef-11111EXAMPLE"  \
--function-response-types "ReportBatchItemFailures"
3. Update your function code to catch all exceptions and return failed messages in a
batchItemFailures  JSON response. The batchItemFailures  response must include a list of 
message IDs, as itemIdentifier  JSON values.
881AWS Lambda Developer Guide
Implementing partial batch responses
For example, suppose you have a batch of ﬁve messages, with message IDs id1, id2, id3, id4, and
id5. Your function successfully processes id1, id3, and id5. To make messages id2 and id4 visible 
again in your queue, your function should return the following response:
{  
  "batchItemFailures": [  
        { 
            "itemIdentifier": "id2" 
        }, 
        { 
            "itemIdentifier": "id4" 
        } 
    ]
}
Here's an example of function code that returns the list of failed message IDs in the batch:
Python
Example – Python function code for batchItemFailures
import json
def lambda_handler(event, context): 
    if event: 
        batch_item_failures = [] 
        sqs_batch_response = {} 
      
        for record in event["Records"]: 
            try: 
                # process message 
            except Exception as e: 
                batch_item_failures.append({"itemIdentifier": record['messageId']}) 
         
        sqs_batch_response["batchItemFailures"] = batch_item_failures 
        return sqs_batch_response
Java
Example – Java function code for batchItemFailures
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.SQSEvent;
import com.amazonaws.services.lambda.runtime.events.SQSBatchResponse; 
  
import java.util.ArrayList;
import java.util.List; 
  
public class ProcessSQSMessageBatch implements RequestHandler<SQSEvent, 
 SQSBatchResponse> { 
    @Override 
    public SQSBatchResponse handleRequest(SQSEvent sqsEvent, Context context) { 
  
         List<SQSBatchResponse.BatchItemFailure> batchItemFailures = new 
 ArrayList<SQSBatchResponse.BatchItemFailure>(); 
         String messageId = ""; 
         for (SQSEvent.SQSMessage message : sqsEvent.getRecords()) { 
             try { 
                 //process your message 
                 messageId = message.getMessageId(); 
882AWS Lambda Developer Guide
Amazon SQS conﬁguration parameters
             } catch (Exception e) { 
                 //Add failed message identifier to the batchItemFailures list 
                 batchItemFailures.add(new 
 SQSBatchResponse.BatchItemFailure(messageId)); 
             } 
         } 
         return new SQSBatchResponse(batchItemFailures); 
     }
}
If the failed events do not return to the queue, see How do I troubleshoot Lambda function SQS 
ReportBatchItemFailures? in the AWS Knowledge Center.
Success and failure conditions
Lambda treats a batch as a complete success if your function returns any of the following:
•An empty batchItemFailures  list
•A null batchItemFailures  list
•An empty EventResponse
•A null EventResponse
Lambda treats a batch as a complete failure if your function returns any of the following:
•An invalid JSON response
•An empty string itemIdentifier
•A null itemIdentifier
•An itemIdentifier  with a bad key name
•An itemIdentifier  value with a message ID that doesn't exist
CloudWatch metrics
To determine whether your function is correctly reporting batch item failures, you can monitor the
NumberOfMessagesDeleted  and ApproximateAgeOfOldestMessage  Amazon SQS metrics in 
Amazon CloudWatch.
•NumberOfMessagesDeleted  tracks the number of messages removed from your queue. If this drops 
to 0, this is a sign that your function response is not correctly returning failed messages.
•ApproximateAgeOfOldestMessage  tracks how long the oldest message has stayed in your queue. A 
sharp increase in this metric can indicate that your function is not correctly returning failed messages.
Amazon SQS conﬁguration parameters
All Lambda event source types share the same CreateEventSourceMapping (p. 1292 ) and
UpdateEventSourceMapping (p. 1495 ) API operations. However, only some of the parameters apply to 
Amazon SQS.
Event source parameters that apply to Amazon SQS
Parameter Required Default Notes
BatchSize N 10 For standard queues, 
the maximum is 10,000. 
883AWS Lambda Developer Guide
Tutorial
ParameterRequired Default Notes
For FIFO queues, the 
maximum is 10.
Enabled N true
EventSourceArn Y   The ARN of the data 
stream or a stream 
consumer
FunctionName Y
FilterCriteria N Lambda event 
ﬁltering  (p. 155)
FunctionResponseTypesN To let your function 
report speciﬁc 
failures in a batch, 
include the value
ReportBatchItemFailures
in
FunctionResponseTypes . 
For more information, 
see Implementing 
partial batch 
responses (p. 881).
MaximumBatchingWindowInSeconds N 0
ScalingConﬁg N Conﬁguring maximum 
concurrency for 
Amazon SQS event 
sources (p. 879)
Tutorial: Using Lambda with Amazon SQS
In this tutorial, you create a Lambda function that consumes messages from an Amazon Simple Queue 
Service (Amazon SQS) queue. The Lambda function runs whenever a new message is added to the queue. 
The function writes the messages to an Amazon CloudWatch Logs stream. The following diagram shows 
the AWS resources you use to complete the tutorial.
884AWS Lambda Developer Guide
Tutorial
To complete this tutorial, you carry out the following steps:
1.Create a Lambda function that writes messages to CloudWatch Logs.
2.Create an Amazon SQS queue.
3.Create a Lambda event source mapping. The event source mapping reads the Amazon SQS queue and 
invokes your Lambda function when a new message is added.
4.Test the setup by adding messages to your queue and monitoring the results in CloudWatch Logs.
Prerequisites
Sign up for an AWS account
If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS account
1. Open https://portal.aws.amazon.com/billing/signup.
2. Follow the online instructions.
Part of the sign-up procedure involves receiving a phone call and entering a veriﬁcation code on the 
phone keypad.
When you sign up for an AWS account, an AWS account root user is created. The root user has access 
to all AWS services and resources in the account. As a security best practice, assign administrative 
access to an administrative user, and use only the root user to perform tasks that require root user 
access.
AWS sends you a conﬁrmation email after the sign-up process is complete. At any time, you can view 
your current account activity and manage your account by going to https://aws.amazon.com/ and 
choosing My Account.
885AWS Lambda Developer Guide
Tutorial
Create an administrative user
After you sign up for an AWS account, create an administrative user so that you don't use the root user 
for everyday tasks.
Secure your AWS account root user
1. Sign in to the AWS Management Console as the account owner by choosing Root user and entering 
your AWS account email address. On the next page, enter your password.
For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.
2. Turn on multi-factor authentication (MFA) for your root user.
For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM 
User Guide .
Create an administrative user
• For your daily administrative tasks, grant administrative access to an administrative user in AWS IAM 
Identity Center (successor to AWS Single Sign-On).
For instructions, see Getting started in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
Sign in as the administrative user
• To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email 
address when you created the IAM Identity Center user.
For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the
AWS Sign-In User Guide.
Install the AWS Command Line Interface
If you have not yet installed the AWS Command Line Interface, follow the steps at Installing or updating 
the latest version of the AWS CLI to install it.
The tutorial requires a command line terminal or shell to run commands. In Linux and macOS, use your 
preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) are 
not supported by the operating system's built-in terminals. To get a Windows-integrated version 
of Ubuntu and Bash, install the Windows Subsystem for Linux.
886AWS Lambda Developer Guide
Tutorial
Create the execution role
An execution role (p. 913) is an AWS Identity and Access Management (IAM) role that grants a Lambda 
function permission to access AWS services and resources. To allow your function to read items from 
Amazon SQS, attach the AWSLambdaSQSQueueExecutionRole permissions policy.
To create an execution role and attach an Amazon SQS permissions policy
1. Open the Roles page of the IAM console.
2. Choose Create role.
3. For Trusted entity type, choose AWS service.
4. For Use case , choose Lambda .
5. Choose Next.
6. In the Permissions policies search box, enter AWSLambdaSQSQueueExecutionRole .
7. Select the AWSLambdaSQSQueueExecutionRole policy, and then choose Next.
8. Under Role details, for Role name, enter lambda-sqs-role , then choose Create role.
Create the function
Create a Lambda function that processes your Amazon SQS messages. The following sample code for 
Node.js writes each message to CloudWatch Logs.
Note
For code examples in other languages, see Sample Amazon SQS function code (p. 896).
To create a Node.js Lambda function
1. Create a directory for the project, and then switch to that directory.
887AWS Lambda Developer Guide
Tutorial
mkdir sqs-tutorial
cd sqs-tutorial
2. Save the following sample code as a ﬁle named index.mjs .
Example index.mjs
export const handler = async function(event, context) { 
  event.Records.forEach(record => { 
    const { body } = record; 
    console.log(body); 
  }); 
  return {};
}
3. Create a deployment package using the following zip command.
zip function.zip index.mjs
4. Create a Lambda function using the create-function AWS CLI command. For the role parameter, 
enter the Amazon Resource Name (ARN) of the execution role that you created earlier.
aws lambda create-function --function-name ProcessSQSRecord \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: 111122223333 :role/lambda-sqs-role
Test the function
Invoke your Lambda function manually using the invoke AWS CLI command and a sample Amazon SQS 
event.
To invoke the Lambda function with a sample event
1. Save the following JSON as a ﬁle named input.json . This JSON simulates an event that Amazon 
SQS might send to your Lambda function, where "body" contains the actual message from the 
queue. In this example, the message is "test" .
Example Amazon SQS event
This is a test event—you don't need to change the message or the account number.
{ 
888AWS Lambda Developer Guide
Tutorial
    "Records": [ 
        { 
            "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
            "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
            "body": "test", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1545082649183", 
                "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
                "ApproximateFirstReceiveTimestamp": "1545082649185" 
            }, 
            "messageAttributes": {}, 
            "md5OfBody": "098f6bcd4621d373cade4e832627b4f6", 
            "eventSource": "aws:sqs", 
            "eventSourceARN": "arn:aws:sqs:us-east-1:111122223333:my-queue", 
            "awsRegion": "us-east-1" 
        } 
    ]
}
2. Run the following invoke AWS CLI command. This command returns CloudWatch logs in the 
response. For more information about retrieving logs, see Accessing logs with the AWS CLI (p. 970).
aws lambda invoke --function-name ProcessSQSRecord --payload file://input.json out --
log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --
decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
3. Find the INFO log in the response. This is where the Lambda function logs the message body. You 
should see test  in this log (the body of the test message). Example:
START RequestId: afd3gmke5-6732-4e74-b1fd-391754st2a53 Version: $LATEST
2023-06-22T11:02:42.242Z  afd3gmke5-6732-4e74-b1fd-391754st2a53 INFO  test
END RequestId: afd3gmke5-6732-4e74-b1fd-391754st2a53
REPORT RequestId: afd3gmke5-6732-4e74-b1fd-391754st2a53 Duration: 143.05 ms Billed 
 Duration: 144 ms Memory Size: 128 MB     Max Memory Used: 68 MB
Create an Amazon SQS queue
Create an Amazon SQS queue that the Lambda function can use as an event source.
889AWS Lambda Developer Guide
Tutorial
To create a queue
1. Open the Amazon SQS console.
2. Choose Create queue .
3. Enter a name for the queue. Leave all other options at the default settings.
4. Choose Create queue .
5. After creating the queue, record its Amazon Resource Name (ARN). You need this in the next step 
when you associate the queue with your Lambda function.
Conﬁgure the event source
Connect the Amazon SQS queue to your Lambda function by creating an event source mapping (p. 150). 
The event source mapping reads the Amazon SQS queue and invokes your Lambda function when a new 
message is added.
To create a mapping between your Amazon SQS queue and your Lambda function, use the create-event-
source-mapping AWS CLI command. Example:
aws lambda create-event-source-mapping --function-name ProcessSQSRecord  --batch-size 10 \
--event-source-arn arn:aws:sqs: us-east-1:111122223333:my-queue
To get a list of your event source mappings, use the list-event-source-mappings command. Example:
aws lambda list-event-source-mappings --function-name ProcessSQSRecord
Send a test message
890AWS Lambda Developer Guide
Tutorial
To send an Amazon SQS message to the Lambda function
1. Open the Amazon SQS console.
2. Choose the queue that you created earlier.
3. Choose Send and receive messages.
4. Under Message body , enter a test message, such as "this is a test message."
5. Choose Send message .
Lambda polls the queue for updates. When there is a new message, Lambda invokes your function 
with this new event data from the queue. If the function handler returns without exceptions, Lambda 
considers the message successfully processed and begins reading new messages in the queue. After 
successfully processing a message, Lambda automatically deletes it from the queue. If the handler 
throws an exception, Lambda considers the batch of messages not successfully processed, and Lambda 
invokes the function with the same batch of messages.
Check the CloudWatch logs
To conﬁrm that the function processed the message
1. Open the Functions page of the Lambda console.
2. Choose the ProcessSQSRecord function.
3. Choose Monitor .
4. Choose View logs in CloudWatch.
5. In the CloudWatch console, choose the Log stream  for the function.
6. Find the INFO log. This is where the Lambda function logs the message body. You should see the 
message that you sent from the Amazon SQS queue. Example:
2023-06-22T13:05:03.623Z afd3gmke5-6732.. INFO this is a test message
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
891AWS Lambda Developer Guide
SQS cross-account tutorial
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
To delete the Amazon SQS queue
1. Sign in to the AWS Management Console and open the Amazon SQS console at https:// 
console.aws.amazon.com/sqs/.
2. Select the queue you created.
3. Choose Delete.
4. Enter confirm in the text input ﬁeld.
5. Choose Delete.
Tutorial: Using a cross-account Amazon SQS queue as 
an event source
In this tutorial, you create a Lambda function that consumes messages from an Amazon Simple Queue 
Service (Amazon SQS) queue in a diﬀerent AWS account. This tutorial involves two AWS accounts:
Account A refers to the account that contains your Lambda function, and Account B refers to the 
account that contains the Amazon SQS queue.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
892AWS Lambda Developer Guide
SQS cross-account tutorial
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role (Account A)
In Account A, create an execution role (p. 913) that gives your function permission to access the 
required AWS resources.
To create an execution role
1. Open the Roles page in the AWS Identity and Access Management (IAM) console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – AWS Lambda
•Permissions – AWSLambdaSQSQueueExecutionRole
•Role name – cross-account-lambda-sqs-role
The AWSLambdaSQSQueueExecutionRole policy has the permissions that the function needs to read 
items from Amazon SQS and to write logs to Amazon CloudWatch Logs.
Create the function (Account A)
In Account A, create a Lambda function that processes your Amazon SQS messages. The following 
Node.js 18 code example writes each message to a log in CloudWatch Logs.
Note
For code examples in other languages, see Sample Amazon SQS function code (p. 896).
Example index.mjs
export const handler = async function(event, context) { 
  event.Records.forEach(record => { 
    const { body } = record; 
    console.log(body); 
  }); 
  return {};
}
To create the function
Note
Following these steps creates a function in Node.js 18. For other languages, the steps are similar, 
but some details are diﬀerent.
1. Save the code example as a ﬁle named index.mjs .
2. Create a deployment package.
zip function.zip index.mjs
3. Create the function using the create-function  AWS Command Line Interface (AWS CLI) 
command.
aws lambda create-function --function-name CrossAccountSQSExample \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs18.x \
--role arn:aws:iam:: <AccountA_ID> :role/cross-account-lambda-sqs-role
893AWS Lambda Developer Guide
SQS cross-account tutorial
Test the function (Account A)
In Account A, test your Lambda function manually using the invoke AWS CLI command and a sample 
Amazon SQS event.
If the handler returns normally without exceptions, Lambda considers the message to be successfully 
processed and begins reading new messages in the queue. After successfully processing a message, 
Lambda automatically deletes it from the queue. If the handler throws an exception, Lambda considers 
the batch of messages not successfully processed, and Lambda invokes the function with the same batch 
of messages.
1. Save the following JSON as a ﬁle named input.txt .
{ 
    "Records": [ 
        { 
            "messageId": "059f36b4-87a3-44ab-83d2-661975830a7d", 
            "receiptHandle": "AQEBwJnKyrHigUMZj6rYigCgxlaS3SLy0a...", 
            "body": "test", 
            "attributes": { 
                "ApproximateReceiveCount": "1", 
                "SentTimestamp": "1545082649183", 
                "SenderId": "AIDAIENQZJOLO23YVJ4VO", 
                "ApproximateFirstReceiveTimestamp": "1545082649185" 
            }, 
            "messageAttributes": {}, 
            "md5OfBody": "098f6bcd4621d373cade4e832627b4f6", 
            "eventSource": "aws:sqs", 
            "eventSourceARN": "arn:aws:sqs:us-east-1:111122223333:example-queue", 
            "awsRegion": "us-east-1" 
        } 
    ]
}
The preceding JSON simulates an event that Amazon SQS might send to your Lambda function, 
where "body" contains the actual message from the queue.
2. Run the following invoke AWS CLI command.
aws lambda invoke --function-name CrossAccountSQSExample \
--cli-binary-format raw-in-base64-out \
--payload file://input.txt outputfile.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
3. Verify the output in the ﬁle outputfile.txt .
Create an Amazon SQS queue (Account B)
In Account B, create an Amazon SQS queue that the Lambda function in Account A can use as an event 
source.
To create a queue
1. Open the Amazon SQS console.
2. Choose Create queue .
3. Create a queue with the following properties.
894AWS Lambda Developer Guide
SQS cross-account tutorial
•Type – Standard
•Name  – LambdaCrossAccountQueue
•Conﬁguration  – Keep the default settings.
•Access policy – Choose Advanced. Paste in the following JSON policy:
{ 
   "Version": "2012-10-17", 
   "Id": "Queue1_Policy_UUID", 
   "Statement": [{ 
      "Sid":"Queue1_AllActions", 
      "Effect": "Allow", 
      "Principal": { 
         "AWS": [ 
            "arn:aws:iam:: <AccountA_ID> :role/cross-account-lambda-sqs-role" 
         ] 
      }, 
      "Action": "sqs:*", 
      "Resource": "arn:aws:sqs:us-east-1: <AccountB_ID> :LambdaCrossAccountQueue" 
    } 
  ]
}
This policy grants the Lambda execution role in Account A permissions to consume messages from 
this Amazon SQS queue.
4. After creating the queue, record its Amazon Resource Name (ARN). You need this in the next step 
when you associate the queue with your Lambda function.
Conﬁgure the event source (Account A)
In Account A, create an event source mapping between the Amazon SQS queue in Account Band your 
Lambda function by running the following create-event-source-mapping  AWS CLI command.
aws lambda create-event-source-mapping --function-name CrossAccountSQSExample --batch-size 
 10 \
--event-source-arn arn:aws:sqs:us-east-1: <AccountB_ID> :LambdaCrossAccountQueue
To get a list of your event source mappings, run the following command.
aws lambda list-event-source-mappings --function-name CrossAccountSQSExample \
--event-source-arn arn:aws:sqs:us-east-1: <AccountB_ID> :LambdaCrossAccountQueue
Test the setup
You can now test the setup as follows:
1.In Account B, open the Amazon SQS console.
2.Choose LambdaCrossAccountQueue, which you created earlier.
3.Choose Send and receive messages.
4.Under Message body , enter a test message.
5.Choose Send message .
Your Lambda function in Account A should receive the message. Lambda will continue to poll the queue 
for updates. When there is a new message, Lambda invokes your function with this new event data from 
895AWS Lambda Developer Guide
Sample code
the queue. Your function runs and creates logs in Amazon CloudWatch. You can view the logs in the
CloudWatch console.
Clean up your resources
You can now delete the resources that you created for this tutorial, unless you want to retain them. 
By deleting AWS resources that you're no longer using, you prevent unnecessary charges to your AWS 
account.
In Account A, clean up your execution role and Lambda function.
To delete the execution role
1. Open the Roles page of the IAM console.
2. Select the execution role that you created.
3. Choose Delete.
4. Enter the name of the role in the text input ﬁeld and choose Delete.
To delete the Lambda function
1. Open the Functions page of the Lambda console.
2. Select the function that you created.
3. Choose Actions, Delete.
4. Type delete in the text input ﬁeld and choose Delete.
In Account B, clean up the Amazon SQS queue.
To delete the Amazon SQS queue
1. Sign in to the AWS Management Console and open the Amazon SQS console at https:// 
console.aws.amazon.com/sqs/.
2. Select the queue you created.
3. Choose Delete.
4. Enter confirm in the text input ﬁeld.
5. Choose Delete.
Sample Amazon SQS function code
Sample code is available for the following languages.
Topics
•Node.js  (p. 896)
•Java (p. 897)
•C# (p. 897)
•Go (p. 898)
•Python (p. 899)
Node.js
The following is example code that receives an Amazon SQS event message as input and processes it. For 
illustration, the code writes some of the incoming event data to CloudWatch Logs.
896AWS Lambda Developer Guide
Sample code
Example index.js (Node.js 12)
exports.handler = async function(event, context) { 
  event.Records.forEach(record => { 
    const { body } = record; 
    console.log(body); 
  }); 
  return {};
}
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
Java
The following is example Java code that receives an Amazon SQS event message as input and processes 
it. For illustration, the code writes some of the incoming event data to CloudWatch Logs.
In the code, handleRequest  is the handler. The handler uses the predeﬁned SQSEvent  class that is 
deﬁned in the aws-lambda-java-events  library.
Example Handler.java
package example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.SQSEvent;
import com.amazonaws.services.lambda.runtime.events.SQSEvent.SQSMessage;
public class Handler implements RequestHandler<SQSEvent, Void>{ 
    @Override 
    public Void handleRequest(SQSEvent event, Context context) 
    { 
        for(SQSMessage msg : event.getRecords()){ 
            System.out.println(new String(msg.getBody())); 
        } 
        return null; 
    }
}
Dependencies
•aws-lambda-java-core
•aws-lambda-java-events
Build the code with the Lambda library dependencies to create a deployment package. For instructions, 
see Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446).
C#
The following is example C# code that receives an Amazon SQS event message as input and processes it. 
For illustration, the code writes some of the incoming event data to the console.
In the code, handleRequest  is the handler. The handler uses the predeﬁned SQSEvent  class that is 
deﬁned in the AWS.Lambda.SQSEvents  library.
897AWS Lambda Developer Guide
Sample code
Example ProcessingSQSRecords.cs
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.Json.JsonSerializer))]
namespace SQSLambdaFunction
{ 
    public class SQSLambdaFunction 
    { 
        public string HandleSQSEvent(SQSEvent sqsEvent, ILambdaContext context) 
        { 
            Console.WriteLine($"Beginning to process {sqsEvent.Records.Count} records..."); 
            foreach (var record in sqsEvent.Records) 
            { 
                Console.WriteLine($"Message ID: {record.MessageId}"); 
                Console.WriteLine($"Event Source: {record.EventSource}"); 
                Console.WriteLine($"Record Body:"); 
                Console.WriteLine(record.Body); 
            } 
            Console.WriteLine("Processing complete."); 
            return $"Processed {sqsEvent.Records.Count} records."; 
        } 
    }
}
Replace the Program.cs  in a .NET Core project with the above sample. For instructions, see Deploy C# 
Lambda functions with .zip ﬁle archives (p. 566).
Go
The following is example Go code that receives an Amazon SQS event message as input and processes it. 
For illustration, the code writes some of the incoming event data to CloudWatch Logs.
In the code, handler is the handler. The handler uses the predeﬁned SQSEvent  class that is deﬁned in 
the aws-lambda-go-events  library.
Example ProcessSQSRecords.go
package main
import ( 
    "context" 
    "fmt" 
    "github.com/aws/aws-lambda-go/events" 
    "github.com/aws/aws-lambda-go/lambda"
)
func handler(ctx context.Context, sqsEvent events.SQSEvent) error { 
    for _, message := range sqsEvent.Records { 
        fmt.Printf("The message %s for event source %s = %s \n", message.MessageId, 
 message.EventSource, message.Body) 
    } 
    return nil
}
func main() { 
    lambda.Start(handler)
898AWS Lambda Developer Guide
Sample template
}
Build the executable with go build  and create a deployment package. For instructions, see Deploy Go 
Lambda functions with .zip ﬁle archives (p. 520).
Python
The following is example Python code that accepts an Amazon SQS record as input and processes it. For 
illustration, the code writes to some of the incoming event data to CloudWatch Logs.
Example ProcessSQSRecords.py
from __future__ import print_function
def lambda_handler(event, context): 
    for record in event['Records']: 
        print("test") 
        payload = record["body"] 
        print(str(payload))
Zip up the sample code to create a deployment package. For instructions, see Working with .zip ﬁle 
archives for Python Lambda functions (p. 352).
AWS SAM template for an Amazon SQS application
You can build this application using AWS SAM. To learn more about creating AWS SAM templates, see
AWS SAM template basics in the AWS Serverless Application Model Developer Guide.
Below is a sample AWS SAM template for the Lambda application from the tutorial  (p. 884). Copy 
the text below to a .yaml ﬁle and save it next to the ZIP package you created previously. Note that 
the Handler  and Runtime parameter values should match the ones you used when you created the 
function in the previous section.
Example template.yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Example of processing messages on an SQS queue with Lambda
Resources: 
  MySQSQueueFunction: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler
      Runtime: nodejs18.x
      Events: 
        MySQSEvent: 
          Type: SQS 
          Properties: 
            Queue: !GetAtt MySqsQueue.Arn 
            BatchSize: 10 
  MySqsQueue: 
    Type: AWS::SQS::Queue
For information on how to package and deploy your serverless application using the package and deploy 
commands, see Deploying serverless applications in the AWS Serverless Application Model Developer 
Guide .
899AWS Lambda Developer Guide
VPC Lattice
Using AWS Lambda with Amazon VPC Lattice
You can register your Lambda functions as targets within an Amazon VPC Lattice service network. By 
doing this, your Lambda function becomes a service within the network, and clients that have access 
to the VPC Lattice service network can call your service. If your Lambda function needs to access 
services within a service network, you can connect your function to a VPC that's already associated with 
the service network. Having your services live within a VPC Lattice network can help you more easily 
discover, connect, access, and monitor them.
Topics
•VPC Lattice concepts (p. 900)
•Prerequisites and permissions (p. 901)
•Limitations  (p. 902)
•Registering your Lambda function with a VPC Lattice network (p. 902)
•Updating the target of a service in a VPC Lattice network (p. 904)
•Deregistering a Lambda function target (p. 905)
•Cross-account networking (p. 905)
•Receiving events from VPC Lattice (p. 906)
•Sending responses back to VPC Lattice (p. 906)
•Monitoring a service in a VPC Lattice network (p. 907)
VPC Lattice concepts
Throughout this guide, we'll frequently refer to the following VPC Lattice terms:
•Service – A service is any software application that can run on an instance, container, or within a 
serverless function. This topic focuses only on services built using Lambda functions.
•Service network – A service network is a logical boundary containing a network of services. This topic 
covers how to conﬁgure your Lambda functions as services within a VPC Lattice service network.
•Target group – A target group is a collection of compute type destinations that run a service. Target 
groups for Lambda can contain only one Lambda function as the target. You cannot have a target 
group with multiple functions as targets.
•Listener  – A listener is a process that receives traﬃc and routes it to diﬀerent target groups within the 
service network.
•Listener rule – A listener rule encompasses the priority, actions, and conditions that a listener uses 
to determine where to route traﬃc. Each listener has a default listener rule, and a listener can have 
multiple listener rules. A listener rule can contain the following:
•Protocol – The protocol that the listener uses to send the request to the destination. Can be either 
HTTP or HTTPS.
•Port – The port that the listener polls for incoming requests. Can be between 1 and 65535 inclusive.
•Path – The path to the target resource. For the default listener rule, path is the default path of /. A 
listener rule can have 6 paths at maximum, including the default path.
•Priority – A listener uses the priority of a path to determine which path to route traﬃc to. A lower 
number denotes higher priority. The default path has the lowest priority. If you add a new path, VPC 
Lattice assigns it at the second lowest priority by default. This is just above the priority of the default 
path, but at a lower priority than all other non-default paths.
In addition, we'll refer to the following AWS Identity and Access Management (IAM) entities:
•Network owner – The network owner is the IAM role that owns the VPC Lattice service network.
900AWS Lambda Developer Guide
Prerequisites and permissions
•Service owner – The service owner is the IAM role that owns the service built using a Lambda function. 
The service owner and the network owner do not have to be the same entity.
Using Lambda with VPC Lattice and VPC-enabled functions
By default, Lambda functions cannot access any private resources in a VPC. When you conﬁgure a 
Lambda function to connect to private subnets in a VPC, you're allowing the VPC-enabled function to 
access resources within that VPC. In other words, you're only focusing on the scope of a single VPC.
Lambda functions registered as services in a VPC Lattice network are not the same as VPC-enabled 
functions, but they can be complementary to each other. When you register a Lambda function as a 
service in a VPC Lattice network, you're creating an ingress path to your function from one or more VPCs. 
Additionally, your function may have an optional egress path to another VPC.
When registering a Lambda function as a service, you're focusing on the ingress scenario. This 
encompasses the speciﬁc listener rule conﬁgurations that listeners use to route traﬃc to your service. 
From there, your Lambda function may communicate with other AWS services within your VPC through 
a  Hyperplane ENI (elastic network interface). The following diagram illustrates this, where the Lambda 
function is a service within the VPC Lattice network.
Prerequisites and permissions
This topic assumes that you have both a VPC Lattice service network and a Lambda function. If you don't 
already have a VPC Lattice service network, refer to the VPC Lattice user guide to create one.
When you register your Lambda function as a target via the Lambda console or AWS Command Line 
Interface (AWS CLI), Lambda automatically adds the necessary permissions for you.
For Lambda to automatically add permissions for you, so that you can successfully create a Lambda 
function as a target of a Lambda service, your role must have the following IAM permissions:
•AddPermission
•CreateListener
•CreateService
•CreateServiceNetworkServiceAssociation
•CreateTargetGroup
901AWS Lambda Developer Guide
Limitations
•ListServiceNetworks (required for console workﬂow only)
•RegisterTargets
To update an existing service in a VPC Lattice network to point to a Lambda function, your role must 
have the following IAM permissions:
•CreateService
•ListListeners  (required for console workﬂow only)
•ListServices (required for console workﬂow only)
•RegisterTargets
You can also manually add the permission using the following AWS CLI command:
aws lambda add-permission  
    --function-name my-function  \  
    --action lambda:InvokeFunction \ 
    --statement-id allow-vpc-lattice \ 
    --principal vpc-lattice.amazonaws.com 
    --source-arn target-group-arn
Limitations
When using Lambda functions with VPC Lattice networks, keep in mind the following limitations:
•The Lambda function and the target group must be in the same account and in the same Region.
•The maximum size of the request body that you can forward to a service created using a Lambda 
function is 6 MB.
•The maximum size of the response JSON that the Lambda function can return is 6 MB.
•You an choose HTTP and HTTPS protocols only.
Registering your Lambda function with a VPC Lattice 
network
You can register any existing Lambda function with a VPC Lattice network using the AWS console or AWS 
CLI. After registering the function as a service, it can immediately start receiving requests.
To register a Lambda function with a VPC Lattice network (console)
1. Open the Function page of the Lambda console.
2. Choose the name of the function you want to register.
3. Under Function overview, choose Add trigger .
4. In the dropdown menu, select VPC Lattice Application Network.
5. For Intent , choose Create new .
6. For Service name, enter a name for your service.
7. For VPC Lattice network, select the service network that you want to associate this Lambda 
function with. You can also enter the full Amazon Resource Name (ARN) of the service network. If 
you don't have an existing service network, you can choose the link in the description, which takes 
you to the Amazon VPC console where you can create a VPC Lattice network.
902AWS Lambda Developer Guide
Registering your Lambda function 
with a VPC Lattice network
Note
You don't need to select a VPC Lattice network to ﬁnish setting up the trigger. However, if 
you create the trigger without selecting a network, clients cannot access your service until 
you associate it with a VPC Lattice network.
8. For Listener , conﬁgure the following settings:
•Listener name  – Enter a name for your listener
•Protocol – The protocol that the listener uses to send the request to the destination. Can be either 
HTTP or HTTPS.
•Port – The port that the listener polls for incoming requests. Can be between 1 and 65535 
inclusive.
•Choose Add Listener . VPC Lattice will create a default routing with the default path /. After 
service creation, you cannot change its name, protocol, and port settings, but you can still deﬁne 
new routing paths.
9. Choose Add.
To register a Lambda function with a VPC Lattice network (AWS CLI)
1. Create a service using the create-service  command. Note down the service's ARN in the 
response. You'll need it in the next steps.
aws vpc-lattice create-service --name my-vpc-lattice-service
2. Create a target group using the create-target-group  command. Note down the target group's 
ARN in the response. You'll need it in the next steps.
aws vpc-lattice create-target-group \ 
    --name my-vpc-lattice-target-group \ 
    --type LAMBDA
3. Create a listener within the service network using the create-listener  command. New listeners 
automatically use the default path of /. Replace the value of the service parameter with your 
service's ARN from step 1. Replace the value of TargetGroupArn  in the default-action
parameter with your target group ARN from step 2.
aws vpc-lattice create-listener \ 
    --name https 
    --service-identifier svc-0e2f2665e1cebb720 \ 
    --protocol HTTPS \ 
    --default-action 
 forward='{targetGroups={targetGroupIdentifier=tg-0e2f2665e1cebb720}}'
4. Register your Lambda function as a target using the register-targets  command. Replace the 
value of the target-group-arn  parameter with your target group ARN from step 2. Replace the 
value of Id in the targets parameter with the ARN of your Lambda function.
aws vpc-lattice register-targets \ 
    --target-group-identifier arn:aws:vpc-lattice:us-west-2:123456789012:targetgroup/
tg-0e2f2665e1cebb720 \ 
    --targets id=arn:aws:lambda:us-west-2:123456789012:function:my-function
Note
In the previous register-targets  command, if your Lambda function doesn't already 
explicitly allow VPC Lattice to invoke it, VPC Lattice attaches the necessary permissions to 
903AWS Lambda Developer Guide
Updating the target of a service in a VPC Lattice network
your function's execution role automatically. To allow VPC Lattice to automatically attach 
permissions, your role needs to have the AddPermission permission.
5. Associate the service with the service network using the create-service-network-service-
association  command. Replace the value of the service parameter with your service ARN from 
step 1. Replace the value of the service-network  parameter with the ARN of your VPC Lattice 
service network.
aws vpc-lattice create-service-network-service-association \ 
    --service-identifier arn:aws:vpc-lattice:us-west-2:123456789012:service/
svc-0b9b89d907bc8668c \ 
    --service-network-identifier arn:aws:vpc-lattice:us-
west-2:123456789012:servicenetwork/03d622a31e5154247
Updating the target of a service in a VPC Lattice 
network
You can update any existing service within a VPC Lattice network to point to a Lambda function target. 
You can do this by adding a new routing path using the AWS console or AWS CLI. When you add a 
new path, VPC Lattice assigns that path the second lowest priority, just above the default path (lowest 
priority).
To update the target of a service to point to a Lambda function (console)
1. Open the Function page of the Lambda console.
2. Choose the name of the function you want to register.
3. Under Function overview, choose Add trigger .
4. In the dropdown menu, select VPC Lattice Application Network.
5. For Intent , choose Select existing.
6. For Service name, choose an existing service.
7. For Listener , choose an existing listener.
8. For Rule name, enter a name for the new rule.
9. For Path, deﬁne a new routing path for the listener.
10. Choose Add.
For the following steps, you'll need the ARN of your service, as well as the ARN of the listener that you 
want to add a new rule for.
1. Create a new target group using the create-target-group  command. Note down the target 
group's ARN in the response, as you'll need it for future steps.
aws vpc-lattice create-target-group \ 
    --name my-vpc-lattice-target-group \ 
    --type LAMBDA
2. Create a new rule for your existing listener using the create-rule  command. This command 
assumes that your conditions are in a ﬁle called conditions-pattern.json  in your current 
directory. Replace the value of the listener-arn  parameter with the ARN of your listener. Replace 
the value of TargetGroupArn  in the actions parameter with your target group ARN from step 1.
aws vpc-lattice create-rule \ 
    --name my-rule 
    --priority 1 \ 
904AWS Lambda Developer Guide
Deregistering a Lambda function target
    --listener-identifier listener-0e9af499f72e5251b \ 
    --service-identifier svc-01755f67d3a427803 
    --match httpMatch='{pathMatch={match={prefix="/test"}}}'  
    --default action 
 forward='{targetGroups=[{targetGroupIdentifier=tg-042d5b70f1e743940}]}'
3. Register your Lambda function as a target using the register-targets  command. Replace the 
value of the target-group-arn  parameter with your target group ARN from step 2. Replace the 
value of Id in the targets parameter with the ARN of your Lambda function.
aws vpc-lattice register-targets \ 
    --target-group-identifier arn:aws:vpc-lattice:us-west-2:123456789012:targetgroup/
tg-0e2f2665e1cebb720 \ 
    --targets id=arn:aws:lambda:us-west-2:123456789012:function:my-new-function
Deregistering a Lambda function target
To deregister a Lambda function target in a VPC Lattice network, use the VPC console. For more 
information, see the VPC Lattice user guide.
Alternatively, you can use the following AWS CLI command:
aws vpc-lattice deregister-targets \ 
      --target-group-identifier arn:aws:vpc-lattice:us-west-2:123456789012:targetgroup/
tg-0e2f2665e1cebb720 \ 
      --targets id=arn:aws:lambda:us-west-2:123456789012:function:my-new-function
You cannot deregister a service built using Lambda functions from the Lambda console.
Cross-account networking
Services within your VPC Lattice service network don't have to all be in the same AWS account. In 
addition, the VPC Lattice service network itself can reside in a diﬀerent account. This means that you 
can associate a service built using Lambda functions with a service network in a diﬀerent AWS account. 
You'll need speciﬁc permissions from the network owner to create these service associations. For more 
information about permissions required, see  Prepare to call the VPC Lattice API in the Amazon VPC 
Lattice user guide.
You can create an association between a Lambda function with a service network in a diﬀerent account 
through the AWS console. To do this, instead of choosing the VPC Lattice network from the dropdown 
menu (this only displays networks in your account), paste the full ARN of the network.
In general, you can create an association between any service and any service network with the create-
service-network-service-association  AWS CLI command. This means you can manage your 
service networks in a central account and have services built using Lambda functions in other accounts 
across your AWS organization. In the following example, note that the service  and service-network
live in two diﬀerent accounts:
aws vpc-lattice create-service-network-service-association \ 
    --service arn:aws:vpc-lattice:us-west-2:123456789012:service/svc-0b9b89d907bc8668c \ 
    --service-network arn:aws:vpc-lattice:us-
west-2:444455556666:servicenetwork/03d622a31e5154247
905AWS Lambda Developer Guide
Receiving events from VPC Lattice
Receiving events from VPC Lattice
The VPC Lattice service routes Lambda invocation requests over HTTP and HTTPS. The following is an 
example event that your Lambda function might receive from VPC Lattice, in JSON format:
{ 
    "body": "request_body", 
    "headers": { 
        "accept": "*/*", 
        "content-length": "9", 
        "user-agent": "FooClient/1.0", 
        "host": "foo.example.org", 
        "x-foo": "bar,baz", 
        "x-forwarded-for": "192.0.2.1" 
    }, 
    "is_base64_encoded": false, 
    "method": "POST", 
    "query_string_parameters": { 
        "foo": "bar" 
    }, 
    "raw_path": "/foo/bar/baz?foo=bar&foo=baz"
}
If the content-encoding  header is not present, Base64 encoding depends on the content type. For the 
content types, text/* , application/json , application/xml , and application/javascript , 
the service sends the body as is and sets isBase64Encoded  to false .
Note
The request body can have a maximum size of 1023 KiB if sent in plaintext, or 767 KiB if base64 
encoded. The list of request headers can have a maximum of 50 key-value pairs.
Sending responses back to VPC Lattice
When you send a response from your Lambda function back to VPC Lattice, the response must include 
the Base64 encoding status, status code, and relevant headers. The body is optional. The following is an 
example response in JSON format:
{ 
    "isBase64Encoded": false, 
    "statusCode": 200, 
    "statusDescription": "200 OK", 
    "headers": { 
        "Set-Cookie": "cookies", 
        "Content-Type": "application/json" 
    }, 
    "body": "Hello from Lambda (optional)"
}
To include binary content in the response body, you must Base64 encode the content and set
isBase64Encoded  to true. This tells VPC Lattice to decode the content before sending the response to 
the client.
VPC Lattice doesn't honor hop-by-hop headers such as Connection  or Transfer-Encoding . Also, you 
can omit the Content-Length  header because VPC Lattice automatically computes it before sending 
responses to clients.
Note
The response body can have a maximum size of 1023 KiB if sent in plaintext, or 767 KiB if 
base64 encoded. The list of response headers can have a maximum of 50 key-value pairs.
906AWS Lambda Developer Guide
Monitoring a service in a VPC Lattice network
Monitoring a service in a VPC Lattice network
To monitor services built using Lambda functions in a VPC Lattice network, VPC Lattice provides 
Amazon CloudWatch metrics, AWS CloudTrail logs, and access logs. These tools can help you track key 
performance metrics such as the total number of requests to your service and the number of connection 
timeouts.
By default, Lambda automatically emits metrics to CloudWatch and event history logs to CloudTrail. 
Access logs are optional, and Lambda deactivates them by default. For more information on monitoring, 
see  Monitoring Amazon VPC Lattice in the VPC Lattice user guide.
907AWS Lambda Developer Guide
Function code
Best practices for working with AWS 
Lambda functions
The following are recommended best practices for using AWS Lambda:
Topics
•Function code (p. 908)
•Function conﬁguration (p. 909)
•Metrics and alarms  (p. 910)
•Working with streams (p. 910)
•Security best practices (p. 911)
For more information about best practices for Lambda applications, see Application design  in Serverless 
Land.
Function code
•Separate the Lambda handler from your core logic. This allows you to make a more unit-testable 
function. In Node.js this may look like:
exports.myHandler = function(event, context, callback) { 
 var foo = event.foo; 
 var bar = event.bar; 
 var result = MyLambdaFunction (foo, bar); 
 callback(null, result);
}
function MyLambdaFunction (foo, bar) { 
 // MyLambdaFunction logic here
}
•Take advantage of execution environment reuse to improve the performance of your function.
Initialize SDK clients and database connections outside of the function handler, and cache static assets 
locally in the /tmp directory. Subsequent invocations processed by the same instance of your function 
can reuse these resources. This saves cost by reducing function run time.
To avoid potential data leaks across invocations, don’t use the execution environment to store user 
data, events, or other information with security implications. If your function relies on a mutable state 
that can’t be stored in memory within the handler, consider creating a separate function or separate 
versions of a function for each user.
•Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over 
time. Attempting to reuse an idle connection when invoking a function will result in a connection error. 
To maintain your persistent connection, use the keep-alive directive associated with your runtime. For 
an example, see Reusing Connections with Keep-Alive in Node.js.
•Use environment variables (p. 77) to pass operational parameters to your function. For example, if 
you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, 
conﬁgure the bucket name as an environment variable.
908AWS Lambda Developer Guide
Function conﬁguration
•Control the dependencies in your function's deployment package.  The AWS Lambda execution 
environment contains a number of libraries such as the AWS SDK for the Node.js and Python runtimes 
(a full list can be found here: Lambda runtimes  (p. 41)). To enable the latest set of features and 
security updates, Lambda will periodically update these libraries. These updates may introduce subtle 
changes to the behavior of your Lambda function. To have full control of the dependencies your 
function uses, package all of your dependencies with your deployment package.
•Minimize your deployment package size to its runtime necessities.  This will reduce the amount of 
time that it takes for your deployment package to be downloaded and unpacked ahead of invocation. 
For functions authored in Java or .NET Core, avoid uploading the entire AWS SDK library as part of 
your deployment package. Instead, selectively depend on the modules which pick up components of 
the SDK you need (e.g. DynamoDB, Amazon S3 SDK modules and Lambda core libraries).
•Reduce the time it takes Lambda to unpack deployment packages authored in Java by putting your 
dependency .jar ﬁles in a separate /lib directory. This is faster than putting all your function’s code 
in a single jar with a large number of .class  ﬁles. See Deploy Java Lambda functions with .zip or JAR 
ﬁle archives (p. 446) for instructions.
•Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on
execution environment (p. 14) startup. For example, prefer simpler Java dependency injection (IoC) 
frameworks like Dagger  or Guice, over more complex ones like Spring Framework.
•Avoid using recursive code in your Lambda function, wherein the function automatically calls itself 
until some arbitrary criteria is met. This could lead to unintended volume of function invocations and 
escalated costs. If you do accidentally do so, set the function reserved concurrency to 0 immediately to 
throttle all invocations to the function, while you update the code.
•Do not use non-documented, non-public APIs  in your Lambda function code. For AWS Lambda 
managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal 
APIs. These internal API updates may be backwards-incompatible, leading to unintended consequences 
such as invocation failures if your function has a dependency on these non-public APIs. See the API 
reference (p. 1274 ) for a list of publicly available APIs.
•Write idempotent code. Writing idempotent code for your functions ensures that duplicate events 
are handled the same way. Your code should properly validate events and gracefully handle duplicate 
events. For more information, see How do I make my Lambda function idempotent?.
Function conﬁguration
•Performance testing your Lambda function is a crucial part in ensuring you pick the optimum 
memory size conﬁguration. Any increase in memory size triggers an equivalent increase in CPU 
available to your function. The memory usage for your function is determined per-invoke and can be 
viewed in Amazon CloudWatch. On each invoke a REPORT: entry will be made, as shown below:
REPORT RequestId: 3604209a-e9a3-11e6-939a-754dd98c7be3 Duration: 12.34 ms Billed 
 Duration: 100 ms Memory Size: 128 MB Max Memory Used: 18 MB
By analyzing the Max Memory Used:  ﬁeld, you can determine if your function needs more memory 
or if you over-provisioned your function's memory size.
To ﬁnd the right memory conﬁguration for your functions, we recommend using the open source 
AWS Lambda Power Tuning project. For more information, see AWS Lambda Power Tuning on GitHub.
To optimize function performance, we also recommend deploying libraries that can leverage Advanced 
Vector Extensions 2 (AVX2). This allows you to process demanding workloads, including machine 
learning inferencing, media processing, high performance computing (HPC), scientiﬁc simulations, and 
ﬁnancial modeling. For more information, see  Creating faster AWS Lambda functions with AVX2.
•Load test your Lambda function to determine an optimum timeout value. It is important to analyze 
how long your function runs so that you can better determine any problems with a dependency 
909AWS Lambda Developer Guide
Metrics and alarms
service that may increase the concurrency of the function beyond what you expect. This is especially 
important when your Lambda function makes network calls to resources that may not handle 
Lambda's scaling.
•Use most-restrictive permissions when setting IAM policies. Understand the resources and 
operations your Lambda function needs, and limit the execution role to these permissions. For more 
information, see Lambda resource access permissions (p. 912).
•Be familiar with Lambda quotas  (p. 1269 ). Payload size, ﬁle descriptors and /tmp space are often 
overlooked when determining runtime resource limits.
•Delete Lambda functions that you are no longer using. By doing so, the unused functions won't 
needlessly count against your deployment package size limit.
•If you are using Amazon Simple Queue Service as an event source, make sure the value of the 
function's expected invocation time does not exceed the Visibility Timeout value on the queue. This 
applies both to CreateFunction (p. 1304 ) and UpdateFunctionConﬁguration (p. 1516 ).
•In the case of CreateFunction, AWS Lambda will fail the function creation process.
•In the case of UpdateFunctionConﬁguration, it could result in duplicate invocations of the function.
Metrics and alarms
•Use Working with Lambda function metrics (p. 965) and  CloudWatch Alarms instead of creating 
or updating a metric from within your Lambda function code. It's a much more eﬃcient way to track 
the health of your Lambda functions, allowing you to catch issues early in the development process. 
For instance, you can conﬁgure an alarm based on the expected duration of your Lambda function 
invocation in order to address any bottlenecks or latencies attributable to your function code.
•Leverage your logging library and AWS Lambda Metrics and Dimensions to catch app errors (e.g. 
ERR, ERROR, WARNING, etc.)
•Use AWS Cost Anomaly Detection to detect unusual activity on your account. Cost Anomaly Detection 
uses machine learning to continuously monitor your cost and usage while minimizing false positive 
alerts. Cost Anomaly Detection uses data from AWS Cost Explorer, which has a delay of up to 24 hours. 
As a result, it can take up to 24 hours to detect an anomaly after usage occurs. To get started with Cost 
Anomaly Detection, you must ﬁrst  sign up for Cost Explorer. Then, access Cost Anomaly Detection.
Working with streams
•Test with diﬀerent batch and record sizes so that the polling frequency of each event source is tuned 
to how quickly your function is able to complete its task. The CreateEventSourceMapping (p. 1292 )
BatchSize parameter controls the maximum number of records that can be sent to your function with 
each invoke. A larger batch size can often more eﬃciently absorb the invoke overhead across a larger 
set of records, increasing your throughput.
By default, Lambda invokes your function as soon as records are available. If the batch that Lambda 
reads from the event source has only one record in it, Lambda sends only one record to the function. 
To avoid invoking the function with a small number of records, you can tell the event source to 
buﬀer records for up to 5 minutes by conﬁguring a batching window . Before invoking the function, 
Lambda continues to read records from the event source until it has gathered a full batch, the batching 
window expires, or the batch reaches the payload limit of 6 MB. For more information, see Batching 
behavior (p. 151).
•Increase Kinesis stream processing throughput by adding shards. A Kinesis stream is composed 
of one or more shards. Lambda will poll each shard with at most one concurrent invocation. For 
example, if your stream has 100 active shards, there will be at most 100 Lambda function invocations 
running concurrently. Increasing the number of shards will directly increase the number of maximum 
concurrent Lambda function invocations and can increase your Kinesis stream processing throughput. 
910AWS Lambda Developer Guide
Security best practices
If you are increasing the number of shards in a Kinesis stream, make sure you have picked a good 
partition key (see Partition Keys) for your data, so that related records end up on the same shards and 
your data is well distributed.
•Use Amazon CloudWatch on IteratorAge to determine if your Kinesis stream is being processed. For 
example, conﬁgure a CloudWatch alarm with a maximum setting to 30000 (30 seconds).
Security best practices
•Monitor your usage of AWS Lambda as it relates to security best practices by using AWS Security 
Hub.  Security Hub uses security controls to evaluate resource conﬁgurations and security standards to 
help you comply with various compliance frameworks. For more information about using Security Hub 
to evaluate Lambda resources, see AWS Lambda controls in the AWS Security Hub User Guide.
911AWS Lambda Developer Guide
Lambda resource access permissions
You can use AWS Identity and Access Management (IAM) to manage access to the Lambda API and 
resources such as functions and layers. For users and applications in your account that use Lambda, you 
can create IAM policies that apply to users, groups, or roles.
Every Lambda function has an IAM role called an execution role (p. 913). In this role, you can attach a 
policy that deﬁnes the permissions that your function needs to access other AWS services and resources. 
At a minimum, your function needs access to Amazon CloudWatch Logs for log streaming. If your 
function calls other service APIs with the AWS SDK, you must include the necessary permissions in the 
execution role's policy. Lambda also uses the execution role to get permission to read from event sources 
when you use an event source mapping (p. 150) to invoke your function.
To give other accounts and AWS services permission to use your Lambda resources, use a resource-based 
policy (p. 929). Lambda resources include functions, versions, aliases, and layer versions. When a user 
tries to access a Lambda resource, Lambda considers both the user's identity-based policies (p. 920)
and the resource's resource-based policy. When an AWS service such as Amazon Simple Storage Service 
(Amazon S3) calls your Lambda function, Lambda considers only the resource-based policy.
To manage permissions for users and applications in your account, we recommend using an AWS 
managed policy (p. 920). You can use these managed policies as-is, or as a starting point for writing 
your own more restrictive policies. Policies can restrict user permissions by the resource that an action 
aﬀects, and by additional optional conditions. For more information, see Resources and conditions for 
Lambda actions (p. 935).
If your Lambda functions contain calls to other AWS resources, you might also want to restrict which 
functions can access those resources. To do this, include the lambda:SourceFunctionArn  condition 
key in an IAM identity-based policy or service control policy (SCP) for the target resource. For more 
information, see Working with Lambda execution environment credentials (p. 917).
For more information about IAM, see the IAM User Guide .
For more information about applying security principles to Lambda applications, see Security in 
Serverless Land.
Topics
•Lambda execution role (p. 913)
•Identity-based IAM policies for Lambda (p. 920)
•Attribute-based access control for Lambda (p. 925)
•Using resource-based policies for Lambda (p. 929)
•Resources and conditions for Lambda actions (p. 935)
•Using permissions boundaries for AWS Lambda applications (p. 942)
912AWS Lambda Developer Guide
Execution role
Lambda execution role
A Lambda function's execution role is an AWS Identity and Access Management (IAM) role that grants the 
function permission to access AWS services and resources. For example, you might create an execution 
role that has permission to send logs to Amazon CloudWatch and upload trace data to AWS X-Ray. This 
page provides information on how to create, view, and manage a Lambda function's execution role.
You provide an execution role when you create a function. When you invoke your function, Lambda 
automatically provides your function with temporary credentials by assuming this role. You don't 
have to call sts:AssumeRole  in your function code.
In order for Lambda to properly assume your execution role, the role's trust policy (p. 914) must 
specify the Lambda service principal (lambda.amazonaws.com ) as a trusted service.
To view a function's execution role
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Choose Conﬁguration , and then choose Permissions.
4. Under Resource summary, review the services and resources that the function can access.
5. Choose a service from the dropdown list to see permissions related to that service.
You can add or remove permissions from a function's execution role at any time, or conﬁgure your 
function to use a diﬀerent role. Add permissions for any services that your function calls with the AWS 
SDK, and for services that Lambda uses to enable optional features.
When you add permissions to your function, update its code or conﬁguration as well. This forces running 
instances of your function, which have outdated credentials, to stop and be replaced.
Topics
•Creating an execution role in the IAM console (p. 913)
•Grant least privilege access to your Lambda execution role (p. 914)
•Managing roles with the IAM API (p. 914)
•Session duration for temporary security credentials (p. 915)
•AWS managed policies for Lambda features (p. 915)
•Working with Lambda execution environment credentials (p. 917)
Creating an execution role in the IAM console
By default, Lambda creates an execution role with minimal permissions when you create a function in the 
Lambda console (p. 4). You can also create an execution role in the IAM console.
To create an execution role in the IAM console
1. Open the Roles page in the IAM console.
2. Choose Create role.
3. Under Use case , choose Lambda .
4. Choose Next.
5. Select the AWS managed policies AWSLambdaBasicExecutionRole and
AWSXRayDaemonWriteAccess.
6. Choose Next.
7. Enter a Role name and then choose Create role.
913AWS Lambda Developer Guide
Grant least privilege access to your Lambda execution role
For detailed instructions, see Creating a role for an AWS service (console) in the IAM User Guide .
Grant least privilege access to your Lambda execution 
role
When you ﬁrst create an IAM role for your Lambda function during the development phase, you might 
sometimes grant permissions beyond what is required. Before publishing your function in the production 
environment, as a best practice, adjust the policy to include only the required permissions. For more 
information, see Apply least-privilege permissions in the IAM User Guide .
Use IAM Access Analyzer to help identify the required permissions for the IAM execution role policy. IAM 
Access Analyzer reviews your AWS CloudTrail logs over the date range that you specify and generates 
a policy template with only the permissions that the function used during that time. You can use the 
template to create a managed policy with ﬁne-grained permissions, and then attach it to the IAM role. 
That way, you grant only the permissions that the role needs to interact with AWS resources for your 
speciﬁc use case.
For more information, see Generate policies based on access activity in the IAM User Guide .
Managing roles with the IAM API
To create an execution role with the AWS Command Line Interface (AWS CLI), use the create-role
command. When using this command, you can specify the  trust policy inline. A role's trust policy gives 
the speciﬁed principals permission to assume the role. In the following example, you grant the Lambda 
service principal permission to assume your role. Note that requirements for escaping quotes in the JSON 
string may vary depending on your shell.
aws iam create-role --role-name lambda-ex --assume-role-policy-document '{"Version": 
 "2012-10-17","Statement": [{ "Effect": "Allow", "Principal": {"Service": 
 "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}'
You can also deﬁne the trust policy for the role using a separate JSON ﬁle. In the following example,
trust-policy.json  is a ﬁle in the current directory.
Example trust-policy.json
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Principal": { 
        "Service": "lambda.amazonaws.com" 
      }, 
      "Action": "sts:AssumeRole" 
    } 
  ]
}
aws iam create-role --role-name lambda-ex --assume-role-policy-document file://trust-
policy.json
You should see the following output:
{ 
    "Role": { 
        "Path": "/", 
914AWS Lambda Developer Guide
Session duration for temporary security credentials
        "RoleName": "lambda-ex", 
        "RoleId": "AROAQFOXMPL6TZ6ITKWND", 
        "Arn": "arn:aws:iam::123456789012:role/lambda-ex", 
        "CreateDate": "2020-01-17T23:19:12Z", 
        "AssumeRolePolicyDocument": { 
            "Version": "2012-10-17", 
            "Statement": [ 
                { 
                    "Effect": "Allow", 
                    "Principal": { 
                        "Service": "lambda.amazonaws.com" 
                    }, 
                    "Action": "sts:AssumeRole" 
                } 
            ] 
        } 
    }
}
Note
Lambda automatically assumes your execution role when you invoke your function. You should 
avoid calling sts:AssumeRole  manually in your function code. If your use case requires that 
the role assumes itself, you must include the role itself as a trusted principal in your role's trust 
policy. For more information on how to modify a role trust policy, see  Modifying a role trust 
policy (console) in the IAM User Guide.
To add permissions to the role, use the attach-policy-to-role command. Start by adding the
AWSLambdaBasicExecutionRole  managed policy.
aws iam attach-role-policy --role-name lambda-ex --policy-arn arn:aws:iam::aws:policy/
service-role/AWSLambdaBasicExecutionRole
Session duration for temporary security credentials
Lambda assumes the execution role associated with your function to fetch temporary security 
credentials which are then available as environment variables during a function's invocation. If you use 
these temporary credentials outside of Lambda, such as to create a presigned Amazon S3 URL, you can't 
control the session duration. The IAM maximum session duration setting doesn't apply to sessions that 
are assumed by AWS services such as Lambda. Use the sts:AssumeRole action if you need control over 
session duration.
AWS managed policies for Lambda features
The following AWS managed policies provide permissions that are required to use Lambda features.
Change Description Date
AWSLambdaMSKExecutionRole
– Lambda added the
kafka:DescribeClusterV2
permission to this policy.AWSLambdaMSKExecutionRole
grants permissions to read 
and access records from an 
Amazon Managed Streaming 
for Apache Kafka (Amazon MSK) 
cluster, manage elastic network 
interfaces (ENIs), and write to 
CloudWatch Logs.June 17, 2022
915AWS Lambda Developer Guide
AWS managed policies for Lambda features
Change Description Date
AWSLambdaBasicExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaBasicExecutionRole
grants permissions to upload 
logs to CloudWatch.February 14, 2022
AWSLambdaDynamoDBExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaDynamoDBExecutionRole
grants permissions to read 
records from an Amazon 
DynamoDB stream and write to 
CloudWatch Logs.February 14, 2022
AWSLambdaKinesisExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaKinesisExecutionRole
grants permissions to read 
events from an Amazon Kinesis 
data stream and write to 
CloudWatch Logs.February 14, 2022
AWSLambdaMSKExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaMSKExecutionRole
grants permissions to read 
and access records from an 
Amazon Managed Streaming 
for Apache Kafka (Amazon MSK) 
cluster, manage elastic network 
interfaces (ENIs), and write to 
CloudWatch Logs.February 14, 2022
AWSLambdaSQSQueueExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaSQSQueueExecutionRole
grants permissions to read 
a message from an Amazon 
Simple Queue Service (Amazon 
SQS) queue and write to 
CloudWatch Logs.February 14, 2022
AWSLambdaVPCAccessExecutionRole
– Lambda started tracking 
changes to this policy.AWSLambdaVPCAccessExecutionRole
grants permissions to manage 
ENIs within an Amazon VPC and 
write to CloudWatch Logs.February 14, 2022
AWSXRayDaemonWriteAccess
– Lambda started tracking 
changes to this policy.AWSXRayDaemonWriteAccess
grants permissions to upload 
trace data to X-Ray.February 14, 2022
CloudWatchLambdaInsightsExecutionRolePolicy
– Lambda started tracking 
changes to this policy.CloudWatchLambdaInsightsExecutionRolePolicy
grants permissions to write 
runtime metrics to CloudWatch 
Lambda Insights.February 14, 2022
AmazonS3ObjectLambdaExecutionRolePolicy
– Lambda started tracking 
changes to this policy.AmazonS3ObjectLambdaExecutionRolePolicy
grants permissions to interact 
with Amazon Simple Storage 
Service (Amazon S3) object 
Lambda and to write to 
CloudWatch Logs.February 14, 2022
916AWS Lambda Developer Guide
Working with Lambda execution environment credentials
For some features, the Lambda console attempts to add missing permissions to your execution role in a 
customer managed policy. These policies can become numerous. To avoid creating extra policies, add the 
relevant AWS managed policies to your execution role before enabling features.
When you use an event source mapping (p. 150) to invoke your function, Lambda uses the execution role 
to read event data. For example, an event source mapping for Kinesis reads events from a data stream 
and sends them to your function in batches.
When a service assumes a role in your account, you can include the aws:SourceAccount  and
aws:SourceArn  global condition context keys in your role trust policy to limit access to the role to only 
requests that are generated by expected resources. For more information, see Cross-service confused 
deputy prevention for AWS Security Token Service.
You can use event source mappings with the following services:
Services that Lambda reads events from
•Amazon DynamoDB (p. 707)
•Amazon Kinesis (p. 756)
•Amazon MQ (p. 780)
•Amazon Managed Streaming for Apache Kafka (Amazon MSK) (p. 789)
•Self-managed Apache Kafka (p. 743)
•Amazon Simple Queue Service (Amazon SQS) (p. 875)
•Amazon DocumentDB (with MongoDB compatibility) (Amazon DocumentDB) (p. 682)
In addition to the AWS managed policies, the Lambda console provides templates for creating a custom 
policy with permissions for additional use cases. When you create a function in the Lambda console, 
you can choose to create a new execution role with permissions from one or more templates. These 
templates are also applied automatically when you create a function from a blueprint, or when you 
conﬁgure options that require access to other services. Example templates are available in this guide's
GitHub repository.
Working with Lambda execution environment 
credentials
It's common for your Lambda function code to make API requests to other AWS services. To make these 
requests, Lambda generates an ephemeral set of credentials by assuming your function's execution 
role. These credentials are available as environment variables during your function's invocation. 
When working with AWS SDKs, you don't need to provide credentials for the SDK directly in code. By 
default, the credential provider chain sequentially checks each place where you can set credentials 
and selects the ﬁrst one available—usually the environment variables (AWS_ACCESS_KEY_ID ,
AWS_SECRET_ACCESS_KEY , and AWS_SESSION_TOKEN ).
Lambda injects the source function ARN into the credentials context if the request is an AWS API request 
that comes from within your execution environment. Lambda also injects the source function ARN for the 
following AWS API requests that Lambda makes on your behalf outside of your execution environment:
Service Action Reason
CloudWatch Logs CreateLogGroup ,
CreateLogStream ,
PutLogEventsTo store logs into a CloudWatch 
Logs log group
X-Ray PutTraceSegments To send trace data to X-Ray
917AWS Lambda Developer Guide
Working with Lambda execution environment credentials
Service Action Reason
Amazon EFS ClientMount To connect your function to 
an Amazon Elastic File System 
(Amazon EFS) ﬁle system
Other AWS API calls that Lambda makes outside of your execution environment on your behalf using 
the same execution role don't contain the source function ARN. Examples of such API calls outside the 
execution environment include:
•Calls to AWS Key Management Service (AWS KMS) to automatically encrypt and decrypt your 
environment variables.
•Calls to Amazon Elastic Compute Cloud (Amazon EC2) to create elastic network interfaces (ENIs) for a 
VPC-enabled function.
•Calls to AWS services, such as Amazon Simple Queue Service (Amazon SQS), to read from an event 
source that's set up as an event source mapping (p. 150).
With the source function ARN in the credentials context, you can verify whether a call to your resource 
came from a speciﬁc Lambda function's code. To verify this, use the lambda:SourceFunctionArn
condition key in an IAM identity-based policy or service control policy (SCP).
Note
You cannot use the lambda:SourceFunctionArn  condition key in resource-based policies.
With this condition key in your identity-based policies or SCPs, you can implement security controls 
for the API actions that your function code makes to other AWS services. This has a few key security 
applications, such as helping you identify the source of a credential leak.
Note
The lambda:SourceFunctionArn  condition key is diﬀerent from the lambda:FunctionArn
and aws:SourceArn  condition keys. The lambda:FunctionArn  condition key applies only to
event source mappings (p. 150) and helps deﬁne which functions your event source can invoke. 
The aws:SourceArn  condition key applies only to policies where your Lambda function is 
the target resource, and helps deﬁne which other AWS services and resources can invoke that 
function. The lambda:SourceFunctionArn  condition key can apply to any identity-based 
policy or SCP to deﬁne the speciﬁc Lambda functions that have permissions to make speciﬁc 
AWS API calls to other resources.
To use lambda:SourceFunctionArn  in your policy, include it as a condition with any of the ARN 
condition operators. The value of the key must be a valid ARN.
For example, suppose your Lambda function code makes an s3:PutObject  call that targets a speciﬁc 
Amazon S3 bucket. You might want to allow only one speciﬁc Lambda function to have s3:PutObject
access that bucket. In this case, your function's execution role should have a policy attached that looks 
like this:
Example policy granting a speciﬁc Lambda function access to an Amazon S3 resource
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "ExampleSourceFunctionArn", 
            "Effect": "Allow", 
            "Action": "s3:PutObject", 
            "Resource": "arn:aws:s3:::lambda_bucket/*", 
            "Condition": { 
918AWS Lambda Developer Guide
Working with Lambda execution environment credentials
                "ArnEquals": { 
                    "lambda:SourceFunctionArn": "arn:aws:lambda:us-
east-1:123456789012:function:source_lambda" 
                } 
            } 
        } 
    ]
}
This policy allows only s3:PutObject  access if the source is the Lambda function with ARN
arn:aws:lambda:us-east-1:123456789012:function:source_lambda . This policy doesn't allow
s3:PutObject  access to any other calling identity. This is true even if a diﬀerent function or entity 
makes an s3:PutObject  call with the same execution role.
Note
The lambda:SourceFunctionARN  condition key doesn't support Lambda function versions 
or function aliases. If you use the ARN for a particular function version or alias, your function 
won't have permission to take the action you specify. Be sure to use the unqualiﬁed ARN for 
your function without a version or alias suﬃx.
You can also use lambda:SourceFunctionArn  in service control policies. For example, suppose you 
want to restrict access to your bucket to either a single Lambda function's code or to calls from a speciﬁc 
Amazon Virtual Private Cloud (VPC). The following SCP illustrates this.
Example policy denying access to Amazon S3 under speciﬁc conditions
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Action": [ 
                "s3:*" 
            ], 
            "Resource": "arn:aws:s3:::lambda_bucket/*", 
            "Effect": "Deny", 
            "Condition": { 
                "StringNotEqualsIfExists": { 
                    "aws:SourceVpc": [ 
                        "vpc-12345678" 
                    ] 
                }, 
                "ArnNotEqualsIfExists": { 
                    "lambda:SourceFunctionArn": "arn:aws:lambda:us-
east-1:123456789012:function:source_lambda" 
                } 
            } 
        } 
    ]
}
This policy denies all S3 actions unless they come from a speciﬁc Lambda function with ARN
arn:aws:lambda:*:123456789012:function:source_lambda , or unless they come from the 
speciﬁed VPC. The StringNotEqualsIfExists  operator tells IAM to process this condition only if the
aws:SourceVpc  key is present in the request. Similarly, IAM considers the ArnNotEqualsIfExists
operator only if the lambda:SourceFunctionArn  exists.
919AWS Lambda Developer Guide
User policies
Identity-based IAM policies for Lambda
You can use identity-based policies in AWS Identity and Access Management (IAM) to grant users in your 
account access to Lambda. Identity-based policies can apply to users directly, or to groups and roles that 
are associated with a user. You can also grant users in another account permission to assume a role in 
your account and access your Lambda resources. This page shows an example of how identity-based 
policies can be used for function development.
Lambda provides AWS managed policies that grant access to Lambda API actions and, in some cases, 
access to other AWS services used to develop and manage Lambda resources. Lambda updates these 
managed policies as needed to ensure that your users have access to new features when they're released.
•AWSLambda_FullAccess – Grants full access to Lambda actions and other AWS services used to 
develop and maintain Lambda resources. This policy was created by scoping down the previous policy
AWSLambdaFullAccess.
•AWSLambda_ReadOnlyAccess – Grants read-only access to Lambda resources. This policy was created 
by scoping down the previous policy AWSLambdaReadOnlyAccess.
•AWSLambdaRole – Grants permissions to invoke Lambda functions.
AWS managed policies grant permission to API actions without restricting the Lambda functions or layers 
that a user can modify. For ﬁner-grained control, you can create your own policies that limit the scope of 
a user's permissions.
Sections
•Function development (p. 920)
•Layer development and use (p. 923)
•Cross-account roles (p. 924)
•Condition keys for VPC settings (p. 924)
Function development
Use identity-based policies to allow users to perform operations on Lambda functions.
Note
For a function deﬁned as a container image, the user permission to access the image MUST 
be conﬁgured in the Amazon Elastic Container Registry For an example, see Amazon ECR 
permissions.  (p. 125)
The following shows an example of a permissions policy with limited scope. It allows a user to create and 
manage Lambda functions named with a designated preﬁx (intern-), and conﬁgured with a designated 
execution role.
Example Function development policy
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "ReadOnlyPermissions", 
            "Effect": "Allow",  
            "Action": [ 
                "lambda:GetAccountSettings", 
                "lambda:GetEventSourceMapping", 
                "lambda:GetFunction", 
                "lambda:GetFunctionConfiguration",            
920AWS Lambda Developer Guide
Function development
                "lambda:GetFunctionCodeSigningConfig", 
                "lambda:GetFunctionConcurrency",                 
                "lambda:ListEventSourceMappings", 
                "lambda:ListFunctions",       
                "lambda:ListTags", 
                "iam:ListRoles" 
            ], 
            "Resource": "*" 
        }, 
        { 
            "Sid": "DevelopFunctions", 
            "Effect": "Allow",  
            "NotAction": [ 
                "lambda:AddPermission", 
                "lambda:PutFunctionConcurrency" 
            ], 
            "Resource": "arn:aws:lambda:*:*:function:intern-*" 
        }, 
        { 
            "Sid": "DevelopEventSourceMappings", 
            "Effect": "Allow",  
            "Action": [ 
                "lambda:DeleteEventSourceMapping", 
                "lambda:UpdateEventSourceMapping", 
                "lambda:CreateEventSourceMapping" 
            ], 
            "Resource": "*", 
            "Condition": { 
                "StringLike": { 
                    "lambda:FunctionArn": "arn:aws:lambda:*:*:function:intern-*" 
                } 
            } 
        }, 
        { 
            "Sid": "PassExecutionRole", 
            "Effect": "Allow",  
            "Action": [ 
                "iam:ListRolePolicies", 
                "iam:ListAttachedRolePolicies", 
                "iam:GetRole", 
                "iam:GetRolePolicy", 
                "iam:PassRole", 
                "iam:SimulatePrincipalPolicy" 
            ], 
            "Resource": "arn:aws:iam::*:role/intern-lambda-execution-role" 
        }, 
        { 
            "Sid": "ViewLogs", 
            "Effect": "Allow",  
            "Action": [ 
                "logs:*" 
            ], 
            "Resource": "arn:aws:logs:*:*:log-group:/aws/lambda/intern-*" 
        } 
    ]
}
The permissions in the policy are organized into statements based on the resources and 
conditions (p. 935) that they support.
•ReadOnlyPermissions  – The Lambda console uses these permissions when you browse and view 
functions. They don't support resource patterns or conditions.
921AWS Lambda Developer Guide
Function development
            "Action": [ 
                "lambda:GetAccountSettings", 
                "lambda:GetEventSourceMapping", 
                "lambda:GetFunction", 
                "lambda:GetFunctionConfiguration",            
                "lambda:GetFunctionCodeSigningConfig", 
                "lambda:GetFunctionConcurrency",                 
                "lambda:ListEventSourceMappings", 
                "lambda:ListFunctions",       
                "lambda:ListTags", 
                "iam:ListRoles" 
            ], 
            "Resource": "*"
•DevelopFunctions  – Use any Lambda action that operates on functions preﬁxed with
intern- , except AddPermission  and PutFunctionConcurrency . AddPermission  modiﬁes 
the resource-based policy (p. 929) on the function and can have security implications.
PutFunctionConcurrency  reserves scaling capacity for a function and can take capacity away from 
other functions.
            "NotAction": [ 
                "lambda:AddPermission", 
                "lambda:PutFunctionConcurrency" 
            ], 
            "Resource": "arn:aws:lambda:*:*:function:intern-*"
•DevelopEventSourceMappings  – Manage event source mappings on functions that are preﬁxed 
with intern-. These actions operate on event source mappings, but you can restrict them by function 
with a condition .
            "Action": [ 
                "lambda:DeleteEventSourceMapping", 
                "lambda:UpdateEventSourceMapping", 
                "lambda:CreateEventSourceMapping" 
            ], 
            "Resource": "*", 
            "Condition": { 
                "StringLike": { 
                    "lambda:FunctionArn": "arn:aws:lambda:*:*:function:intern-*" 
                } 
            }
•PassExecutionRole  – View and pass only a role named intern-lambda-execution-role , which 
must be created and managed by a user with IAM permissions. PassRole  is used when you assign an 
execution role to a function.
            "Action": [ 
                "iam:ListRolePolicies", 
                "iam:ListAttachedRolePolicies", 
                "iam:GetRole", 
                "iam:GetRolePolicy", 
                "iam:PassRole", 
                "iam:SimulatePrincipalPolicy" 
            ], 
            "Resource": "arn:aws:iam::*:role/intern-lambda-execution-role"
•ViewLogs  – Use CloudWatch Logs to view logs for functions that are preﬁxed with intern- .
922AWS Lambda Developer Guide
Layer development and use
            "Action": [ 
                "logs:*" 
            ], 
            "Resource": "arn:aws:logs:*:*:log-group:/aws/lambda/intern-*"
This policy allows a user to get started with Lambda, without putting other users' resources at risk. It 
doesn't allow a user to conﬁgure a function to be triggered by or call other AWS services, which requires 
broader IAM permissions. It also doesn't include permission to services that don't support limited-scope 
policies, like CloudWatch and X-Ray. Use the read-only policies for these services to give the user access 
to metrics and trace data.
When you conﬁgure triggers for your function, you need access to use the AWS service that invokes 
your function. For example, to conﬁgure an Amazon S3 trigger, you need permission to use the 
Amazon S3 actions that manage bucket notiﬁcations. Many of these permissions are included in the
AWSLambdaFullAccess managed policy. Example policies are available in this guide's GitHub repository.
Layer development and use
The following policy grants a user permission to create layers and use them with functions. The resource 
patterns allow the user to work in any AWS Region and with any layer version, as long as the name of the 
layer starts with test- .
Example layer development policy
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "PublishLayers", 
            "Effect": "Allow", 
            "Action": [ 
                "lambda:PublishLayerVersion" 
            ], 
            "Resource": "arn:aws:lambda:*:*:layer:test-*" 
        }, 
        { 
            "Sid": "ManageLayerVersions", 
            "Effect": "Allow", 
            "Action": [ 
                "lambda:GetLayerVersion", 
                "lambda:DeleteLayerVersion" 
            ], 
            "Resource": "arn:aws:lambda:*:*:layer:test-*:*" 
        } 
    ]
}
You can also enforce layer use during function creation and conﬁguration with the lambda:Layer
condition. For example, you can prevent users from using layers published by other accounts. The 
following policy adds a condition to the CreateFunction  and UpdateFunctionConfiguration
actions to require that any layers speciﬁed come from account 123456789012 .
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "ConfigureFunctions", 
            "Effect": "Allow", 
            "Action": [ 
923AWS Lambda Developer Guide
Cross-account roles
                "lambda:CreateFunction", 
                "lambda:UpdateFunctionConfiguration" 
            ], 
            "Resource": "*", 
             "Condition": { 
                "ForAllValues:StringLike": { 
                    "lambda:Layer": [ 
                        "arn:aws:lambda:*: 123456789012 :layer:*:*" 
                    ] 
                } 
            }
        } 
    ]
}
To ensure that the condition applies, verify that no other statements grant the user permission to these 
actions.
Cross-account roles
You can apply any of the preceding policies and statements to a role, which you can then share with 
another account to give it access to your Lambda resources. Unlike a user, a role doesn't have credentials 
for authentication. Instead, it has a trust policy that speciﬁes who can assume the role and use its 
permissions.
You can use cross-account roles to give accounts that you trust access to Lambda actions and 
resources. If you just want to grant permission to invoke a function or use a layer, use resource-based 
policies  (p. 929) instead.
For more information, see IAM roles in the IAM User Guide .
Condition keys for VPC settings
You can use condition keys for VPC settings to provide additional permission controls for your Lambda 
functions. For example, you can enforce that all Lambda functions in your organization are connected to 
a VPC. You can also specify the subnets and security groups that the functions are allowed to use, or are 
denied from using.
For more information, see the section called “Using IAM condition keys for VPC settings” (p. 88).
924AWS Lambda Developer Guide
Control access using tags
Attribute-based access control for Lambda
With attribute-based access control (ABAC), you can use tags to control access to your Lambda functions. 
You can attach tags to a Lambda function, pass them in certain API requests, or attach them to the AWS 
Identity and Access Management (IAM) principal making the request. For more information about how 
AWS grants attribute-based access, see Controlling access to AWS resources using tags in the IAM User 
Guide .
You can use ABAC to grant least privilege  without specifying an Amazon Resource Name (ARN) or ARN 
pattern in the IAM policy. Instead, you can specify a tag in the condition element of an IAM policy to 
control access. Scaling is easier with ABAC because you don't have to update your IAM policies when you 
create new functions. Instead, add tags to the new functions to control access.
In Lambda, tags work at the function level. Tags aren't supported for layers, code signing conﬁgurations, 
or event source mappings. When you tag a function, those tags apply to all versions and aliases 
associated with the function. For information about how to tag functions, see Using tags on Lambda 
functions (p. 257).
You can use the following condition keys to control function actions:
•aws:ResourceTag/tag-key: Control access based on the tags that are attached to Lambda functions.
•aws:RequestTag/tag-key: Require tags to be present in a request, such as when creating a new 
function.
•aws:PrincipalTag/tag-key: Control what the IAM principal (the person making the request) is allowed to 
do based on the tags that are attached to their IAM user or role.
•aws:TagKeys: Control whether speciﬁc tag keys can be used in a request.
For a complete list of Lambda actions that support ABAC, see Function actions (p. 938) and check the
Condition  column in the table.
The following steps demonstrate one way to set up permissions using ABAC. In this example scenario, 
you'll create four IAM permissions policies. Then, you'll attach these policies to a new IAM role. Finally, 
you'll create an IAM user and give that user permission to assume the new role.
Prerequisites
Make sure that you have a Lambda execution role (p. 913). You'll use this role when you grant IAM 
permissions and when you create a Lambda function.
Step 1: Require tags on new functions
When using ABAC with Lambda, it's a best practice to require that all functions have tags. This helps 
ensure that your ABAC permissions policies work as expected.
Create an IAM policy similar to the following example. This policy uses the aws:RequestTag/tag-key and
aws:TagKeys condition keys to require that new functions and the IAM principal creating the functions 
both have the project  tag. The ForAllValues  modiﬁer ensures that project is the only allowed tag. 
If you don't include the ForAllValues  modiﬁer, users can add other tags to the function as long as 
they also pass project .
Example – Require tags on new functions
{ 
  "Version": "2012-10-17", 
  "Statement": { 
925AWS Lambda Developer Guide
Step 2: Control actions using tags
    "Effect": "Allow", 
    "Action": [ 
      "lambda:CreateFunction", 
      "lambda:TagResource" 
    ], 
    "Resource": "arn:aws:lambda:*:*:function:*", 
    "Condition": { 
      "StringEquals": { 
        "aws:RequestTag/ project": "${aws:PrincipalTag/ project}" 
      }, 
      "ForAllValues:StringEquals": { 
        "aws:TagKeys": " project" 
      } 
    } 
  }
}
Step 2: Allow actions based on tags attached to a 
Lambda function and IAM principal
Create a second IAM policy using the aws:ResourceTag/tag-key condition key to require the principal's 
tag to match the tag that's attached to the function. The following example policy allows principals with 
the project tag to invoke functions with the project tag. If a function has any other tags, the action is 
denied.
Example – Require matching tags on function and IAM principal
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Effect": "Allow", 
      "Action": [ 
        "lambda:InvokeFunction", 
        "lambda:GetFunction" 
      ], 
      "Resource": "arn:aws:lambda:*:*:function:*", 
      "Condition": { 
        "StringEquals": { 
          "aws:ResourceTag/ project": "${aws:PrincipalTag/ project}" 
        } 
      } 
    } 
  ]
}
Step 3: Grant list permissions
Create a policy that allows the principal to list Lambda functions and IAM roles. This allows the principal 
to see all Lambda functions and IAM roles on the console and when calling the API actions.
Example – Grant Lambda and IAM list permissions
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "AllResourcesLambdaNoTags", 
      "Effect": "Allow", 
926AWS Lambda Developer Guide
Step 4: Grant IAM permissions
      "Action": [ 
        "lambda:GetAccountSettings", 
        "lambda:ListFunctions", 
        "iam:ListRoles" 
      ], 
      "Resource": "*" 
    } 
  ]
}
Step 4: Grant IAM permissions
Create a policy that allows iam:PassRole. This permission is required when you assign an execution role 
to a function. In the following example policy, replace the example ARN with the ARN of your Lambda 
execution role.
Note
Do not use the ResourceTag  condition key in a policy with the iam:PassRole  action. 
You cannot use the tag on an IAM role to control access to who can pass that role. For more 
information about permissions required to pass a role to a service, see Granting a user 
permissions to pass a role to an AWS service.
Example – Grant permission to pass the execution role
{ 
  "Version": "2012-10-17", 
  "Statement": [ 
    { 
      "Sid": "VisualEditor0", 
      "Effect": "Allow", 
      "Action": [ 
        "iam:PassRole" 
      ], 
      "Resource": " arn:aws:iam::111122223333:role/lambda-ex " 
    } 
  ]
}
Step 5: Create the IAM role
It's a best practice to use roles to delegate permissions. Create an IAM role called abac-project-role :
•On Step 1: Select trusted entity: Choose AWS account and then choose This account.
•On Step 2: Add permissions : Attach the four IAM policies that you created in the previous steps.
•On Step 3: Name, review, and create: Choose Add tag . For Key, enter project . Don't enter a Value.
Step 6: Create the IAM user
Create an IAM user called abac-test-user . In the Set permissions  section, choose Attach existing 
policies directly and then choose Create policy. Enter the following policy deﬁnition. Replace
111122223333  with your AWS account ID. This policy allows abac-test-user  to assume abac-
project-role .
Example – Allow IAM user to assume ABAC role
{ 
927AWS Lambda Developer Guide
Step 7: Test the permissions
  "Version": "2012-10-17", 
  "Statement": { 
    "Effect": "Allow", 
    "Action": "sts:AssumeRole", 
    "Resource": "arn:aws:iam:: 111122223333 :role/abac-project-role " 
  }
}
Step 7: Test the permissions
1. Sign in to the AWS console as abac-test-user . For more information, see Sign in as an IAM user .
2. Switch to the abac-project-role  role. For more information, see Switching to a role (console).
3. Create a Lambda function (p. 257):
•Under Permissions, choose Change default execution role, and then for Execution role, 
choose Use an existing role. Choose the same execution role that you used in Step 4: Grant IAM 
permissions  (p. 927).
•Under Advanced settings, choose Enable tags and then choose Add new tag . For Key, enter
project . Don't enter a Value.
4. Test the function (p. 137).
5. Create a second Lambda function and add a diﬀerent tag, such as environment . This 
operation should fail because the ABAC policy that you created in Step 1: Require tags on new 
functions (p. 925) only allows the principal to create functions with the project  tag.
6. Create a third function without tags. This operation should fail because the ABAC policy that you 
created in Step 1: Require tags on new functions (p. 925) doesn't allow the principal to create 
functions without tags.
This authorization strategy allows you to control access without creating new policies for each new user. 
To grant access to new users, simply give them permission to assume the role that corresponds to their 
assigned project.
928AWS Lambda Developer Guide
Resource-based policies
Using resource-based policies for Lambda
Lambda supports resource-based permissions policies for Lambda functions and layers. Resource-based 
policies let you grant usage permission to other AWS accounts or organizations on a per-resource basis. 
You also use a resource-based policy to allow an AWS service to invoke your function on your behalf.
For Lambda functions, you can grant an account permission (p. 932) to invoke or manage a function. 
You can also use a single resource-based policy to grant permissions to an entire organization in 
AWS Organizations. You can also use resource-based policies to grant invoke permission to an AWS 
service (p. 931) that invokes a function in response to activity in your account.
To view a function's resource-based policy
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Permissions.
4. Scroll down to Resource-based policy and then choose View policy document. The resource-based 
policy shows the permissions that are applied when another account or AWS service attempts to 
access the function. The following example shows a statement that allows Amazon S3 to invoke a 
function named my-function  for a bucket named my-bucket  in account 123456789012 .
Example Resource-based policy
{ 
    "Version": "2012-10-17", 
    "Id": "default", 
    "Statement": [ 
        { 
            "Sid": "lambda-allow-s3-my-function", 
            "Effect": "Allow", 
            "Principal": { 
              "Service": "s3.amazonaws.com" 
            }, 
            "Action": "lambda:InvokeFunction", 
            "Resource":  "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
            "Condition": { 
              "StringEquals": { 
                "AWS:SourceAccount": "123456789012" 
              }, 
              "ArnLike": { 
                "AWS:SourceArn": "arn:aws:s3:::my-bucket" 
              } 
            } 
        } 
     ]
}
For Lambda layers, you can only use a resource-based policy on a speciﬁc layer version, instead of the 
entire layer. In addition to policies that grant permission to a single account or multiple accounts, for 
layers, you can also grant permission to all accounts in an organization.
Note
You can only update resource-based policies for Lambda resources within the scope of the
AddPermission (p. 1280 ) and AddLayerVersionPermission (p. 1276 ) API actions. Currently, you 
can't author policies for your Lambda resources in JSON, or use conditions that don't map to 
parameters for those actions.
929AWS Lambda Developer Guide
Supported API actions
Resource-based policies apply to a single function, version, alias, or layer version. They grant permission 
to one or more services and accounts. For trusted accounts that you want to have access to multiple 
resources, or to use API actions that resource-based policies don't support, you can use cross-account 
roles (p. 920).
Topics
•Supported API actions (p. 930)
•Granting function access to AWS services (p. 931)
•Granting function access to an organization (p. 931)
•Granting function access to other accounts (p. 932)
•Granting layer access to other accounts (p. 933)
•Cleaning up resource-based policies (p. 934)
Supported API actions
The following Lambda API actions support resource-based policies:
•CreateAlias (p. 1285 )
•DeleteAlias  (p. 1321 )
•DeleteFunction (p. 1332 )
•DeleteFunctionConcurrency (p. 1336 )
•DeleteFunctionEventInvokeConﬁg
•DeleteProvisionedConcurrencyConﬁg
•GetAlias  (p. 1348 )
•GetFunction (p. 1359 )
•GetFunctionConcurrency
•GetFunctionConﬁguration (p. 1368 )
•GetFunctionEventInvokeConﬁg
•GetPolicy (p. 1391 )
•GetProvisionedConcurrencyConﬁg
•Invoke (p. 1399 )
•ListAliases  (p. 1413 )
•ListFunctionEventInvokeConﬁgs
•ListProvisionedConcurrencyConﬁgs
•ListTags (p. 1443 )
•ListVersionsByFunction (p. 1445 )
•PublishVersion (p. 1454 )
•PutFunctionConcurrency (p. 1466 )
•PutFunctionEventInvokeConﬁg
•PutProvisionedConcurrencyConﬁg
•TagResource (p. 1484 )
•UntagResource (p. 1486 )
•UpdateAlias  (p. 1488 )
•UpdateFunctionCode (p. 1506 )
930AWS Lambda Developer Guide
Granting function access to AWS services
•UpdateFunctionEventInvokeConﬁg
Granting function access to AWS services
When you use an AWS service to invoke your function (p. 628), you grant permission in a statement on a 
resource-based policy. You can apply the statement to the entire function to be invoked or managed, or 
limit the statement to a single version or alias.
Note
When you add a trigger to your function with the Lambda console, the console updates the 
function's resource-based policy to allow the service to invoke it. To grant permissions to other 
accounts or services that aren't available in the Lambda console, you can use the AWS CLI.
Add a statement with the add-permission  command. The simplest resource-based policy statement 
allows a service to invoke a function. The following command grants Amazon SNS permission to invoke a 
function named my-function .
aws lambda add-permission --function-name my-function --action lambda:InvokeFunction --
statement-id sns \
--principal sns.amazonaws.com --output text
You should see the following output:
{"Sid":"sns","Effect":"Allow","Principal":
{"Service":"sns.amazonaws.com"},"Action":"lambda:InvokeFunction","Resource":"arn:aws:lambda:us-
east-2:123456789012:function:my-function"}
This lets Amazon SNS call the lambda:Invoke  API for the function, but it doesn't restrict the Amazon 
SNS topic that triggers the invocation. To ensure that your function is only invoked by a speciﬁc resource, 
specify the Amazon Resource Name (ARN) of the resource with the source-arn  option. The following 
command only allows Amazon SNS to invoke the function for subscriptions to a topic named my-topic .
aws lambda add-permission --function-name my-function --action lambda:InvokeFunction --
statement-id sns-my-topic \
--principal sns.amazonaws.com --source-arn arn:aws:sns: us-east-2:123456789012:my-topic
Some services can invoke functions in other accounts. If you specify a source ARN that has your account 
ID in it, that isn't an issue. For Amazon S3, however, the source is a bucket whose ARN doesn't have 
an account ID in it. It's possible that you could delete the bucket and another account could create a 
bucket with the same name. Use the source-account  option with your account ID to ensure that only 
resources in your account can invoke the function.
aws lambda add-permission --function-name my-function --action lambda:InvokeFunction --
statement-id s3-account \
--principal s3.amazonaws.com --source-arn arn:aws:s3::: my-bucket-123456  --source-
account 123456789012
Granting function access to an organization
To grant permissions to an organization in AWS Organizations, specify the organization ID as the
principal-org-id . The following AddPermission (p. 1280 ) AWS CLI command grants invocation 
access to all users in organization o-a1b2c3d4e5f .
aws lambda add-permission --function-name example \
--statement-id PrincipalOrgIDExample --action lambda:InvokeFunction \
931AWS Lambda Developer Guide
Granting function access to other accounts
--principal * --principal-org-id o-a1b2c3d4e5f 
Note
In this command, Principal  is *. This means that all users in the organization o-
a1b2c3d4e5f  get function invocation permissions. If you specify an AWS account or role as the
Principal , then only that principal gets function invocation permissions, but only if they are 
also part of the o-a1b2c3d4e5f  organization.
This command creates a resource-based policy that looks like the following:
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "PrincipalOrgIDExample", 
            "Effect": "Allow", 
            "Principal": "*", 
            "Action": "lambda:InvokeFunction", 
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:example", 
             "Condition": { 
                "StringEquals": { 
                    "aws:PrincipalOrgID": "o-a1b2c3d4e5f" 
                } 
            }
        } 
    ]
}
For more information, see  aws:PrincipalOrgID in the AWS Identity and Access Management user guide.
Granting function access to other accounts
To grant permissions to another AWS account, specify the account ID as the principal . The following 
example grants account 111122223333  permission to invoke my-function  with the prod  alias.
aws lambda add-permission --function-name my-function: prod --statement-id xaccount --action 
 lambda:InvokeFunction \
--principal 111122223333  --output text
You should see the following output:
{"Sid":"xaccount","Effect":"Allow","Principal":
{"AWS":"arn:aws:iam::111122223333:root"},"Action":"lambda:InvokeFunction","Resource":"arn:aws:lambda:us-
east-2:123456789012:function:my-function"}
The resource-based policy grants permission for the other account to access the function, but doesn't 
allow users in that account to exceed their permissions. Users in the other account must have the 
corresponding user permissions  (p. 920) to use the Lambda API.
To limit access to a user or role in another account, specify the full ARN of the identity as the principal. 
For example, arn:aws:iam::123456789012:user/developer .
The alias  (p. 104) limits which version the other account can invoke. It requires the other account to 
include the alias in the function ARN.
aws lambda invoke --function-name arn:aws:lambda:us-west-2:123456789012:function:my-
function:prod out
932AWS Lambda Developer Guide
Granting layer access to other accounts
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "1"
}
The function owner can then update the alias to point to a new version without the caller needing to 
change the way they invoke your function. This ensures that the other account doesn't need to change its 
code to use the new version, and it only has permission to invoke the version of the function associated 
with the alias.
You can grant cross-account access for most API actions that operate on an existing function (p. 938). 
For example, you could grant access to lambda:ListAliases  to let an account get a list of aliases, or
lambda:GetFunction  to let them download your function code. Add each permission separately, or 
use lambda:*  to grant access to all actions for the speciﬁed function.
To grant other accounts permission for multiple functions, or for actions that don't operate on a 
function, we recommend that you use IAM roles (p. 920).
Granting layer access to other accounts
To grant layer-usage permission to another account, add a statement to the layer version's permissions 
policy using the add-layer-version-permission command. In each statement, you can grant permission 
to a single account, all accounts, or an organization.
aws lambda add-layer-version-permission --layer-name xray-sdk-nodejs --statement-id 
 xaccount \
--action lambda:GetLayerVersion  --principal 111122223333 --version-number 1 --output text
You should see output similar to the following:
e210ffdc-e901-43b0-824b-5fcd0dd26d16    {"Sid":"xaccount","Effect":"Allow","Principal":
{"AWS":"arn:aws:iam::111122223333:root"},"Action":"lambda:GetLayerVersion","Resource":"arn:aws:lambda:us-
east-2:123456789012:layer:xray-sdk-nodejs:1"}
Permissions apply only to a single layer version. Repeat the process each time that you create a new layer 
version.
To grant permission to all accounts in an organization, use the organization-id  option. The following 
example grants all accounts in an organization permission to use version 3 of a layer.
aws lambda add-layer-version-permission --layer-name my-layer \
--statement-id engineering-org --version-number 3 --principal '*' \
--action lambda:GetLayerVersion --organization-id o-t194hfs8cz --output text
You should see the following output:
b0cd9796-d4eb-4564-939f-de7fe0b42236    {"Sid":"engineering-
org","Effect":"Allow","Principal":"*","Action":"lambda:GetLayerVersion","Resource":"arn:aws:lambda:us-
east-2:123456789012:layer:my-layer:3","Condition":{"StringEquals":{"aws:PrincipalOrgID":"o-
t194hfs8cz"}}}"
To grant permission to all AWS accounts, use * for the principal, and omit the organization ID. For 
multiple accounts or organizations, you need to add multiple statements.
933AWS Lambda Developer Guide
Cleaning up resource-based policies
Cleaning up resource-based policies
To view a function's resource-based policy, use the get-policy  command.
aws lambda get-policy --function-name my-function --output text
You should see the following output:
{"Version":"2012-10-17","Id":"default","Statement":
[{"Sid":"sns","Effect":"Allow","Principal":
{"Service":"s3.amazonaws.com"},"Action":"lambda:InvokeFunction","Resource":"arn:aws:lambda:us-
east-2:123456789012:function:my-function","Condition":{"ArnLike":
{"AWS:SourceArn":"arn:aws:sns:us-east-2:123456789012:lambda*"}}}]}      7c681fc9-b791-4e91-
acdf-eb847fdaa0f0
For versions and aliases, append the version number or alias to the function name.
aws lambda get-policy --function-name my-function:PROD
To remove permissions from your function, use remove-permission .
aws lambda remove-permission --function-name example --statement-id sns
Use the get-layer-version-policy  command to view the permissions on a layer.
aws lambda get-layer-version-policy --layer-name my-layer --version-number 3 --output text
You should see the following output:
b0cd9796-d4eb-4564-939f-de7fe0b42236    {"Sid":"engineering-
org","Effect":"Allow","Principal":"*","Action":"lambda:GetLayerVersion","Resource":"arn:aws:lambda:us-
west-2:123456789012:layer:my-layer:3","Condition":{"StringEquals":{"aws:PrincipalOrgID":"o-
t194hfs8cz"}}}"
Use remove-layer-version-permission  to remove statements from the policy.
aws lambda remove-layer-version-permission --layer-name my-layer --version-number 3 --
statement-id engineering-org
934AWS Lambda Developer Guide
Resources and conditions
Resources and conditions for Lambda actions
You can restrict the scope of a user's permissions by specifying resources and conditions in an AWS 
Identity and Access Management (IAM) policy. Each action in a policy supports a combination of resource 
and condition types that varies depending on the behavior of the action.
Every IAM policy statement grants permission to an action that's performed on a resource. When the 
action doesn't act on a named resource, or when you grant permission to perform the action on all 
resources, the value of the resource in the policy is a wildcard (*). For many actions, you can restrict the 
resources that a user can modify by specifying the Amazon Resource Name (ARN) of a resource, or an 
ARN pattern that matches multiple resources.
To restrict permissions by resource, specify the resource by ARN.
Lambda resource ARN format
•Function – arn:aws:lambda: us-west-2 :123456789012 :function: my-function
•Function version – arn:aws:lambda: us-west-2 :123456789012 :function: my-function :1
•Function alias – arn:aws:lambda: us-west-2 :123456789012 :function: my-function :TEST
•Event source mapping – arn:aws:lambda: us-west-2 :123456789012 :event-source-
mapping: fa123456-14a1-4fd2-9fec-83de64ad683de6d47
•Layer – arn:aws:lambda: us-west-2 :123456789012 :layer:my-layer
•Layer version – arn:aws:lambda: us-west-2 :123456789012 :layer:my-layer :1
For example, the following policy allows a user in AWS account 123456789012  to invoke a function 
named my-function  in the US West (Oregon) AWS Region.
Example invoke function policy
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "Invoke", 
            "Effect": "Allow", 
            "Action": [ 
                "lambda:InvokeFunction" 
            ], 
             "Resource": "arn:aws:lambda:us-west-2:123456789012:function:my-function"
        } 
    ]
}
This is a special case where the action identiﬁer (lambda:InvokeFunction ) diﬀers from the API 
operation ( Invoke (p. 1399 )). For other actions, the action identiﬁer is the operation name preﬁxed by
lambda: .
Sections
•Policy conditions (p. 936)
•Function resource names (p. 936)
•Function actions (p. 938)
•Event source mapping actions (p. 940)
•Layer actions (p. 940)
935AWS Lambda Developer Guide
Policy conditions
Policy conditions
Conditions are an optional policy element that applies additional logic to determine if an action is 
allowed. In addition to common conditions that all actions support, Lambda deﬁnes condition types that 
you can use to restrict the values of additional parameters on some actions.
For example, the lambda:Principal  condition lets you restrict the service or account that a user can 
grant invocation access to on a function's resource-based policy (p. 929). The following policy lets a 
user grant permission to Amazon Simple Notiﬁcation Service (Amazon SNS) topics to invoke a function 
named test .
Example manage function policy permissions
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "ManageFunctionPolicy", 
            "Effect": "Allow", 
            "Action": [ 
                "lambda:AddPermission", 
                "lambda:RemovePermission" 
            ], 
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:test:*", 
             "Condition": { 
                "StringEquals": { 
                    "lambda:Principal": "sns.amazonaws.com" 
                } 
            }
        } 
    ]
}
The condition requires that the principal is Amazon SNS and not another service or account. The resource 
pattern requires that the function name is test and includes a version number or alias. For example,
test:v1 .
For more information on resources and conditions for Lambda and other AWS services, see Actions, 
resources, and condition keys for AWS services in the Service Authorization Reference.
Function resource names
You reference a Lambda function in a policy statement using an Amazon Resource Name (ARN). The 
format of a function ARN depends on whether you are referencing the whole function (unqualiﬁed) or a 
function version (p. 108) or alias  (p. 104) (qualiﬁed).
When making Lambda API calls, users can specify a version or alias by passing a version ARN or 
alias ARN in the GetFunction (p. 1359 ) FunctionName  parameter, or by setting a value in the
GetFunction (p. 1359 ) Qualifier  parameter. Lambda makes authorization decisions by comparing the 
resource element in the IAM policy with both the FunctionName  and Qualifier  passed in API calls. If 
there is a mismatch, Lambda denies the request.
Whether you are allowing or denying an action on your function, you must use the correct function 
ARN types in your policy statement to achieve the results that you expect. For example, if your policy 
references the unqualiﬁed ARN, Lambda accepts requests that reference the unqualiﬁed ARN but denies 
requests that reference a qualiﬁed ARN.
Note
You can't use a wildcard character (*) to match the account ID. For more information on 
accepted syntax, see IAM JSON policy reference in the IAM User Guide .
936AWS Lambda Developer Guide
Function resource names
Example allowing invocation of an unqualiﬁed ARN
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "lambda:InvokeFunction", 
             "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction"
        } 
    ]
}
If your policy references a speciﬁc qualiﬁed ARN, Lambda accepts requests that reference that ARN 
but denies requests that reference the unqualiﬁed ARN or a diﬀerent qualiﬁed ARN, for example,
myFunction:2 .
Example allowing invocation of a speciﬁc qualiﬁed ARN
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "lambda:InvokeFunction", 
             "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction:1"
        } 
    ]
}
If your policy references any qualiﬁed ARN using :*, Lambda accepts any qualiﬁed ARN but denies 
requests that reference the unqualiﬁed ARN.
Example allowing invocation of any qualiﬁed ARN
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "lambda:InvokeFunction", 
             "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction:*"
        } 
    ]
}
If your policy references any ARN using *, Lambda accepts any qualiﬁed or unqualiﬁed ARN.
Example allowing invocation of any qualiﬁed or unqualiﬁed ARN
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Action": "lambda:InvokeFunction", 
             "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction*"
        } 
    ]
}
937AWS Lambda Developer Guide
Function actions
Function actions
Actions that operate on a function can be restricted to a speciﬁc function by function, version, or alias 
ARN, as described in the following table. Actions that don't support resource restrictions are granted for 
all resources (*).
Function actions
Action Resource Condition
AddPermission (p. 1280 )
RemovePermission (p. 1482 )Function
Function version
Function aliaslambda:Principal
aws:ResourceTag/${TagKey}
lambda:FunctionUrlAuthType
Invoke (p. 1399 )
Permission:
lambda:InvokeFunctionFunction
Function version
Function aliasaws:ResourceTag/${TagKey}
CreateFunction (p. 1304 ) Function lambda:CodeSigningConfigArn
lambda:Layer
lambda:VpcIds
lambda:SubnetIds
lambda:SecurityGroupIds
aws:ResourceTag/${TagKey}
aws:RequestTag/${TagKey}
aws:TagKeys
UpdateFunctionConﬁguration (p. 1516 )Function lambda:CodeSigningConfigArn
lambda:Layer
lambda:VpcIds
lambda:SubnetIds
lambda:SecurityGroupIds
aws:ResourceTag/${TagKey}
CreateAlias (p. 1285 )
DeleteAlias  (p. 1321 )
DeleteFunction (p. 1332 )
DeleteFunctionCodeSigningConﬁg
DeleteFunctionConcurrency (p. 1336 )
GetAlias  (p. 1348 )Function aws:ResourceTag/${TagKey}
938AWS Lambda Developer Guide
Function actions
Action Resource Condition
GetFunction (p. 1359 )
GetFunctionCodeSigningConﬁg
GetFunctionConcurrency
GetFunctionConﬁguration (p. 1368 )
GetPolicy (p. 1391 )
ListProvisionedConcurrencyConﬁgs
ListAliases  (p. 1413 )
ListTags (p. 1443 )
ListVersionsByFunction (p. 1445 )
PublishVersion (p. 1454 )
PutFunctionCodeSigningConﬁg
PutFunctionConcurrency (p. 1466 )
UpdateAlias  (p. 1488 )
UpdateFunctionCode (p. 1506 )
CreateFunctionUrlConﬁg
DeleteFunctionUrlConﬁg
GetFunctionUrlConﬁg
UpdateFunctionUrlConﬁgFunction
Function aliaslambda:FunctionUrlAuthType
lambda:FunctionArn
aws:ResourceTag/${TagKey}
ListFunctionUrlConﬁgsFunction lambda:FunctionUrlAuthType
DeleteFunctionEventInvokeConﬁg
GetFunctionEventInvokeConﬁg
ListFunctionEventInvokeConﬁgs
PutFunctionEventInvokeConﬁg
UpdateFunctionEventInvokeConﬁgFunction aws:ResourceTag/${TagKey}
DeleteProvisionedConcurrencyConﬁg
GetProvisionedConcurrencyConﬁg
PutProvisionedConcurrencyConﬁgFunction alias
Function versionaws:ResourceTag/${TagKey}
GetAccountSettings (p. 1346 )
ListFunctions (p. 1425 )* None
939AWS Lambda Developer Guide
Event source mapping actions
Action Resource Condition
TagResource (p. 1484 )Function aws:ResourceTag/${TagKey}
aws:RequestTag/${TagKey}
aws:TagKeys
UntagResource (p. 1486 )Function aws:ResourceTag/${TagKey}
aws:TagKeys
Event source mapping actions
For event source mappings (p. 150), you can restrict delete and update permissions to a speciﬁc event 
source. The lambda:FunctionArn  condition lets you restrict which functions a user can conﬁgure an 
event source to invoke.
For these actions, the resource is the event source mapping, so Lambda provides a condition that lets you 
restrict permission based on the function that the event source mapping invokes.
Event source mapping actions
Action Resource Condition
DeleteEventSourceMapping (p. 1325 )
UpdateEventSourceMapping (p. 1495 )Event source mapping lambda:FunctionArn
CreateEventSourceMapping (p. 1292 ) * lambda:FunctionArn
GetEventSourceMapping (p. 1353 )
ListEventSourceMappings (p. 1418 )* None
Layer actions
Layer actions let you restrict the layers that a user can manage or use with a function. Actions related 
to layer use and permissions act on a version of a layer, while PublishLayerVersion  acts on a layer 
name. You can use either with wildcards to restrict the layers that a user can work with by name.
Note
The GetLayerVersion (p. 1382 ) action also covers GetLayerVersionByArn (p. 1386 ). Lambda does 
not support GetLayerVersionByArn  as an IAM action.
Layer actions
Action Resource Condition
AddLayerVersionPermission (p. 1276 )
RemoveLayerVersionPermission (p. 1480 )
GetLayerVersion (p. 1382 )
GetLayerVersionPolicy (p. 1389 )Layer version None
940AWS Lambda Developer Guide
Layer actions
Action Resource Condition
DeleteLayerVersion (p. 1342 )
ListLayerVersions (p. 1437 )
PublishLayerVersion (p. 1449 )Layer None
ListLayers (p. 1434 ) * None
941AWS Lambda Developer Guide
Permissions boundaries
Using permissions boundaries for AWS Lambda 
applications
When you create an application (p. 1070 ) in the AWS Lambda console, Lambda applies a permissions 
boundary to the application's IAM roles. The permissions boundary limits the scope of the execution 
role (p. 913) that the application's template creates for each of its functions, and any roles that you 
add to the template. The permissions boundary prevents users with write access to the application's Git 
repository from escalating the application's permissions beyond the scope of its own resources.
The application templates in the Lambda console include a global property that applies a permissions 
boundary to all functions that they create.
Globals: 
  Function: 
    PermissionsBoundary: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/
${AppId}-${AWS::Region}-PermissionsBoundary'
The boundary limits the permissions of the functions' roles. You can add permissions to a function's 
execution role in the template, but that permission is only eﬀective if it's also allowed by the permissions 
boundary. The role that AWS CloudFormation assumes to deploy the application enforces the use of the 
permissions boundary. That role only has permission to create and pass roles that have the application's 
permissions boundary attached.
By default, an application's permissions boundary enables functions to perform actions on the resources 
in the application. For example, if the application includes an Amazon DynamoDB table, the boundary 
allows access to any API action that can be restricted to operate on speciﬁc tables with resource-level 
permissions. You can only use actions that don't support resource-level permissions if they're speciﬁcally 
permitted in the boundary. These include Amazon CloudWatch Logs and AWS X-Ray API actions for 
logging and tracing.
Example permissions boundary
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Action": [ 
                "*" 
            ], 
            "Resource": [ 
                 "arn:aws:lambda:us-east-2:123456789012:function:my-app-getAllItemsFunction-
*", 
                "arn:aws:lambda:us-east-2:123456789012:function:my-app-getByIdFunction-*", 
                "arn:aws:lambda:us-east-2:123456789012:function:my-app-putItemFunction-*", 
                "arn:aws:dynamodb:us-east-1:123456789012:table/my-app-SampleTable-*"
            ], 
            "Effect": "Allow", 
            "Sid": "StackResources" 
        }, 
        { 
            "Action": [ 
                 "logs:CreateLogGroup", 
                "logs:CreateLogStream", 
                "logs:DescribeLogGroups", 
                "logs:PutLogEvents", 
                "xray:Put*"
            ], 
            "Resource": "*", 
942AWS Lambda Developer Guide
Permissions boundaries
            "Effect": "Allow", 
            "Sid": "StaticPermissions" 
        }, 
        ... 
    ]
}
To access other resources or API actions, you or an administrator must expand the permissions boundary 
to include those resources. You might also need to update the execution role or deployment role of an 
application to allow the use of additional actions.
•Permissions boundary – Extend the application's permissions boundary when you add resources to 
your application, or the execution role needs access to more actions. In IAM, add resources to the 
boundary to allow the use of API actions that support resource-level permissions on that resource's 
type. For actions that don't support resource-level permissions, add them in a statement that isn't 
scoped to any resource.
•Execution role – Extend a function's execution role when it needs to use additional actions. In the 
application template, add policies to the execution role. The intersection of permissions in the 
boundary and execution role is granted to the function.
•Deployment role – Extend the application's deployment role when it needs additional permissions 
to create or conﬁgure resources. In IAM, add policies to the application's deployment role. The 
deployment role needs the same user permissions that you need to deploy or update an application in 
AWS CloudFormation.
For a tutorial that walks through adding resources to an application and extending its permissions, see
??? (p. 1070 ).
For more information, see Permissions boundaries for IAM entities in the IAM User Guide.
943AWS Lambda Developer Guide
Data protection
Security in AWS Lambda
Cloud security at AWS is the highest priority. As an AWS customer, you beneﬁt from a data center and 
network architecture that is built to meet the requirements of the most security-sensitive organizations.
Security is a shared responsibility between AWS and you. The shared responsibility model describes this 
as security of the cloud and security in the cloud:
•Security of the cloud – AWS is responsible for protecting the infrastructure that runs AWS services in 
the AWS Cloud. AWS also provides you with services that you can use securely. Third-party auditors 
regularly test and verify the eﬀectiveness of our security as part of the AWS compliance programs. 
To learn about the compliance programs that apply to AWS Lambda, see AWS Services in Scope by 
Compliance Program.
•Security in the cloud – Your responsibility is determined by the AWS service that you use. You are also 
responsible for other factors including the sensitivity of your data, your company’s requirements, and 
applicable laws and regulations.
This documentation helps you understand how to apply the shared responsibility model when using 
Lambda. The following topics show you how to conﬁgure Lambda to meet your security and compliance 
objectives. You also learn how to use other AWS services that help you to monitor and secure your 
Lambda resources.
For more information about applying security principles to Lambda applications, see Security in 
Serverless Land.
Topics
•Data protection in AWS Lambda (p. 944)
•Identity and access management for Lambda (p. 946)
•Compliance validation for AWS Lambda (p. 957)
•Resilience in AWS Lambda (p. 958)
•Infrastructure security in AWS Lambda (p. 959)
•Conﬁguration and vulnerability analysis in AWS Lambda (p. 959)
Data protection in AWS Lambda
The AWS shared responsibility model applies to data protection in AWS Lambda. As described in this 
model, AWS is responsible for protecting the global infrastructure that runs all of the AWS Cloud. You 
are responsible for maintaining control over your content that is hosted on this infrastructure. This 
content includes the security conﬁguration and management tasks for the AWS services that you use. For 
more information about data privacy, see the Data Privacy FAQ. For information about data protection in 
Europe, see the AWS Shared Responsibility Model and GDPR blog post on the AWS Security Blog.
For data protection purposes, we recommend that you protect AWS account credentials and set up 
individual users with AWS IAM Identity Center (successor to AWS Single Sign-On) or AWS Identity and 
Access Management (IAM). That way, each user is given only the permissions necessary to fulﬁll their job 
duties. We also recommend that you secure your data in the following ways:
944AWS Lambda Developer Guide
Encryption in transit
•Use multi-factor authentication (MFA) with each account.
•Use SSL/TLS to communicate with AWS resources. We require TLS 1.2 and recommend TLS 1.3.
•Set up API and user activity logging with AWS CloudTrail.
•Use AWS encryption solutions, along with all default security controls within AWS services.
•Use advanced managed security services such as Amazon Macie, which assists in discovering and 
securing sensitive data that is stored in Amazon S3.
•If you require FIPS 140-2 validated cryptographic modules when accessing AWS through a command 
line interface or an API, use a FIPS endpoint. For more information about the available FIPS endpoints, 
see Federal Information Processing Standard (FIPS) 140-2.
We strongly recommend that you never put conﬁdential or sensitive information, such as your 
customers' email addresses, into tags or free-form text ﬁelds such as a Name  ﬁeld. This includes when 
you work with Lambda or other AWS services using the console, API, AWS CLI, or AWS SDKs. Any data 
that you enter into tags or free-form text ﬁelds used for names may be used for billing or diagnostic 
logs. If you provide a URL to an external server, we strongly recommend that you do not include 
credentials information in the URL to validate your request to that server.
Sections
•Encryption in transit (p. 945)
•Encryption at rest (p. 945)
Encryption in transit
Lambda API endpoints only support secure connections over HTTPS. When you manage Lambda 
resources with the AWS Management Console,AWS SDK, or the Lambda API, all communication is 
encrypted with Transport Layer Security (TLS). For a full list of API endpoints, see AWS Regions and 
endpoints  in the AWS General Reference.
When you connect your function to a ﬁle system (p. 99), Lambda uses encryption in transit for all 
connections. For more information, see Data encryption in Amazon EFS in the Amazon Elastic File System 
User Guide .
When you use environment variables (p. 77), you can enable console encryption helpers to use client-
side encryption to protect the environment variables in transit. For more information, see Securing 
environment variables (p. 81).
Encryption at rest
You can use environment variables (p. 77) to store secrets securely for use with Lambda functions. 
Lambda always encrypts environment variables at rest. By default, Lambda uses an AWS KMS key that 
Lambda creates in your account to encrypt your environment variables. This AWS managed key is named
aws/lambda .
On a per-function basis, you can optionally conﬁgure Lambda to use a customer managed key instead 
of the default AWS managed key to encrypt your environment variables. For more information, see
Securing environment variables (p. 81).
Lambda always encrypts ﬁles that you upload to Lambda, including deployment packages (p. 122) and
layer archives (p. 988).
Amazon CloudWatch Logs and AWS X-Ray also encrypt data by default, and can be conﬁgured to use a 
customer managed key. For details, see Encrypt log data in CloudWatch Logs and Data protection in AWS 
X-Ray.
945AWS Lambda Developer Guide
Identity and access management
Identity and access management for Lambda
AWS Identity and Access Management (IAM) is an AWS service that helps an administrator securely 
control access to AWS resources. IAM administrators control who can be authenticated  (signed in) and
authorized  (have permissions) to use Lambda resources. IAM is an AWS service that you can use with no 
additional charge.
Topics
•Audience (p. 946)
•Authenticating with identities  (p. 946)
•Managing access using policies (p. 948)
•How AWS Lambda works with IAM (p. 950)
•AWS Lambda identity-based policy examples (p. 950)
•AWS managed policies for AWS Lambda (p. 952)
•Troubleshooting AWS Lambda identity and access (p. 955)
Audience
How you use AWS Identity and Access Management (IAM) diﬀers, depending on the work that you do in 
Lambda.
Service user – If you use the Lambda service to do your job, then your administrator provides you with 
the credentials and permissions that you need. As you use more Lambda features to do your work, you 
might need additional permissions. Understanding how access is managed can help you request the right 
permissions from your administrator. If you cannot access a feature in Lambda, see Troubleshooting AWS 
Lambda identity and access (p. 955).
Service administrator – If you're in charge of Lambda resources at your company, you probably have 
full access to Lambda. It's your job to determine which Lambda features and resources your service users 
should access. You must then submit requests to your IAM administrator to change the permissions 
of your service users. Review the information on this page to understand the basic concepts of IAM. 
To learn more about how your company can use IAM with Lambda, see How AWS Lambda works with 
IAM (p. 950).
IAM administrator  – If you're an IAM administrator, you might want to learn details about how you can 
write policies to manage access to Lambda. To view example Lambda identity-based policies that you 
can use in IAM, see AWS Lambda identity-based policy examples (p. 950).
Authenticating with identities
Authentication is how you sign in to AWS using your identity credentials. You must be authenticated
(signed in to AWS) as the AWS account root user, as an IAM user, or by assuming an IAM role.
You can sign in to AWS as a federated identity by using credentials provided through an identity source. 
AWS IAM Identity Center (successor to AWS Single Sign-On) (IAM Identity Center) users, your company's 
single sign-on authentication, and your Google or Facebook credentials are examples of federated 
identities. When you sign in as a federated identity, your administrator previously set up identity 
federation using IAM roles. When you access AWS by using federation, you are indirectly assuming a role.
Depending on the type of user you are, you can sign in to the AWS Management Console or the AWS 
access portal. For more information about signing in to AWS, see How to sign in to your AWS account in 
the AWS Sign-In User Guide.
946AWS Lambda Developer Guide
Authenticating with identities
If you access AWS programmatically, AWS provides a software development kit (SDK) and a command 
line interface (CLI) to cryptographically sign your requests by using your credentials. If you don't use AWS 
tools, you must sign requests yourself. For more information about using the recommended method to 
sign requests yourself, see Signing AWS API requests in the IAM User Guide .
Regardless of the authentication method that you use, you might be required to provide additional 
security information. For example, AWS recommends that you use multi-factor authentication (MFA) 
to increase the security of your account. To learn more, see Multi-factor authentication in the AWS IAM 
Identity Center (successor to AWS Single Sign-On) User Guide and Using multi-factor authentication (MFA) 
in AWS in the IAM User Guide .
AWS account root user
When you create an AWS account, you begin with one sign-in identity that has complete access to 
all AWS services and resources in the account. This identity is called the AWS account root user  and is 
accessed by signing in with the email address and password that you used to create the account. We 
strongly recommend that you don't use the root user for your everyday tasks. Safeguard your root user 
credentials and use them to perform the tasks that only the root user can perform. For the complete list 
of tasks that require you to sign in as the root user, see Tasks that require root user credentials in the
AWS Account Management Reference Guide.
Users and groups
An IAM user  is an identity within your AWS account that has speciﬁc permissions for a single person or 
application. Where possible, we recommend relying on temporary credentials instead of creating IAM 
users who have long-term credentials such as passwords and access keys. However, if you have speciﬁc 
use cases that require long-term credentials with IAM users, we recommend that you rotate access keys. 
For more information, see Rotate access keys regularly for use cases that require long-term credentials in 
the IAM User Guide .
An IAM group  is an identity that speciﬁes a collection of IAM users. You can't sign in as a group. You 
can use groups to specify permissions for multiple users at a time. Groups make permissions easier to 
manage for large sets of users. For example, you could have a group named IAMAdmins  and give that 
group permissions to administer IAM resources.
Users are diﬀerent from roles. A user is uniquely associated with one person or application, but a role 
is intended to be assumable by anyone who needs it. Users have permanent long-term credentials, but 
roles provide temporary credentials. To learn more, see When to create an IAM user (instead of a role) in 
the IAM User Guide .
IAM roles
An IAM role  is an identity within your AWS account that has speciﬁc permissions. It is similar to an IAM 
user, but is not associated with a speciﬁc person. You can temporarily assume an IAM role in the AWS 
Management Console by switching roles. You can assume a role by calling an AWS CLI or AWS API 
operation or by using a custom URL. For more information about methods for using roles, see Using IAM 
roles in the IAM User Guide .
IAM roles with temporary credentials are useful in the following situations:
•Federated user access – To assign permissions to a federated identity, you create a role and deﬁne 
permissions for the role. When a federated identity authenticates, the identity is associated with 
the role and is granted the permissions that are deﬁned by the role. For information about roles for 
federation, see  Creating a role for a third-party Identity Provider in the IAM User Guide . If you use IAM 
Identity Center, you conﬁgure a permission set. To control what your identities can access after they 
authenticate, IAM Identity Center correlates the permission set to a role in IAM. For information about 
permissions sets, see  Permission sets in the AWS IAM Identity Center (successor to AWS Single Sign-On) 
User Guide .
947AWS Lambda Developer Guide
Managing access using policies
•Temporary IAM user permissions – An IAM user or role can assume an IAM role to temporarily take on 
diﬀerent permissions for a speciﬁc task.
•Cross-account access – You can use an IAM role to allow someone (a trusted principal) in a diﬀerent 
account to access resources in your account. Roles are the primary way to grant cross-account access. 
However, with some AWS services, you can attach a policy directly to a resource (instead of using a role 
as a proxy). To learn the diﬀerence between roles and resource-based policies for cross-account access, 
see How IAM roles diﬀer from resource-based policies in the IAM User Guide .
•Cross-service access – Some AWS services use features in other AWS services. For example, when you 
make a call in a service, it's common for that service to run applications in Amazon EC2 or store objects 
in Amazon S3. A service might do this using the calling principal's permissions, using a service role, or 
using a service-linked role.
•Principal permissions  – When you use an IAM user or role to perform actions in AWS, you are 
considered a principal. Policies grant permissions to a principal. When you use some services, you 
might perform an action that then triggers another action in a diﬀerent service. In this case, you 
must have permissions to perform both actions. To see whether an action requires additional 
dependent actions in a policy, see Actions, Resources, and Condition Keys for AWS Lambda in the
Service Authorization Reference.
•Service role – A service role is an IAM role that a service assumes to perform actions on your behalf. 
An IAM administrator can create, modify, and delete a service role from within IAM. For more 
information, see Creating a role to delegate permissions to an AWS service in the IAM User Guide .
•Service-linked role – A service-linked role is a type of service role that is linked to an AWS service. 
The service can assume the role to perform an action on your behalf. Service-linked roles appear in 
your AWS account and are owned by the service. An IAM administrator can view, but not edit the 
permissions for service-linked roles.
•Applications running on Amazon EC2 – You can use an IAM role to manage temporary credentials 
for applications that are running on an EC2 instance and making AWS CLI or AWS API requests. 
This is preferable to storing access keys within the EC2 instance. To assign an AWS role to an EC2 
instance and make it available to all of its applications, you create an instance proﬁle that is attached 
to the instance. An instance proﬁle contains the role and enables programs that are running on the 
EC2 instance to get temporary credentials. For more information, see Using an IAM role to grant 
permissions to applications running on Amazon EC2 instances in the IAM User Guide .
To learn whether to use IAM roles or IAM users, see When to create an IAM role (instead of a user) in the
IAM User Guide .
Managing access using policies
You control access in AWS by creating policies and attaching them to AWS identities or resources. A 
policy is an object in AWS that, when associated with an identity or resource, deﬁnes their permissions. 
AWS evaluates these policies when a principal (user, root user, or role session) makes a request. 
Permissions in the policies determine whether the request is allowed or denied. Most policies are stored 
in AWS as JSON documents. For more information about the structure and contents of JSON policy 
documents, see Overview of JSON policies in the IAM User Guide .
Administrators can use AWS JSON policies to specify who has access to what. That is, which principal  can 
perform actions on what resources, and under what conditions.
By default, users and roles have no permissions. To grant users permission to perform actions on the 
resources that they need, an IAM administrator can create IAM policies. The administrator can then add 
the IAM policies to roles, and users can assume the roles.
IAM policies deﬁne permissions for an action regardless of the method that you use to perform the 
operation. For example, suppose that you have a policy that allows the iam:GetRole  action. A user with 
that policy can get role information from the AWS Management Console, the AWS CLI, or the AWS API.
948AWS Lambda Developer Guide
Managing access using policies
Identity-based policies
Identity-based policies are JSON permissions policy documents that you can attach to an identity, such 
as an IAM user, group of users, or role. These policies control what actions users and roles can perform, 
on which resources, and under what conditions. To learn how to create an identity-based policy, see
Creating IAM policies in the IAM User Guide .
Identity-based policies can be further categorized as inline policies  or managed policies . Inline policies 
are embedded directly into a single user, group, or role. Managed policies are standalone policies that 
you can attach to multiple users, groups, and roles in your AWS account. Managed policies include AWS 
managed policies and customer managed policies. To learn how to choose between a managed policy or 
an inline policy, see Choosing between managed policies and inline policies in the IAM User Guide .
Resource-based policies
Resource-based policies are JSON policy documents that you attach to a resource. Examples of resource-
based policies are IAM role trust policies  and Amazon S3 bucket policies . In services that support resource-
based policies, service administrators can use them to control access to a speciﬁc resource. For the 
resource where the policy is attached, the policy deﬁnes what actions a speciﬁed principal can perform 
on that resource and under what conditions. You must specify a principal in a resource-based policy. 
Principals can include accounts, users, roles, federated users, or AWS services.
Resource-based policies are inline policies that are located in that service. You can't use AWS managed 
policies from IAM in a resource-based policy.
Access control lists (ACLs)
Access control lists (ACLs) control which principals (account members, users, or roles) have permissions to 
access a resource. ACLs are similar to resource-based policies, although they do not use the JSON policy 
document format.
Amazon S3, AWS WAF, and Amazon VPC are examples of services that support ACLs. To learn more about 
ACLs, see Access control list (ACL) overview in the Amazon Simple Storage Service Developer Guide.
Other policy types
AWS supports additional, less-common policy types. These policy types can set the maximum 
permissions granted to you by the more common policy types.
•Permissions boundaries – A permissions boundary is an advanced feature in which you set the 
maximum permissions that an identity-based policy can grant to an IAM entity (IAM user or role). 
You can set a permissions boundary for an entity. The resulting permissions are the intersection of an 
entity's identity-based policies and its permissions boundaries. Resource-based policies that specify 
the user or role in the Principal  ﬁeld are not limited by the permissions boundary. An explicit deny 
in any of these policies overrides the allow. For more information about permissions boundaries, see
Permissions boundaries for IAM entities in the IAM User Guide .
•Service control policies (SCPs) – SCPs are JSON policies that specify the maximum permissions for 
an organization or organizational unit (OU) in AWS Organizations. AWS Organizations is a service for 
grouping and centrally managing multiple AWS accounts that your business owns. If you enable all 
features in an organization, then you can apply service control policies (SCPs) to any or all of your 
accounts. The SCP limits permissions for entities in member accounts, including each AWS account 
root user. For more information about Organizations and SCPs, see How SCPs work in the AWS 
Organizations User Guide .
•Session policies  – Session policies are advanced policies that you pass as a parameter when you 
programmatically create a temporary session for a role or federated user. The resulting session's 
permissions are the intersection of the user or role's identity-based policies and the session policies. 
949AWS Lambda Developer Guide
How AWS Lambda works with IAM
Permissions can also come from a resource-based policy. An explicit deny in any of these policies 
overrides the allow. For more information, see Session policies  in the IAM User Guide .
Multiple policy types
When multiple types of policies apply to a request, the resulting permissions are more complicated to 
understand. To learn how AWS determines whether to allow a request when multiple policy types are 
involved, see Policy evaluation logic in the IAM User Guide .
How AWS Lambda works with IAM
Before you use IAM to manage access to Lambda, you should understand what IAM features are available 
to use with Lambda. To get a high-level view of how Lambda and other AWS services work with IAM, see
AWS services that work with IAM in the IAM User Guide .
For an overview of permissions, policies, and roles as they are used by Lambda, see Lambda resource 
access permissions (p. 912).
AWS Lambda identity-based policy examples
By default, users and roles don't have permission to create or modify Lambda resources. They also can't 
perform tasks using the AWS Management Console, AWS CLI, or AWS API. An administrator must create 
IAM policies that grant users and roles permission to perform speciﬁc API operations on the speciﬁed 
resources they need. The administrator must then attach those policies to the users or groups that 
require those permissions.
To learn how to create an IAM identity-based policy using these example JSON policy documents, see
Creating policies on the JSON tab in the IAM User Guide .
Topics
•Policy best practices (p. 950)
•Using the Lambda console (p. 951)
•Allow users to view their own permissions (p. 951)
Policy best practices
Identity-based policies determine whether someone can create, access, or delete Lambda resources in 
your account. These actions can incur costs for your AWS account. When you create or edit identity-based 
policies, follow these guidelines and recommendations:
•Get started with AWS managed policies and move toward least-privilege permissions – To get 
started granting permissions to your users and workloads, use the AWS managed policies that grant 
permissions for many common use cases. They are available in your AWS account. We recommend that 
you reduce permissions further by deﬁning AWS customer managed policies that are speciﬁc to your 
use cases. For more information, see AWS managed policies or AWS managed policies for job functions
in the IAM User Guide .
•Apply least-privilege permissions – When you set permissions with IAM policies, grant only the 
permissions required to perform a task. You do this by deﬁning the actions that can be taken on 
speciﬁc resources under speciﬁc conditions, also known as least-privilege permissions . For more 
information about using IAM to apply permissions, see  Policies and permissions in IAM in the IAM User 
Guide .
•Use conditions in IAM policies to further restrict access – You can add a condition to your policies to 
limit access to actions and resources. For example, you can write a policy condition to specify that all 
950AWS Lambda Developer Guide
Identity-based policy examples
requests must be sent using SSL. You can also use conditions to grant access to service actions if they 
are used through a speciﬁc AWS service, such as AWS CloudFormation. For more information, see  IAM 
JSON policy elements: Condition in the IAM User Guide .
•Use IAM Access Analyzer to validate your IAM policies to ensure secure and functional permissions
– IAM Access Analyzer validates new and existing policies so that the policies adhere to the IAM 
policy language (JSON) and IAM best practices. IAM Access Analyzer provides more than 100 policy 
checks and actionable recommendations to help you author secure and functional policies. For more 
information, see IAM Access Analyzer policy validation in the IAM User Guide .
•Require multi-factor authentication (MFA) – If you have a scenario that requires IAM users or a root 
user in your AWS account, turn on MFA for additional security. To require MFA when API operations are 
called, add MFA conditions to your policies. For more information, see  Conﬁguring MFA-protected API 
access in the IAM User Guide .
For more information about best practices in IAM, see Security best practices in IAM in the IAM User 
Guide .
Using the Lambda console
To access the AWS Lambda console, you must have a minimum set of permissions. These permissions 
must allow you to list and view details about the Lambda resources in your AWS account. If you create an 
identity-based policy that is more restrictive than the minimum required permissions, the console won't 
function as intended for entities (users or roles) with that policy.
For an example policy that grants minimal access for function development, see Function 
development (p. 920). In addition to Lambda APIs, the Lambda console uses other services to display 
trigger conﬁguration and let you add new triggers. If your users use Lambda with other services, they 
need access to those services as well. For details on conﬁguring other services with Lambda, see Using 
AWS Lambda with other services (p. 628).
Allow users to view their own permissions
This example shows how you might create a policy that allows IAM users to view the inline and managed 
policies that are attached to their user identity. This policy includes permissions to complete this action 
on the console or programmatically using the AWS CLI or AWS API.
{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Sid": "ViewOwnUserInfo", 
            "Effect": "Allow", 
            "Action": [ 
                "iam:GetUserPolicy", 
                "iam:ListGroupsForUser", 
                "iam:ListAttachedUserPolicies", 
                "iam:ListUserPolicies", 
                "iam:GetUser" 
            ], 
            "Resource": ["arn:aws:iam::*:user/${aws:username}"] 
        }, 
        { 
            "Sid": "NavigateInConsole", 
            "Effect": "Allow", 
            "Action": [ 
                "iam:GetGroupPolicy", 
                "iam:GetPolicyVersion", 
                "iam:GetPolicy", 
                "iam:ListAttachedGroupPolicies", 
951AWS Lambda Developer Guide
AWS managed policies
                "iam:ListGroupPolicies", 
                "iam:ListPolicyVersions", 
                "iam:ListPolicies", 
                "iam:ListUsers" 
            ], 
            "Resource": "*" 
        } 
    ]
}
AWS managed policies for AWS Lambda
An AWS managed policy is a standalone policy that is created and administered by AWS. AWS managed 
policies are designed to provide permissions for many common use cases so that you can start assigning 
permissions to users, groups, and roles.
Keep in mind that AWS managed policies might not grant least-privilege permissions for your speciﬁc 
use cases because they're available for all AWS customers to use. We recommend that you reduce 
permissions further by deﬁning  customer managed policies  that are speciﬁc to your use cases.
You cannot change the permissions deﬁned in AWS managed policies. If AWS updates the permissions 
deﬁned in an AWS managed policy, the update aﬀects all principal identities (users, groups, and roles) 
that the policy is attached to. AWS is most likely to update an AWS managed policy when a new AWS 
service is launched or new API operations become available for existing services.
For more information, see AWS managed policies in the IAM User Guide .
Topics
•AWS managed policy: AWSLambda_FullAccess (p. 952)
•AWS managed policy: AWSLambda_ReadOnlyAccess (p. 953)
•AWS managed policy: AWSLambdaBasicExecutionRole (p. 953)
•AWS managed policy: AWSLambdaDynamoDBExecutionRole (p. 954)
•AWS managed policy: AWSLambdaENIManagementAccess (p. 954)
•AWS managed policy: AWSLambdaExecute (p. 954)
•AWS managed policy: AWSLambdaInvocation-DynamoDB (p. 954)
•AWS managed policy: AWSLambdaKinesisExecutionRole (p. 954)
•AWS managed policy: AWSLambdaMSKExecutionRole (p. 954)
•AWS managed policy: AWSLambdaRole (p. 955)
•AWS managed policy: AWSLambdaSQSQueueExecutionRole (p. 955)
•AWS managed policy: AWSLambdaVPCAccessExecutionRole (p. 955)
•Lambda updates to AWS managed policies (p. 955)
AWS managed policy: AWSLambda_FullAccess
This policy grants full access to Lambda actions. It also grants permissions to other AWS services that are 
used to develop and maintain Lambda resources.
You can attach the AWSLambda_FullAccess  policy to your users, groups, and roles.
Permissions details
This policy includes the following permissions:
•lambda – Allows principals full access to Lambda.
952AWS Lambda Developer Guide
AWS managed policies
•cloudformation  – Allows principals to describe AWS CloudFormation stacks and list the resources in 
those stacks.
•cloudwatch  – Allows principals to list Amazon CloudWatch metrics and get metric data.
•ec2 – Allows principals to describe security groups, subnets, and VPCs.
•iam – Allows principals to get policies, policy versions, roles, role policies, attached role policies, and 
the list of roles. This policy also allows principals to pass roles to Lambda. The PassRole  permission is 
used when you assign an execution role to a function.
•kms – Allows principals to list aliases.
•logs – Allows principals to describe Amazon CloudWatch log groups. For log groups that are 
associated with a Lambda function, this policy allows the principal to describe log streams, get log 
events, and ﬁlter log events.
•states – Allows principals to describe and list AWS Step Functions state machines.
•tag – Allows principals to get resources based on their tags.
•xray – Allows principals to get AWS X-Ray trace summaries and retrieve a list of traces speciﬁed by ID.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambda_FullAccess in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambda_ReadOnlyAccess
This policy grants read-only access to Lambda resources and to other AWS services that are used to 
develop and maintain Lambda resources.
You can attach the AWSLambda_ReadOnlyAccess  policy to your users, groups, and roles.
Permissions details
This policy includes the following permissions:
•lambda – Allows principals to get and list all resources.
•cloudformation  – Allows principals to describe and list AWS CloudFormation stacks and list the 
resources in those stacks.
•cloudwatch  – Allows principals to list Amazon CloudWatch metrics and get metric data.
•ec2 – Allows principals to describe security groups, subnets, and VPCs.
•iam – Allows principals to get policies, policy versions, roles, role policies, attached role policies, and 
the list of roles.
•kms – Allows principals to list aliases.
•logs – Allows principals to describe Amazon CloudWatch log groups. For log groups that are 
associated with a Lambda function, this policy allows the principal to describe log streams, get log 
events, and ﬁlter log events.
•states – Allows principals to describe and list AWS Step Functions state machines.
•tag – Allows principals to get resources based on their tags.
•xray – Allows principals to get AWS X-Ray trace summaries and retrieve a list of traces speciﬁed by ID.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambda_ReadOnlyAccess in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaBasicExecutionRole
This policy grants permissions to upload logs to CloudWatch Logs.
You can attach the AWSLambdaBasicExecutionRole  policy to your users, groups, and roles.
953AWS Lambda Developer Guide
AWS managed policies
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaBasicExecutionRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaDynamoDBExecutionRole
This policy grants permissions to read records from an Amazon DynamoDB stream and write to 
CloudWatch Logs.
You can attach the AWSLambdaDynamoDBExecutionRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaDynamoDBExecutionRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaENIManagementAccess
This policy grants permissions to create, describe, and delete elastic network interfaces used by a VPC-
enabled Lambda function.
You can attach the AWSLambdaENIManagementAccess  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaENIManagementAccess in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaExecute
This policy grants PUT and GET access to Amazon Simple Storage Service and full access to CloudWatch 
Logs.
You can attach the AWSLambdaExecute  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaExecute in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaInvocation-DynamoDB
This policy grants read access to Amazon DynamoDB Streams.
You can attach the AWSLambdaInvocation-DynamoDB  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaInvocation-DynamoDB in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaKinesisExecutionRole
This policy grants permissions to read events from an Amazon Kinesis data stream and write to 
CloudWatch Logs.
You can attach the AWSLambdaKinesisExecutionRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaKinesisExecutionRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaMSKExecutionRole
This policy grants permissions to read and access records from an Amazon Managed Streaming for 
Apache Kafka cluster, manage elastic network interfaces, and write to CloudWatch Logs.
954AWS Lambda Developer Guide
Troubleshooting
You can attach the AWSLambdaMSKExecutionRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaMSKExecutionRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaRole
This policy grants permissions to invoke Lambda functions.
You can attach the AWSLambdaRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaSQSQueueExecutionRole
This policy grants permissions to read and delete messages from an Amazon Simple Queue Service 
queue, and grants write permissions to CloudWatch Logs.
You can attach the AWSLambdaSQSQueueExecutionRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaSQSQueueExecutionRole in the AWS Managed Policy Reference Guide.
AWS managed policy: AWSLambdaVPCAccessExecutionRole
This policy grants permissions to manage elastic network interfaces within an Amazon Virtual Private 
Cloud and write to CloudWatch Logs.
You can attach the AWSLambdaVPCAccessExecutionRole  policy to your users, groups, and roles.
For more information about this policy, including the JSON policy document and policy versions, see
AWSLambdaVPCAccessExecutionRole in the AWS Managed Policy Reference Guide.
Lambda updates to AWS managed policies
Change Description Date
AWSLambda_ReadOnlyAccess – 
ChangeLambda updated the
AWSLambda_ReadOnlyAccess
policy to allow principals to list 
AWS CloudFormation stacks.July 27, 2023
AWS Lambda started tracking 
changesAWS Lambda started tracking 
changes for its AWS managed 
policies.July 27, 2023
Troubleshooting AWS Lambda identity and access
Use the following information to help you diagnose and ﬁx common issues that you might encounter 
when working with Lambda and IAM.
Topics
955AWS Lambda Developer Guide
Troubleshooting
•I am not authorized to perform an action in Lambda (p. 956)
•I am not authorized to perform iam:PassRole (p. 956)
•I'm an administrator and want to migrate from AWS managed policies for Lambda that will be 
deprecated (p. 956)
•I want to allow people outside of my AWS account to access my Lambda resources (p. 957)
I am not authorized to perform an action in Lambda
If the AWS Management Console tells you that you're not authorized to perform an action, then you 
must contact your administrator for assistance. Your administrator is the person that provided you with 
your sign-in credentials.
The following example error occurs when the mateojackson  user tries to use the console to view details 
about a function but does not have lambda:GetFunction  permissions.
User: arn:aws:iam::123456789012:user/mateojackson is not authorized to perform: 
 lambda:GetFunction on resource: my-function
In this case, Mateo asks his administrator to update his policies to allow him to access the my-function
resource using the lambda:GetFunction  action.
I am not authorized to perform iam:PassRole
If you receive an error that you're not authorized to perform the iam:PassRole  action, your policies 
must be updated to allow you to pass a role to Lambda.
Some AWS services allow you to pass an existing role to that service instead of creating a new service 
role or service-linked role. To do this, you must have permissions to pass the role to the service.
The following example error occurs when an IAM user named marymajor  tries to use the console to 
perform an action in Lambda. However, the action requires the service to have permissions that are 
granted by a service role. Mary does not have permissions to pass the role to the service.
User: arn:aws:iam::123456789012:user/ marymajor  is not authorized to perform: iam:PassRole
In this case, Mary's policies must be updated to allow her to perform the iam:PassRole  action.
If you need help, contact your AWS administrator. Your administrator is the person who provided you 
with your sign-in credentials.
I'm an administrator and want to migrate from AWS managed 
policies for Lambda that will be deprecated
After March 1, 2021, the AWS managed policies AWSLambdaReadOnlyAccess and
AWSLambdaFullAccess will be deprecated and can no longer be attached to new users. For more 
information about policy deprecations, see Deprecated AWS managed policies in the IAM User Guide .
Lambda has introduced two new AWS managed policies:
•The AWSLambda_ReadOnlyAccess policy grants read-only access to Lambda, Lambda console 
features, and other related AWS services. This policy was created by scoping down the previous policy
AWSLambdaReadOnlyAccess.
956AWS Lambda Developer Guide
Compliance validation
•The AWSLambda_FullAccess policy grants full access to Lambda, Lambda console features, 
and other related AWS services. This policy was created by scoping down the previous policy
AWSLambdaFullAccess.
Using the AWS managed policies
We recommend using the newly launched managed policies to grant users, groups, and roles access to 
Lambda; however, review the permissions granted in the policies to ensure they meet your requirements.
•To review the permissions of the AWSLambda_ReadOnlyAccess policy, see the
AWSLambda_ReadOnlyAccess policy page in the IAM console.
•To review the permissions of the AWSLambda_FullAccess policy, see the AWSLambda_FullAccess
policy page in the IAM console.
After reviewing the permissions, you can attach the policies to an IAM identity (groups, users, or roles). 
For instructions about attaching an AWS managed policy, see Adding and removing IAM identity 
permissions  in the IAM User Guide .
Using customer managed policies
If you need more ﬁne-grained access control or would like to add permissions, you can create your own
customer managed policies . For more information, see Creating policies on the JSON tab in the IAM User 
Guide .
I want to allow people outside of my AWS account to access my 
Lambda resources
You can create a role that users in other accounts or people outside of your organization can use to 
access your resources. You can specify who is trusted to assume the role. For services that support 
resource-based policies or access control lists (ACLs), you can use those policies to grant people access to 
your resources.
To learn more, consult the following:
•To learn whether Lambda supports these features, see How AWS Lambda works with IAM (p. 950).
•To learn how to provide access to your resources across AWS accounts that you own, see Providing 
access to an IAM user in another AWS account that you own in the IAM User Guide .
•To learn how to provide access to your resources to third-party AWS accounts, see Providing access to 
AWS accounts owned by third parties in the IAM User Guide .
•To learn how to provide access through identity federation, see Providing access to externally 
authenticated users (identity federation) in the IAM User Guide .
•To learn the diﬀerence between using roles and resource-based policies for cross-account access, see
How IAM roles diﬀer from resource-based policies in the IAM User Guide .
Compliance validation for AWS Lambda
Third-party auditors assess the security and compliance of AWS Lambda as part of multiple AWS 
compliance programs. These include SOC, PCI, FedRAMP, HIPAA, and others.
For a list of AWS services in scope of speciﬁc compliance programs, see AWS services in scope by 
compliance program. For general information, see AWS compliance programs.
957AWS Lambda Developer Guide
Resilience
You can download third-party audit reports using AWS Artifact. For more information, see Downloading 
reports in AWS artifact.
Your compliance responsibility when using Lambda is determined by the sensitivity of your data, your 
company's compliance objectives, and applicable laws and regulations. AWS provides the following 
resources to help with compliance:
•Security and compliance quick start guides – These deployment guides discuss architectural 
considerations and provide steps for deploying security- and compliance-focused baseline 
environments on AWS.
•Architecting for HIPAA Security and Compliance on Amazon Web Services – This whitepaper describes 
how companies can use AWS to create HIPAA-compliant applications.
•AWS compliance resources – This collection of workbooks and guides might apply to your industry and 
location.
•AWS Conﬁg – This AWS service assesses how well your resource conﬁgurations comply with internal 
practices, industry guidelines, and regulations.
•AWS Security Hub – This AWS service provides a comprehensive view of your security state within AWS 
that helps you check your compliance with security industry standards and best practices.
Resilience in AWS Lambda
The AWS global infrastructure is built around AWS Regions and Availability Zones. AWS Regions provide 
multiple physically separated and isolated Availability Zones, which are connected with low-latency, 
high-throughput, and highly redundant networking. With Availability Zones, you can design and operate 
applications and databases that automatically fail over between Availability Zones without interruption. 
Availability Zones are more highly available, fault tolerant, and scalable than traditional single or 
multiple data center infrastructures.
For more information about AWS Regions and Availability Zones, see AWS global infrastructure.
In addition to the AWS global infrastructure, Lambda oﬀers several features to help support your data 
resiliency and backup needs.
•Versioning – You can use versioning in Lambda to save your function's code and conﬁguration as 
you develop it. Together with aliases, you can use versioning to perform blue/green and rolling 
deployments. For details, see Lambda function versions (p. 108).
•Scaling  – When your function receives a request while it's processing a previous request, Lambda 
launches another instance of your function to handle the increased load. Lambda automatically scales 
to handle 1,000 concurrent executions per Region, a quota  (p. 1269 ) that can be increased if needed. 
For details, see Lambda function scaling (p. 220).
•High availability – Lambda runs your function in multiple Availability Zones to ensure that it is 
available to process events in case of a service interruption in a single zone. If you conﬁgure your 
function to connect to a virtual private cloud (VPC) in your account, specify subnets in multiple 
Availability Zones to ensure high availability. For details, see Connecting outbound networking to 
resources in a VPC (p. 85).
•Reserved concurrency – To make sure that your function can always scale to handle additional 
requests, you can reserve concurrency for it. Setting reserved concurrency for a function ensures that 
it can scale to, but not exceed, a speciﬁed number of concurrent invocations. This ensures that you 
don't lose requests due to other functions consuming all of the available concurrency. For details, see
Conﬁguring reserved concurrency (p. 234).
•Retries – For asynchronous invocations and a subset of invocations triggered by other services, 
Lambda automatically retries on error with delays between retries. Other clients and AWS services that 
invoke functions synchronously are responsible for performing retries. For details, see Error handling 
and automatic retries in AWS Lambda (p. 181).
958AWS Lambda Developer Guide
Infrastructure security
•Dead-letter queue – For asynchronous invocations, you can conﬁgure Lambda to send requests to a 
dead-letter queue if all retries fail. A dead-letter queue is an Amazon SNS topic or Amazon SQS queue 
that receives events for troubleshooting or reprocessing. For details, see Dead-letter queues (p. 148).
Infrastructure security in AWS Lambda
As a managed service, AWS Lambda is protected by AWS global network security. For information about 
AWS security services and how AWS protects infrastructure, see AWS Cloud Security. To design your AWS 
environment using the best practices for infrastructure security, see Infrastructure Protection in Security 
Pillar AWS Well‐Architected Framework.
You use AWS published API calls to access Lambda through the network. Clients must support the 
following:
•Transport Layer Security (TLS). We require TLS 1.2 and recommend TLS 1.3.
•Cipher suites with perfect forward secrecy (PFS) such as DHE (Ephemeral Diﬃe-Hellman) or ECDHE 
(Elliptic Curve Ephemeral Diﬃe-Hellman). Most modern systems such as Java 7 and later support these 
modes.
Additionally, requests must be signed by using an access key ID and a secret access key that is associated 
with an IAM principal. Or you can use the AWS Security Token Service (AWS STS) to generate temporary 
security credentials to sign requests.
Conﬁguration and vulnerability analysis in AWS 
Lambda
AWS Lambda provides runtimes  (p. 41) that run your function code in an Amazon Linux–based execution 
environment. Lambda is responsible for keeping software in the runtime and execution environment up 
to date, releasing new runtimes for new languages and frameworks, and deprecating runtimes when the 
underlying software is no longer supported.
If you use additional libraries with your function, you're responsible for updating the libraries. You can 
include additional libraries in the deployment package (p. 122), or in layers (p. 988) that you attach 
to your function. You can also build custom runtimes  (p. 60) and use layers to share them with other 
accounts.
Lambda deprecates runtimes when the software on the runtime or its execution environment reaches 
end of life. When Lambda deprecates a runtime, you're responsible for migrating your functions 
to a supported runtime for the same language or framework. For details, see Runtime deprecation 
policy (p. 42).
Sections
•Detect vulnerabilities in your Lambda functions With Amazon Inspector (p. 959)
Detect vulnerabilities in your Lambda functions With 
Amazon Inspector
You can use Amazon Inspector to detect security vulnerabilities in your Lambda functions and 
layers. Amazon Inspector is an automated vulnerability scanning service that discovers and reports 
959AWS Lambda Developer Guide
Detect vulnerabilities in your Lambda 
functions With Amazon Inspector
vulnerabilities based on its vulnerability intelligence database. The Amazon Inspector vulnerability 
intelligence database sources data from internal AWS security research teams, paid vendor feeds, and 
industry-standard security advisories.
Amazon Inspector automatically creates an inventory of your active Lambda functions and layers then 
continuously monitors them for software package vulnerabilities. When Amazon Inspector discovers a 
vulnerability, it generates a ﬁnding that contains details about the security issue, and how to remediate 
the issue. You can view Amazon Inspector ﬁndings in the Amazon Inspector console or process them 
through other AWS services.
For information on activating and conﬁguring Amazon Inspector Lambda scanning, see Scanning 
Lambda functions with Amazon Inspector.
960AWS Lambda Developer Guide
Monitoring and troubleshooting 
Lambda functions
AWS Lambda integrates with other AWS services to help you monitor and troubleshoot your Lambda 
functions. Lambda automatically monitors Lambda functions on your behalf and reports metrics through 
Amazon CloudWatch. To help you monitor your code when it runs, Lambda automatically tracks the 
number of requests, the invocation duration per request, and the number of requests that result in an 
error.
You can use other AWS services to troubleshoot your Lambda functions. This section describes how 
to use these AWS services to monitor, trace, debug, and troubleshoot your Lambda functions and 
applications. For details about function logging and errors in each runtime, see individual runtime 
sections.
For more information about monitoring Lambda applications, see  Monitoring and observability in 
Serverless Land.
Sections
•Monitoring functions on the Lambda console (p. 962)
•Working with Lambda function metrics (p. 965)
•Accessing Amazon CloudWatch logs for AWS Lambda (p. 969)
•Using AWS Lambda with AWS X-Ray (p. 973)
•Using Lambda Insights in Amazon CloudWatch (p. 977)
•Using CodeGuru Proﬁler with your Lambda function (p. 983)
•Example workﬂows using other AWS services (p. 985)
961AWS Lambda Developer Guide
Monitoring console
Monitoring functions on the Lambda console
Lambda monitors functions on your behalf and sends metrics to Amazon CloudWatch. The Lambda 
console creates monitoring graphs for these metrics and shows them on the Monitoring  page for each 
Lambda function.
This page describes the basics of using the Lambda console to view function metrics, including total 
requests, duration, and error rates.
Pricing
CloudWatch has a perpetual free tier. Beyond the free tier threshold, CloudWatch charges for metrics, 
dashboards, alarms, logs, and insights. For more information, see Amazon CloudWatch pricing.
Using the Lambda console
You can monitor your Lambda functions and applications on the Lambda console.
To monitor a function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose the Monitor  tab.
Types of monitoring graphs
The following section describes the monitoring graphs on the Lambda console.
Lambda monitoring graphs
•Invocations – The number of times that the function was invoked.
•Duration  – The average, minimum, and maximum amount of time your function code spends 
processing an event.
•Error count and success rate (%) – The number of errors and the percentage of invocations that 
completed without error.
•Throttles – The number of times that an invocation failed due to concurrency limits.
•IteratorAge  – For stream event sources, the age of the last item in the batch when Lambda received it 
and invoked the function.
•Async delivery failures – The number of errors that occurred when Lambda attempted to write to a 
destination or dead-letter queue.
•Concurrent executions – The number of function instances that are processing events.
Viewing graphs on the Lambda console
The following section describes how to view CloudWatch monitoring graphs on the Lambda console, and 
open the CloudWatch metrics dashboard.
To view monitoring graphs for a function
1. Open the Functions page of the Lambda console.
962AWS Lambda Developer Guide
Viewing queries on the CloudWatch Logs console
2. Choose a function.
3. Choose the Monitor  tab.
4. On the Metrics , Logs , or Traces tab, choose from the predeﬁned time ranges, or choose a custom 
time range.
5. To see the deﬁnition of a graph in CloudWatch, choose the three vertical dots (Widget actions), and 
then choose View in metrics  to open the Metrics  dashboard on the CloudWatch console.
Viewing queries on the CloudWatch Logs console
The following section describes how to view and add reports from CloudWatch Logs Insights to a custom 
dashboard on the CloudWatch Logs console.
To view reports for a function
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose the Monitor  tab.
4. Choose View logs in CloudWatch.
5. Choose View in Logs Insights .
6. Choose from the predeﬁned time ranges, or choose a custom time range.
7. Choose Run query.
8. (Optional) Choose Save.
963AWS Lambda Developer Guide
What's next?
What's next?
•Learn about the metrics that Lambda records and sends to CloudWatch in Working with Lambda 
function metrics (p. 965).
•Learn how to use CloudWatch Lambda Insights to collect and aggregate Lambda function runtime 
performance metrics and logs in Using Lambda Insights in Amazon CloudWatch (p. 977).
964AWS Lambda Developer Guide
Function metrics
Working with Lambda function metrics
When your AWS Lambda function ﬁnishes processing an event, Lambda sends metrics about the 
invocation to Amazon CloudWatch. There is no charge for these metrics.
On the CloudWatch console, you can build graphs and dashboards with these metrics. You can set 
alarms to respond to changes in utilization, performance, or error rates. Lambda sends metric data to 
CloudWatch in 1-minute intervals. For more immediate insight into your Lambda function, you can 
create high-resolution  custom metrics  as described in Serverless Land. Charges apply for custom metrics 
and CloudWatch alarms. For more information, see Amazon CloudWatch Pricing.
This page describes the Lambda function invocation, performance, and concurrency metrics available on 
the CloudWatch console.
Sections
•Viewing metrics on the CloudWatch console (p. 965)
•Types of metrics (p. 965)
Viewing metrics on the CloudWatch console
You can use the CloudWatch console to ﬁlter and sort function metrics by function name, alias, or 
version.
To view metrics on the CloudWatch console
1. Open the Metrics page  (AWS/Lambda  namespace) of the CloudWatch console.
2. On the Browse tab, under Metrics , choose any of the following dimensions:
•By Function Name (FunctionName ) – View aggregate metrics for all versions and aliases of a 
function.
•By Resource (Resource ) – View metrics for a version or alias of a function.
•By Executed Version (ExecutedVersion ) – View metrics for a combination of alias and version. 
Use the ExecutedVersion  dimension to compare error rates for two versions of a function that 
are both targets of a weighted alias (p. 104).
•Across All Functions (none) – View aggregate metrics for all functions in the current AWS Region.
3. Choose a metric, then choose Add to graph  or another graphing option.
By default, graphs use the Sum statistic for all metrics. To choose a diﬀerent statistic and customize the 
graph, use the options on the Graphed metrics  tab.
Note
The timestamp on a metric reﬂects when the function was invoked. Depending on the duration 
of the invocation, this can be several minutes before the metric is emitted. For example, if your 
function has a 10-minute timeout, then look more than 10 minutes in the past for accurate 
metrics.
For more information about CloudWatch, see the Amazon CloudWatch User Guide.
Types of metrics
The following section describes the types of Lambda metrics available on the CloudWatch console.
965AWS Lambda Developer Guide
Types of metrics
Invocation metrics
Invocation metrics are binary indicators of the outcome of a Lambda function invocation. For example, 
if the function returns an error, then Lambda sends the Errors metric with a value of 1. To get a count 
of the number of function errors that occurred each minute, view the Sum of the Errors  metric with a 
period of 1 minute.
Note
View the following invocation metrics with the Sum statistic.
•Invocations  – The number of times that your function code is invoked, including successful 
invocations and invocations that result in a function error. Invocations aren't recorded if the invocation 
request is throttled or otherwise results in an invocation error. The value of Invocations  equals the 
number of requests billed.
•Errors – The number of invocations that result in a function error. Function errors include exceptions 
that your code throws and exceptions that the Lambda runtime throws. The runtime returns errors 
for issues such as timeouts and conﬁguration errors. To calculate the error rate, divide the value of
Errors by the value of Invocations . Note that the timestamp on an error metric reﬂects when the 
function was invoked, not when the error occurred.
•DeadLetterErrors  – For asynchronous invocation (p. 142), the number of times that Lambda 
attempts to send an event to a dead-letter queue (DLQ) but fails. Dead-letter errors can occur due to 
misconﬁgured resources or size limits.
•DestinationDeliveryFailures  – For asynchronous invocation and supported event source 
mappings , the number of times that Lambda attempts to send an event to a destination  (p. 38) but 
fails. For event source mappings, Lambda supports destinations for stream sources (DynamoDB and 
Kinesis). Delivery errors can occur due to permissions errors, misconﬁgured resources, or size limits. 
Errors can also occur if the destination you have conﬁgured is an unsupported type such as an Amazon 
SQS FIFO queue or an Amazon SNS FIFO topic.
•Throttles  – The number of invocation requests that are throttled. When all function instances are 
processing requests and no concurrency is available to scale up, Lambda rejects additional requests 
with a TooManyRequestsException  error. Throttled requests and other invocation errors don't 
count as either Invocations  or Errors .
•OversizedRecordCount  – For Amazon DocumentDB event sources, the number of events your 
function receives from your change stream that are over 6 MB in size. Lambda drops the message and 
emits this metric.
•ProvisionedConcurrencyInvocations  – The number of times that your function code is invoked 
using provisioned concurrency (p. 237).
•ProvisionedConcurrencySpilloverInvocations  – The number of times that your function code 
is invoked using standard concurrency when all provisioned concurrency is in use.
•RecursiveInvocationsDropped  – The number of times that Lambda has stopped invocation of 
your function because it's detected that your function is part of an inﬁnite recursive loop. Lambda 
recursive loop detection (p. 184) monitors how many times a function is invoked as part of a chain of 
requests by tracking metadata added by supported AWS SDKs. If your function is invoked as part of a 
chain of requests more than 16 times, Lambda drops the next invocation.
Performance metrics
Performance metrics provide performance details about a single function invocation. For example, the
Duration  metric indicates the amount of time in milliseconds that your function spends processing an 
event. To get a sense of how fast your function processes events, view these metrics with the Average  or
Max statistic.
•Duration  – The amount of time that your function code spends processing an event. The billed 
duration for an invocation is the value of Duration  rounded up to the nearest millisecond.
966AWS Lambda Developer Guide
Types of metrics
•PostRuntimeExtensionsDuration  – The cumulative amount of time that the runtime spends 
running code for extensions after the function code has completed.
•IteratorAge  – For DynamoDB, Kinesis, and Amazon DocumentDB event sources, the age of the last 
record in the event. This metric measures the time between when a stream receives the record and 
when the event source mapping sends the event to the function.
•OffsetLag  – For self-managed Apache Kafka and Amazon Managed Streaming for Apache Kafka 
(Amazon MSK) event sources, the diﬀerence in oﬀset between the last record written to a topic and 
the last record that your function's consumer group processed. Though a Kafka topic can have multiple 
partitions, this metric measures the oﬀset lag at the topic level.
Duration  also supports percentile (p) statistics. Use percentiles to exclude outlier values that skew
Average  and Maximum statistics. For example, the p95 statistic shows the maximum duration of 95 
percent of invocations, excluding the slowest 5 percent. For more information, see Percentiles in the
Amazon CloudWatch User Guide.
Concurrency metrics
Lambda reports concurrency metrics as an aggregate count of the number of instances processing 
events across a function, version, alias, or AWS Region. To see how close you are to hitting concurrency 
limits  (p. 232), view these metrics with the Max statistic.
•ConcurrentExecutions  – The number of function instances that are processing events. If 
this number reaches your concurrent executions quota (p. 1269 ) for the Region, or the reserved 
concurrency (p. 234) limit on the function, then Lambda throttles additional invocation requests.
•ProvisionedConcurrentExecutions  – The number of function instances that are processing 
events using provisioned concurrency (p. 237). For each invocation of an alias or version with 
provisioned concurrency, Lambda emits the current count.
•ProvisionedConcurrencyUtilization  – For a version or alias, the value of
ProvisionedConcurrentExecutions  divided by the total amount of provisioned concurrency 
allocated. For example, .5 indicates that 50 percent of allocated provisioned concurrency is in use.
•UnreservedConcurrentExecutions  – For a Region, the number of events that functions without 
reserved concurrency are processing.
Asynchronous invocation metrics
Asynchronous invocation metrics provide details about asynchronous invocations from event 
sources and direct invocations. You can set thresholds and alarms to notify you of certain changes. 
For example, when there's an undesired increase in the number of events queued for processing 
(AsyncEventsReceived ). Or, when an event has been waiting a long time to be processed 
(AsyncEventAge ).
•AsyncEventsReceived  – The number of events that Lambda successfully queues for processing. 
This metric provides insight into the number of events that a Lambda function receives. Monitor this 
metric and set alarms for thresholds to check for issues. For example, to detect an undesirable number 
of events sent to Lambda, and to quickly diagnose issues resulting from incorrect trigger or function 
conﬁgurations. Mismatches between AsyncEventsReceived  and Invocations  can indicate a 
disparity in processing, events being dropped, or a potential queue backlog.
•AsyncEventAge  – The time between when Lambda successfully queues the event and when the 
function is invoked. The value of this metric increases when events are being retried due to invocation 
failures or throttling. Monitor this metric and set alarms for thresholds on diﬀerent statistics for when 
a queue buildup occurs. To troubleshoot an increase in this metric, look at the Errors  metric to 
identify function errors and the Throttles  metric to identify concurrency issues.
•AsyncEventsDropped  – The number of events that are dropped without successfully executing the 
function. If you conﬁgure a dead-letter queue (DLQ) or OnFailure  destination, then events are sent 
967AWS Lambda Developer Guide
Types of metrics
there before they're dropped. Events are dropped for various reasons. For example, events can exceed 
the maximum event age or exhaust the maximum retry attempts, or reserved concurrency might be 
set to 0. To troubleshoot why events are dropped, look at the Errors metric to identify function 
errors and the Throttles  metric to identify concurrency issues.
968AWS Lambda Developer Guide
Function logs
Accessing Amazon CloudWatch logs for AWS 
Lambda
AWS Lambda automatically monitors Lambda functions on your behalf, pushing logs to Amazon 
CloudWatch. To help you troubleshoot failures in a function, after you set up permissions, Lambda logs 
all requests handled by your function and also automatically stores logs generated by your code through 
Amazon CloudWatch Logs.
You can insert logging statements into your code to help you validate that your code is working as 
expected. Lambda automatically integrates with CloudWatch Logs and pushes all logs from your code to 
a CloudWatch Logs group associated with a Lambda function, which is named /aws/lambda/<function 
name> .
You can view logs for Lambda functions using the Lambda console, the CloudWatch console, the AWS 
Command Line Interface (AWS CLI), or the CloudWatch API.
Note
It may take 5 to 10 minutes for logs to show up after a function invocation.
Section
•Prerequisites (p. 969)
•Pricing  (p. 969)
•Accessing logs with the Lambda console (p. 969)
•Accessing logs with the AWS CLI (p. 970)
•Runtime function logging (p. 972)
•What's next? (p. 972)
Prerequisites
Your execution role (p. 913) needs permission to upload logs to CloudWatch Logs. You can add 
CloudWatch Logs permissions using the AWSLambdaBasicExecutionRole  AWS managed policy 
provided by Lambda. To add this policy to your role, run the following command:
aws iam attach-role-policy --role-name your-role  --policy-arn arn:aws:iam::aws:policy/
service-role/AWSLambdaBasicExecutionRole
For more information, see AWS managed policies for Lambda features (p. 915).
Pricing
There is no additional charge for using Lambda logs; however, standard CloudWatch Logs charges apply. 
For more information, see CloudWatch pricing.
Accessing logs with the Lambda console
To view logs using the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Monitor .
969AWS Lambda Developer Guide
Using the AWS CLI
4. Choose View logs in CloudWatch.
Accessing logs with the AWS CLI
The AWS CLI is an open-source tool that enables you to interact with AWS services using commands in 
your command line shell. To complete the steps in this section, you must have the following:
•AWS Command Line Interface (AWS CLI) version 2
•AWS CLI – Quick conﬁguration with aws configure
You can use the AWS CLI to retrieve logs for an invocation using the --log-type  command option. 
The response contains a LogResult  ﬁeld that contains up to 4 KB of base64-encoded logs from the 
invocation.
Example retrieve a log ID
The following example shows how to retrieve a log ID  from the LogResult  ﬁeld for a function named
my-function .
aws lambda invoke --function-name my-function out --log-type Tail
You should see the following output:
{ 
    "StatusCode": 200, 
    "LogResult": 
 "U1RBUlQgUmVxdWVzdElkOiA4N2QwNDRiOC1mMTU0LTExZTgtOGNkYS0yOTc0YzVlNGZiMjEgVmVyc2lvb...", 
    "ExecutedVersion": "$LATEST"
}
Example decode the logs
In the same command prompt, use the base64 utility to decode the logs. The following example shows 
how to retrieve base64-encoded logs for my-function .
aws lambda invoke --function-name my-function out --log-type Tail \
--query 'LogResult' --output text --cli-binary-format raw-in-base64-out | base64 --decode
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
You should see the following output:
START RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8 Version: $LATEST
"AWS_SESSION_TOKEN": "AgoJb3JpZ2luX2VjELj...", "_X_AMZN_TRACE_ID": "Root=1-5d02e5ca-
f5792818b6fe8368e5b51d50;Parent=191db58857df8395;Sampled=0"",ask/lib:/opt/lib",
END RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8
REPORT RequestId: 57f231fb-1730-4395-85cb-4f71bd2b87b8  Duration: 79.67 ms      Billed 
 Duration: 80 ms         Memory Size: 128 MB     Max Memory Used: 73 MB
The base64 utility is available on Linux, macOS, and Ubuntu on Windows. macOS users may need to use
base64 -D .
970AWS Lambda Developer Guide
Using the AWS CLI
Example get-logs.sh script
In the same command prompt, use the following script to download the last ﬁve log events. The script 
uses sed to remove quotes from the output ﬁle, and sleeps for 15 seconds to allow time for the logs to 
become available. The output includes the response from Lambda and the output from the get-log-
events command.
Copy the contents of the following code sample and save in your Lambda project directory as get-
logs.sh .
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
#!/bin/bash
aws lambda invoke --function-name my-function --cli-binary-format raw-in-base64-out --
payload '{"key": "value"}' out
sed -i'' -e 's/"//g' out
sleep 15
aws logs get-log-events --log-group-name /aws/lambda/ my-function  --log-stream-name stream1
 --limit 5
Example macOS and Linux (only)
In the same command prompt, macOS and Linux users may need to run the following command to 
ensure the script is executable.
chmod -R 755 get-logs.sh
Example retrieve the last ﬁve log events
In the same command prompt, run the following script to get the last ﬁve log events.
./get-logs.sh
You should see the following output:
{ 
    "StatusCode": 200, 
    "ExecutedVersion": "$LATEST"
}
{ 
    "events": [ 
        { 
            "timestamp": 1559763003171, 
            "message": "START RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf Version: 
 $LATEST\n", 
            "ingestionTime": 1559763003309 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tENVIRONMENT VARIABLES\r{\r  \"AWS_LAMBDA_FUNCTION_VERSION\": \"$LATEST\",\r ...", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003173, 
            "message": "2019-06-05T19:30:03.173Z\t4ce9340a-b765-490f-ad8a-02ab3415e2bf
\tINFO\tEVENT\r{\r  \"key\": \"value\"\r}\n", 
971AWS Lambda Developer Guide
Runtime function logging
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "END RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\n", 
            "ingestionTime": 1559763018353 
        }, 
        { 
            "timestamp": 1559763003218, 
            "message": "REPORT RequestId: 4ce9340a-b765-490f-ad8a-02ab3415e2bf\tDuration: 
 26.73 ms\tBilled Duration: 27 ms \tMemory Size: 128 MB\tMax Memory Used: 75 MB\t\n", 
            "ingestionTime": 1559763018353 
        } 
    ], 
    "nextForwardToken": "f/34783877304859518393868359594929986069206639495374241795", 
    "nextBackwardToken": "b/34783877303811383369537420289090800615709599058929582080"
}
Runtime function logging
To debug and validate that your code is working as expected, you can output logs with the standard 
logging functionality for your programming language. The Lambda runtime uploads your function's log 
output to CloudWatch Logs. For language-speciﬁc instructions, see the following topics:
•AWS Lambda function logging in Node.js (p. 299)
•AWS Lambda function logging in Python (p. 374)
•AWS Lambda function logging in Ruby (p. 424)
•AWS Lambda function logging in Java (p. 469)
•AWS Lambda function logging in Go (p. 542)
•Lambda function logging in C# (p. 578)
•AWS Lambda function logging in PowerShell (p. 606)
What's next?
•Learn more about log groups and accessing them through the CloudWatch console in Monitoring 
system, application, and custom log ﬁles  in the Amazon CloudWatch User Guide.
972AWS Lambda Developer Guide
AWS X-Ray
Using AWS Lambda with AWS X-Ray
You can use AWS X-Ray to visualize the components of your application, identify performance 
bottlenecks, and troubleshoot requests that resulted in an error. Your Lambda functions send trace data 
to X-Ray, and X-Ray processes the data to generate a service map and searchable trace summaries.
If you've enabled X-Ray tracing in a service that invokes your function, Lambda sends traces to X-Ray 
automatically. The upstream service, such as Amazon API Gateway, or an application hosted on Amazon 
EC2 that is instrumented with the X-Ray SDK, samples incoming requests and adds a tracing header 
that tells Lambda to send traces or not. Traces from upstream message producers, such as Amazon SQS, 
are automatically linked to traces from downstream Lambda functions, creating an end-to-end view of 
the entire application. For more information, see Tracing event-driven applications in the AWS X-Ray 
Developer Guide .
Note
X-Ray tracing is currently not supported for Lambda functions with Amazon Managed Streaming 
for Apache Kafka (Amazon MSK), self-managed Apache Kafka, Amazon MQ with ActiveMQ and 
RabbitMQ, or Amazon DocumentDB event source mappings.
To toggle active tracing on your Lambda function with the console, follow these steps:
To turn on active tracing
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Conﬁguration  and then choose Monitoring and operations tools .
4. Choose Edit.
5. Under X-Ray, toggle on Active tracing.
6. Choose Save.
Pricing
You can use X-Ray tracing for free each month up to a certain limit as part of the AWS Free Tier. 
Beyond that threshold, X-Ray charges for trace storage and retrieval. For more information, see
AWS X-Ray pricing.
Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda 
console, Lambda adds the required permissions to your function's execution role (p. 913). Otherwise, add 
the AWSXRayDaemonWriteAccess policy to the execution role.
X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm to ensure that 
tracing is eﬃcient, while still providing a representative sample of all requests. The sampling rate is 1 
request per second and 5 percent of additional requests.
Note
You cannot conﬁgure the X-Ray sampling rate for your functions.
In X-Ray, a trace  records information about a request that is processed by one or more services. Services 
record segments  that contain layers of subsegments . Lambda records a segment for the Lambda service 
that handles the invocation request, and one for the work done by the function. The function segment 
comes with subsegments for Initialization , Invocation , Restore  (Lambda SnapStart (p. 1098 )
only), and Overhead . For more information, see  Lambda execution environment lifecycle (p. 14).
Note
X-Ray treats unhandled exceptions in your Lambda function as Error statuses. X-Ray records
Fault statuses only when Lambda experiences internal server errors. For more information, see
Errors, faults, and exceptions in the X-Ray Developer Guide.
973AWS Lambda Developer Guide
Execution role permissions
The Initialization  subsegment represents the init phase of the Lambda execution environment 
lifecycle. During this phase, Lambda creates or unfreezes an execution environment with the resources 
you have conﬁgured, downloads the function code and all layers, initializes extensions, initializes the 
runtime, and runs the function's initialization code.
The Invocation  subsegment represents the invoke phase where Lambda invokes the function handler. 
This begins with runtime and extension registration and it ends when the runtime is ready to send the 
response.
(Lambda SnapStart (p. 1098 ) only) The Restore subsegment shows the time it takes for Lambda to 
restore a snapshot, load the runtime (JVM), and run any afterRestore  runtime hooks  (p. 1107 ). The 
process of restoring snapshots can include time spent on activities outside the MicroVM. This time is not 
reported in the Restore  subsegment, but is included in the AWS::Lambda  segment in X-Ray traces.
The Overhead  subsegment represents the phase that occurs between the time when the runtime sends 
the response and the signal for the next invoke. During this time, the runtime ﬁnishes all tasks related to 
an invoke and prepares to freeze the sandbox.
Note
Occasionally, you may notice a large gap between the function initialization and invocation 
phases in your X-Ray traces. For functions using provisioned concurrency (p. 237), this is because 
Lambda initializes your function instances well in advance of invocation. For functions using
unreserved (on-demand) concurrency (p. 220), Lambda may proactively initialize a function 
instance, even if there's no invocation. Visually, both of these cases show up as a time gap 
between the initialization and invocation phases.
Important
In Lambda, you can use the X-Ray SDK to extend the Invocation  subsegment with additional 
subsegments for downstream calls, annotations, and metadata. You can't access the function 
segment directly or record work done outside of the handler invocation scope.
See the following topics for a language-speciﬁc introduction to tracing in Lambda:
•Instrumenting Node.js code in AWS Lambda (p. 308)
•Instrumenting Python code in AWS Lambda (p. 392)
•Instrumenting Ruby code in AWS Lambda (p. 433)
•Instrumenting Java code in AWS Lambda (p. 493)
•Instrumenting Go code in AWS Lambda (p. 551)
•Instrumenting C# code in AWS Lambda (p. 591)
For a full list of services that support active instrumentation, see Supported AWS services in the AWS X-
Ray Developer Guide.
Sections
•Execution role permissions (p. 974)
•The AWS X-Ray daemon (p. 975)
•Enabling active tracing with the Lambda API (p. 975)
•Enabling active tracing with AWS CloudFormation (p. 975)
Execution role permissions
Lambda needs the following permissions to send trace data to X-Ray. Add them to your function's
execution role (p. 913).
•xray:PutTraceSegments
974AWS Lambda Developer Guide
The AWS X-Ray daemon
•xray:PutTelemetryRecords
These permissions are included in the AWSXRayDaemonWriteAccess managed policy.
The AWS X-Ray daemon
Instead of sending trace data directly to the X-Ray API, the X-Ray SDK uses a daemon process. The AWS 
X-Ray daemon is an application that runs in the Lambda environment and listens for UDP traﬃc that 
contains segments and subsegments. It buﬀers incoming data and writes it to X-Ray in batches, reducing 
the processing and memory overhead required to trace invocations.
The Lambda runtime allows the daemon to up to 3 percent of your function's conﬁgured memory or 16 
MB, whichever is greater. If your function runs out of memory during invocation, the runtime terminates 
the daemon process ﬁrst to free up memory.
The daemon process is fully managed by Lambda and cannot be conﬁgured by the user. All segments 
generated by function invocations are recorded in the same account as the Lambda function. The 
daemon cannot be conﬁgured to redirect them to any other account.
For more information, see The X-Ray daemon in the X-Ray Developer Guide.
Enabling active tracing with the Lambda API
To manage tracing conﬁguration with the AWS CLI or AWS SDK, use the following API operations:
•UpdateFunctionConﬁguration (p. 1516 )
•GetFunctionConﬁguration (p. 1368 )
•CreateFunction (p. 1304 )
The following example AWS CLI command enables active tracing on a function named my-function.
aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
Tracing mode is part of the version-speciﬁc conﬁguration when you publish a version of your function. 
You can't change the tracing mode on a published version.
Enabling active tracing with AWS CloudFormation
To activate tracing on an AWS::Lambda::Function  resource in an AWS CloudFormation template, use 
the TracingConfig  property.
Example function-inline.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Lambda::Function
    Properties: 
       TracingConfig: 
        Mode: Active
      ...
For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function  resource, use the
Tracing property.
975AWS Lambda Developer Guide
Enabling active tracing with AWS CloudFormation
Example template.yml – Tracing conﬁguration
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
       Tracing: Active
      ...
976AWS Lambda Developer Guide
Function insights
Using Lambda Insights in Amazon CloudWatch
Amazon CloudWatch Lambda Insights collects and aggregates Lambda function runtime performance 
metrics and logs for your serverless applications. This page describes how to enable and use Lambda 
Insights to diagnose issues with your Lambda functions.
Sections
•How Lambda Insights monitors serverless applications (p. 977)
•Pricing  (p. 977)
•Supported runtimes (p. 977)
•Enabling Lambda Insights in the Lambda console (p. 977)
•Enabling Lambda Insights programmatically (p. 978)
•Using the Lambda Insights dashboard (p. 978)
•Example workﬂow to detect function anomalies (p. 980)
•Example workﬂow using queries to troubleshoot a function (p. 981)
•What's next? (p. 964)
How Lambda Insights monitors serverless 
applications
CloudWatch Lambda Insights is a monitoring and troubleshooting solution for serverless applications 
running on AWS Lambda. The solution collects, aggregates, and summarizes system-level metrics 
including CPU time, memory, disk and network usage. It also collects, aggregates, and summarizes 
diagnostic information such as cold starts and Lambda worker shutdowns to help you isolate issues with 
your Lambda functions and resolve them quickly.
Lambda Insights uses a new CloudWatch Lambda Insights extension, which is provided as a Lambda 
layer (p. 988). When you enable this extension on a Lambda function for a supported runtime, it 
collects system-level metrics and emits a single performance log event for every invocation of that 
Lambda function. CloudWatch uses embedded metric formatting to extract metrics from the log events. 
For more information, see Using AWS Lambda extensions.
The Lambda Insights layer extends the CreateLogStream  and PutLogEvents  for the /aws/lambda-
insights/  log group.
Pricing
When you enable Lambda Insights for your Lambda function, Lambda Insights reports 8 metrics per 
function and every function invocation sends about 1KB of log data to CloudWatch. You only pay for 
the metrics and logs reported for your function by Lambda Insights. There are no minimum fees or 
mandatory service usage polices. You do not pay for Lambda Insights if the function is not invoked. For a 
pricing example, see Amazon CloudWatch pricing.
Supported runtimes
You can use Lambda Insights with any of the runtimes that support Lambda extensions (p. 1006 ).
Enabling Lambda Insights in the Lambda console
You can enable Lambda Insights enhanced monitoring on new and existing Lambda functions. When 
you enable Lambda Insights on a function in the Lambda console for a supported runtime, Lambda 
977AWS Lambda Developer Guide
Enabling Lambda Insights programmatically
adds the Lambda Insights extension as a layer to your function, and veriﬁes or attempts to attach the
CloudWatchLambdaInsightsExecutionRolePolicy  policy to your function’s execution role.
To enable Lambda Insights in the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose your function.
3. Choose the Conﬁguration  tab.
4. On the Monitoring tools  pane, choose Edit.
5. Under Lambda Insights , turn on Enhanced monitoring.
6. Choose Save.
Enabling Lambda Insights programmatically
You can also enable Lambda Insights using the AWS Command Line Interface (AWS CLI), AWS Serverless 
Application Model (SAM) CLI, AWS CloudFormation, or the AWS Cloud Development Kit (AWS CDK). 
When you enable Lambda Insights programmatically on a function for a supported runtime, CloudWatch 
attaches the CloudWatchLambdaInsightsExecutionRolePolicy  policy to your function’s execution 
role.
For more information, see Getting started with Lambda Insights in the Amazon CloudWatch User Guide.
Using the Lambda Insights dashboard
The Lambda Insights dashboard has two views in the CloudWatch console: the multi-function overview 
and the single-function view. The multi-function overview aggregates the runtime metrics for the 
Lambda functions in the current AWS account and Region. The single-function view shows the available 
runtime metrics for a single Lambda function.
You can use the Lambda Insights dashboard multi-function overview in the CloudWatch console to 
identify over- and under-utilized Lambda functions. You can use the Lambda Insights dashboard single-
function view in the CloudWatch console to troubleshoot individual requests.
To view the runtime metrics for all functions
1. Open the Multi-function page in the CloudWatch console.
2. Choose from the predeﬁned time ranges, or choose a custom time range.
3. (Optional) Choose Add to dashboard  to add the widgets to your CloudWatch dashboard.
978AWS Lambda Developer Guide
Using the Lambda Insights dashboard
To view the runtime metrics of a single function
1. Open the Single-function page in the CloudWatch console.
2. Choose from the predeﬁned time ranges, or choose a custom time range.
3. (Optional) Choose Add to dashboard  to add the widgets to your CloudWatch dashboard.
For more information, see Creating and working with widgets on CloudWatch dashboards.
979AWS Lambda Developer Guide
Detecting function anomalies
Example workﬂow to detect function anomalies
You can use the multi-function overview on the Lambda Insights dashboard to identify and detect 
compute memory anomalies with your function. For example, if the multi-function overview indicates 
that a function is using a large amount of memory, you can view detailed memory utilization metrics 
in the Memory Usage pane. You can then go to the Metrics dashboard to enable anomaly detection or 
create an alarm.
To enable anomaly detection for a function
1. Open the Multi-function page in the CloudWatch console.
2. Under Function summary, choose your function's name.
The single-function view opens with the function runtime metrics.
3. On the Memory Usage pane, choose the three vertical dots, and then choose View in metrics  to 
open the Metrics  dashboard.
4. On the Graphed metrics  tab, in the Actions column, choose the ﬁrst icon to enable anomaly 
detection for the function.
980AWS Lambda Developer Guide
Troubleshooting a function
For more information, see Using CloudWatch Anomaly Detection.
Example workﬂow using queries to troubleshoot a 
function
You can use the single-function view on the Lambda Insights dashboard to identify the root cause of 
a spike in function duration. For example, if the multi-function overview indicates a large increase in 
function duration, you can pause on or choose each function in the Duration  pane to determine which 
function is causing the increase. You can then go to the single-function view and review the Application 
logs to determine the root cause.
To run queries on a function
1. Open the Multi-function page in the CloudWatch console.
2. In the Duration  pane, choose your function to ﬁlter the duration metrics.
3. Open the Single-function page.
4. Choose the Filter metrics by function name dropdown list, and then choose your function.
5. To view the Most recent 1000 application logs, choose the Application logs tab.
6. Review the Timestamp  and Message  to identify the invocation request that you want to 
troubleshoot.
981AWS Lambda Developer Guide
What's next?
7. To show the Most recent 1000 invocations, choose the Invocations tab.
8. Select the Timestamp  or Message  for the invocation request that you want to troubleshoot.
9. Choose the View logs dropdown list, and then choose View performance logs.
An autogenerated query for your function opens in the Logs Insights  dashboard.
10. Choose Run query to generate a Logs  message for the invocation request.
What's next?
•Learn how to create a CloudWatch Logs dashboard in Create a Dashboard in the Amazon CloudWatch 
User Guide .
•Learn how to add queries to a CloudWatch Logs dashboard in Add Query to Dashboard or Export 
Query Results in the Amazon CloudWatch User Guide.
982AWS Lambda Developer Guide
Code proﬁler
Using CodeGuru Proﬁler with your Lambda 
function
You can use Amazon CodeGuru Proﬁler to gain insights into runtime performance of your Lambda 
functions. This page describes how to activate CodeGuru Proﬁler from the Lambda console.
Sections
•Supported runtimes (p. 983)
•Activating CodeGuru Proﬁler from the Lambda console (p. 983)
•What happens when you activate CodeGuru Proﬁler from the Lambda console? (p. 983)
•What's next? (p. 984)
Supported runtimes
You can activate CodeGuru Proﬁler from the Lambda console if your function's runtime is Python3.8, 
Python3.9, Java 8 with Amazon Linux 2, or Java 11. For additional runtime versions, you can activate 
CodeGuru Proﬁler manually.
•For Java runtimes, see  Proﬁling your Java applications that run on AWS Lambda.
•For Python runtimes, see  Proﬁling your Python applications that run on AWS Lambda.
Activating CodeGuru Proﬁler from the Lambda 
console
This section describes how to activate CodeGuru Proﬁler from the Lambda console.
To activate CodeGuru Proﬁler from the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose your function.
3. Choose the Conﬁguration  tab.
4. On the Monitoring and operations tools  pane, choose Edit.
5. Under Amazon CodeGuru Proﬁler, turn on Code proﬁling .
6. Choose Save.
After activation, CodeGuru automatically creates a proﬁler group with the name aws-lambda-<your-
function-name> . You can change the name from the CodeGuru console.
What happens when you activate CodeGuru Proﬁler 
from the Lambda console?
When you activate CodeGuru Proﬁler from the console, Lambda automatically does the following on 
your behalf:
•Lambda adds a CodeGuru Proﬁler layer to your function. For more details, see  Use AWS Lambda layers
in the Amazon CodeGuru Proﬁler User Guide .
983AWS Lambda Developer Guide
What's next?
•Lambda also adds environment variables to your function. The exact value varies based on the 
runtime.
Environment variables
Runtimes Key Value
java8.al2, java11 JAVA_TOOL_OPTIONS -javaagent:/opt/
codeguru-profiler-java-
agent-standalone.jar
python3.8, python3.9 AWS_LAMBDA_EXEC_WRAPPER /opt/
codeguru_profiler_lambda_exec
•Lambda adds the AmazonCodeGuruProfilerAgentAccess  policy to your function's execution role.
Note
When you deactivate CodeGuru Proﬁler from the console, Lambda automatically removes the 
CodeGuru Proﬁler layer from your function. However, Lambda does not remove the environment 
variables or the AmazonCodeGuruProfilerAgentAccess  policy from your execution role.
What's next?
•Learn more about the data collected by your proﬁler group in Working with visualizations in the
Amazon CodeGuru Proﬁler User Guide .
984AWS Lambda Developer Guide
Example workﬂows
Example workﬂows using other AWS services
AWS Lambda integrates with other AWS services to help you monitor, trace, debug, and troubleshoot 
your Lambda functions. This page shows workﬂows you can use with AWS X-Ray, AWS Trusted Advisor 
and CloudWatch ServiceLens to trace and troubleshoot your Lambda functions.
Sections
•Prerequisites (p. 985)
•Pricing  (p. 986)
•Example AWS X-Ray workﬂow to view a service map (p. 986)
•Example AWS X-Ray workﬂow to view trace details (p. 986)
•Example AWS Trusted Advisor workﬂow to view recommendations (p. 987)
•What's next? (p. 987)
Prerequisites
The following section describes the steps to using AWS X-Ray and Trusted Advisor to troubleshoot your 
Lambda functions.
Using AWS X-Ray
AWS X-Ray needs to be enabled on the Lambda console to complete the AWS X-Ray workﬂows on this 
page. If your execution role does not have the required permissions, the Lambda console will attempt to 
add them to your execution role.
To enable AWS X-Ray on the Lambda console
1. Open the Functions page of the Lambda console.
2. Choose your function.
3. Choose the Conﬁguration  tab.
4. On the Monitoring tools  pane, choose Edit.
5. Under AWS X-Ray, turn on Active tracing.
6. Choose Save.
Using AWS Trusted Advisor
AWS Trusted Advisor inspects your AWS environment and makes recommendations on ways you can save 
money, improve system availability and performance, and help close security gaps. You can use Trusted 
Advisor checks to evaluate the Lambda functions and applications in your AWS account. The checks 
provide recommended steps to take and resources for more information.
•For more information on AWS support plans for Trusted Advisor checks, see Support plans.
•For more information about the checks for Lambda, see AWS Trusted Advisor best practice checklist.
•For more information on how to use the Trusted Advisor console, see Get started with AWS Trusted 
Advisor.
•For instructions on how to allow and deny console access to Trusted Advisor, see IAM policy examples.
985AWS Lambda Developer Guide
Pricing
Pricing
•With AWS X-Ray you pay only for what you use, based on the number of traces recorded, retrieved, 
and scanned. For more information, see AWS X-Ray Pricing.
•Trusted Advisor cost optimization checks are included with AWS Business and Enterprise support 
subscriptions. For more information, see AWS Trusted Advisor Pricing.
Example AWS X-Ray workﬂow to view a service map
If you've enabled AWS X-Ray, you can view a ServiceLens service map on the CloudWatch console. A 
service map displays your service endpoints and resources as nodes and highlights the traﬃc, latency, 
and errors for each node and its connections.
You can choose a node to see detailed insights about the correlated metrics, logs, and traces associated 
with that part of the service. This enables you to investigate problems and their eﬀect on an application.
To view service map and traces using the CloudWatch console
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose Monitoring .
4. Choose View traces in X-Ray.
5. Choose Service map.
6. Choose from the predeﬁned time ranges, or choose a custom time range.
7. To troubleshoot requests, choose a ﬁlter.
Example AWS X-Ray workﬂow to view trace details
If you've enabled AWS X-Ray, you can use the single-function view on the CloudWatch Lambda Insights 
dashboard to show the distributed trace data of a function invocation error. For example, if the 
application logs message shows an error, you can open the ServiceLens traces view to see the distributed 
trace data and the other services handling the transaction.
To view trace details of a function
1. Open the single-function view in the CloudWatch console.
2. Choose the Application logs tab.
3. Use the Timestamp  or Message  to identify the invocation request that you want to troubleshoot.
4. To show the Most recent 1000 invocations, choose the Invocations tab.
986AWS Lambda Developer Guide
Using Trusted Advisor to view recommendations
5. Choose the Request ID column to sort entries in ascending alphabetical order.
6. In the Trace column, choose View .
The Trace details page opens in the ServiceLens traces view.
Example AWS Trusted Advisor workﬂow to view 
recommendations
Trusted Advisor checks Lambda functions in all AWS Regions to identify functions with the highest 
potential cost savings, and deliver actionable recommendations for optimization. It analyzes your 
Lambda usage data such as function execution time, billed duration, memory used, memory conﬁgured, 
timeout conﬁguration and errors.
For example, the Lambda Functions with High Error Rate check recommends that you use AWS X-Ray or 
CloudWatch to detect errors with your Lambda functions.
To check for functions with high error rates
1. Open the Trusted Advisor console.
2. Choose the Cost Optimization  category.
3. Scroll down to AWS Lambda Functions with High Error Rates. Expand the section to see the results 
and the recommended actions.
What's next?
•Learn more about how to integrate traces, metrics, logs, and alarms in Using ServiceLens to Monitor 
the Health of Your Applications.
•Learn more about how to get a list of Trusted Advisor checks in Using Trusted Advisor as a web service.
987AWS Lambda Developer Guide
Working with Lambda layers
A Lambda layer is a .zip ﬁle archive that contains supplementary code or data. Layers usually contain 
library dependencies, a custom runtime  (p. 60), or conﬁguration ﬁles.
There are multiple reasons why you might consider using layers:
•To reduce the size of your deployment packages. Instead of including all of your function 
dependencies along with your function code in your deployment package, put them in a layer. This 
keeps deployment packages small and organized.
•To separate core function logic from dependencies. With layers, you can update your function 
dependencies independent of your function code, and vice versa. This promotes separation of concerns 
and helps you focus on your function logic.
•To share dependencies across multiple functions. After you create a layer, you can apply it to any 
number of functions in your account. Without layers, you need to include the same dependencies in 
each individual deployment package.
•To use the Lambda console code editor. The code editor is a useful tool for testing minor function 
code updates quickly. However, you can’t use the editor if your deployment package size is too large. 
Using layers reduces your package size and can unlock usage of the code editor.
The following diagram illustrates the high-level architectural diﬀerences between two functions that 
share dependencies. One uses Lambda layers, and the other does not.
988AWS Lambda Developer Guide
When you add a layer to a function, Lambda extracts the layer contents into the /opt directory in your 
function’s execution environment (p. 14). All natively supported Lambda runtimes include paths to 
speciﬁc directories within the /opt directory. This gives your function access to your layer content. For 
more information about these speciﬁc paths and how to properly package your layers, see the section 
called “Packaging layers” (p. 991).
You can include up to ﬁve layers per function. Also, you can use layers only with Lambda functions
deployed as a .zip ﬁle archive (p. 18). For functions deﬁned as a container image (p. 122), package 
your preferred runtime and all code dependencies when you create the container image. For more 
information, see  Working with Lambda layers and extensions in container images on the AWS Compute 
Blog.
Topics
•How to use layers (p. 990)
•Layers and layer versions (p. 990)
•Sample applications  (p. 990)
989AWS Lambda Developer Guide
How to use layers
•Packaging your layer content (p. 991)
•Creating and deleting layers in Lambda (p. 993)
•Adding layers to functions (p. 995)
•Using AWS CloudFormation with layers (p. 998)
•Using AWS SAM with layers (p. 999)
How to use layers
To create a layer, package your dependencies into a .zip ﬁle, similar to how you create a normal 
deployment package (p. 118). More speciﬁcally, the general process of creating and using layers involves 
these three steps:
•First, package your layer content. This means creating a .zip ﬁle archive. For more information, see
the section called “Packaging layers” (p. 991).
•Next, create the layer in Lambda. For more information, see the section called “Creating and deleting 
layers” (p. 993).
•Add the layer to your function(s). For more information, see the section called “Adding 
layers” (p. 995).
Layers and layer versions
A layer version is an immutable snapshot of a speciﬁc version of a layer. When you create a new layer, 
Lambda creates a new layer version with a version number of 1. Each time you publish an update to the 
layer, Lambda increments the version number and creates a new layer version.
Every layer version is identiﬁed by a unique Amazon Resource Name (ARN). When adding a layer to the 
function, you must specify the exact layer version you want to use.
Sample applications
The GitHub repository for this guide provides blank sample applications that demonstrate the use of 
layers for dependency management.
•Node.js  –  blank-nodejs
•Python –  blank-python
•Java –  blank-java
•Ruby –  blank-ruby
990AWS Lambda Developer Guide
Packaging layers
Packaging your layer content
A Lambda layer is a .zip ﬁle archive that contains supplementary code or data. Layers usually contain 
library dependencies, a custom runtime  (p. 60), or conﬁguration ﬁles.
This section explains how to properly package your layer content. For more conceptual information 
about layers and why you might consider using them, see Lambda layers  (p. 988).
The ﬁrst step to creating a layer is to bundle all of your layer content into a .zip ﬁle archive. Because 
Lambda functions run on Amazon Linux (p. 41), your layer content must be able to compile and build 
in a Linux environment. If you build packages on your local Windows or Mac machine, you’ll get output 
binaries for that operating system by default. These binaries may not work properly when you upload 
them to Lambda.
To ensure that your layer content works properly in a Linux environment, we recommend creating your 
layer content using AWS Cloud9. AWS Cloud9 is a cloud-based integrated development environment 
(IDE) that provides built-in access to a Linux server for running and testing code. For more information, 
see  Using Lambda layers to simplify your development process on the AWS Compute Blog.
Topics
•Layer paths for each Lambda runtime (p. 991)
Layer paths for each Lambda runtime
When you add a layer to a function, Lambda loads the layer content into the /opt directory of that 
execution environment. For each Lambda runtime, the PATH variable already includes speciﬁc folder 
paths within the /opt directory. To ensure that your layer content gets picked up by the PATH  variable, 
include the content in the following folder paths based on your runtime:
Layer paths for each Lambda runtime
Runtime Path
nodejs/node_modules
nodejs/node14/node_modules  (NODE_PATH )
nodejs/node16/node_modules  (NODE_PATH )Node.js
nodejs/node18/node_modules  (NODE_PATH )
/opt/python Python
/opt/python/lib/python3.x/site-packages  (site 
directories)
Java java/lib  (CLASSPATH )
ruby/gems/2.7.0  (GEM_PATH ) Ruby
ruby/lib  (RUBYLIB )
bin (PATH ) All runtimes
lib (LD_LIBRARY_PATH )
The following examples show how you can structure the folders in your layer .zip archive.
991AWS Lambda Developer Guide
Layer paths for each Lambda runtime
Node.js
Example ﬁle structure for the AWS X-Ray SDK for Node.js
xray-sdk.zip
# nodejs/node_modules/aws-xray-sdk
Python
Example ﬁle structure for the Pillow library
pillow.zip
# python/PIL
# python/Pillow-5.3.0.dist-info
Ruby
Example ﬁle structure for the JSON gem
json.zip
# ruby/gems/2.7.0/ 
               | build_info 
               | cache 
               | doc 
               | extensions 
               | gems 
               | # json-2.1.0 
               # specifications 
                 # json-2.1.0.gemspec
Java
Example ﬁle structure for the Jackson JAR ﬁle
jackson.zip
# java/lib/jackson-core-2.2.3.jar
All
Example ﬁle structure for the jq library
jq.zip
# bin/jq
992AWS Lambda Developer Guide
Creating and deleting layers
Creating and deleting layers in Lambda
A Lambda layer is a .zip ﬁle archive that contains supplementary code or data. Layers usually contain 
library dependencies, a custom runtime  (p. 60), or conﬁguration ﬁles.
This section explains how to create and delete layers in Lambda. For more conceptual information about 
layers and why you might consider using them, see Lambda layers  (p. 988).
After you’ve packaged your layer content (p. 991), the next step is to create the layer in Lambda. 
This section demonstrates how to create and delete layers using the Lambda console or the Lambda 
API only. To create a layer using AWS CloudFormation, see the section called “Layers with AWS 
CloudFormation” (p. 998). To create a layer using the AWS Serverless Application Model (AWS SAM), 
see the section called “Layers with AWS SAM” (p. 999).
Topics
•Creating a layer (p. 993)
•Deleting a layer version (p. 994)
Creating a layer
To create a layer, you can either upload the .zip ﬁle archive from your local machine or from Amazon 
Simple Storage Service (Amazon S3). Lambda extracts the layer contents into the /opt directory when 
setting up the execution environment for the function.
Layers can have one or more layer versions (p. 990). When you create a layer, Lambda sets the layer 
version to version 1. You can change the permissions on an existing layer version at any time. However, 
to update the code or make other conﬁguration changes, you must create a new version of the layer.
To create a layer (console)
1. Open the Layers page of the Lambda console.
2. Choose Create layer.
3. Under Layer conﬁguration, for Name , enter a name for your layer.
4. (Optional) For Description , enter a description for your layer.
5. To upload your layer code, do one of the following:
• To upload a .zip ﬁle from your computer, choose Upload a .zip ﬁle. Then, choose Upload to 
select your local .zip ﬁle.
• To upload a ﬁle from Amazon S3, choose Upload a ﬁle from Amazon S3. Then, for Amazon S3 
link URL , enter a link to the ﬁle.
6. (Optional) For Compatible architectures, choose one value or both values. For more information, 
see the section called “Instruction sets (ARM/x86)” (p. 33).
7. (Optional) For Compatible runtimes, choose the runtimes that your layer is compatible with.
8. (Optional) For License, enter any necessary license information.
9. Choose Create .
Alternatively, you can also use the PublishLayerVersion (p. 1449 ) API to create a layer. For example, 
you can use the publish-layer-version  AWS Command Line Interface (CLI) command with a 
name, description, and .zip ﬁle archive speciﬁed. The license info, compatible runtimes, and compatible 
architecture parameters are optional.
aws lambda publish-layer-version --layer-name my-layer \ 
    --description "My layer" \ 
993AWS Lambda Developer Guide
Deleting a layer version
    --license-info "MIT" \ 
    --zip-file fileb://layer.zip \ 
    --compatible-runtimes python3.7 python3.8 \ 
    --compatible-architectures "arm64" "x86_64"
You should see output similar to the following:
{ 
    "Content": { 
        "Location": "https://awslambda-us-east-2-layers.s3.us-east-2.amazonaws.com/
snapshots/123456789012/my-layer-4aaa2fbb-ff77-4b0a-ad92-5b78a716a96a?
versionId=27iWyA73cCAYqyH...", 
        "CodeSha256": "tv9jJO+rPbXUUXuRKi7CwHzKtLDkDRJLB3cC3Z/ouXo=", 
        "CodeSize": 169 
    }, 
    "LayerArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer", 
    "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:1", 
    "Description": "My layer", 
    "CreatedDate": "2018-11-14T23:03:52.894+0000", 
    "Version": 1, 
    "CompatibleArchitectures": [ 
        "arm64", 
        "x86_64" 
     ], 
    "LicenseInfo": "MIT", 
    "CompatibleRuntimes": [ 
        "python3.7", 
        "python3.8" 
    ]
}
Each time you call publish-layer-version , you create a new version of the layer.
Deleting a layer version
To delete a layer version, use the DeleteLayerVersion (p. 1342 ) API. For example, you can use the
delete-layer-version  CLI command with the layer name and layer version speciﬁed.
aws lambda delete-layer-version --layer-name my-layer --version-number 1
When you delete a layer version, you can no longer conﬁgure a Lambda function to use it. However, any 
function that already uses the version continues to have access to it. Also, Lambda never reuses version 
numbers for a layer name.
994AWS Lambda Developer Guide
Adding layers
Adding layers to functions
A Lambda layer is a .zip ﬁle archive that contains supplementary code or data. Layers usually contain 
library dependencies, a custom runtime  (p. 60), or conﬁguration ﬁles.
This section explains how to add a layer to a Lambda function. For more conceptual information about 
layers and why you might consider using them, see Lambda layers  (p. 988).
Before you can conﬁgure a Lambda function to use a layer, you must:
•Package your layer content (p. 991)
•Create a layer in Lambda (p. 993)
•Make sure that you have permission to call the GetLayerVersion (p. 1382 ) API on the layer version. 
For functions in your AWS account, you must have this permission in your user policy (p. 920). To 
use a layer in another account, the owner of that account must grant your account permission in a
resource-based policy (p. 929). For examples, see the section called “Granting layer access to other 
accounts” (p. 933).
You can add up to ﬁve layers to a Lambda function. The total unzipped size of the function and all layers 
cannot exceed the unzipped deployment package size quota of 250 MB. For more information, see
Lambda Quotas  (p. 1269 ).
Your functions can continue to use any layer version that you’ve already added, even after that layer 
version has been deleted, or after your permission to access the layer is revoked. However, you cannot 
create a new function that uses a deleted layer version.
Note
Make sure that the layers you add to a function are compatible with the runtime and instruction 
set architecture of the function.
To add a layer to a function (console)
1. Open the Functions page of the Lambda console.
2. Choose the function to conﬁgure.
3. Under Layers, choose Add a layer
4. Under Choose a layer, choose a layer source:
a. For the AWS layers or Custom layers layer sources, choose a layer from the pull-down menu. 
Under Version, choose a layer version from the pull-down menu.
b. For the Specify an ARN layer source, enter an ARN in the text box and choose Verify. Then, 
choose Add.
The order in which you add the layers is the order in which Lambda merges the layer content into the 
execution environment. You can change the layer merge order using the console.
To update layer merge order for your function (console)
1. Open the Functions page of the Lambda console.
2. Choose the function to conﬁgure.
3. Under Layers, choose Edit
4. Choose one of the layers.
5. Choose Merge earlier  or Merge later  to adjust the order of the layers.
6. Choose Save.
995AWS Lambda Developer Guide
Accessing layer content from your function
Layers are versioned. The content of each layer version is immutable. The owner of a layer can release 
new layer versions to provide updated content. You can use the console to update the layer version 
attached to your functions.
To update layer versions for your function (console)
1. Open the Layers page of the Lambda console.
2. Choose the layer you want to update the version for.
3. Choose the Functions using this version tab.
4. Choose the functions you want to modify, then choose Edit.
5. For Layer version, choose the layer version to change to.
6. Choose Update functions.
You cannot update function layer versions across AWS accounts.
Topics
•Accessing layer content from your function (p. 996)
•Finding layer information (p. 996)
Accessing layer content from your function
If your Lambda function includes layers, Lambda extracts the layer contents into the /opt directory in 
the function execution environment. Lambda extracts the layers in the order (low to high) listed by the 
function. Lambda merges folders with the same name. If the same ﬁle appears in multiple layers, the 
function uses the version in the last extracted layer.
Each Lambda runtime adds speciﬁc /opt directory folders to the PATH variable. Your function code 
can access the layer content without having to specify the path. For more information about path 
settings in the Lambda execution environment, see the section called “Deﬁned runtime environment 
variables” (p. 80).
Refer to the section called “Layer paths for each Lambda runtime” (p. 991) to learn where to include your 
libraries when creating a layer.
If you’re using a Node.js or Python runtime, you can use the built-in code editor in the Lambda console. 
You should be able to import any library that you’ve added as a layer to the current function.
Finding layer information
To ﬁnd layers in your account that are compatible with your function’s runtime, use the
ListLayers (p. 1434 ) API. For example, you can use the following list-layers  AWS Command Line 
Interface (CLI) command:
aws lambda list-layers --compatible-runtime python3.9
You should see output similar to the following:
{ 
    "Layers": [ 
        { 
            "LayerName": "my-layer", 
            "LayerArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer", 
            "LatestMatchingVersion": { 
996AWS Lambda Developer Guide
Finding layer information
                "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-
layer:2", 
                "Version": 2, 
                "Description": "My layer", 
                "CreatedDate": "2018-11-15T00:37:46.592+0000", 
                "CompatibleRuntimes": [ 
                    "python3.7", 
                    "python3.8", 
                    "python3.9", 
                ] 
            } 
        } 
    ]
}
To list all layers in your account, omit the --compatible-runtime  option. The response details show 
the latest version of each layer.
You can also get the latest version of a layer using the ListLayerVersions (p. 1437 ) API. For example, you 
can use the following list-layer-versions  CLI command:
aws lambda list-layer-versions --layer-name my-layer
You should see output similar to the following:
{ 
    "LayerVersions": [ 
        { 
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:2", 
            "Version": 2, 
            "Description": "My layer", 
            "CreatedDate": "2018-11-15T00:37:46.592+0000", 
            "CompatibleRuntimes": [ 
                "java11" 
            ] 
        }, 
        { 
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:1", 
            "Version": 1, 
            "Description": "My layer", 
            "CreatedDate": "2018-11-15T00:27:46.592+0000", 
            "CompatibleRuntimes": [ 
                "java11" 
            ] 
        } 
    ]
}
997AWS Lambda Developer Guide
Layers with AWS CloudFormation
Using AWS CloudFormation with layers
You can use AWS CloudFormation to create a layer and associate the layer with your Lambda function. 
The following example template creates a layer named my-lambda-layer  and attaches the layer to the 
Lambda function using the Layers property.
---
Description: CloudFormation Template for Lambda Function with Lambda Layer
Resources: 
  MyLambdaLayer: 
    Type: AWS::Lambda::LayerVersion 
    Properties: 
      LayerName: my-lambda-layer 
      Description: My Lambda Layer 
      Content: 
        S3Bucket: my-bucket 
        S3Key: my-layer.zip 
      CompatibleRuntimes: 
        - python3.7 
        - python3.8 
        - python3.9 
  MyLambdaFunction: 
    Type: AWS::Lambda::Function 
    Properties: 
      FunctionName: my-lambda-function 
      Runtime: python3.9 
      Handler: index.handler 
      Timeout: 10 
      Policies: 
        - AWSLambdaBasicExecutionRole 
        - AWSLambda_ReadOnlyAccess 
        - AWSXrayWriteOnlyAccess 
      Layers: 
        - !Ref MyLambdaLayer
998AWS Lambda Developer Guide
Layers with AWS SAM
Using AWS SAM with layers
You can use the AWS Serverless Application Model (AWS SAM) to automate the creation of layers in your 
application. The AWS::Serverless::LayerVersion  resource type creates a layer version that you can 
reference from your Lambda function conﬁguration.
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: AWS SAM Template for Lambda Function with Lambda Layer
Resources: 
  MyLambdaLayer: 
    Type: AWS::Serverless::LayerVersion 
    Properties: 
      LayerName: my-lambda-layer 
      Description: My Lambda Layer 
      ContentUri: s3://my-bucket/my-layer.zip 
      CompatibleRuntimes: 
        - python3.7 
        - python3.8 
        - python3.9 
  MyLambdaFunction: 
    Type: AWS::Serverless::Function 
    Properties: 
      FunctionName: MyLambdaFunction 
      Runtime: python3.9 
      Handler: app.handler 
      CodeUri: s3://my-bucket/my-function 
      Layers: 
        - !Ref MyLambdaLayer
999AWS Lambda Developer Guide
Execution environment
Lambda extensions
You can use Lambda extensions to augment your Lambda functions. For example, use Lambda 
extensions to integrate functions with your preferred monitoring, observability, security, and governance 
tools. You can choose from a broad set of tools that AWS Lambda Partners provides, or you can create 
your own Lambda extensions (p. 1006 ).
Lambda supports external and internal extensions. An external extension runs as an independent process 
in the execution environment and continues to run after the function invocation is fully processed. 
Because extensions run as separate processes, you can write them in a diﬀerent language than the 
function. All Lambda runtimes  (p. 41) support extensions.
An internal extension runs as part of the runtime process. Your function accesses internal extensions by 
using wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS . For more information, 
see Modifying the runtime environment (p. 52).
You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS 
CLI), or infrastructure as code (IaC) services and tools such as AWS CloudFormation, AWS Serverless 
Application Model (AWS SAM), and Terraform.
You are charged for the execution time that the extension consumes (in 1 ms increments). For more 
pricing information for extensions, see AWS Lambda Pricing. For pricing information for partner 
extensions, see those partners' websites. There is no cost to install your own extensions.
Topics
•Execution environment (p. 1000 )
•Impact on performance and resources  (p. 1001 )
•Permissions (p. 1001 )
•Conﬁguring Lambda extensions (p. 1002 )
•AWS Lambda extensions partners (p. 1004 )
•Lambda Extensions API (p. 1006 )
•Lambda Telemetry API (p. 1017 )
Execution environment
Lambda invokes your function in an execution environment (p. 14), which provides a secure and isolated 
runtime environment. The execution environment manages the resources required to run your function 
and provides lifecycle support for the function's runtime and extensions.
The lifecycle of the execution environment includes the following phases:
•Init: In this phase, Lambda creates or unfreezes an execution environment with the conﬁgured 
resources, downloads the code for the function and all layers, initializes any extensions, initializes the 
runtime, and then runs the function’s initialization code (the code outside the main handler). The Init
phase happens either during the ﬁrst invocation, or in advance of function invocations if you have 
enabled provisioned concurrency (p. 237).
The Init phase is split into three sub-phases: Extension init , Runtime init , and Function 
init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before 
the function code runs.
1000AWS Lambda Developer Guide
Impact on performance and resources 
When Lambda SnapStart (p. 1098 ) is activated, the Init phase happens when you publish a 
function version. Lambda saves a snapshot of the memory and disk state of the initialized execution 
environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a
beforeCheckpoint  runtime hook  (p. 1107 ), then the code runs at the end of Init  phase.
•Restore (SnapStart only): When you ﬁrst invoke a SnapStart (p. 1098 ) function and as the function 
scales up, Lambda resumes new execution environments from the persisted snapshot instead of 
initializing the function from scratch. If you have an afterRestore()  runtime hook  (p. 1107 ), the 
code runs at the end of the Restore phase. You are charged for the duration of afterRestore()
runtime hooks. The runtime (JVM) must load and afterRestore()  runtime hooks must complete 
within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the
Restore phase completes, Lambda invokes the function handler (the Invoke  phase).
•Invoke: In this phase, Lambda invokes the function handler. After the function runs to completion, 
Lambda prepares to handle another function invocation.
•Shutdown : This phase is triggered if the Lambda function does not receive any invocations for a period 
of time. In the Shutdown  phase, Lambda shuts down the runtime, alerts the extensions to let them 
stop cleanly, and then removes the environment. Lambda sends a Shutdown  event to each extension, 
which tells the extension that the environment is about to be shut down.
During the Init phase, Lambda extracts layers containing extensions into the /opt directory in the 
execution environment. Lambda looks for extensions in the /opt/extensions/  directory, interprets 
each ﬁle as an executable bootstrap for launching the extension, and starts all extensions in parallel.
Impact on performance and resources
The size of your function's extensions counts towards the deployment package size limit. For a .zip 
ﬁle archive, the total unzipped size of the function and all extensions cannot exceed the unzipped 
deployment package size limit of 250 MB.
Extensions can impact the performance of your function because they share function resources such as 
CPU, memory, and storage. For example, if an extension performs compute-intensive operations, you 
may see your function's execution duration increase.
Each extension must complete its initialization before Lambda invokes the function. Therefore, 
an extension that consumes signiﬁcant initialization time can increase the latency of the function 
invocation.
To measure the extra time that the extension takes after the function execution, you can use the
PostRuntimeExtensionsDuration  function metric (p. 965). To measure the increase in memory 
used, you can use the MaxMemoryUsed  metric. To understand the impact of a speciﬁc extension, you can 
run diﬀerent versions of your functions side by side.
Permissions
Extensions have access to the same resources as functions. Because extensions are executed within the 
same environment as the function, permissions are shared between the function and the extension.
For a .zip ﬁle archive, you can create an AWS CloudFormation template to simplify the task of attaching 
the same extension conﬁguration—including AWS Identity and Access Management (IAM) permissions—
to multiple functions.
1001AWS Lambda Developer Guide
Conﬁguring extensions
Conﬁguring Lambda extensions
Conﬁguring extensions (.zip ﬁle archive)
You can add an extension to your function as a Lambda layer (p. 988). Using layers enables you to share 
extensions across your organization or to the entire community of Lambda developers. You can add one 
or more extensions to a layer. You can register up to 10 extensions for a function.
You add the extension to your function using the same method as you would for any layer. For more 
information, see Lambda layers  (p. 988).
Add an extension to your function (console)
1. Open the Functions page of the Lambda console.
2. Choose a function.
3. Choose the Code  tab if it is not already selected.
4. Under Layers, choose Edit.
5. For Choose a layer, choose Specify an ARN.
6. For Specify an ARN, enter the Amazon Resource Name (ARN) of an extension layer.
7. Choose Add.
Using extensions in container images
You can add extensions to your container image (p. 122). The ENTRYPOINT container image setting 
speciﬁes the main process for the function. Conﬁgure the ENTRYPOINT setting in the Dockerﬁle, or as an 
override in the function conﬁguration.
You can run multiple processes within a container. Lambda manages the lifecycle of the main process 
and any additional processes. Lambda uses the Extensions API (p. 1006 ) to manage the extension 
lifecycle.
Example: Adding an external extension
An external extension runs in a separate process from the Lambda function. Lambda starts a process for 
each extension in the /opt/extensions/  directory. Lambda uses the Extensions API to manage the 
extension lifecycle. After the function has run to completion, Lambda sends a Shutdown  event to each 
external extension.
Example of adding an external extension to a Python base image
FROM public.ecr.aws/lambda/python:3.8
# Copy and install the app
COPY /app /app
WORKDIR /app
RUN pip install -r requirements.txt
# Add an extension from the local directory into /opt
ADD my-extension.zip /opt
CMD python ./my-function.py     
Next steps
To learn more about extensions, we recommend the following resources:
1002AWS Lambda Developer Guide
Next steps
•For a basic working example, see Building Extensions for AWS Lambda on the AWS Compute Blog.
•For information about extensions that AWS Lambda Partners provides, see Introducing AWS Lambda 
Extensions on the AWS Compute Blog.
•To view available example extensions and wrapper scripts, see AWS Lambda Extensions on the AWS 
Samples GitHub repository.
1003AWS Lambda Developer Guide
Extensions partners
AWS Lambda extensions partners
AWS Lambda has partnered with several third party entities to provide extensions to integrate with your 
Lambda functions. The following list details third party extensions that are ready for you to use at any 
time.
•AppDynamics  – Provides automatic instrumentation of Node.js or Python Lambda functions, providing 
visibility and alerting on function performance.
•Check Point CloudGuard – An extension-based runtime solution that oﬀers full lifecycle security for 
serverless applications.
•Datadog  – Provides comprehensive, real-time visibility to your serverless applications through the use 
of metrics, traces, and logs.
•Dynatrace – Provides visibility into traces and metrics, and leverages AI for automated error detection 
and root cause analysis across the entire application stack.
•Elastic  – Provides Application Performance Monitoring (APM) to identify and resolve root cause issues 
using correlated traces, metrics, and logs.
•Epsagon  – Listens to invocation events, stores traces, and sends them in parallel to Lambda function 
executions.
•Fastly– Protects your Lambda functions from suspicious activity, such as injection-style attacks, 
account takeover via credential stuﬃng, malicious bots, and API abuse.
•HashiCorp Vault – Manages secrets and makes them available for developers to use within function 
code, without making functions Vault aware.
•Honeycomb – Observability tool for debugging your app stack.
•Lumigo  – Proﬁles Lambda function invocations and collects metrics for troubleshooting issues in 
serverless and microservice environments.
•New Relic – Runs alongside Lambda functions, automatically collecting, enhancing, and transporting 
telemetry to New Relic's uniﬁed observability platform.
•Sedai  – An autonomous cloud management platform, powered by AI/ML, that delivers continuous 
optimization for cloud operations teams to maximize cloud cost savings, performance, and availability 
at scale.
•Sentry – Diagnose, ﬁx, and optimize performance of Lambda functions.
•Site24x7  – Achieve real-time observability into your Lambda environments
•Splunk  – Collects high-resolution, low-latency metrics for eﬃcient and eﬀective monitoring of Lambda 
functions.
•Sumo Logic  – Provides visibility into the health and performance of serverless applications.
•Thundra  – Provides asynchronous telemetry reporting, such as traces, metrics, and logs.
AWS managed extensions
AWS provides its own managed extensions, including:
•AWS AppConﬁg – Use feature ﬂags and dynamic data to update your Lambda functions. You can also 
use this extension to update other dynamic conﬁguration, such as ops throttling and tuning.
•Amazon CodeGuru Proﬁler – Improves application performance and reduces cost by pinpointing an 
application's most expensive line of code and providing recommendations for improving code.
•CloudWatch Lambda Insights – Monitor, troubleshoot, and optimize the performance of your Lambda 
functions through automated dashboards.
•AWS Distro for OpenTelemetry (ADOT) – Enables functions to send trace data to AWS monitoring 
services such as AWS X-Ray, and to destinations that support OpenTelemetry such as Honeycomb and 
Lightstep.
1004AWS Lambda Developer Guide
AWS managed extensions
•AWS Parameters and Secrets – Enables customers to securely retrieve parameters from AWS Systems 
Manager Parameter Store and secrets from AWS Secrets Manager.
For additional extensions samples and demo projects, see AWS Lambda Extensions.
1005AWS Lambda Developer Guide
Extensions API
Lambda Extensions API
Lambda function authors use extensions to integrate Lambda with their preferred tools for monitoring, 
observability, security, and governance. Function authors can use extensions from AWS, AWS 
Partners (p. 1004 ), and open-source projects. For more information on using extensions, see Introducing 
AWS Lambda Extensions on the AWS Compute Blog. This section describes how to use the Lambda 
Extensions API, the Lambda execution environment lifecycle, and the Lambda Extensions API reference.
As an extension author, you can use the Lambda Extensions API to integrate deeply into the Lambda
execution environment (p. 14). Your extension can register for function and execution environment 
lifecycle events. In response to these events, you can start new processes, run logic, and control and 
participate in all phases of the Lambda lifecycle: initialization, invocation, and shutdown. In addition, you 
can use the Runtime Logs API  (p. 1045 ) to receive a stream of logs.
An extension runs as an independent process in the execution environment and can continue to run after 
the function invocation is fully processed. Because extensions run as processes, you can write them in a 
diﬀerent language than the function. We recommend that you implement extensions using a compiled 
language. In this case, the extension is a self-contained binary that is compatible with supported 
runtimes. All Lambda runtimes  (p. 41) support extensions. If you use a non-compiled language, ensure 
that you include a compatible runtime in the extension.
Lambda also supports internal extensions. An internal extension runs as a separate thread in the runtime 
process. The runtime starts and stops the internal extension. An alternative way to integrate with the 
Lambda environment is to use language-speciﬁc environment variables and wrapper scripts (p. 52). You 
can use these to conﬁgure the runtime environment and modify the startup behavior of the runtime 
process.
You can add extensions to a function in two ways. For a function deployed as a .zip ﬁle archive (p. 18), 
you deploy your extension as a layer (p. 988). For a function deﬁned as a container image, you add the 
extensions (p. 1002 ) to your container image.
Note
For example extensions and wrapper scripts, see AWS Lambda Extensions on the AWS Samples 
GitHub repository.
Topics
•Lambda execution environment lifecycle (p. 1006 )
•Extensions API reference (p. 1012 )
Lambda execution environment lifecycle
The lifecycle of the execution environment includes the following phases:
1006AWS Lambda Developer Guide
Lambda execution environment lifecycle
•Init: In this phase, Lambda creates or unfreezes an execution environment with the conﬁgured 
resources, downloads the code for the function and all layers, initializes any extensions, initializes the 
runtime, and then runs the function’s initialization code (the code outside the main handler). The Init
phase happens either during the ﬁrst invocation, or in advance of function invocations if you have 
enabled provisioned concurrency (p. 237).
The Init phase is split into three sub-phases: Extension init , Runtime init , and Function 
init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before 
the function code runs.
•Invoke: In this phase, Lambda invokes the function handler. After the function runs to completion, 
Lambda prepares to handle another function invocation.
•Shutdown : This phase is triggered if the Lambda function does not receive any invocations for a period 
of time. In the Shutdown  phase, Lambda shuts down the runtime, alerts the extensions to let them 
stop cleanly, and then removes the environment. Lambda sends a Shutdown  event to each extension, 
which tells the extension that the environment is about to be shut down.
Each phase starts with an event from Lambda to the runtime and to all registered extensions. The 
runtime and each extension signal completion by sending a Next API request. Lambda freezes the 
execution environment when each process has completed and there are no pending events.
Topics
•Init phase  (p. 1008 )
•Invoke phase (p. 15)
•Shutdown phase (p. 16)
•Permissions and conﬁguration (p. 1011 )
•Failure handling (p. 1012 )
•Troubleshooting extensions (p. 1012 )
1007AWS Lambda Developer Guide
Lambda execution environment lifecycle
Init phase
During the Extension init  phase, each extension needs to register with Lambda to receive events. 
Lambda uses the full ﬁle name of the extension to validate that the extension has completed the 
bootstrap sequence. Therefore, each Register  API call must include the Lambda-Extension-Name
header with the full ﬁle name of the extension.
You can register up to 10 extensions for a function. This limit is enforced through the Register  API call.
After each extension registers, Lambda starts the Runtime init  phase. The runtime process calls
functionInit  to start the Function init  phase.
The Init phase completes after the runtime and each registered extension indicate completion by 
sending a Next API request.
Note
Extensions can complete their initialization at any point in the Init  phase.
Invoke phase
When a Lambda function is invoked in response to a Next API request, Lambda sends an Invoke event 
to the runtime and to each extension that is registered for the Invoke event.
During the invocation, external extensions run in parallel with the function. They also continue running 
after the function has completed. This enables you to capture diagnostic information or to send logs, 
metrics, and traces to a location of your choice.
1008AWS Lambda Developer Guide
Lambda execution environment lifecycle
After receiving the function response from the runtime, Lambda returns the response to the client, even 
if extensions are still running.
The Invoke phase ends after the runtime and all extensions signal that they are done by sending a Next
API request.
Event payload: The event sent to the runtime (and the Lambda function) carries the entire request, 
headers (such as RequestId ), and payload. The event sent to each extension contains metadata that 
describes the event content. This lifecycle event includes the type of the event, the time that the 
function times out (deadlineMs ), the requestId , the invoked function's Amazon Resource Name 
(ARN), and tracing headers.
Extensions that want to access the function event body can use an in-runtime SDK that communicates 
with the extension. Function developers use the in-runtime SDK to send the payload to the extension 
when the function is invoked.
Here is an example payload:
{ 
    "eventType": "INVOKE", 
    "deadlineMs": 676051, 
    "requestId": "3da1f2dc-3222-475e-9205-e2e6c6318895", 
    "invokedFunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:ExtensionTest", 
    "tracing": { 
        "type": "X-Amzn-Trace-Id", 
        "value": 
 "Root=1-5f35ae12-0c0fec141ab77a00bc047aa2;Parent=2be948a625588e32;Sampled=1" 
    } 
 }           
Duration limit : The function's timeout setting limits the duration of the entire Invoke phase. For 
example, if you set the function timeout as 360 seconds, the function and all extensions need to 
complete within 360 seconds. Note that there is no independent post-invoke phase. The duration is 
the sum of all invocation time (runtime + extensions) and is not calculated until the function and all 
extensions have ﬁnished running.
Performance impact and extension overhead: Extensions can impact function performance. As an 
extension author, you have control over the performance impact of your extension. For example, if 
your extension performs compute-intensive operations, the function's duration increases because the 
extension and the function code share the same CPU resources. In addition, if your extension performs 
1009AWS Lambda Developer Guide
Lambda execution environment lifecycle
extensive operations after the function invocation completes, the function duration increases because 
the Invoke phase continues until all extensions signal that they are completed.
Note
Lambda allocates CPU power in proportion to the function's memory setting. You might see 
increased execution and initialization duration at lower memory settings because the function 
and extension processes are competing for the same CPU resources. To reduce the execution and 
initialization duration, try increasing the memory setting.
To help identify the performance impact introduced by extensions on the Invoke  phase, Lambda 
outputs the PostRuntimeExtensionsDuration  metric. This metric measures the cumulative time 
spent between the runtime Next API request and the last extension Next API request. To measure the 
increase in memory used, use the MaxMemoryUsed  metric. For more information about function metrics, 
see Working with Lambda function metrics (p. 965).
Function developers can run diﬀerent versions of their functions side by side to understand the impact 
of a speciﬁc extension. We recommend that extension authors publish expected resource consumption to 
make it easier for function developers to choose a suitable extension.
Shutdown phase
When Lambda is about to shut down the runtime, it sends a Shutdown  to each registered external 
extension. Extensions can use this time for ﬁnal cleanup tasks. The Shutdown  event is sent in response 
to a Next API request.
Duration limit : The maximum duration of the Shutdown  phase depends on the conﬁguration of 
registered extensions:
•0 ms – A function with no registered extensions
•500 ms – A function with a registered internal extension
•2,000 ms – A function with one or more registered external extensions
For a function with external extensions, Lambda reserves up to 300 ms (500 ms for a runtime with 
an internal extension) for the runtime process to perform a graceful shutdown. Lambda allocates the 
remainder of the 2,000 ms limit for external extensions to shut down.
If the runtime or an extension does not respond to the Shutdown  event within the limit, Lambda ends 
the process using a SIGKILL  signal.
1010AWS Lambda Developer Guide
Lambda execution environment lifecycle
Event payload: The Shutdown  event contains the reason for the shutdown and the time remaining in 
milliseconds.
The shutdownReason  includes the following values:
•SPINDOWN – Normal shutdown
•TIMEOUT – Duration limit timed out
•FAILURE – Error condition, such as an out-of-memory  event
{  
  "eventType": "SHUTDOWN",  
  "shutdownReason": "reason for shutdown",  
  "deadlineMs": "the time and date that the function times out in Unix time milliseconds"  
}         
       
Permissions and conﬁguration
Extensions run in the same execution environment as the Lambda function. Extensions also share 
resources with the function, such as CPU, memory, and /tmp disk storage. In addition, extensions use the 
same AWS Identity and Access Management (IAM) role and security context as the function.
File system and network access permissions: Extensions run in the same ﬁle system and network 
name namespace as the function runtime. This means that extensions need to be compatible with the 
associated operating system. If an extension requires any additional outbound network traﬃc rules, you 
must apply these rules to the function conﬁguration.
Note
Because the function code directory is read-only, extensions cannot modify the function code.
1011AWS Lambda Developer Guide
Extensions API reference
Environment variables: Extensions can access the function's environment variables (p. 77), except for the 
following variables that are speciﬁc to the runtime process:
•AWS_EXECUTION_ENV
•AWS_LAMBDA_LOG_GROUP_NAME
•AWS_LAMBDA_LOG_STREAM_NAME
•AWS_XRAY_CONTEXT_MISSING
•AWS_XRAY_DAEMON_ADDRESS
•LAMBDA_RUNTIME_DIR
•LAMBDA_TASK_ROOT
•_AWS_XRAY_DAEMON_ADDRESS
•_AWS_XRAY_DAEMON_PORT
•_HANDLER
Failure handling
Initialization failures : If an extension fails, Lambda restarts the execution environment to enforce 
consistent behavior and to encourage fail fast for extensions. Also, for some customers, the extensions 
must meet mission-critical needs such as logging, security, governance, and telemetry collection.
Invoke failures (such as out of memory, function timeout): Because extensions share resources with the 
runtime, memory exhaustion aﬀects them. When the runtime fails, all extensions and the runtime itself 
participate in the Shutdown  phase. In addition, the runtime is restarted—either automatically as part of 
the current invocation, or via a deferred re-initialization mechanism.
If there is a failure (such as a function timeout or runtime error) during Invoke, the Lambda service 
performs a reset. The reset behaves like a Shutdown  event. First, Lambda shuts down the runtime, then 
it sends a Shutdown  event to each registered external extension. The event includes the reason for the 
shutdown. If this environment is used for a new invocation, the extension and runtime are re-initialized 
as part of the next invocation.
For a more detailed explanation of the previous diagram, see Failures during the invoke phase (p. 16).
Extension logs: Lambda sends the log output of extensions to CloudWatch Logs. Lambda also generates 
an additional log event for each extension during Init. The log event records the name and registration 
preference (event, conﬁg) on success, or the failure reason on failure.
Troubleshooting extensions
•If a Register  request fails, make sure that the Lambda-Extension-Name  header in the Register
API call contains the full ﬁle name of the extension.
•If the Register  request fails for an internal extension, make sure that the request does not register 
for the Shutdown  event.
Extensions API reference
The OpenAPI speciﬁcation for the extensions API version 2020-01-01  is available here: extensions-api.zip
1012AWS Lambda Developer Guide
Extensions API reference
You can retrieve the value of the API endpoint from the AWS_LAMBDA_RUNTIME_API  environment 
variable. To send a Register  request, use the preﬁx 2020-01-01/  before each API path. For example:
http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/register 
API methods
•Register (p. 1013 )
•Next (p. 1014 )
•Init error (p. 1015 )
•Exit error (p. 1016 )
Register
During Extension init , all extensions need to register with Lambda to receive events. Lambda uses 
the full ﬁle name of the extension to validate that the extension has completed the bootstrap sequence. 
Therefore, each Register  API call must include the Lambda-Extension-Name  header with the full ﬁle 
name of the extension.
Internal extensions are started and stopped by the runtime process, so they are not permitted to register 
for the Shutdown  event.
Path – /extension/register
Method  – POST
Request headers
•Lambda-Extension-Name  – The full ﬁle name of the extension. Required: yes. Type: string.
•Lambda-Extension-Accept-Feature  – Use this to specify optional Extensions features during 
registration. Required: no. Type: comma separated string. Features available to specify using this 
setting:
•accountId  – If speciﬁed, the Extension registration response will contain the account ID associated 
with the Lambda function that you're registering the Extension for.
Request body parameters
•events – Array of the events to register for. Required: no. Type: array of strings. Valid strings: INVOKE ,
SHUTDOWN .
Response headers
•Lambda-Extension-Identifier  – Generated unique agent identiﬁer (UUID string) that is required 
for all subsequent requests.
Response codes
•200 – Response body contains the function name, function version, and handler name.
•400 – Bad Request
•403 – Forbidden
•500 – Container error. Non-recoverable state. Extension should exit promptly.
1013AWS Lambda Developer Guide
Extensions API reference
Example Example request body
{ 
    'events': [ 'INVOKE', 'SHUTDOWN']
}              
Example Example response body
{ 
    "functionName": "helloWorld", 
    "functionVersion": "$LATEST", 
    "handler": "lambda_function.lambda_handler"
}                
Example Example response body with optional accountId feature
{ 
    "functionName": "helloWorld", 
    "functionVersion": "$LATEST", 
    "handler": "lambda_function.lambda_handler", 
    "accountId": "123456789012"
}
Next
Extensions send a Next API request to receive the next event, which can be an Invoke event or a
Shutdown  event. The response body contains the payload, which is a JSON document that contains 
event data.
The extension sends a Next API request to signal that it is ready to receive new events. This is a blocking 
call.
Do not set a timeout on the GET call, as the extension can be suspended for a period of time until there 
is an event to return.
Path – /extension/event/next
Method  – GET
Request headers
•Lambda-Extension-Identifier  – Unique identiﬁer for extension (UUID string). Required: yes. 
Type: UUID string.
Response headers
•Lambda-Extension-Event-Identifier  – Unique identiﬁer for the event (UUID string).
Response codes
•200 – Response contains information about the next event (EventInvoke  or EventShutdown ).
•403 – Forbidden
•500 – Container error. Non-recoverable state. Extension should exit promptly.
1014AWS Lambda Developer Guide
Extensions API reference
Init error
The extension uses this method to report an initialization error to Lambda. Call it when the extension 
fails to initialize after it has registered. After Lambda receives the error, no further API calls succeed. The 
extension should exit after it receives the response from Lambda.
Path – /extension/init/error
Method  – POST
Request headers
•Lambda-Extension-Identifier  – Unique identiﬁer for extension. Required: yes. Type: UUID string.
•Lambda-Extension-Function-Error-Type  – Error type that the extension encountered. Required: 
yes. This header consists of a string value. Lambda accepts any string, but we recommend a format of 
<category.reason>. For example:
•Extension.NoSuchHandler
•Extension.APIKeyNotFound
•Extension.ConﬁgInvalid
•Extension.UnknownReason
Request body parameters
•ErrorRequest  – Information about the error. Required: no.
This ﬁeld is a JSON object with the following structure:
{ 
      errorMessage: string (text description of the error), 
      errorType: string, 
      stackTrace: array of strings
}
Note that Lambda accepts any value for errorType .
The following example shows a Lambda function error message in which the function could not parse 
the event data provided in the invocation.
Example Function error
{ 
      "errorMessage" : "Error parsing event data.", 
      "errorType" : "InvalidEventDataException", 
      "stackTrace": [ ]
}       
Response codes
•202 – Accepted
•400 – Bad Request
•403 – Forbidden
•500 – Container error. Non-recoverable state. Extension should exit promptly.
1015AWS Lambda Developer Guide
Extensions API reference
Exit error
The extension uses this method to report an error to Lambda before exiting. Call it when you encounter 
an unexpected failure. After Lambda receives the error, no further API calls succeed. The extension 
should exit after it receives the response from Lambda.
Path – /extension/exit/error
Method  – POST
Request headers
•Lambda-Extension-Identifier  – Unique identiﬁer for extension. Required: yes. Type: UUID string.
•Lambda-Extension-Function-Error-Type  – Error type that the extension encountered. Required: 
yes. This header consists of a string value. Lambda accepts any string, but we recommend a format of 
<category.reason>. For example:
•Extension.NoSuchHandler
•Extension.APIKeyNotFound
•Extension.ConﬁgInvalid
•Extension.UnknownReason
Request body parameters
•ErrorRequest  – Information about the error. Required: no.
This ﬁeld is a JSON object with the following structure:
{ 
      errorMessage: string (text description of the error), 
      errorType: string, 
      stackTrace: array of strings
}
Note that Lambda accepts any value for errorType .
The following example shows a Lambda function error message in which the function could not parse 
the event data provided in the invocation.
Example Function error
{ 
      "errorMessage" : "Error parsing event data.", 
      "errorType" : "InvalidEventDataException", 
      "stackTrace": [ ]
}       
Response codes
•202 – Accepted
•400 – Bad Request
•403 – Forbidden
•500 – Container error. Non-recoverable state. Extension should exit promptly.
1016AWS Lambda Developer Guide
Telemetry API
Lambda Telemetry API
Using the Lambda Telemetry API, your extensions can directly receive telemetry data from Lambda. 
During function initialization and invocation, Lambda automatically captures telemetry, such as logs, 
platform metrics, and platform traces. With Telemetry API, extensions can get this telemetry data 
directly from Lambda in near real time.
You can subscribe your Lambda extensions to telemetry streams directly from within the Lambda 
execution environment. After subscribing, Lambda automatically streams all telemetry data to your 
extensions. You can then process, ﬁlter, and deliver that data to your preferred destination, such as an 
Amazon Simple Storage Service (Amazon S3) bucket or a third-party observability tools provider.
The following diagram shows how the Extensions API and Telemetry API connect extensions to Lambda 
from within the execution environment. The Runtime API also connects your runtime and function to 
Lambda.
Important
The Lambda Telemetry API supersedes the Lambda Logs API. While the Logs API remains fully 
functional, we recommend using only the Telemetry API going forward. You can subscribe 
your extension to a telemetry stream using either the Telemetry API or the Logs API. After 
subscribing using one of these APIs, any attempt to subscribe using the other API returns an 
error.
Extensions can use the Telemetry API to subscribe to three diﬀerent telemetry streams:
•Platform telemetry – Logs, metrics, and traces, which describe events and errors related to the 
execution environment runtime lifecycle, extension lifecycle, and function invocations.
•Function logs – Custom logs that the Lambda function code generates.
•Extension logs – Custom logs that the Lambda extension code generates.
Note
Lambda sends logs and metrics to CloudWatch, and traces to X-Ray (if you've activated tracing), 
even if an extension subscribes to telemetry streams.
Sections
•Creating extensions using the Telemetry API (p. 1018 )
•Registering your extension (p. 1019 )
•Creating a telemetry listener (p. 1019 )
•Specifying a destination protocol (p. 1020 )
•Conﬁguring memory usage and buﬀering (p. 1021 )
•Sending a subscription request to the Telemetry API (p. 1022 )
•Inbound Telemetry API messages (p. 1022 )
1017AWS Lambda Developer Guide
Creating extensions using the Telemetry API
•Lambda Telemetry API reference (p. 1025 )
•Lambda Telemetry API Event schema reference (p. 1028 )
•Converting Lambda Telemetry API Event objects to OpenTelemetry Spans (p. 1041 )
•Lambda Logs API  (p. 1045 )
Creating extensions using the Telemetry API
Lambda extensions run as independent processes in the execution environment, and can continue to 
run after the function invocation completes. Because extensions are separate processes, you can write 
them in a language diﬀerent from the function code. We recommend implementing extensions using a 
compiled language such as Golang or Rust. This way, the extension is a self-contained binary that can be 
compatible with any supported runtime.
The following diagram illustrates a four-step process to create an extension that receives and processes 
telemetry data using the Telemetry API.
Here is each step in more detail:
1.Register your extension using the the section called “Extensions API” (p. 1006 ). This provides you with 
a Lambda-Extension-Identifier , which you'll need in the following steps. For more information 
about how to register your extension, see the section called “Registering your extension” (p. 1019 ).
2.Create a telemetry listener. This can be a basic HTTP or TCP server. Lambda uses the URI of the 
telemetry listener to send telemetry data to your extension. For more information, see the section 
called “Creating a telemetry listener” (p. 1019 ).
3.Using the Subscribe API in the Telemetry API, subscribe your extension to your desired telemetry 
streams. You'll need the URI of your telemetry listener for this step. For more information, see the 
section called “Sending a subscription request to the Telemetry API” (p. 1022 ).
4.Get telemetry data from Lambda via the telemetry listener. You can do any custom processing of this 
data, such as dispatching the data to Amazon S3 or to an external observability service.
1018AWS Lambda Developer Guide
Registering your extension
Note
A Lambda function's execution environment can start and stop multiple times as part of its
lifecycle (p. 1006 ). In general, your extension code runs during function invocations, and also up 
to 2 seconds during the shutdown phase. We recommend batching the telemetry as it arrives to 
your listener, and using the Invoke  and Shutdown  lifecycle events to dispatch each batch to 
their desired destinations.
Registering your extension
Before you can subscribe to receive telemetry data, you must register your Lambda extension. 
Registration occurs during the extension initialization phase (p. 1008 ). The following example shows an 
HTTP request to register an extension.
POST http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/register 
 Lambda-Extension-Name: lambda_extension_name
{ 
    'events': [ 'INVOKE', 'SHUTDOWN']
}
If the request succeeds, the subscriber receives an HTTP 200 success response. The response header 
contains the Lambda-Extension-Identifier . The response body contains other properties of the 
function.
HTTP/1.1 200 OK
Lambda-Extension-Identifier: a1b2c3d4-5678-90ab-cdef-EXAMPLE11111
{ 
    "functionName": "lambda_function", 
    "functionVersion": "$LATEST", 
    "handler": "lambda_handler", 
    "accountId": "123456789012"
}
For more information, see the the section called “Extensions API reference” (p. 1012 ).
Creating a telemetry listener
Your Lambda extension must have a listener that handles incoming requests from the Telemetry API. The 
following code shows an example telemetry listener implementation in Golang:
// Starts the server in a goroutine where the log events will be sent
func (s *TelemetryApiListener) Start() (string, error) { 
 address := listenOnAddress() 
 l.Info("[listener:Start] Starting on address", address) 
 s.httpServer = &http.Server{Addr: address} 
 http.HandleFunc("/", s.http_handler) 
 go func() { 
  err := s.httpServer.ListenAndServe() 
  if err != http.ErrServerClosed { 
   l.Error("[listener:goroutine] Unexpected stop on Http Server:", err) 
   s.Shutdown() 
  } else { 
   l.Info("[listener:goroutine] Http Server closed:", err) 
  } 
 }() 
 return fmt.Sprintf("http://%s/", address), nil
}
// http_handler handles the requests coming from the Telemetry API.
// Everytime Telemetry API sends log events, this function will read them from the response 
 body
1019AWS Lambda Developer Guide
Specifying a destination protocol
// and put into a synchronous queue to be dispatched later.
// Logging or printing besides the error cases below is not recommended if you have 
 subscribed to
// receive extension logs. Otherwise, logging here will cause Telemetry API to send new 
 logs for
// the printed lines which may create an infinite loop.
func (s *TelemetryApiListener) http_handler(w http.ResponseWriter, r *http.Request) { 
 body, err := ioutil.ReadAll(r.Body) 
 if err != nil { 
  l.Error("[listener:http_handler] Error reading body:", err) 
  return 
 } 
 // Parse and put the log messages into the queue 
 var slice []interface{} 
 _ = json.Unmarshal(body, &slice) 
 for _, el := range slice { 
  s.LogEventsQueue.Put(el) 
 } 
 l.Info("[listener:http_handler] logEvents received:", len(slice), " LogEventsQueue 
 length:", s.LogEventsQueue.Len()) 
 slice = nil
}
Specifying a destination protocol
When you subscribe to receive telemetry using the Telemetry API, you can specify a destination protocol 
in addition to the destination URI:
{ 
    "destination": { 
        "protocol": "HTTP", 
        "URI": "http://sandbox.localdomain:8080" 
    }
}
Lambda accepts two protocols for receiving telemetry:
•HTTP (recommended) – Lambda delivers telemetry to a local HTTP endpoint (http://
sandbox.localdomain:${PORT}/${PATH} ) as an array of records in JSON format. The $PATH
parameter is optional. Lambda supports only HTTP, not HTTPS. Lambda delivers telemetry through 
POST requests.
•TCP – Lambda delivers telemetry to a TCP port in Newline delimited JSON (NDJSON) format.
Note
We strongly recommend using HTTP rather than TCP. With TCP, the Lambda platform cannot 
acknowledge when it delivers telemetry to the application layer. Therefore, if your extension 
crashes, you might lose telemetry. HTTP does not have this limitation.
Before subscribing to receive telemetry, set up the local HTTP listener or TCP port. During setup, note 
the following:
•Lambda sends telemetry only to destinations that are inside the execution environment.
•Lambda retries the attempt to send telemetry (with backoﬀ) if there is no listener, or if the POST 
request results in an error. If the telemetry listener crashes, then it continues to receive telemetry after 
Lambda restarts the execution environment.
•Lambda reserves port 9001. There are no other port number restrictions or recommendations.
1020AWS Lambda Developer Guide
Conﬁguring memory usage and buﬀering
Conﬁguring memory usage and buﬀering
An execution environment's memory usage increases linearly as the number of subscribers increases. 
Subscriptions consume memory resources because each subscription opens a new memory buﬀer 
to store telemetry data. Buﬀer memory usage counts towards overall memory consumption in the 
execution environment.
When you subscribe to receive telemetry using the Telemetry API, you can buﬀer telemetry data 
and deliver it to subscribers in batches. To help optimize memory usage, you can specify a buﬀering 
conﬁguration:
{ 
    "buffering": { 
        "maxBytes": 256*1024, 
        "maxItems": 1000, 
        "timeoutMs": 100 
    }
}
Buﬀering conﬁguration settings
Parameter Description Defaults and limits
maxBytes The maximum volume of 
telemetry (in bytes) to buﬀer in 
memory.Default: 262,144
Minimum: 262,144
Maximum: 1,048,576
maxItems The maximum number of events 
to buﬀer in memory.Default: 10,000
Minimum: 1,000
Maximum: 10,000
timeoutMs The maximum time (in 
milliseconds) to buﬀer a batch.Default: 1,000
Minimum: 25
Maximum: 30,000
When conﬁguring buﬀering, note the following points:
•If any of the input streams are closed, then Lambda ﬂushes the logs. This can happen if, for example, 
the runtime crashes.
•Each subscriber can specify a diﬀerent buﬀering conﬁguration in their subscription request.
•Consider the buﬀer size that you need for reading the data. Expect to receive payloads as large as 2 * 
maxBytes + metadataBytes , where maxBytes  is part of your buﬀering conﬁguration. To get an 
idea of how much metadataBytes  you should account for, review the following metadata. Lambda 
adds metadata similar to this to each record:
{ 
   "time": "2022-08-20T12:31:32.123Z", 
   "type": "function", 
   "record": "Hello World"
}
1021AWS Lambda Developer Guide
Sending a subscription request to the Telemetry API
•If the subscriber cannot process incoming telemetry fast enough, Lambda might drop records to keep 
memory utilization bounded. When this occurs, Lambda sends a platform.logsDropped  event.
Sending a subscription request to the Telemetry API
Lambda extensions can subscribe to receive telemetry data by sending a subscription request to the 
Telemetry API. The subscription request should contain information about the types of events that 
you want the extension to subscribe to. In addition, the request can contain delivery destination 
information  (p. 1020 ) and a buﬀering conﬁguration (p. 1021 ).
Before sending a subscription request, you must have an extension ID (Lambda-Extension-
Identifier ). When you register your extension with the Extensions API (p. 1019 ), you obtain an 
extension ID from the API response.
Subscription occurs during the extension initialization phase (p. 1008 ). The following example shows 
an HTTP request to subscribe to all three telemetry streams: platform telemetry, function logs, and 
extension logs.
PUT http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry HTTP/1.1
{ 
   "schemaVersion": "2022-07-01", 
   "types": [ 
        "platform", 
        "function", 
        "extension" 
   ], 
   "buffering": { 
        "maxItems": 1000, 
        "maxBytes": 256*1024, 
        "timeoutMs": 100 
   }, 
   "destination": { 
        "protocol": "HTTP", 
        "URI": "http://sandbox.localdomain:8080" 
   }
}
If the request succeeds, then the subscriber receives an HTTP 200 success response.
HTTP/1.1 200 OK
"OK"
Inbound Telemetry API messages
After subscribing using the Telemetry API, an extension automatically starts to receive telemetry from 
Lambda via POST requests to the telemetry listener. Each POST request body contains an array of Event
objects. Event is a JSON object with the following schema:
{ 
   time: String, 
   type: String, 
   record: Object
}
•The time property deﬁnes when the Lambda platform generated the event. This isn't the same as 
when the event actually occurred. The string value of time is a timestamp in ISO 8601 format.
1022AWS Lambda Developer Guide
Inbound Telemetry API messages
•The type property deﬁnes the event type. The following table describes all possible values.
•The record property deﬁnes a JSON object that contains the telemetry data. The schema of this 
JSON object depends on the type .
The following table summarizes all types of Event objects, and links to the Telemetry API Event
schema reference (p. 1028 ) for each event type.
Telemetry API message types
Category Event type Description Event record schema
Platform event platform.initStart Function initialization 
started.the section called 
“platform.initStart ” (p. 1030 )
schema
Platform event platform.initRuntimeDone Function initialization 
completed.the section called 
“platform.initRuntimeDone ” (p. 1030 )
schema
Platform event platform.initReport A report of function 
initialization.the section called 
“platform.initReport ” (p. 1031 )
schema
Platform event platform.start Function invocation 
started.the section called 
“platform.start ” (p. 1031 )
schema
Platform event platform.runtimeDone The runtime ﬁnished 
processing an event 
with either success or 
failure.the section called 
“platform.runtimeDone ” (p. 1032 )
schema
Platform event platform.report A report of function 
invocation.the section called 
“platform.report ” (p. 1033 )
schema
Platform event platform.restoreStart Runtime restore 
started.the section called 
“platform.restoreStart ” (p. 1033 )
schema
Platform event platform.restoreRuntimeDone Runtime restore 
completed.the section called 
“platform.restoreRuntimeDone ” (p. 1034 )
schema
Platform event platform.restoreReport Report of runtime 
restore.the section called 
“platform.restoreReport ” (p. 1035 )
schema
Platform event platform.telemetrySubscription The extension 
subscribed to the 
Telemetry API.the section called 
“platform.telemetrySubscription ” (p. 1036 )
schema
Platform event platform.logsDropped Lambda dropped log 
entries.the section called 
“platform.logsDropped ” (p. 1036 )
schema
Function logs function A log line from function 
code.the section called 
“function ” (p. 1037 )
schema
1023AWS Lambda Developer Guide
Inbound Telemetry API messages
CategoryEvent type Description Event record schema
Extension logs extension A log line from 
extension code.the section called 
“extension ” (p. 1037 )
schema
1024AWS Lambda Developer Guide
API reference
Lambda Telemetry API reference
Use the Lambda Telemetry API endpoint to subscribe extensions to telemetry streams. You can retrieve 
the Telemetry API endpoint from the AWS_LAMBDA_RUNTIME_API  environment variable. To send an API 
request, append the API version (2022-07-01/ ) and telemetry/ . For example:
http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry/
For the OpenAPI Speciﬁcation (OAS) deﬁnition of the subscription responses version 2022-07-01 , see 
the following:
•HTTP – telemetry-api-http-schema.zip
•TCP – telemetry-api-tcp-schema.zip
API operations
•Subscribe  (p. 1025 )
Subscribe
To subscribe to a telemetry stream, a Lambda extension can send a Subscribe API request.
•Path – /telemetry
•Method  – PUT
•Headers
•Content-Type : application/json
•Request body parameters
•schemaVersion
•Required: Yes
•Type: String
•Valid values: "2022-07-01"
•destination  – The conﬁguration settings that deﬁne the telemetry event destination and the 
protocol for event delivery.
•Required: Yes
•Type: Object
{ 
    "protocol": "HTTP", 
    "URI": "http://sandbox.localdomain:8080"
}
•protocol – The protocol that Lambda uses to send telemetry data.
•Required: Yes
•Type: String
•Valid values: "HTTP" |"TCP"
•URI – The URI to send telemetry data to.
•Required: Yes
•Type: String
•For more information, see the section called “Specifying a destination protocol” (p. 1020 ).
•types – The types of telemetry that you want the extension to subscribe to.
1025AWS Lambda Developer Guide
API reference
•Required: Yes
•Type: Array of strings
•Valid values: "platform" |"function" |"extension"
•buﬀering  – The conﬁguration settings for event buﬀering.
•Required: No
•Type: Object
{ 
   "buffering": { 
        "maxItems": 1000, 
        "maxBytes": 256*1024, 
        "timeoutMs": 100 
   }
}
•maxItems  – The maximum number of events to buﬀer in memory.
•Required: No
•Type: Integer
•Default: 1,000
•Minimum: 1,000
•Maximum: 10,000
•maxBytes – The maximum volume of telemetry (in bytes) to buﬀer in memory.
•Required: No
•Type: Integer
•Default: 262,144
•Minimum: 262,144
•Maximum: 1,048,576
•timeoutMs  – The maximum time (in milliseconds) to buﬀer a batch.
•Required: No
•Type: Integer
•Default: 1,000
•Minimum: 25
•Maximum: 30,000
•For more information, see the section called “Conﬁguring memory usage and buﬀering” (p. 1021 ).
Example Subscribe API request
PUT http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry HTTP/1.1
{ 
   "schemaVersion": "2022-07-01", 
   "types": [ 
        "platform", 
        "function", 
        "extension" 
   ], 
   "buffering": { 
        "maxItems": 1000, 
        "maxBytes": 256*1024, 
        "timeoutMs": 100 
   }, 
   "destination": { 
        "protocol": "HTTP", 
        "URI": "http://sandbox.localdomain:8080" 
1026AWS Lambda Developer Guide
API reference
   }
}
If the Subscribe request succeeds, the extension receives an HTTP 200 success response:
HTTP/1.1 200 OK
"OK"
If the Subscribe request fails, the extension receives an error response. For example:
HTTP/1.1 400 OK
{ 
    "errorType": "ValidationError", 
    "errorMessage": "URI port is not provided; types should not be empty"
}
Here are some additional response codes that the extension can receive:
•200 – Request completed successfully
•202 – Request accepted. Subscription request response in local testing environment
•400 – Bad request
•500 – Service error
1027AWS Lambda Developer Guide
Event schema reference
Lambda Telemetry API Event schema reference
Use the Lambda Telemetry API endpoint to subscribe extensions to telemetry streams. You can retrieve 
the Telemetry API endpoint from the AWS_LAMBDA_RUNTIME_API  environment variable. To send an API 
request, append the API version (2022-07-01/ ) and telemetry/ . For example:
http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry/
For the OpenAPI Speciﬁcation (OAS) deﬁnition of the subscription responses version 2022-07-01 , see 
the following:
•HTTP – telemetry-api-http-schema.zip
•TCP – telemetry-api-tcp-schema.zip
The following table is a summary of all the types of Event objects that the Telemetry API supports.
Telemetry API message types
Category Event type Description Event record schema
Platform event platform.initStart Function initialization 
started.the section called 
“platform.initStart ” (p. 1030 )
schema
Platform event platform.initRuntimeDone Function initialization 
completed.the section called 
“platform.initRuntimeDone ” (p. 1030 )
schema
Platform event platform.initReport A report of function 
initialization.the section called 
“platform.initReport ” (p. 1031 )
schema
Platform event platform.start Function invocation 
started.the section called 
“platform.start ” (p. 1031 )
schema
Platform event platform.runtimeDone The runtime ﬁnished 
processing an event 
with either success or 
failure.the section called 
“platform.runtimeDone ” (p. 1032 )
schema
Platform event platform.report A report of function 
invocation.the section called 
“platform.report ” (p. 1033 )
schema
Platform event platform.restoreStart Runtime restore 
started.the section called 
“platform.restoreStart ” (p. 1033 )
schema
Platform event platform.restoreRuntimeDone Runtime restore 
completed.the section called 
“platform.restoreRuntimeDone ” (p. 1034 )
schema
Platform event platform.restoreReport Report of runtime 
restore.the section called 
“platform.restoreReport ” (p. 1035 )
schema
1028AWS Lambda Developer Guide
Event schema reference
CategoryEvent type Description Event record schema
Platform event platform.telemetrySubscription The extension 
subscribed to the 
Telemetry API.the section called 
“platform.telemetrySubscription ” (p. 1036 )
schema
Platform event platform.logsDropped Lambda dropped log 
entries.the section called 
“platform.logsDropped ” (p. 1036 )
schema
Function logs function A log line from function 
code.the section called 
“function ” (p. 1037 )
schema
Extension logs extension A log line from 
extension code.the section called 
“extension ” (p. 1037 )
schema
Contents
•Telemetry API Event object types (p. 1030 )
•platform.initStart (p. 1030 )
•platform.initRuntimeDone (p. 1030 )
•platform.initReport (p. 1031 )
•platform.start (p. 1031 )
•platform.runtimeDone (p. 1032 )
•platform.report (p. 1033 )
•platform.restoreStart (p. 1033 )
•platform.restoreRuntimeDone (p. 1034 )
•platform.restoreReport (p. 1035 )
•platform.extension (p. 1035 )
•platform.telemetrySubscription (p. 1036 )
•platform.logsDropped (p. 1036 )
•function (p. 1037 )
•extension (p. 1037 )
•Shared object types (p. 1037 )
•InitPhase  (p. 1037 )
•InitReportMetrics (p. 1038 )
•InitType (p. 1038 )
•ReportMetrics (p. 1038 )
•RestoreReportMetrics (p. 1038 )
•RuntimeDoneMetrics  (p. 1039 )
•Span  (p. 1039 )
•Status  (p. 1039 )
•TraceContext (p. 1040 )
•TracingType (p. 1040 )
1029AWS Lambda Developer Guide
Event schema reference
Telemetry API Event object types
This section details the types of Event objects that the Lambda Telemetry API supports. In the event 
descriptions, a question mark ( ?) indicates that the attribute may not be present in the object.
platform.initStart
A platform.initStart  event indicates that the function initialization phase has started. A
platform.initStart  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.initStart
- record: PlatformInitStart
The PlatformInitStart  object has the following attributes:
•initializationType – the section called “ InitType ” (p. 1038) object
•phase  – the section called “ InitPhase ” (p. 1037) object
•runtimeVersion? – String
•runtimeVersionArn? – String
The following is an example Event of type platform.initStart :
{ 
    "time": "2022-10-12T00:00:15.064Z", 
    "type": "platform.initStart", 
    "record": { 
        "initializationType": "on-demand", 
        "phase": "init", 
        "runtimeVersion": "nodejs-14.v3", 
        "runtimeVersionArn": "arn" 
    }
}
platform.initRuntimeDone
A platform.initRuntimeDone  event indicates that the function initialization phase has completed. A
platform.initRuntimeDone  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.initRuntimeDone
- record: PlatformInitRuntimeDone
The PlatformInitRuntimeDone  object has the following attributes:
•initializationType – the section called “ InitType ” (p. 1038) object
•phase  – the section called “ InitPhase ” (p. 1037) object
•status  – the section called “ Status” (p. 1039) object
•spans?  – List of the section called “Span”  (p. 1039) objects
The following is an example Event of type platform.initRuntimeDone :
1030AWS Lambda Developer Guide
Event schema reference
{ 
    "time": "2022-10-12T00:01:15.000Z", 
    "type": "platform.initRuntimeDone", 
    "record": { 
        "initializationType": "on-demand" 
        "status": "success", 
        "spans": [ 
            { 
                "name": "someTimeSpan", 
                "start": "2022-06-02T12:02:33.913Z", 
                "durationMs": 70.5 
            } 
        ] 
    }
}
platform.initReport
A platform.initReport  event contains an overall report of the function initialization phase. A
platform.initReport  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.initReport
- record: PlatformInitReport
The PlatformInitReport  object has the following attributes:
•initializationType – the section called “ InitType ” (p. 1038) object
•phase  – the section called “ InitPhase ” (p. 1037) object
•metrics  – the section called “ InitReportMetrics ” (p. 1038) object
•spans?  – List of the section called “Span”  (p. 1039) objects
The following is an example Event of type platform.initReport :
{ 
    "time": "2022-10-12T00:01:15.000Z", 
    "type": "platform.initReport", 
    "record": { 
        "initializationType": "on-demand", 
        "phase": "init", 
        "metrics": { 
            "durationMs": 125.33 
        }, 
        "spans": [ 
            { 
                "name": "someTimeSpan", 
                "start": "2022-06-02T12:02:33.913Z", 
                "durationMs": 90.1 
            } 
        ] 
    }
}
platform.start
A platform.start  event indicates that the function invocation phase has started. A platform.start
Event object has the following shape:
1031AWS Lambda Developer Guide
Event schema reference
Event: Object
- time: String
- type: String = platform.start
- record: PlatformStart
The PlatformStart  object has the following attributes:
•requestId  – String
•version? – String
•tracing?  – the section called “ TraceContext ” (p. 1040)
The following is an example Event of type platform.start :
{ 
    "time": "2022-10-12T00:00:15.064Z", 
    "type": "platform.initStart", 
    "record": { 
        "requestId": "6d68ca91-49c9-448d-89b8-7ca3e6dc66aa", 
        "version": "$LATEST", 
        "tracing": { 
            "spanId": "54565fb41ac79632", 
            "type": "X-Amzn-Trace-Id", 
            "value": 
 "Root=1-62e900b2-710d76f009d6e7785905449a;Parent=0efbd19962d95b05;Sampled=1" 
        } 
    }
}
platform.runtimeDone
A platform.runtimeDone  event indicates that the function invocation phase has completed. A
platform.runtimeDone  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.runtimeDone
- record: PlatformRuntimeDone
The PlatformRuntimeDone  object has the following attributes:
•errorType? – String
•metrics?  – the section called “ RuntimeDoneMetrics ” (p. 1039) object
•requestId  – String
•status  – the section called “ Status” (p. 1039) object
•spans?  – List of the section called “Span”  (p. 1039) objects
•tracing?  – the section called “ TraceContext ” (p. 1040) object
The following is an example Event of type platform.runtimeDone :
{ 
    "time": "2022-10-12T00:01:15.000Z", 
    "type": "platform.runtimeDone", 
    "record": { 
        "requestId": "6d68ca91-49c9-448d-89b8-7ca3e6dc66aa", 
        "status": "success", 
1032AWS Lambda Developer Guide
Event schema reference
        "tracing": { 
            "spanId": "54565fb41ac79632", 
            "type": "X-Amzn-Trace-Id", 
            "value": 
 "Root=1-62e900b2-710d76f009d6e7785905449a;Parent=0efbd19962d95b05;Sampled=1" 
        }, 
        "spans": [ 
            { 
                "name": "someTimeSpan", 
                "start": "2022-08-02T12:01:23:521Z", 
                "durationMs": 80.0 
            } 
        ], 
        "metrics": { 
            "durationMs": 140.0, 
            "producedBytes": 16 
        } 
    }
}
platform.report
A platform.report  event contains an overall report of the function initialization phase. A
platform.report  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.report
- record: PlatformReport
The PlatformReport  object has the following attributes:
•metrics  – the section called “ ReportMetrics ” (p. 1038) object
•requestId  – String
•spans?  – List of the section called “Span”  (p. 1039) objects
•status  – the section called “ Status” (p. 1039) object
•tracing?  – the section called “ TraceContext ” (p. 1040) object
The following is an example Event of type platform.report :
{ 
    "time": "2022-10-12T00:01:15.000Z", 
    "type": "platform.report", 
    "record": { 
        "metrics": { 
            "billedDurationMs": 694, 
            "durationMs": 693.92, 
            "initDurationMs": 397.68, 
            "maxMemoryUsedMB": 84, 
            "memorySizeMB": 128 
        }, 
        "requestId": "6d68ca91-49c9-448d-89b8-7ca3e6dc66aa", 
    }
}
platform.restoreStart
A platform.restoreStart  event indicates that a function environment restoration event started. 
In an environment restoration event, Lambda creates the environment from a cached snapshot 
1033AWS Lambda Developer Guide
Event schema reference
rather than initializing it from scratch. For more information, see Lambda SnapStart (p. 1098 ). A
platform.restoreStart  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.restoreStart
- record: PlatformRestoreStart
The PlatformRestoreStart  object has the following attributes:
•runtimeVersion? – String
•runtimeVersionArn? – String
The following is an example Event of type platform.restoreStart :
{ 
    "time": "2022-10-12T00:00:15.064Z", 
    "type": "platform.restoreStart", 
    "record": { 
        "runtimeVersion": "nodejs-14.v3", 
        "runtimeVersionArn": "arn" 
    }
}
platform.restoreRuntimeDone
A platform.restoreRuntimeDone  event indicates that a function environment restoration event 
completed. In an environment restoration event, Lambda creates the environment from a cached 
snapshot rather than initializing it from scratch. For more information, see Lambda SnapStart (p. 1098 ). 
A platform.restoreRuntimeDone  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.restoreRuntimeDone
- record: PlatformRestoreRuntimeDone
The PlatformRestoreRuntimeDone  object has the following attributes:
•errorType? – String
•spans?  – List of the section called “Span”  (p. 1039) objects
•status  – the section called “ Status” (p. 1039) object
The following is an example Event of type platform.restoreRuntimeDone :
{ 
    "time": "2022-10-12T00:00:15.064Z", 
    "type": "platform.restoreRuntimeDone", 
    "record": { 
        "status": "success", 
        "spans": [ 
            { 
                "name": "someTimeSpan", 
                "start": "2022-08-02T12:01:23:521Z", 
                "durationMs": 80.0 
            } 
        ] 
    }
1034AWS Lambda Developer Guide
Event schema reference
}
platform.restoreReport
A platform.restoreReport  event contains an overall report of a function restoration event. A
platform.restoreReport  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.restoreReport
- record: PlatformRestoreReport
The PlatformRestoreReport  object has the following attributes:
•metrics?  – the section called “RestoreReportMetrics”  (p. 1038) object
•spans?  – List of the section called “Span”  (p. 1039) objects
The following is an example Event of type platform.restoreReport :
{ 
    "time": "2022-10-12T00:00:15.064Z", 
    "type": "platform.restoreReport", 
    "record": { 
        "metrics": { 
            "durationMs": 15.19 
        }, 
        "spans": [ 
            { 
                "name": "someTimeSpan", 
                "start": "2022-08-02T12:01:23:521Z", 
                "durationMs": 30.0 
            } 
        ] 
    }
}
platform.extension
An extension  event contains logs from the extension code. An extension  Event object has the 
following shape:
Event: Object
- time: String
- type: String = extension
- record: {}
The PlatformExtension  object has the following attributes:
•events – List of String
•name  – String
•state  – String
The following is an example Event of type platform.extension :
{ 
    "time": "2022-10-12T00:02:15.000Z", 
1035AWS Lambda Developer Guide
Event schema reference
    "type": "platform.extension", 
    "record": { 
        "events": [ "INVOKE", "SHUTDOWN" ], 
        "name": "my-telemetry-extension", 
        "state": "Ready" 
    }
}
platform.telemetrySubscription
A platform.telemetrySubscription  event contains information about an extension subscription. A
platform.telemetrySubscription  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.telemetrySubscription
- record: PlatformTelemetrySubscription
The PlatformTelemetrySubscription  object has the following attributes:
•name  – String
•state  – String
•types – List of String
The following is an example Event of type platform.telemetrySubscription :
{ 
    "time": "2022-10-12T00:02:35.000Z", 
    "type": "platform.telemetrySubscription", 
    "record": { 
        "name": "my-telemetry-extension", 
        "state": "Subscribed", 
        "types": [ "platform", "function" ] 
    }
}
platform.logsDropped
A platform.logsDropped  event contains information about dropped events. Lambda emits 
the platform.logsDropped  event when an extension can't process one or more events. A
platform.logsDropped  Event object has the following shape:
Event: Object
- time: String
- type: String = platform.logsDropped
- record: PlatformLogsDropped
The PlatformLogsDropped  object has the following attributes:
•droppedBytes – Integer
•droppedRecords – Integer
•reason  – String
The following is an example Event of type platform.logsDropped :
{ 
1036AWS Lambda Developer Guide
Event schema reference
    "time": "2022-10-12T00:02:35.000Z", 
    "type": "platform.logsDropped", 
    "record": { 
        "droppedBytes": 12345, 
        "droppedRecords": 123, 
        "reason": "Consumer seems to have fallen behind as it has not acknowledged receipt 
 of logs." 
    }
}
function
A function  event contains logs from the function code. A function  Event object has the following 
shape:
Event: Object
- time: String
- type: String = function
- record: {}
The following is an example Event of type function :
{ 
    "time": "2022-10-12T00:03:50.000Z", 
    "type": "function", 
    "record": "[INFO] Hello world, I am a function!"
}
extension
A extension  event contains logs from the extension code. A extension  Event object has the 
following shape:
Event: Object
- time: String
- type: String = extension
- record: {}
The following is an example Event of type extension :
{ 
    "time": "2022-10-12T00:03:50.000Z", 
    "type": "extension", 
    "record": "[INFO] Hello world, I am an extension!"
}
Shared object types
This section details the types of shared objects that the Lambda Telemetry API supports.
InitPhase
A string enum that describes the phase when the initialization step occurs. In most cases, Lambda runs 
the function initialization code during the init phase. However, in some error cases, Lambda may re-run 
the function initialization code during the invoke phase. (This is called a suppressed init .)
•Type – String
•Valid values – init |invoke |snap-start
1037AWS Lambda Developer Guide
Event schema reference
InitReportMetrics
An object that contains metrics about an initialization phase.
•Type – Object
An InitReportMetrics  object has the following shape:
InitReportMetrics: Object
- durationMs: Double
The following is an example InitReportMetrics  object:
{ 
    "durationMs": 247.88
}
InitType
A string enum that describes how Lambda initialized the environment.
•Type – String
•Valid values – on-demand |provisioned-concurrency
ReportMetrics
An object that contains metrics about a completed phase.
•Type – Object
A ReportMetrics  object has the following shape:
ReportMetrics: Object
- billedDurationMs: Integer
- durationMs: Double
- initDurationMs?: Double
- maxMemoryUsedMB: Integer
- memorySizeMB: Integer
- restoreDurationMs?: Double
The following is an example ReportMetrics  object:
{ 
    "billedDurationMs": 694, 
    "durationMs": 693.92, 
    "initDurationMs": 397.68, 
    "maxMemoryUsedMB": 84, 
    "memorySizeMB": 128
}
RestoreReportMetrics
An object that contains metrics about a completed restoration phase.
•Type – Object
1038AWS Lambda Developer Guide
Event schema reference
A RestoreReportMetrics  object has the following shape:
RestoreReportMetrics: Object
- durationMs: Double
The following is an example RestoreReportMetrics  object:
{ 
    "durationMs": 15.19
}
RuntimeDoneMetrics
An object that contains metrics about an invocation phase.
•Type – Object
A RuntimeDoneMetrics  object has the following shape:
RuntimeDoneMetrics: Object
- durationMs: Double
- producedBytes?: Integer
The following is an example RuntimeDoneMetrics  object:
{ 
    "durationMs": 200.0, 
    "producedBytes": 15
}
Span
An object that contains details about a span. A span represents a unit of work or operation in a trace. For 
more information about spans, see Span  on the Tracing API page of the OpenTelemetry Docs website.
Lambda supports the following two spans for the platform.RuntimeDone  event:
•The responseLatency  span describes how long it took your Lambda function to start sending the 
response.
•The responseDuration  span describes how long it took your Lambda function to ﬁnish sending the 
entire response.
The following is an example responseLatency  span object:
{ 
        "name": "responseLatency",  
        "start": "2022-08-02T12:01:23.521Z", 
        "durationMs": 23.02 
      }
Status
An object that describes the status of an initialization or invocation phase. If the status is either failure
or error , then the Status object also contains an errorType  ﬁeld describing the error.
1039AWS Lambda Developer Guide
Event schema reference
•Type – Object
•Valid status values – success |failure |error |timeout
TraceContext
An object that describes the properties of a trace.
•Type – Object
A TraceContext  object has the following shape:
TraceContext: Object
- spanId?: String
- type: TracingType enum
- value: String
The following is an example TraceContext  object:
{ 
    "spanId": "073a49012f3c312e", 
    "type": "X-Amzn-Trace-Id", 
    "value": "Root=1-62e900b2-710d76f009d6e7785905449a;Parent=0efbd19962d95b05;Sampled=1"
}
TracingType
A string enum that describes the type of tracing in a the section called 
“TraceContext ” (p. 1040) object.
•Type – String
•Valid values – X-Amzn-Trace-Id
1040AWS Lambda Developer Guide
Converting events to OTel Spans
Converting Lambda Telemetry API Event objects to 
OpenTelemetry Spans
The AWS Lambda Telemetry API schema is semantically compatible with OpenTelemetry (OTel). This 
means that you can convert your AWS Lambda Telemetry API Event objects to OpenTelemetry (OTel) 
Spans. When converting, you shouldn't map a single Event object to a single OTel Span. Instead, you 
should present all three events related to a lifecycle phase in a single OTel Span. For example, the
start , runtimeDone , and runtimeReport  events represent a single function invocation. Present all 
three of these events as a single OTel Span.
You can convert your events using Span Events or Child (nested) Spans. The tables on this page describe 
the mappings between Telemetry API schema properties and OTel Span properties for both approaches. 
For more information about OTel Spans, see Span  on the Tracing API page of the OpenTelemetry Docs 
website.
Sections
•Map to OTel Spans with Span Events (p. 1041 )
•Map to OTel Spans with Child Spans (p. 1043 )
Map to OTel Spans with Span Events
In the following tables, e represents the event coming from the telemetry source.
Mapping the *Start events
OpenTelemetry Lambda Telemetry API schema
Span.Name Your extension generates this value based on the
type  ﬁeld.
Span.StartTime Use e.time .
Span.EndTime N/A, because the event hasn't completed yet.
Span.Kind Set to Server .
Span.Status Set to Unset .
Span.TraceId Parse the AWS X-Ray header found in
e.tracing.value , then use the TraceId  value.
Span.ParentId Parse the X-Ray header found in
e.tracing.value , then use the Parent  value.
Span.SpanId Use e.tracing.spanId  if available. Otherwise, 
generate a new SpanId .
Span.SpanContext.TraceState N/A for an X-Ray trace context.
Span.SpanContext.TraceFlags Parse the X-Ray header found in
e.tracing.value , then use the Sampled  value.
Span.Attributes Your extension can add any custom values here.
1041AWS Lambda Developer Guide
Converting events to OTel Spans
Mapping the *RuntimeDone  events
OpenTelemetry Lambda Telemetry API schema
Span.Name Your extension generates the value based on the
type  ﬁeld.
Span.StartTime Use e.time from the matching *Start event.
Alternatively, use e.time - 
e.metrics.durationMs .
Span.EndTime N/A, because the event hasn't completed yet.
Span.Kind Set to Server .
Span.Status If e.status  doesn't equal success , then set to
Error .
Otherwise, set to Ok.
Span.Events[] Use e.spans[] .
Span.Events[i].Name Use e.spans[i].name .
Span.Events[i].Time Use e.spans[i].start .
Span.TraceId Parse the AWS X-Ray header found in
e.tracing.value , then use the TraceId  value.
Span.ParentId Parse the X-Ray header found in
e.tracing.value , then use the Parent  value.
Span.SpanId Use the same SpanId from the *Start event. 
If unavailable, then use e.tracing.spanId , or 
generate a new SpanId .
Span.SpanContext.TraceState N/A for an X-Ray trace context.
Span.SpanContext.TraceFlags Parse the X-Ray header found in
e.tracing.value , then use the Sampled  value.
Span.Attributes Your extension can add any custom values here.
Mapping the *Report events
OpenTelemetry Lambda Telemetry API schema
Span.Name Your extension generates the value based on the
type  ﬁeld.
Span.StartTime Use e.time from the matching *Start event.
Alternatively, use e.time - 
e.metrics.durationMs .
Span.EndTime Use e.time .
Span.Kind Set to Server .
1042AWS Lambda Developer Guide
Converting events to OTel Spans
OpenTelemetry Lambda Telemetry API schema
Span.Status Use the same value as the *RuntimeDone  event.
Span.TraceId Parse the AWS X-Ray header found in
e.tracing.value , then use the TraceId  value.
Span.ParentId Parse the X-Ray header found in
e.tracing.value , then use the Parent  value.
Span.SpanId Use the same SpanId from the *Start event. 
If unavailable, then use e.tracing.spanId , or 
generate a new SpanId .
Span.SpanContext.TraceState N/A for an X-Ray trace context.
Span.SpanContext.TraceFlags Parse the X-Ray header found in
e.tracing.value , then use the Sampled  value.
Span.Attributes Your extension can add any custom values here.
Map to OTel Spans with Child Spans
The following table describes how to convert Lambda Telemetry API events into OTel Spans with Child 
(nested) Spans for *RuntimeDone  Spans. For *Start  and *Report mappings, refer to the tables in the 
section called “Map to OTel Spans with Span Events” (p. 1041 ), as they're the same for Child Spans. In 
this table, e represents the event coming from the telemetry source.
Mapping the *RuntimeDone  events
OpenTelemetry Lambda Telemetry API schema
Span.Name Your extension generates the value based on the
type  ﬁeld.
Span.StartTime Use e.time from the matching *Start event.
Alternatively, use e.time - 
e.metrics.durationMs .
Span.EndTime N/A, because the event hasn't completed yet.
Span.Kind Set to Server .
Span.Status If e.status  doesn't equal success , then set to
Error .
Otherwise, set to Ok.
Span.TraceId Parse the AWS X-Ray header found in
e.tracing.value , then use the TraceId  value.
Span.ParentId Parse the X-Ray header found in
e.tracing.value , then use the Parent  value.
Span.SpanId Use the same SpanId from the *Start event. 
If unavailable, then use e.tracing.spanId , or 
generate a new SpanId .
1043AWS Lambda Developer Guide
Converting events to OTel Spans
OpenTelemetry Lambda Telemetry API schema
Span.SpanContext.TraceState N/A for an X-Ray trace context.
Span.SpanContext.TraceFlags Parse the X-Ray header found in
e.tracing.value , then use the Sampled  value.
Span.Attributes Your extension can add any custom values here.
ChildSpan[i].Name Use e.spans[i].name .
ChildSpan[i].StartTime Use e.spans[i].start .
ChildSpan[i].EndTime Use e.spans[i].start + 
e.spans[i].durations .
ChildSpan[i].Kind Same as parent Span.Kind .
ChildSpan[i].Status Same as parent Span.Status .
ChildSpan[i].TraceId Same as parent Span.TraceId .
ChildSpan[i].ParentId Use parent Span.SpanId .
ChildSpan[i].SpanId Generate a new SpanId .
ChildSpan[i].SpanContext.TraceState N/A for an X-Ray trace context.
ChildSpan[i].SpanContext.TraceFlags Same as parent
Span.SpanContext.TraceFlags .
1044AWS Lambda Developer Guide
Logs API
Lambda Logs API
Important
The Lambda Telemetry API supersedes the Lambda Logs API. While the Logs API remains fully 
functional, we recommend using only the Telemetry API going forward. You can subscribe 
your extension to a telemetry stream using either the Telemetry API or the Logs API. After 
subscribing using one of these APIs, any attempt to subscribe using the other API returns an 
error.
Lambda automatically captures runtime logs and streams them to Amazon CloudWatch. This log stream 
contains the logs that your function code and extensions generate, and also the logs that Lambda 
generates as part of the function invocation.
Lambda extensions (p. 1006 ) can use the Lambda Runtime Logs API to subscribe to log streams directly 
from within the Lambda execution environment (p. 14). Lambda streams the logs to the extension, and 
the extension can then process, ﬁlter, and send the logs to any preferred destination.
The Logs API allows extensions to subscribe to three diﬀerent logs streams:
•Function logs that the Lambda function generates and writes to stdout  or stderr .
•Extension logs that extension code generates.
•Lambda platform logs, which record events and errors related to invocations and extensions.
Note
Lambda sends all logs to CloudWatch, even when an extension subscribes to one or more of the 
log streams.
Topics
•Subscribing to receive logs (p. 1046 )
•Memory usage (p. 1046 )
•Destination protocols (p. 1046 )
•Buﬀering conﬁguration (p. 1046 )
•Example subscription  (p. 1047 )
•Sample code for Logs API (p. 1047 )
•Logs API reference (p. 1047 )
•Log messages  (p. 1048 )
1045AWS Lambda Developer Guide
Logs API
Subscribing to receive logs
A Lambda extension can subscribe to receive logs by sending a subscription request to the Logs API.
To subscribe to receive logs, you need the extension identiﬁer (Lambda-Extension-Identifier ). First
register the extension (p. 1013 ) to receive the extension identiﬁer. Then subscribe to the Logs API during
initialization  (p. 15). After the initialization phase completes, Lambda does not process subscription 
requests.
Note
Logs API subscription is idempotent. Duplicate subscribe requests do not result in duplicate 
subscriptions.
Memory usage
Memory usage increases linearly as the number of subscribers increases. Subscriptions consume memory 
resources because each subscription opens a new memory buﬀer to store the logs. To help optimize 
memory usage, you can adjust the buﬀering conﬁguration (p. 1046 ). Buﬀer memory usage counts 
towards overall memory consumption in the execution environment.
Destination protocols
You can choose one of the following protocols to receive the logs:
1.HTTP (recommended) – Lambda delivers logs to a local HTTP endpoint (http://
sandbox.localdomain:${PORT}/${PATH} ) as an array of records in JSON format. The $PATH
parameter is optional. Note that only HTTP is supported, not HTTPS. You can choose to receive logs 
through PUT or POST.
2.TCP – Lambda delivers logs to a TCP port in Newline delimited JSON (NDJSON) format.
We recommend using HTTP rather than TCP. With TCP, the Lambda platform cannot acknowledge when 
it delivers logs to the application layer. Therefore, you might lose logs if your extension crashes. HTTP 
does not share this limitation.
We also recommend setting up the local HTTP listener or the TCP port before subscribing to receive logs. 
During setup, note the following:
•Lambda sends logs only to destinations that are inside the execution environment.
•Lambda retries the attempt to send the logs (with backoﬀ) if there is no listener, or if the POST or 
PUT request results in an error. If the log subscriber crashes, it continues to receive logs after Lambda 
restarts the execution environment.
•Lambda reserves port 9001. There are no other port number restrictions or recommendations.
Buﬀering conﬁguration
Lambda can buﬀer logs and deliver them to the subscriber. You can conﬁgure this behavior in the 
subscription request by specifying the following optional ﬁelds. Note that Lambda uses the default value 
for any ﬁeld that you do not specify.
•timeoutMs  – The maximum time (in milliseconds) to buﬀer a batch. Default: 1,000. Minimum: 25. 
Maximum: 30,000.
•maxBytes – The maximum size (in bytes) of the logs to buﬀer in memory. Default: 262,144. Minimum: 
262,144. Maximum: 1,048,576.
•maxItems  – The maximum number of events to buﬀer in memory. Default: 10,000. Minimum: 1,000. 
Maximum: 10,000.
1046AWS Lambda Developer Guide
Logs API
During buﬀering conﬁguration, note the following points:
•Lambda ﬂushes the logs if any of the input streams are closed, for example, if the runtime crashes.
•Each subscriber can specify a diﬀerent buﬀering conﬁguration in their subscription request.
•Consider the buﬀer size that you need for reading the data. Expect to receive payloads as large as
2*maxBytes+metadata , where maxBytes  is conﬁgured in the subscribe request. For example, 
Lambda adds the following metadata bytes to each record:
{
"time": "2020-08-20T12:31:32.123Z",
"type": "function",
"record": "Hello World"
}            
•If the subscriber cannot process incoming logs quickly enough, Lambda might drop logs to 
keep memory utilization bounded. To indicate the number of dropped records, Lambda sends a
platform.logsDropped  log.
Example subscription
The following example shows a request to subscribe to the platform and function logs.
PUT http://${AWS_LAMBDA_RUNTIME_API}/2020-08-15/logs HTTP/1.1
{ "schemaVersion": "2020-08-15", 
  "types": [ 
      "platform", 
      "function" 
    ], 
  "buffering": { 
      "maxItems": 1000, 
      "maxBytes": 262144, 
      "timeoutMs": 100 
    }, 
  "destination": { 
    "protocol": "HTTP", 
    "URI": "http://sandbox.localdomain:8080/lambda_logs" 
  }
}     
If the request succeeds, the subscriber receives an HTTP 200 success response.
HTTP/1.1 200 OK
"OK"       
Sample code for Logs API
For sample code showing how to send logs to a custom destination, see Using AWS Lambda extensions 
to send logs to custom destinations  on the AWS Compute Blog.
For Python and Go code examples showing how to develop a basic Lambda extension and subscribe to 
the Logs API, see AWS Lambda Extensions on the AWS Samples GitHub repository. For more information 
about building a Lambda extension, see the section called “Extensions API” (p. 1006 ).
Logs API reference
You can retrieve the Logs API endpoint from the AWS_LAMBDA_RUNTIME_API  environment variable. To 
send an API request, use the preﬁx 2020-08-15/  before the API path. For example:
1047AWS Lambda Developer Guide
Logs API
http://${AWS_LAMBDA_RUNTIME_API}/2020-08-15/logs
The OpenAPI speciﬁcation for the Logs API version 2020-08-15  is available here: logs-api-request.zip
Subscribe
To subscribe to one or more of the log streams available in the Lambda execution environment, 
extensions send a Subscribe API request.
Path – /logs
Method  – PUT
Body parameters
destination  – See the section called “Destination protocols” (p. 1046 ). Required: yes. Type: strings.
buffering  – See the section called “Buﬀering conﬁguration” (p. 1046 ). Required: no. Type: strings.
types – An array of the types of logs to receive. Required: yes. Type: array of strings. Valid values: 
"platform", "function", "extension".
schemaVersion  – Required: no. Default value: "2020-08-15". Set to "2021-03-18" for the extension to 
receive platform.runtimeDone  (p. 1051 ) messages.
Response parameters
The OpenAPI speciﬁcations for the subscription responses version 2020-08-15  are available for the HTTP 
and TCP protocols:
•HTTP: logs-api-http-response.zip
•TCP: logs-api-tcp-response.zip
Response codes
•200 – Request completed successfully
•202 – Request accepted. Response to a subscription request during local testing.
•4XX – Bad Request
•500 – Service error
If the request succeeds, the subscriber receives an HTTP 200 success response.
HTTP/1.1 200 OK
"OK"       
If the request fails, the subscriber receives an error response. For example:
HTTP/1.1 400 OK
{ 
    "errorType": "Logs.ValidationError", 
    "errorMessage": URI port is not provided; types should not be empty"
}    
Log messages
The Logs API allows extensions to subscribe to three diﬀerent logs streams:
1048AWS Lambda Developer Guide
Logs API
•Function – Logs that the Lambda function generates and writes to stdout  or stderr .
•Extension – Logs that extension code generates.
•Platform – Logs that the runtime platform generates, which record events and errors related to 
invocations and extensions.
Topics
•Function logs (p. 1049 )
•Extension logs (p. 1049 )
•Platform logs (p. 1049 )
Function logs
The Lambda function and internal extensions generate function logs and write them to stdout  or
stderr .
The following example shows the format of a function log message. { "time": 
"2020-08-20T12:31:32.123Z", "type": "function", "record": "ERROR encountered. Stack trace:\n\my-
function (line 10)\n" }
Extension logs
Extensions can generate extension logs. The log format is the same as for a function log.
Platform logs
Lambda generates log messages for platform events such as platform.start , platform.end , and
platform.fault .
Optionally, you can subscribe to the 2021-03-18  version of the Logs API schema, which includes the
platform.runtimeDone  log message.
Example platform log messages
The following example shows the platform start and platform end logs. These logs indicate the 
invocation start time and invocation end time for the invocation that the requestId speciﬁes.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.start", 
    "record": {"requestId": "6f7f0961f83442118a7af6fe80b88d56"}    
}
{ 
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.end", 
    "record": {"requestId": "6f7f0961f83442118a7af6fe80b88d56"}    
}
The platform.initRuntimeDone log message shows the status of the Runtime init  sub-phase, which 
is part of the Init lifecyle phase (p. 15). When Runtime init  is successful, the runtime sends a /next
runtime API request (for the on-demand  and provisioned-concurrency  initialization types) or
restore/next  (for the snap-start  initialization type). The following example shows a successful
platform.initRuntimeDone log message for the snap-start  initialization type.
{ 
  "time":"2022-07-17T18:41:57.083Z", 
  "type":"platform.initRuntimeDone", 
1049AWS Lambda Developer Guide
Logs API
  "record":{ 
      "initializationType":"snap-start", 
      "status":"success" 
  }
}
The platform.initReport log message shows how long the Init phase lasted and how many 
milliseconds you were billed for during this phase. When the initialization type is provisioned-
concurrency , Lambda sends this message during invocation. When the initialization type is snap-
start, Lambda sends this message after restoring the snapshot. The following example shows a
platform.initReport log message for the snap-start  initialization type.
{ 
  "time":"2022-07-17T18:41:57.083Z", 
  "type":"platform.initReport", 
  "record":{ 
      "initializationType":"snap-start", 
      "metrics":{ 
          "durationMs":731.79, 
          "billedDurationMs":732 
          } 
  }
}
The platform report log includes metrics about the invocation that the requestId speciﬁes. The
initDurationMs  ﬁeld is included in the log only if the invocation included a cold start. If AWS X-Ray 
tracing is active, the log includes X-Ray metadata. The following example shows a platform report log for 
an invocation that included a cold start.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.report", 
    "record": {"requestId": "6f7f0961f83442118a7af6fe80b88d56", 
        "metrics": {"durationMs": 101.51, 
            "billedDurationMs": 300, 
            "memorySizeMB": 512, 
            "maxMemoryUsedMB": 33, 
            "initDurationMs": 116.67 
        } 
    }
} 
The platform fault log captures runtime or execution environment errors. The following example shows a 
platform fault log message.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.fault", 
    "record": "RequestId: d783b35e-a91d-4251-af17-035953428a2c Process exited before 
 completing request"
}
Lambda generates a platform extension log when an extension registers with the extensions API. The 
following example shows a platform extension message.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.extension", 
    "record": {"name": "Foo.bar", 
1050AWS Lambda Developer Guide
Logs API
        "state": "Ready", 
        "events": ["INVOKE", "SHUTDOWN"] 
     }
}
Lambda generates a platform logs subscription log when an extension subscribes to the logs API. The 
following example shows a logs subscription message.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.logsSubscription", 
    "record": {"name": "Foo.bar", 
        "state": "Subscribed", 
        "types": ["function", "platform"], 
    }
}
Lambda generates a platform logs dropped log when an extension is not able to process the number of 
logs that it is receiving. The following example shows a platform.logsDropped  log message.
{      
    "time": "2020-08-20T12:31:32.123Z", 
    "type": "platform.logsDropped", 
    "record": {"reason": "Consumer seems to have fallen behind as it has not acknowledged 
 receipt of logs.", 
        "droppedRecords": 123, 
        "droppedBytes" 12345 
    }
}
The platform.restoreStart log message shows the time that the Restore phase started (snap-start
initialization type only). Example:
{  
  "time":"2022-07-17T18:43:44.782Z",  
  "type":"platform.restoreStart",  
  "record":{}  
}
The platform.restoreReport log message shows how long the Restore phase lasted and how many 
milliseconds you were billed for during this phase (snap-start  initialization type only). Example:
{ 
  "time":"2022-07-17T18:43:45.936Z", 
  "type":"platform.restoreReport", 
  "record":{ 
      "metrics":{ 
          "durationMs":70.87, 
          "billedDurationMs":13 
      } 
  }
}
Platform runtimeDone  messages
If you set the schema version to "2021-03-18" in the subscribe request, Lambda sends a
platform.runtimeDone  message after the function invocation completes either successfully or 
with an error. The extension can use this message to stop all the telemetry collection for this function 
invocation.
1051AWS Lambda Developer Guide
Logs API
The OpenAPI speciﬁcation for the Log event type in schema version 2021-03-18  is available here:
schema-2021-03-18.zip
Lambda generates the platform.runtimeDone  log message when the runtime sends a Next  or
Error runtime API request. The platform.runtimeDone  log informs consumers of the Logs API that 
the function invocation completes. Extensions can use this information to decide when to send all the 
telemetry collected during that invocation.
Examples
Lambda sends the platform.runtimeDone  message after the runtime sends the NEXT request when 
the function invocation completes. The following examples show messages for each of the status values: 
success, failure, and timeout.
Example Example success message
{ 
    "time": "2021-02-04T20:00:05.123Z", 
    "type": "platform.runtimeDone", 
    "record": { 
       "requestId":"6f7f0961f83442118a7af6fe80b88", 
       "status": "success" 
    }
}          
Example Example failure message
{ 
   "time": "2021-02-04T20:00:05.123Z", 
   "type": "platform.runtimeDone", 
   "record": { 
      "requestId":"6f7f0961f83442118a7af6fe80b88", 
      "status": "failure" 
   }
}         
Example Example timeout message
{ 
   "time": "2021-02-04T20:00:05.123Z", 
   "type": "platform.runtimeDone", 
   "record": { 
      "requestId":"6f7f0961f83442118a7af6fe80b88", 
      "status": "timeout" 
  }
}
Example Example platform.restoreRuntimeDone message (snap-start  initialization type 
only)
The platform.restoreRuntimeDone log message shows whether or not the Restore  phase was 
successful. Lambda sends this message when the runtime sends a restore/next  runtime API request. 
There are three possible statuses: success, failure, and timeout. The following example shows a successful
platform.restoreRuntimeDone log message.
{ 
  "time":"2022-07-17T18:43:45.936Z", 
  "type":"platform.restoreRuntimeDone", 
1052AWS Lambda Developer Guide
Logs API
  "record":{ 
      "status":"success" 
  }
}
1053AWS Lambda Developer Guide
Deployment
Troubleshooting issues in Lambda
The following topics provide troubleshooting advice for errors and issues that you might encounter 
when using the Lambda API, console, or tools. If you ﬁnd an issue that is not listed here, you can use the
Feedback button on this page to report it.
For more troubleshooting advice and answers to common support questions, visit the AWS Knowledge 
Center .
For more information about debugging and troubleshooting Lambda applications, see Debugging  in 
Serverless Land.
Topics
•Troubleshoot deployment issues in Lambda (p. 1054 )
•Troubleshoot invocation issues in Lambda (p. 1057 )
•Troubleshoot execution issues in Lambda (p. 1061 )
•Troubleshoot networking issues in Lambda (p. 1063 )
•Troubleshoot container image issues in Lambda (p. 1064 )
Troubleshoot deployment issues in Lambda
When you update your function, Lambda deploys the change by launching new instances of the function 
with the updated code or settings. Deployment errors prevent the new version from being used and can 
arise from issues with your deployment package, code, permissions, or tools.
When you deploy updates to your function directly with the Lambda API or with a client such as the AWS 
CLI, you can see errors from Lambda directly in the output. If you use services like AWS CloudFormation, 
AWS CodeDeploy, or AWS CodePipeline, look for the response from Lambda in the logs or event stream 
for that service.
General: Permission is denied / Cannot load such ﬁle
Error: EACCES: permission denied, open '/var/task/index.js'
Error: cannot load such ﬁle -- function
Error: [Errno 13] Permission denied: '/var/task/function.py'
The Lambda runtime needs permission to read the ﬁles in your deployment package. You can use the
chmod command to change the ﬁle mode. The following example commands make all ﬁles and folders in 
the current directory readable by any user.
chmod -R o+rX .
General: Error occurs when calling the 
UpdateFunctionCode
Error: An error occurred (RequestEntityTooLargeException) when calling the UpdateFunctionCode operation
1054AWS Lambda Developer Guide
Amazon S3: Error Code PermanentRedirect.
When you upload a deployment package or layer archive directly to Lambda, the size of the ZIP ﬁle 
is limited to 50 MB. To upload a larger ﬁle, store it in Amazon S3 and use the S3Bucket and S3Key 
parameters.
Note
When you upload a ﬁle directly with the AWS CLI, AWS SDK, or otherwise, the binary ZIP ﬁle is 
converted to base64, which increases its size by about 30%. To allow for this, and the size of 
other parameters in the request, the actual request size limit that Lambda applies is larger. Due 
to this, the 50 MB limit is approximate.
Amazon S3: Error Code PermanentRedirect.
Error: Error occurred while GetObject. S3 Error Code: PermanentRedirect. S3 Error Message: The bucket is in 
this region: us-east-2. Please use this region to retry the request
When you upload a function's deployment package from an Amazon S3 bucket, the bucket must be in 
the same Region as the function. This issue can occur when you specify an Amazon S3 object in a call to
UpdateFunctionCode (p. 1506 ), or use the package and deploy commands in the AWS CLI or AWS SAM 
CLI. Create a deployment artifact bucket for each Region where you develop applications.
General: Cannot ﬁnd, cannot load, unable to import, 
class not found, no such ﬁle or directory
Error: Cannot ﬁnd module 'function'
Error: cannot load such ﬁle -- function
Error: Unable to import module 'function'
Error: Class not found: function.Handler
Error: fork/exec /var/task/function: no such ﬁle or directory
Error: Unable to load type 'Function.Handler' from assembly 'Function'.
The name of the ﬁle or class in your function's handler conﬁguration doesn't match your code. See the 
following section for more information.
General: Undeﬁned method handler
Error: index.handler is undeﬁned or not exported
Error: Handler 'handler' missing on module 'function'
Error: undeﬁned method `handler' for #<LambdaHandler:0x000055b76ccebf98>
Error: No public method named handleRequest with appropriate method signature found on class 
function.Handler
Error: Unable to ﬁnd method 'handleRequest' in type 'Function.Handler' from assembly 'Function'
The name of the handler method in your function's handler conﬁguration doesn't match your code. Each 
runtime deﬁnes a naming convention for handlers, such as filename .methodname . The handler is the 
method in your function's code that the runtime runs when your function is invoked.
For some languages, Lambda provides a library with an interface that expects a handler method to have 
a speciﬁc name. For details about handler naming for each language, see the following topics.
1055AWS Lambda Developer Guide
Lambda: Layer conversion failed
•Building Lambda functions with Node.js (p. 272)
•Building Lambda functions with Python (p. 346)
•Building Lambda functions with Ruby (p. 403)
•Building Lambda functions with Java (p. 438)
•Building Lambda functions with Go (p. 512)
•Building Lambda functions with C# (p. 556)
•Building Lambda functions with PowerShell (p. 600)
Lambda: Layer conversion failed
Error: Lambda layer conversion failed. For advice on resolving this issue, see the Troubleshoot deployment 
issues in Lambda page in the Lambda User Guide.
When you conﬁgure a Lambda function with a layer, Lambda merges the layer with your function code. 
If this process fails to complete, Lambda returns this error. If you encounter this error, take the following 
steps:
•Delete any unused ﬁles from your layer
•Delete any symbolic links in your layer
•Rename any ﬁles that have the same name as a directory in any of your function's layers
Lambda: InvalidParameterValueException or 
RequestEntityTooLargeException
Error: InvalidParameterValueException: Lambda was unable to conﬁgure your environment variables 
because the environment variables you have provided exceeded the 4KB limit. String measured: 
{"A1":"uSFeY5cyPiPn7AtnX5BsM...
Error: RequestEntityTooLargeException: Request must be smaller than 5120 bytes for the 
UpdateFunctionConﬁguration operation
The maximum size of the variables object that is stored in the function's conﬁguration must not exceed 
4096 bytes. This includes key names, values, quotes, commas, and brackets. The total size of the HTTP 
request body is also limited.
{ 
    "FunctionName": "my-function", 
    "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function", 
    "Runtime": "nodejs18.x", 
    "Role": "arn:aws:iam::123456789012:role/lambda-role", 
    "Environment": { 
        "Variables": { 
            "BUCKET": "my-bucket", 
            "KEY": "file.txt" 
        }
    }, 
    ...
}
In this example, the object is 39 characters and takes up 39 bytes when it's stored (without white 
space) as the string {"BUCKET":"my-bucket","KEY":"file.txt"} . Standard ASCII characters in 
environment variable values use one byte each. Extended ASCII and Unicode characters can use between 
2 bytes and 4 bytes per character.
1056AWS Lambda Developer Guide
Lambda: InvalidParameterValueException
Lambda: InvalidParameterValueException
Error: InvalidParameterValueException: Lambda was unable to conﬁgure your environment variables 
because the environment variables you have provided contains reserved keys that are currently not 
supported for modiﬁcation.
Lambda reserves some environment variable keys for internal use. For example, AWS_REGION  is used 
by the runtime to determine the current Region and cannot be overridden. Other variables, like PATH , 
are used by the runtime but can be extended in your function conﬁguration. For a full list, see Deﬁned 
runtime environment variables (p. 80).
Lambda: Concurrency and memory quotas
Error: Speciﬁed ConcurrentExecutions for function decreases account's UnreservedConcurrentExecution 
below its minimum value
Error: 'MemorySize' value failed to satisfy constraint: Member must have value less than or equal to 3008
These errors occur when you exceed the concurrency or memory quotas  (p. 1269 ) for your account. New 
AWS accounts have reduced concurrency and memory quotas. To resolve errors related to concurrency, 
you can request a quota increase. You cannot request memory quota increases.
•Concurrency: You might get an error if you try to create a function using reserved or provisioned 
concurrency, or if your per-function concurrency request (PutFunctionConcurrency (p. 1466 )) exceeds 
your account's concurrency quota.
•Memory: Errors occur if the amount of memory allocated to the function exceeds your account's 
memory quota.
Troubleshoot invocation issues in Lambda
When you invoke a Lambda function, Lambda validates the request and checks for scaling capacity 
before sending the event to your function or, for asynchronous invocation, to the event queue. 
Invocation errors can be caused by issues with request parameters, event structure, function settings, 
user permissions, resource permissions, or limits.
If you invoke your function directly, you see any invocation errors in the response from Lambda. If you 
invoke your function asynchronously with an event source mapping or through another service, you 
might ﬁnd errors in logs, a dead-letter queue, or a failed-event destination. Error handling options and 
retry behavior vary depending on how you invoke your function and on the type of error.
For a list of error types that the Invoke operation can return, see Invoke (p. 1399 ).
IAM: lambda:InvokeFunction not authorized
Error: User: arn:aws:iam::123456789012:user/developer is not authorized to perform: 
lambda:InvokeFunction on resource: my-function
Your user, or the role that you assume, must have permission to invoke a function. This requirement also 
applies to Lambda functions and other compute resources that invoke functions. Add the AWS managed 
policy AWSLambdaRole to your user, or add a custom policy that allows the lambda:InvokeFunction
action on the target function.
Note
Unlike other Lambda API operations, the name of the IAM action (lambda:InvokeFunction ) 
doesn't match the name of the API operation ( Invoke) for invoking a function.
1057AWS Lambda Developer Guide
Lambda: Operation cannot be 
performed ResourceConﬂictException
For more information, see Lambda resource access permissions (p. 912) .
Lambda: Operation cannot be performed 
ResourceConﬂictException
Error: ResourceConﬂictException: The operation cannot be performed at this time. The function is currently 
in the following state: Pending
When you connect a function to a virtual private cloud (VPC) at the time of creation, the function enters 
a Pending state while Lambda creates elastic network interfaces. During this time, you can't invoke or 
modify your function. If you connect your function to a VPC after creation, you can invoke it while the 
update is pending, but you can't modify its code or conﬁguration.
For more information, see Lambda function states (p. 179) .
Lambda: Function is stuck in Pending
Error: A function is stuck in the Pending  state for several minutes.
If a function is stuck in the Pending state for more than six minutes, call one of the following API 
operations to unblock it:
•UpdateFunctionCode (p. 1506 )
•UpdateFunctionConﬁguration (p. 1516 )
•PublishVersion (p. 1454 )
Lambda cancels the pending operation and puts the function into the Failed state. You can then delete 
the function and recreate it, or attempt another update.
Lambda: One function is using all concurrency
Issue:  One function is using all of the available concurrency, causing other functions to be throttled.
To divide your AWS account's available concurrency in an AWS Region into pools, use reserved 
concurrency (p. 234). Reserved concurrency ensures that a function can always scale to its assigned 
concurrency, and that it doesn't scale beyond its assigned concurrency.
General: Cannot invoke function with other accounts 
or services
Issue:  You can invoke your function directly, but it doesn't run when another service or account invokes it.
You grant other services (p. 628) and accounts permission to invoke a function in the function's resource-
based policy (p. 929). If the invoker is in another account, that user must also have permission to invoke 
functions (p. 920).
General: Function invocation is looping
Issue:  Function is invoked continuously in a loop.
This typically occurs when your function manages resources in the same AWS service that triggers it. For 
example, it's possible to create a function that stores an object in an Amazon Simple Storage Service 
1058AWS Lambda Developer Guide
Lambda: Alias routing with provisioned concurrency
(Amazon S3) bucket that's conﬁgured with a notiﬁcation that invokes the function again (p. 815). To stop 
the function from running, on the function conﬁguration page (p. 72), choose Throttle. Then, identify 
the code path or conﬁguration error that caused the recursive invocation.
Lambda: Alias routing with provisioned concurrency
Issue:  Provisioned concurrency spillover invocations during alias routing.
Lambda uses a simple probabilistic model to distribute the traﬃc between the two function versions. 
At low traﬃc levels, you might see a high variance between the conﬁgured and actual percentage 
of traﬃc on each version. If your function uses provisioned concurrency, you can avoid spillover 
invocations (p. 966) by conﬁguring a higher number of provisioned concurrency instances during the 
time that alias routing is active.
Lambda: Cold starts with provisioned concurrency
Issue:  You see cold starts after enabling provisioned concurrency.
When the number of concurrent executions on a function is less than or equal to the conﬁgured level of 
provisioned concurrency (p. 237), there shouldn't be any cold starts. To help you conﬁrm if provisioned 
concurrency is operating normally, do the following:
•Check that provisioned concurrency is enabled (p. 237) on the function version or alias.
Note
Provisioned concurrency is not conﬁgurable on the unpublished version of the 
function (p. 108) ($LATEST).
•Ensure that your triggers invoke the correct function version or alias. For example, if you're using 
Amazon API Gateway, check that API Gateway invokes the function version or alias with provisioned 
concurrency, not $LATEST. To conﬁrm that provisioned concurrency is being used, you can check the
ProvisionedConcurrencyInvocations Amazon CloudWatch metric (p. 251). A non-zero value indicates 
that the function is processing invocations on initialized execution environments.
•Determine whether your function concurrency exceeds the conﬁgured level of provisioned concurrency 
by checking the ProvisionedConcurrencySpilloverInvocations CloudWatch metric (p. 251). A non-zero 
value indicates that all provisioned concurrency is in use and some invocation occurred with a cold 
start.
•Check your invocation frequency (p. 1271 ) (requests per second). Functions with provisioned 
concurrency have a maximum rate of 10 requests per second per provisioned concurrency. For 
example, a function conﬁgured with 100 provisioned concurrency can handle 1,000 requests per 
second. If the invocation rate exceeds 1,000 requests per second, some cold starts can occur.
Note
There is a known issue in which the ﬁrst invocation on an initialized execution environment 
reports a non-zero Init Duration  metric in CloudWatch Logs, even though no cold start has 
occurred. We're developing a ﬁx to correct the reporting to CloudWatch Logs.
Lambda: Latency variability with provisioned 
concurrency
Issue:  You see latency variability on the ﬁrst invocation after enabling provisioned concurrency.
Depending on your function's runtime and memory conﬁguration, it's possible to see some latency 
variability on the ﬁrst invocation on an initialized execution environment. For example, .NET and other 
1059AWS Lambda Developer Guide
Lambda: Variability between 
initialization and invocation times
JIT runtimes can lazily load resources on the ﬁrst invocation, leading to some latency variability (typically 
tens of milliseconds). This variability is more apparent on 128-MiB functions. You mitigate this by 
increasing the function's conﬁgured memory.
Lambda: Variability between initialization and 
invocation times
Issue:  You see unexpected gaps between the times of your function's initialization and invocation phases.
For functions using provisioned concurrency, Lambda initializes the execution environment shortly after 
you publish a function version and ensures that function instances are always available in advance of 
invocation. You can see large gaps between the times of your function's initialization and invocation.
For functions using unreserved (on-demand) concurrency, Lambda occasionally pre-initializes execution 
environments to reduce the number of cold start invocations. For example, Lambda might initialize a 
new execution environment to replace an execution environment that is about to be shut down. If a 
pre-initialized execution environment becomes available while Lambda is initializing a new execution 
environment to process an invocation, Lambda can use the pre-initialized execution environment. When 
Lambda uses a pre-initialized execution environment to handle an invocation, you can observe an 
unexpected time gap between your function's Init  and Invoke  phases. This gap can appear similar to 
what you would observe using provisioned concurrency.
Lambda: Cold starts with new versions
Issue:  You see cold starts while deploying new versions of your function.
When you update a function alias, Lambda automatically shifts provisioned concurrency to the new 
version based on the weights conﬁgured on the alias.
Error: KMSDisabledException: Lambda was unable to decrypt the environment variables because the KMS 
key used is disabled. Please check the function's KMS key settings.
This error can occur if your AWS Key Management Service (AWS KMS) key is disabled, or if the grant that 
allows Lambda to use the key is revoked. If the grant is missing, conﬁgure the function to use a diﬀerent 
key. Then, reassign the custom key to recreate the grant.
EFS: Function could not mount the EFS ﬁle system
Error: EFSMountFailureException: The function could not mount the EFS ﬁle system with access point 
arn:aws:elasticﬁlesystem:us-east-2:123456789012:access-point/fsap-015cxmplb72b405fd.
The mount request to the function's ﬁle system  (p. 99) was rejected. Check the function's permissions, 
and conﬁrm that its ﬁle system and access point exist and are ready for use.
EFS: Function could not connect to the EFS ﬁle 
system
Error: EFSMountConnectivityException: The function couldn't connect to the Amazon EFS ﬁle system with 
access point arn:aws:elasticﬁlesystem:us-east-2:123456789012:access-point/fsap-015cxmplb72b405fd. 
Check your network conﬁguration and try again.
The function couldn't establish a connection to the function's ﬁle system  (p. 99) with the NFS protocol 
(TCP port 2049). Check the security group and routing conﬁguration for the VPC's subnets.
1060AWS Lambda Developer Guide
EFS: Function could not mount 
the EFS ﬁle system due to timeout
EFS: Function could not mount the EFS ﬁle system 
due to timeout
Error: EFSMountTimeoutException: The function could not mount the EFS ﬁle system with access point 
{arn:aws:elasticﬁlesystem:us-east-2:123456789012:access-point/fsap-015cxmplb72b405fd} due to mount 
time out.
The function could connect to the function's ﬁle system  (p. 99), but the mount operation timed out. Try 
again after a short time and consider limiting the function's concurrency (p. 234) to reduce load on the 
ﬁle system.
Lambda: Lambda detected an IO process that was 
taking too long
EFSIOException: This function instance was stopped because Lambda detected an IO process that was 
taking too long.
A previous invocation timed out and Lambda couldn't terminate the function handler. This issue can 
occur when an attached ﬁle system runs out of burst credits and the baseline throughput is insuﬃcient. 
To increase throughput, you can increase the size of the ﬁle system or use provisioned throughput. For 
more information, see Throughput (p. 739) .
Troubleshoot execution issues in Lambda
When the Lambda runtime runs your function code, the event might be processed on an instance of the 
function that's been processing events for some time, or it might require a new instance to be initialized. 
Errors can occur during function initialization, when your handler code processes the event, or when your 
function returns (or fails to return) a response.
Function execution errors can be caused by issues with your code, function conﬁguration, downstream 
resources, or permissions. If you invoke your function directly, you see function errors in the response 
from Lambda. If you invoke your function asynchronously, with an event source mapping, or through 
another service, you might ﬁnd errors in logs, a dead-letter queue, or an on-failure destination. Error 
handling options and retry behavior vary depending on how you invoke your function and on the type of 
error.
When your function code or the Lambda runtime return an error, the status code in the response from 
Lambda is 200 OK. The presence of an error in the response is indicated by a header named X-Amz-
Function-Error . 400 and 500-series status codes are reserved for invocation errors (p. 1057 ).
Lambda: Execution takes too long
Issue:  Function execution takes too long.
If your code takes much longer to run in Lambda than on your local machine, it may be constrained 
by the memory or processing power available to the function. Conﬁgure the function with additional 
memory (p. 72) to increase both memory and CPU.
Lambda: Logs or traces don't appear
Issue:  Logs don't appear in CloudWatch Logs.
1061AWS Lambda Developer Guide
Lambda: The function returns before execution ﬁnishes
Issue:  Traces don't appear in AWS X-Ray.
Your function needs permission to call CloudWatch Logs and X-Ray. Update its execution role (p. 913) to 
grant it permission. Add the following managed policies to enable logs and tracing.
•AWSLambdaBasicExecutionRole
•AWSXRayDaemonWriteAccess
When you add permissions to your function, update its code or conﬁguration as well. This forces running 
instances of your function, which have outdated credentials, to stop and be replaced.
Note
It may take 5 to 10 minutes for logs to show up after a function invocation.
Lambda: The function returns before execution 
ﬁnishes
Issue: (Node.js)  Function returns before code ﬁnishes executing
Many libraries, including the AWS SDK, operate asynchronously. When you make a network call or 
perform another operation that requires waiting for a response, libraries return an object called a 
promise that tracks the progress of the operation in the background.
To wait for the promise to resolve into a response, use the await keyword. This blocks your handler code 
from executing until the promise is resolved into an object that contains the response. If you don't need 
to use the data from the response in your code, you can return the promise directly to the runtime.
Some libraries don't return promises but can be wrapped in code that does. For more information, see
AWS Lambda function handler in Node.js (p. 276).
AWS SDK: Versions and updates
Issue:  The AWS SDK included on the runtime is not the latest version
Issue:  The AWS SDK included on the runtime updates automatically
Runtimes for scripting languages include the AWS SDK and are periodically updated to the latest 
version. The current version for each runtime is listed on runtimes page  (p. 41). To use a newer version 
of the AWS SDK, or to lock your functions to a speciﬁc version, you can bundle the library with your 
function code, or create a Lambda layer (p. 988). For details on creating a deployment package with 
dependencies, see the following topics:
Node.js
Deploy Node.js Lambda functions with .zip ﬁle archives (p. 281)
Python
Working with .zip ﬁle archives for Python Lambda functions (p. 352)
Ruby
Working with .zip ﬁle archives for Ruby Lambda functions (p. 406)
Java
Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446)
1062AWS Lambda Developer Guide
Python: Libraries load incorrectly
Go
Deploy Go Lambda functions with .zip ﬁle archives (p. 520)
C#
Deploy C# Lambda functions with .zip ﬁle archives (p. 566)
PowerShell
Deploy PowerShell Lambda functions with .zip ﬁle archives (p. 602)
Python: Libraries load incorrectly
Issue:  (Python) Some libraries don't load correctly from the deployment package
Libraries with extension modules written in C or C++ must be compiled in an environment with the 
same processor architecture as Lambda (Amazon Linux). For more information, see Working with .zip ﬁle 
archives for Python Lambda functions (p. 352).
Troubleshoot networking issues in Lambda
By default, Lambda runs your functions in an internal virtual private cloud (VPC) with connectivity to 
AWS services and the internet. To access local network resources, you can conﬁgure your function to 
connect to a VPC in your account (p. 85). When you use this feature, you manage the function's internet 
access and network connectivity with Amazon Virtual Private Cloud (Amazon VPC) resources.
Network connectivity errors can result from issues with your VPC's routing conﬁguration, security group 
rules, AWS Identity and Access Management (IAM) role permissions, or network address translation 
(NAT), or from the availability of resources such as IP addresses or network interfaces. Depending on the 
issue, you might see a speciﬁc error or timeout if a request can't reach its destination.
VPC: Function loses internet access or times out
Issue:  Your Lambda function loses internet access after connecting to a VPC.
Error: Error: connect ETIMEDOUT 176.32.98.189:443
Error: Error: Task timed out after 10.00 seconds
Error: ReadTimeoutError: Read timed out. (read timeout=15)
When you connect a function to a VPC, all outbound requests go through the VPC. To connect to the 
internet, conﬁgure your VPC to send outbound traﬃc from the function's subnet to a NAT gateway in a 
public subnet. For more information and sample VPC conﬁgurations, see Internet and service access for 
VPC-connected functions (p. 91).
If some of your TCP connections are timing out, this may be due to packet fragmentation. Lambda 
functions cannot handle incoming fragmented TCP requests, since Lambda does not support IP 
fragmentation for TCP or ICMP.
VPC: Function needs access to AWS services without 
using the internet
Issue:  Your Lambda function needs access to AWS services without using the internet.
1063AWS Lambda Developer Guide
VPC: Elastic network interface limit reached
To connect a function to AWS services from a private subnet with no internet access, use VPC endpoints. 
For a sample AWS CloudFormation template with VPC endpoints for Amazon Simple Storage Service 
(Amazon S3) and Amazon DynamoDB (DynamoDB), see Sample VPC conﬁgurations (p. 91).
VPC: Elastic network interface limit reached
Error: ENILimitReachedException: The elastic network interface limit was reached for the function's VPC.
When you connect a Lambda function to a VPC, Lambda creates an elastic network interface for each 
combination of subnet and security group attached to the function. The default service quota is 250 
network interfaces per VPC. To request a quota increase, use the Service Quotas console.
Troubleshoot container image issues in Lambda
Container: CodeArtifactUserException errors related 
to the code artifact.
Issue:  CodeArtifactUserPendingException error message
The CodeArtifact is pending optimization. The function transitions to active state when Lambda 
completes the optimization. HTTP response code 409.
Issue:  CodeArtifactUserDeletedException error message
The CodeArtifact is scheduled to be deleted. HTTP response code 409.
Issue:  CodeArtifactUserFailedException error message
Lambda failed to optimize the code. You need to correct the code and upload it again. HTTP response 
code 409.
Container: ManifestKeyCustomerException errors 
related to the code manifest key.
Issue:  KMSAccessDeniedException error message
You do not have permissions to access the key to decrypt the manifest. HTTP response code 502.
Issue:  TooManyRequestsException error message
The client is being throttled. The current request rate exceeds the KMS subscription rate. HTTP response 
code 429.
Issue:  KMSNotFoundException error message
Lambda cannot ﬁnd the key to decrypt the manifest. HTTP response code 502.
Issue:  KMSDisabledException error message
The key to decrypt the manifest is disabled. HTTP response code 502.
Issue:  KMSInvalidStateException error message
The key is in a state (such as pending deletion or unavailable) such that Lambda cannot use the key to 
decrypt the manifest. HTTP response code 502.
1064AWS Lambda Developer Guide
Container: Error occurs on runtime InvalidEntrypoint
Container: Error occurs on runtime InvalidEntrypoint
Issue:  You receive a Runtime.ExitError error message, or an error message with "errorType": 
"Runtime.InvalidEntrypoint" .
Verify that the ENTRYPOINT to your container image includes the absolute path as the location. Also 
verify that the image does not contain a symlink as the ENTRYPOINT.
Lambda: System provisioning additional capacity
Error: “Error: We currently do not have suﬃcient capacity in the region you requested. Our system will be 
working on provisioning additional capacity.
Retry the function invocation. If the retry fails, validate that the ﬁles required to run the function code 
can be read by any user. Lambda deﬁnes a default Linux user with least-privileged permissions. You need 
to verify that your application code does not rely on ﬁles that are restricted by other Linux users for 
execution.
CloudFormation: ENTRYPOINT is being overridden 
with a null or empty value
Error: You are using an AWS CloudFormation template, and your container ENTRYPOINT is being 
overridden with a null or empty value.
Review the ImageConfig  resource in the AWS CloudFormation template. If you declare an
ImageConfig  resource in your template, you must provide non-empty values for all three of the 
properties.
1065AWS Lambda Developer Guide
AWS Lambda applications
An AWS Lambda application is a combination of Lambda functions, event sources, and other resources 
that work together to perform tasks. You can use AWS CloudFormation and other tools to collect your 
application's components into a single package that can be deployed and managed as one resource. 
Applications make your Lambda projects portable and enable you to integrate with additional developer 
tools, such as AWS CodePipeline, AWS CodeBuild, and the AWS Serverless Application Model command 
line interface (AWS SAM CLI).
The AWS Serverless Application Repository provides a collection of Lambda applications that you 
can deploy in your account with a few clicks. The repository includes both ready-to-use applications 
and samples that you can use as a starting point for your own projects. You can also submit your own 
projects for inclusion.
AWS CloudFormation enables you to create a template that deﬁnes your application's resources and lets 
you manage the application as a stack . You can more safely add or modify resources in your application 
stack. If any part of an update fails, AWS CloudFormation automatically rolls back to the previous 
conﬁguration. With AWS CloudFormation parameters, you can create multiple environments for your 
application from the same template. AWS SAM extends AWS CloudFormation with a simpliﬁed syntax 
focused on Lambda application development.
The AWS CLI and AWS SAM CLI are command line tools for managing Lambda application stacks. In 
addition to commands for managing application stacks with the AWS CloudFormation API, the AWS 
CLI supports higher-level commands that simplify tasks such as uploading deployment packages and 
updating templates. The AWS SAM CLI provides additional functionality, including validating templates, 
testing locally, and integrating with CI/CD systems.
When creating an application, you can create its Git repository using either CodeCommit or an AWS 
CodeStar connection to GitHub. CodeCommit enables you to use the IAM console to manage SSH keys 
and HTTP credentials for your users. AWS CodeStar connections enables you to connect to your GitHub 
account. For more information about connections, see  What are connections? in the Developer Tools 
console User Guide .
For more information about designing Lambda applications, see Application design  in Serverless Land.
Topics
•Managing applications in the AWS Lambda console (p. 1067 )
•Creating an application with continuous delivery in the Lambda console (p. 1070 )
•Rolling deployments for Lambda functions  (p. 1079 )
•Invoking Lambda functions with the AWS Mobile SDK for Android (p. 1081 )
1066AWS Lambda Developer Guide
Manage applications
Managing applications in the AWS Lambda console
The AWS Lambda console helps you monitor and manage your Lambda applications  (p. 1066 ). The
Applications  menu lists AWS CloudFormation stacks with Lambda functions. The menu includes stacks 
that you launch in AWS CloudFormation by using the AWS CloudFormation console, the AWS Serverless 
Application Repository, the AWS CLI, or the AWS SAM CLI.
To view a Lambda application
1. Open the Lambda console Applications page .
2. Choose an application.
The overview shows the following information about your application.
•AWS CloudFormation template or SAM template  – The template that deﬁnes your application.
•Resources – The AWS resources that are deﬁned in your application's template. To manage your 
application's Lambda functions, choose a function name from the list.
Monitoring applications
The Monitoring  tab shows an Amazon CloudWatch dashboard with aggregate metrics for the resources 
in your application.
To monitor a Lambda application
1. Open the Lambda console Applications page .
2. Choose Monitoring .
By default, the Lambda console shows a basic dashboard. You can customize this page by deﬁning 
custom dashboards in your application template. When your template includes one or more dashboards, 
the page shows your dashboards instead of the default dashboard. You can switch between dashboards 
with the drop-down menu on the top right of the page.
Custom monitoring dashboards
Customize your application monitoring page by adding one or more Amazon CloudWatch dashboards to 
your application template with the AWS::CloudWatch::Dashboard resource type. The following example 
creates a dashboard with a single widget that graphs the number of invocations of a function named
my-function .
1067AWS Lambda Developer Guide
Custom monitoring dashboards
Example function dashboard template
Resources: 
  MyDashboard: 
    Type: AWS::CloudWatch::Dashboard 
    Properties: 
      DashboardName: my-dashboard 
      DashboardBody: | 
        { 
            "widgets": [ 
                { 
                    "type": "metric", 
                    "width": 12, 
                    "height": 6, 
                    "properties": { 
                        "metrics": [ 
                            [ 
                                "AWS/Lambda", 
                                "Invocations", 
                                "FunctionName", 
                                "my-function", 
                                { 
                                    "stat": "Sum", 
                                    "label": "MyFunction" 
                                } 
                            ], 
                            [ 
                                { 
                                    "expression": "SUM(METRICS())", 
                                    "label": "Total Invocations" 
                                } 
                            ] 
                        ], 
                        "region": "us-east-1", 
                        "title": "Invocations", 
                        "view": "timeSeries", 
                        "stacked": false 
                    } 
                } 
            ] 
        }
You can get the deﬁnition for any of the widgets in the default monitoring dashboard from the 
CloudWatch console.
To view a widget deﬁnition
1. Open the Lambda console Applications page .
2. Choose an application that has the standard dashboard.
3. Choose Monitoring .
4. On any widget, choose View in metrics  from the drop-down menu.
1068AWS Lambda Developer Guide
Custom monitoring dashboards
5. Choose Source.
For more information about authoring CloudWatch dashboards and widgets, see Dashboard body 
structure and syntax in the Amazon CloudWatch API Reference.
1069AWS Lambda Developer Guide
Tutorial – Create an application
Creating an application with continuous delivery in 
the Lambda console
You can use the Lambda console to create an application with an integrated continuous delivery pipeline. 
With continuous delivery, every change that you push to your source control repository triggers a 
pipeline that builds and deploys your application automatically. The Lambda console provides starter 
projects for common application types with Node.js sample code and templates that create supporting 
resources.
In this tutorial, you create the following resources.
•Application  – A Node.js Lambda function, build speciﬁcation, and AWS Serverless Application Model 
(AWS SAM) template.
•Pipeline  – An AWS CodePipeline pipeline that connects the other resources to enable continuous 
delivery.
•Repository – A Git repository in AWS CodeCommit. When you push a change, the pipeline copies the 
source code into an Amazon S3 bucket and passes it to the build project.
•Trigger – An Amazon EventBridge (CloudWatch Events) rule that watches the main branch of the 
repository and triggers the pipeline.
•Build project – An AWS CodeBuild build that gets the source code from the pipeline and packages the 
application. The source includes a build speciﬁcation with commands that install dependencies and 
prepare the application template for deployment.
•Deployment conﬁguration – The pipeline's deployment stage deﬁnes a set of actions that take 
the processed AWS SAM template from the build output, and deploy the new version with AWS 
CloudFormation.
•Bucket – An Amazon Simple Storage Service (Amazon S3) bucket for deployment artifact storage.
•Roles – The pipeline's source, build, and deploy stages have IAM roles that allow them to manage AWS 
resources. The application's function has an execution role (p. 913) that allows it to upload logs and 
can be extended to access other services.
Your application and pipeline resources are deﬁned in AWS CloudFormation templates that you can 
customize and extend. Your application repository includes a template that you can modify to add 
Amazon DynamoDB tables, an Amazon API Gateway API, and other application resources. The continuous 
delivery pipeline is deﬁned in a separate template outside of source control and has its own stack.
The pipeline maps a single branch in a repository to a single application stack. You can create additional 
pipelines to add environments for other branches in the same repository. You can also add stages to your 
pipeline for testing, staging, and manual approvals. For more information about AWS CodePipeline, see
What is AWS CodePipeline.
Sections
•Prerequisites (p. 1071 )
•Create an application (p. 1071 )
•Invoke the function (p. 1072 )
•Add an AWS resource (p. 1073 )
•Update the permissions boundary (p. 1075 )
•Update the function code (p. 1075 )
•Next steps (p. 1076 )
•Troubleshooting (p. 1077 )
1070AWS Lambda Developer Guide
Prerequisites
•Clean up  (p. 1078 )
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
This tutorial uses CodeCommit for source control. To set up your local machine to access and update 
application code, see Setting up in the AWS CodeCommit User Guide.
Create an application
Create an application in the Lambda console. In Lambda, an application is an AWS CloudFormation 
stack with a Lambda function and any number of supporting resources. In this tutorial, you create an 
application that has a function and its execution role.
To create an application
1. Open the Lambda console Applications page .
2. Choose Create application .
3. Choose Author from scratch .
4. Conﬁgure application settings.
•Application name  – my-app .
•Runtime  – Node.js 14.x .
•Source control service – CodeCommit .
•Repository name – my-app-repo .
•Permissions – Create roles and permissions boundary.
5. Choose Create .
Lambda creates the pipeline and related resources and commits the sample application code to the Git 
repository. As resources are created, they appear on the overview page.
1071AWS Lambda Developer Guide
Invoke the function
The Infrastructure stack contains the repository, build project, and other resources that combine to form 
a continuous delivery pipeline. When this stack ﬁnishes deploying, it in turn deploys the application stack 
that contains the function and execution role. These are the application resources that appear under
Resources.
Invoke the function
When the deployment process completes, invoke the function from the Lambda console.
To invoke the application's function
1. Open the Lambda console Applications page .
2. Choose my-app.
3. Under Resources, choose helloFromLambdaFunction.
4. Choose Test.
5. Conﬁgure a test event.
•Event name – event
•Body  – {}
6. Choose Create .
7. Choose Test.
The Lambda console runs your function and displays the result. Expand the Details  section under the 
result to see the output and execution details.
1072AWS Lambda Developer Guide
Add an AWS resource
Add an AWS resource
In the previous step, Lambda console created a Git repository that contains function code, a template, 
and a build speciﬁcation. You can add resources to your application by modifying the template and 
pushing changes to the repository. To get a copy of the application on your local machine, clone the 
repository.
To clone the project repository
1. Open the Lambda console Applications page .
2. Choose my-app.
3. Choose Code .
4. Under Repository details, copy the HTTP or SSH repository URI, depending on the authentication 
mode that you conﬁgured during setup  (p. 1071 ).
5. To clone the repository, use the git clone  command.
git clone ssh://git-codecommit.us-east-2.amazonaws.com/v1/repos/my-app-repo
To add a DynamoDB table to the application, deﬁne an AWS::Serverless::SimpleTable  resource in 
the template.
To add a DynamoDB table
1. Open template.yml  in a text editor.
2. Add a table resource, an environment variable that passes the table name to the function, and a 
permissions policy that allows the function to manage it.
Example template.yml - resources
...
Resources: 
   ddbTable: 
    Type: AWS::Serverless::SimpleTable 
    Properties: 
1073AWS Lambda Developer Guide
Add an AWS resource
      PrimaryKey: 
        Name: id 
        Type: String 
      ProvisionedThroughput: 
        ReadCapacityUnits: 1 
        WriteCapacityUnits: 1
  helloFromLambdaFunction: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: ./ 
      Handler: src/handlers/hello-from-lambda.helloFromLambdaHandler 
      Runtime: nodejs14.x 
      MemorySize: 128 
      Timeout: 60 
      Description: A Lambda function that returns a static string. 
       Environment: 
        Variables: 
          DDB_TABLE: !Ref ddbTable
      Policies: 
         - DynamoDBCrudPolicy: 
            TableName: !Ref ddbTable
        - AWSLambdaBasicExecutionRole
3. Commit and push the change.
git commit -am "Add DynamoDB table"
git push
When you push a change, it triggers the application's pipeline. Use the Deployments tab of the 
application screen to track the change as it ﬂows through the pipeline. When the deployment is 
complete, proceed to the next step.
1074AWS Lambda Developer Guide
Update the permissions boundary
Update the permissions boundary
The sample application applies a permissions boundary to its function's execution role. The permissions 
boundary limits the permissions that you can add to the function's role. Without the boundary, users 
with write access to the project repository could modify the project template to give the function 
permission to access resources and services outside of the scope of the sample application.
In order for the function to use the DynamoDB permission that you added to its execution role in the 
previous step, you must extend the permissions boundary to allow the additional permissions. The 
Lambda console detects resources that aren't in the permissions boundary and provides an updated 
policy that you can use to update it.
To update the application's permissions boundary
1. Open the Lambda console Applications page .
2. Choose your application.
3. Under Resources, choose Edit permissions boundary.
4. Follow the instructions shown to update the boundary to allow access to the new table.
For more information about permissions boundaries, see Using permissions boundaries for AWS Lambda 
applications  (p. 942).
Update the function code
Next, update the function code to use the table. The following code uses the DynamoDB table to track 
the number of invocations processed by each instance of the function. It uses the log stream ID as a 
unique identiﬁer for the function instance.
To update the function code
1. Add a new handler named index.js  to the src/handlers  folder with the following content.
Example src/handlers/index.js
const dynamodb = require('aws-sdk/clients/dynamodb');
const docClient = new dynamodb.DocumentClient();
exports.handler = async (event, context) => { 
    const message = 'Hello from Lambda!'; 
    const tableName = process.env.DDB_TABLE; 
    const logStreamName = context.logStreamName; 
    var params = { 
        TableName : tableName, 
        Key: { id : logStreamName }, 
        UpdateExpression: 'set invocations = if_not_exists(invocations, :start) 
 + :inc', 
        ExpressionAttributeValues: { 
            ':start': 0, 
            ':inc': 1 
        }, 
        ReturnValues: 'ALL_NEW' 
    }; 
    await docClient.update(params).promise(); 
    const response = { 
        body: JSON.stringify(message) 
    }; 
    console.log(`body: ${response.body}`); 
    return response;
1075AWS Lambda Developer Guide
Next steps
}
2. Open the application template and change the handler value to src/handlers/index.handler .
Example template.yml
... 
  helloFromLambdaFunction: 
    Type: AWS::Serverless::Function
    Properties: 
      CodeUri: ./ 
      Handler: src/handlers/index.handler
      Runtime: nodejs14.x
3. Commit and push the change.
git add . && git commit -m "Use DynamoDB table"
git push
After the code change is deployed, invoke the function a few times to update the DynamoDB table.
To view the DynamoDB table
1. Open the Tables page of the DynamoDB console.
2. Choose the table that starts with my-app.
3. Choose Items .
4. Choose Start search.
Lambda creates additional instances of your function to handle multiple concurrent invocations. Each log 
stream in the CloudWatch Logs log group corresponds to a function instance. A new function instance 
is also created when you change your function's code or conﬁguration. For more information on scaling, 
see Lambda function scaling (p. 220).
Next steps
The AWS CloudFormation template that deﬁnes your application resources uses the AWS Serverless 
Application Model transform to simplify the syntax for resource deﬁnitions, and automate uploading 
1076AWS Lambda Developer Guide
Troubleshooting
the deployment package and other artifacts. AWS SAM also provides a command line interface (the AWS 
SAM CLI), which has the same packaging and deployment functionality as the AWS CLI, with additional 
features speciﬁc to Lambda applications. Use the AWS SAM CLI to test your application locally in a 
Docker container that emulates the Lambda execution environment.
•Installing the AWS SAM CLI
•Testing and debugging serverless applications with AWS SAM
•Deploying serverless applications using CI/CD systems with AWS SAM
AWS Cloud9 provides an online development environment that includes Node.js, the AWS SAM CLI, and 
Docker. With AWS Cloud9, you can start developing quickly and access your development environment 
from any computer. For instructions, see Getting started in the AWS Cloud9 User Guide.
For local development, AWS toolkits for integrated development environments (IDEs) let you test and 
debug functions before pushing them to your repository.
•AWS Toolkit for JetBrains – Plugin for PyCharm (Python) and IntelliJ (Java) IDEs.
•AWS Toolkit for Eclipse – Plugin for Eclipse IDE (multiple languages).
•AWS Toolkit for Visual Studio Code – Plugin for Visual Studio Code IDE (multiple languages).
•AWS Toolkit for Visual Studio – Plugin for Visual Studio IDE (multiple languages).
Troubleshooting
As you develop your application, you will likely encounter the following types of errors.
•Build errors – Issues that occur during the build phase, including compilation, test, and packaging 
errors.
•Deployment errors – Issues that occur when AWS CloudFormation isn't able to update the application 
stack. These include permissions errors, account quotas, service issues, or template errors.
•Invocation errors – Errors that are returned by a function's code or runtime.
For build and deployment errors, you can identify the cause of an error in the Lambda console.
To troubleshoot application errors
1. Open the Lambda console Applications page .
2. Choose an application.
3. Choose Deployments.
4. To view the application's pipeline, choose Deployment pipeline.
5. Identify the action that encountered an error.
6. To view the error in context, choose Details .
For deployment errors that occur during the ExecuteChangeSet action, the pipeline links to a list of 
stack events in the AWS CloudFormation console. Search for an event with the status UPDATE_FAILED. 
Because AWS CloudFormation rolls back after an error, the relevant event is under several other events 
in the list. If AWS CloudFormation could not create a change set, the error appears under Change sets
instead of under Events.
A common cause of deployment and invocation errors is a lack of permissions in one or more roles. 
The pipeline has a role for deployments (CloudFormationRole ) that's equivalent to the user 
permissions  (p. 920) that you would use to update an AWS CloudFormation stack directly. If you add 
1077AWS Lambda Developer Guide
Clean up
resources to your application or enable Lambda features that require user permissions, the deployment 
role is used. You can ﬁnd a link to the deployment role under Infrastructure in the application overview.
If your function accesses other AWS services or resources, or if you enable features that require the 
function to have additional permissions, the function's execution role (p. 913) is used. All execution roles 
that are created in your application template are also subject to the application's permissions boundary. 
This boundary requires you to explicitly grant access to additional services and resources in IAM after 
adding permissions to the execution role in the template.
For example, to connect a function to a virtual private cloud (p. 85) (VPC), you need user permissions to 
describe VPC resources. The execution role needs permission to manage network interfaces. This requires 
the following steps.
1.Add the required user permissions to the deployment role in IAM.
2.Add the execution role permissions to the permissions boundary in IAM.
3.Add the execution role permissions to the execution role in the application template.
4.Commit and push to deploy the updated execution role.
After you address permissions errors, choose Release change in the pipeline overview to rerun the build 
and deployment.
Clean up
You can continue to modify and use the sample to develop your own application. If you are done using 
the sample, delete the application to avoid paying for the pipeline, repository, and storage.
To delete the application
1. Open the AWS CloudFormation console.
2. Delete the application stack – my-app.
3. Open the Amazon S3 console.
4. Delete the artifact bucket – us-east-2 -123456789012 -my-app-pipe.
5. Return to the AWS CloudFormation console and delete the infrastructure stack – serverlessrepo-
my-app-toolchain.
Function logs are not associated with the application or infrastructure stack in AWS CloudFormation. 
Delete the log group separately in the CloudWatch Logs console.
To delete the log group
1. Open the Log groups page of the Amazon CloudWatch console.
2. Choose the function's log group (/aws/lambda/my-app-
helloFromLambdaFunction- YV1VXMPLK7QK ).
3. Choose Actions, and then choose Delete log group.
4. Choose Yes, Delete.
1078AWS Lambda Developer Guide
Rolling deployments
Rolling deployments for Lambda functions
Use rolling deployments to control the risks associated with introducing new versions of your Lambda 
function. In a rolling deployment, the system automatically deploys the new version of the function and 
gradually sends an increasing amount of traﬃc to the new version. The amount of traﬃc and rate of 
increase are parameters that you can conﬁgure.
You conﬁgure a rolling deployment by using AWS CodeDeploy and AWS SAM. CodeDeploy is a service 
that automates application deployments to Amazon computing platforms such as Amazon EC2 and AWS 
Lambda. For more information, see What is CodeDeploy?. By using CodeDeploy to deploy your Lambda 
function, you can easily monitor the status of the deployment and initiate a rollback if you detect any 
issues.
AWS SAM is an open-source framework for building serverless applications. You create an AWS 
SAM template (in YAML format) to specify the conﬁguration of the components required for the 
rolling deployment. AWS SAM uses the template to create and conﬁgure the components. For more 
information, see What is the AWS SAM?.
In a rolling deployment, AWS SAM performs these tasks:
•It conﬁgures your Lambda function and creates an alias.
The alias routing conﬁguration is the underlying capability that implements the rolling deployment.
•It creates a CodeDeploy application and deployment group.
The deployment group manages the rolling deployment and the rollback (if needed).
•It detects when you create a new version of your Lambda function.
•It triggers CodeDeploy to start the deployment of the new version.
Example AWS SAM Lambda template
The following example shows an AWS SAM template for a simple rolling deployment.
AWSTemplateFormatVersion : '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: A sample SAM template for deploying Lambda functions.
Resources:
# Details about the myDateTimeFunction Lambda function 
  myDateTimeFunction: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: myDateTimeFunction.handler 
      Runtime: nodejs18.x
# Creates an alias named "live" for the function, and automatically publishes when you 
 update the function. 
      AutoPublishAlias: live 
      DeploymentPreference:
# Specifies the deployment configuration 
          Type: Linear10PercentEvery2Minutes
This template deﬁnes a Lambda function named myDateTimeFunction  with the following properties.
1079AWS Lambda Developer Guide
Example AWS SAM Lambda template
AutoPublishAlias
The AutoPublishAlias  property creates an alias named live. In addition, the AWS SAM 
framework automatically detects when you save new code for the function. The framework then 
publishes a new function version and updates the live alias to point to the new version.
DeploymentPreference
The DeploymentPreference  property determines the rate at which the CodeDeploy application 
shifts traﬃc from the original version of the Lambda function to the new version. The value
Linear10PercentEvery2Minutes  shifts an additional ten percent of the traﬃc to the new 
version every two minutes.
For a list of the predeﬁned deployment conﬁgurations, see Deployment conﬁgurations.
For a detailed tutorial on how to use CodeDeploy with Lambda functions, see Deploy an updated 
Lambda function with CodeDeploy.
1080AWS Lambda Developer Guide
Mobile SDK for Android
Invoking Lambda functions with the AWS Mobile 
SDK for Android
You can call a Lambda function from a mobile application. Put business logic in functions to separate 
its development lifecycle from that of front-end clients, making mobile applications less complex to 
develop and maintain. With the Mobile SDK for Android, you use Amazon Cognito to authenticate users 
and authorize requests (p. 1081 ).
When you invoke a function from a mobile application, you choose the event structure, invocation 
type (p. 135), and permission model. You can use aliases  (p. 104) to enable seamless updates to 
your function code, but otherwise the function and application are tightly coupled. As you add more 
functions, you can create an API layer to decouple your function code from your front-end clients and 
improve performance.
To create a fully-featured web API for your mobile and web applications, use Amazon API Gateway. 
With API Gateway, you can add custom authorizers, throttle requests, and cache results for all of your 
functions. For more information, see Using AWS Lambda with Amazon API Gateway (p. 634).
Topics
•Tutorial: Using AWS Lambda with the Mobile SDK for Android (p. 1081 )
•Sample function code (p. 1087 )
Tutorial: Using AWS Lambda with the Mobile SDK for 
Android
In this tutorial, you create a simple Android mobile application that uses Amazon Cognito to get 
credentials and invokes a Lambda function.
The mobile application retrieves AWS credentials from an Amazon Cognito identity pool and uses them 
to invoke a Lambda function with an event that contains request data. The function processes the 
request and returns a response to the front-end.
Prerequisites
This tutorial assumes that you have some knowledge of basic Lambda operations and the Lambda 
console. If you haven't already, follow the instructions in Create a Lambda function with the 
console (p. 4) to create your ﬁrst Lambda function.
To complete the following steps, you need the AWS Command Line Interface (AWS CLI) version 2. 
Commands and the expected output are listed in separate blocks:
aws --version
You should see the following output:
aws-cli/2.0.57 Python/3.7.4 Darwin/19.6.0 exe/x86_64
For long commands, an escape character (\) is used to split a command over multiple lines.
On Linux and macOS, use your preferred shell and package manager.
Note
In Windows, some Bash CLI commands that you commonly use with Lambda (such as zip) 
are not supported by the operating system's built-in terminals. To get a Windows-integrated 
1081AWS Lambda Developer Guide
Tutorial
version of Ubuntu and Bash, install the Windows Subsystem for Linux. Example CLI commands 
in this guide use Linux formatting. Commands which include inline JSON documents must be 
reformatted if you are using the Windows CLI.
Create the execution role
Create the execution role (p. 913) that gives your function permission to access AWS resources.
To create an execution role
1. Open the roles page in the IAM console.
2. Choose Create role.
3. Create a role with the following properties.
•Trusted entity – AWS Lambda.
•Permissions – AWSLambdaBasicExecutionRole.
•Role name – lambda-android-role .
The AWSLambdaBasicExecutionRole policy has the permissions that the function needs to write logs to 
CloudWatch Logs.
Create the function
The following example uses data to generate a string response.
Note
For sample code in other languages, see Sample function code (p. 1087 ).
Example index.js
exports.handler = function(event, context, callback) { 
   console.log("Received event: ", event); 
   var data = { 
       "greetings": "Hello, " + event.firstName + " " + event.lastName + "." 
   }; 
   callback(null, data);
}
To create the function
1. Copy the sample code into a ﬁle named index.js .
2. Create a deployment package.
zip function.zip index.js
3. Create a Lambda function with the create-function  command.
aws lambda create-function --function-name AndroidBackendLambdaFunction \
--zip-file fileb://function.zip --handler index.handler --runtime nodejs16.x \
--role arn:aws:iam:: 111122223333 :role/lambda-android-role
Test the Lambda function
Invoke the function manually using the sample event data.
1082AWS Lambda Developer Guide
Tutorial
To test the Lambda function (AWS CLI)
1. Save the following sample event JSON in a ﬁle, input.txt .
{   "firstName": " first-name ",   "lastName": " last-name " }
2. Run the following invoke command:
aws lambda  invoke --function-name AndroidBackendLambdaFunction \
--payload file:// file-path /input.txt outputfile.txt
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
Create an Amazon Cognito identity pool
In this section, you create an Amazon Cognito identity pool. The identity pool has two IAM 
roles. You update the IAM role for unauthenticated users and grant permissions to run the
AndroidBackendLambdaFunction  Lambda function.
For more information about IAM roles, see IAM roles in the IAM User Guide . For more information about 
Amazon Cognito services, see the Amazon Cognito product detail page.
To create an identity pool
1. Open the Amazon Cognito console.
2. Create a new identity pool called JavaFunctionAndroidEventHandlerPool . Before you follow 
the procedure to create an identity pool, note the following:
•The identity pool you are creating must allow access to unauthenticated identities because our 
example mobile application does not require a user log in. Therefore, make sure to select the
Enable access to unauthenticated identities option.
•Add the following statement to the permission policy associated with the unauthenticated 
identities.
{ 
        "Effect": "Allow", 
        "Action": [ 
            "lambda:InvokeFunction" 
        ], 
        "Resource": [ 
           "arn:aws:lambda:us-
east-1:111122223333 :function:AndroidBackendLambdaFunction" 
        ]
}
The resulting policy will be as follows:
{ 
   "Version":"2012-10-17", 
   "Statement":[ 
      { 
         "Effect":"Allow", 
         "Action":[ 
            "mobileanalytics:PutEvents", 
            "cognito-sync:*" 
1083AWS Lambda Developer Guide
Tutorial
         ], 
         "Resource":[ 
            "*" 
         ] 
      }, 
      { 
         "Effect":"Allow", 
         "Action":[ 
            "lambda:invokefunction" 
         ], 
         "Resource":[ 
            "arn:aws:lambda:us-east-1: account-
id:function:AndroidBackendLambdaFunction" 
         ] 
      } 
   ]
}
For instructions about how to create an identity pool, log in to the Amazon Cognito console and 
follow the New Identity Pool wizard.
3. Note the identity pool ID. You specify this ID in your mobile application you create in the next 
section. The app uses this ID when it sends request to Amazon Cognito to request for temporary 
security credentials.
Create an Android application
Create a simple Android mobile application that generates events and invokes Lambda functions by 
passing the event data as parameters.
The following instructions have been veriﬁed using Android studio.
1. Create a new Android project called AndroidEventGenerator  using the following conﬁguration:
•Select the Phone and Tablet platform.
•Choose Blank Activity.
2. In the build.gradle ( Module:app ) ﬁle, add the following in the dependencies  section:
compile 'com.amazonaws:aws-android-sdk-core:2.2.+'
compile 'com.amazonaws:aws-android-sdk-lambda:2.2.+'
3. Build the project so that the required dependencies are downloaded, as needed.
4. In the Android application manifest (AndroidManifest.xml ), add the following permissions so 
that your application can connect to the Internet. You can add them just before the </manifest>
end tag.
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
5. In MainActivity , add the following imports:
import com.amazonaws.mobileconnectors.lambdainvoker.*;
import com.amazonaws.auth.CognitoCachingCredentialsProvider;
import com.amazonaws.regions.Regions;
6. In the package section, add the following two classes (RequestClass  and ResponseClass ). Note 
that the POJO is same as the POJO you created in your Lambda function in the preceding section.
1084AWS Lambda Developer Guide
Tutorial
•RequestClass . The instances of this class act as the POJO (Plain Old Java Object) for event data 
which consists of ﬁrst and last name. If you are using Java example for your Lambda function 
you created in the preceding section, this POJO is same as the POJO you created in your Lambda 
function code.
package com.example....lambdaeventgenerator ;
public class RequestClass { 
    String firstName; 
    String lastName; 
    public String getFirstName() { 
        return firstName; 
    } 
    public void setFirstName(String firstName) { 
        this.firstName = firstName; 
    } 
    public String getLastName() { 
        return lastName; 
    } 
    public void setLastName(String lastName) { 
        this.lastName = lastName; 
    } 
    public RequestClass(String firstName, String lastName) { 
        this.firstName = firstName; 
        this.lastName = lastName; 
    } 
    public RequestClass() { 
    }
}
•ResponseClass
package com.example....lambdaeventgenerator ;
public class ResponseClass { 
    String greetings; 
    public String getGreetings() { 
        return greetings; 
    } 
    public void setGreetings(String greetings) { 
        this.greetings = greetings; 
    } 
    public ResponseClass(String greetings) { 
        this.greetings = greetings; 
    } 
    public ResponseClass() { 
    }
}
7. In the same package, create interface called MyInterface  for invoking the
AndroidBackendLambdaFunction  Lambda function.
package com.example.....lambdaeventgenerator ;
import com.amazonaws.mobileconnectors.lambdainvoker.LambdaFunction;
1085AWS Lambda Developer Guide
Tutorial
public interface MyInterface { 
    /** 
     * Invoke the Lambda function "AndroidBackendLambdaFunction". 
     * The function name is the method name. 
     */ 
    @LambdaFunction 
     ResponseClass AndroidBackendLambdaFunction(RequestClass request);
}
The @LambdaFunction  annotation in the code maps the speciﬁc client method to the same-name 
Lambda function.
8. To keep the application simple, we are going to add code to invoke the Lambda function in the
onCreate()  event handler. In MainActivity , add the following code toward the end of the
onCreate()  code.
// Create an instance of CognitoCachingCredentialsProvider
CognitoCachingCredentialsProvider cognitoProvider = new 
 CognitoCachingCredentialsProvider( 
        this.getApplicationContext(), " identity-pool-id ", Regions.US_WEST_2);
// Create LambdaInvokerFactory, to be used to instantiate the Lambda proxy.
LambdaInvokerFactory factory = new LambdaInvokerFactory(this.getApplicationContext(), 
        Regions.US_WEST_2, cognitoProvider);
// Create the Lambda proxy object with a default Json data binder.
// You can provide your own data binder by implementing
// LambdaDataBinder.
final MyInterface myInterface = factory.build(MyInterface.class);
RequestClass request = new RequestClass("John", "Doe");
// The Lambda function invocation results in a network call.
// Make sure it is not called from the main thread.
new AsyncTask<RequestClass, Void, ResponseClass>() { 
    @Override 
    protected ResponseClass doInBackground(RequestClass... params) { 
        // invoke "echo" method. In case it fails, it will throw a 
        // LambdaFunctionException. 
        try { 
            return myInterface.AndroidBackendLambdaFunction(params[0]); 
        } catch (LambdaFunctionException lfe) { 
            Log.e("Tag", "Failed to invoke echo", lfe); 
            return null; 
        } 
    } 
    @Override 
    protected void onPostExecute(ResponseClass result) { 
        if (result == null) { 
            return; 
        } 
        // Do a toast 
        Toast.makeText(MainActivity.this, result.getGreetings(), 
 Toast.LENGTH_LONG).show(); 
    }
}.execute(request);
9. Run the code and verify it as follows:
•The Toast.makeText()  displays the response returned.
1086AWS Lambda Developer Guide
Sample code
•Verify that CloudWatch Logs shows the log created by the Lambda function. It should show the 
event data (ﬁrst name and last name). You can also verify this in the AWS Lambda console.
Sample function code
Sample code is available for the following languages.
Topics
•Node.js  (p. 1087 )
•Java (p. 1087 )
Node.js
The following example uses data to generate a string response.
Example index.js
exports.handler = function(event, context, callback) { 
   console.log("Received event: ", event); 
   var data = { 
       "greetings": "Hello, " + event.firstName + " " + event.lastName + "." 
   }; 
   callback(null, data);
}
Zip up the sample code to create a deployment package. For instructions, see Deploy Node.js Lambda 
functions with .zip ﬁle archives (p. 281).
Java
The following example uses data to generate a string response.
In the code, the handler  (myHandler ) uses the RequestClass  and ResponseClass  types for the 
input and output. The code provides implementation for these types.
Example HelloPojo.java
package example;
import com.amazonaws.services.lambda.runtime.Context;  
public class HelloPojo { 
    // Define two classes/POJOs for use with Lambda function. 
    public static class RequestClass { 
        String firstName; 
        String lastName; 
        public String getFirstName() { 
            return firstName; 
        } 
        public void setFirstName(String firstName) { 
            this.firstName = firstName; 
        } 
1087AWS Lambda Developer Guide
Sample code
        public String getLastName() { 
            return lastName; 
        } 
        public void setLastName(String lastName) { 
            this.lastName = lastName; 
        } 
        public RequestClass(String firstName, String lastName) { 
            this.firstName = firstName; 
            this.lastName = lastName; 
        } 
        public RequestClass() { 
        } 
    } 
    public static class ResponseClass { 
        String greetings; 
        public String getGreetings() { 
            return greetings; 
        } 
        public void setGreetings(String greetings) { 
            this.greetings = greetings; 
        } 
        public ResponseClass(String greetings) { 
            this.greetings = greetings; 
        } 
        public ResponseClass() { 
        } 
    } 
    public static ResponseClass myHandler(RequestClass request, Context context){ 
        String greetingString = String.format("Hello %s, %s.", request.firstName, 
 request.lastName); 
        context.getLogger().log(greetingString); 
        return new ResponseClass(greetingString); 
    }
}
Dependencies
•aws-lambda-java-core
Build the code with the Lambda library dependencies to create a deployment package. For instructions, 
see Deploy Java Lambda functions with .zip or JAR ﬁle archives (p. 446).
1088AWS Lambda Developer Guide
Application patterns
Orchestrating functions with Step 
Functions
AWS Step Functions is an orchestration service that lets you connect Lambda functions together into 
serverless workﬂows, called state machines. Use Step Functions to orchestrate serverless applications 
workﬂows (for example, a store checkout process), build long-running workﬂows for IT automation 
and human-approval use cases, or create high-volume short-duration workﬂows for streaming data 
processing and ingestion.
Topics
•State machine application patterns (p. 1089 )
•Managing state machines in the Lambda console (p. 1092 )
•Orchestration examples with Step Functions (p. 1094 )
State machine application patterns
In Step Functions, you orchestrate your resources using state machines, which are deﬁned using a JSON-
based, structured language called Amazon States Language.
Sections
•State machine components (p. 1089 )
•State machine application patterns (p. 1089 )
•Applying patterns to state machines (p. 1090 )
•Example branching application pattern (p. 1090 )
State machine components
State machines contain elements called states  that make up your workﬂow. The logic of each state 
determines which state comes next, what data to pass along, and when to terminate the workﬂow. A 
state is referred to by its name, which can be any string, but which must be unique within the scope of 
the entire state machine.
To create a state machine that uses Lambda, you need the following components:
1.An AWS Identity and Access Management (IAM) role for Lambda with one or more permissions policies 
(such as AWSLambdaRole service permissions).
2.One or more Lambda functions (with the IAM role attached) for your speciﬁc runtime.
3.A state machine authored in Amazon States Language.
State machine application patterns
You can create complex orchestrations for state machines using application patterns such as:
•Catch and retry – Handle errors using sophisticated catch-and-retry functionality.
1089AWS Lambda Developer Guide
Applying patterns to state machines
•Branching  – Design your workﬂow to choose diﬀerent branches based on Lambda function output.
•Chaining  – Connect functions into a series of steps, with the output of one step providing the input to 
the next step.
•Parallelism – Run functions in parallel, or use dynamic parallelism to invoke a function for every 
member of any array.
Applying patterns to state machines
The following shows how you can apply these application patterns to a state machine within an Amazon 
States Language deﬁnition.
Catch and Retry
A Catch  ﬁeld and a Retry ﬁeld add catch-and-retry logic to a state machine. Catch  ("Type": 
"Catch") is an array of objects that deﬁne a fallback state. Retry ("Type": "Retry" ) is an array of 
objects that deﬁne a retry policy if the state encounters runtime errors.
Branching
A Choice  state adds branching logic to a state machine. Choice ("Type": "Choice" ) is an array of 
rules that determine which state the state machine transitions to next.
Chaining
A "Chaining" pattern describes multiple Lambda functions connected together in a state machine. 
You can use chaining to create reusable workﬂow invocations from a Task ("Type": "Task" ) state 
of a state machine.
Parallelism
A Parallel  state adds parallelism logic to a state machine. You can use a Parallel state ("Type": 
"Parallel" ) to create parallel branches of invocation in your state machine.
Dynamic parallelism
A Map state adds dynamic "for-each" loop logic to a state machine. You can use a Map state 
("Type": "Map" ) to run a set of steps for each element of an input array in a state machine. While 
the Parallel  state invokes multiple branches of steps using the same input, a Map state invokes 
the same steps for multiple entries of the array.
In addition to application patterns, Step Functions supports various service integration patterns, 
including the ability to pause a workﬂow for human approval, or to call a legacy system or other third 
party.
Example branching application pattern
In the following example, the WhichCoat  state machine deﬁned in the Amazon States Language (ASL) 
deﬁnition shows a branching application pattern with a Choice state ("Type": "Choice" ). If the 
condition of one of the three Choice states is met, the Lambda function is invoked as a Task:
1.The WearHeavyCoat  state invokes the wear_heavy_coat  Lambda function and returns a message.
2.The WearLightJacket  state invokes the wear_light_jacket  Lambda function and returns a 
message.
3.The None state invokes the no_jacket  Lambda function and returns a message.
The WhichCoat  state machine has the following structure:
1090AWS Lambda Developer Guide
Example branching application pattern
Example Example Amazon States Language deﬁnition
The following Amazon States Language deﬁnition of the WhichCoat  state machine uses a Variable
context object called Weather. If one of the three conditions in StringEquals  is met, the Lambda 
function deﬁned in the Resource  ﬁeld's Amazon Resource Name (ARN) is invoked.
{ 
        "Comment":"Coat Indicator State Machine",    
        "StartAt":"WhichCoat",    
        "States":{ 
            "WhichCoat":{ 
                "Type":"Choice",          
                "Choices":[ 
                { 
                     "Variable":"$.Weather",                
                    "StringEquals":"FREEZING",                  
                    "Next":"WearHeavyCoat"             
                },             
                { 
                     "Variable":"$.Weather",                
                    "StringEquals":"COOL",                  
                    "Next":"WearLightJacket"             
                },             
                { 
                     "Variable":"$.Weather",                
                    "StringEquals":"WARM",                  
                    "Next":"None"             
                } 
                ] 
            },       
            "WearHeavyCoat":{ 
                "Type":"Task",          
                 "Resource":"arn:aws:lambda:us-west-2:01234567890:function:wear_heavy_coat",
         
                "End":true       
            },       
1091AWS Lambda Developer Guide
Manage state machines
            "WearLightJacket":{ 
                "Type":"Task",          
                 "Resource":"arn:aws:lambda:us-
west-2:01234567890:function:wear_light_jacket",          
                "End":true       
            },       
            "None":{ 
                "Type":"Task",          
                 "Resource":"arn:aws:lambda:us-west-2:01234567890:function:no_coat",        
  
                "End":true       
            } 
        } 
    }
Example Example Python function
The following Lambda function in Python (wear_heavy_coat ) can be invoked for the state machine 
deﬁned in the previous example. If the WhichCoat  state machine equals a string value of FREEZING , 
the wear_heavy_coat  function is invoked from Lambda, and the user receives the message that 
corresponds with the function: "You should wear a heavy coat today."
from __future__ import print_function
import datetime 
         
def wear_heavy_coat(message, context): 
    print(message) 
         
    response = {} 
    response['Weather'] = message['Weather'] 
    response['Timestamp'] = datetime.datetime.now().strftime("%Y-%m-%d %H-%M-%S") 
    response['Message'] = 'You should wear a heavy coat today.'     
             
    return response 
     
Example Example invocation data
The following input data runs the WearHeavyCoat  state that invokes the wear_heavy_coat  Lambda 
function, when the Weather  variable is equal to a string value of FREEZING .
{ 
    "Weather":"FREEZING"
}
For more information, see Creating a Step Functions State Machine That Uses Lambda in the AWS Step 
Functions Developer Guide.
Managing state machines in the Lambda console
You can use the Lambda console to edit and view details about your Step Functions state machines and 
the Lambda functions that they use.
Sections
•Viewing state machine details  (p. 1093 )
1092AWS Lambda Developer Guide
Viewing state machine details
•Editing a state machine (p. 1093 )
•Running a state machine  (p. 1093 )
Viewing state machine details
The Lambda console displays a list of your state machines in the current AWS Region that contain at 
least one workﬂow step that invokes a Lambda function.
Choose a state machine to view a graphical representation of the workﬂow. Steps highlighted in blue 
represent Lambda functions. Use the graph controls to zoom in, zoom out, and center the graph.
Note
When a Lambda function is dynamically referenced with JsonPath in the state machine 
deﬁnition, the function details cannot be shown in the Lambda console. Instead, the function 
name is listed as a Dynamic reference, and the corresponding steps in the graph are grayed out.
To view state machine details
1. Open the Lambda console Step Functions state machines page.
2. Choose a state machine.
<result>
The Lambda console opens the Details  page.
</result>
For more information, see Step Functions in the AWS Step Functions Developer Guide.
Editing a state machine
When you want to edit a state machine, Lambda opens the Edit deﬁnition page of the Step Functions 
console.
To edit a state machine
1. Open the Lambda console Step Functions state machine page.
2. Choose a state machine.
3. Choose Edit.
The Step Functions console opens the Edit deﬁnition page.
4. Edit the state machine and choose Save.
For more information about editing state machines, see Step Functions state machine language in the
AWS Step Functions Developer Guide.
Running a state machine
When you want to run a state machine, Lambda opens the New execution page of the Step Functions 
console.
To run a state machine
1. Open the Lambda console Step Functions state machines page.
2. Choose a state machine.
1093AWS Lambda Developer Guide
Orchestration examples
3. Choose Execute.
The Step Functions console opens the New execution page.
4. (Optional) Edit the state machine and choose Start execution.
For more information about running state machines, see Step Functions state machine execution 
concepts in the AWS Step Functions Developer Guide.
Orchestration examples with Step Functions
All work in your Step Functions state machine is done by Tasks . A Task performs work by using an 
activity, a Lambda function, or by passing parameters to the API actions of other Supported AWS Service 
Integrations for Step Functions.
Sections
•Conﬁguring a Lambda function as a task (p. 1094 )
•Conﬁguring a state machine as an event source (p. 1094 )
•Handling function and service errors (p. 1095 )
•AWS CloudFormation and AWS SAM (p. 1096 )
Conﬁguring a Lambda function as a task
Step Functions can invoke Lambda functions directly from a Task  state in an Amazon States Language
deﬁnition.
... 
        "MyStateName":{ 
          "Type":"Task",          
          "Resource":"arn:aws:lambda:us-west-2:01234567890:function:my_lambda_function",    
       
          "End":true  
      ... 
       
You can create a Task state that invokes your Lambda function with the input to the state machine or 
any JSON document.
Example event.json – Input to random-error function (p. 1121 )
{ 
  "max-depth": 10, 
  "current-depth": 0, 
  "error-rate": 0.05
}
Conﬁguring a state machine as an event source
You can create a Step Functions state machine that invokes a Lambda function. The following example 
shows a Task state that invokes version 1 of a function named my-function  with an event payload 
that has three keys. When the function returns a successful response, the state machine continues to the 
next task.
1094AWS Lambda Developer Guide
Handling function and service errors
Example Example state machine
...
"Invoke": { 
  "Type": "Task", 
  "Resource": "arn:aws:states:::lambda:invoke", 
  "Parameters": { 
    "FunctionName": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1", 
    "Payload": { 
      "max-depth": 10, 
      "current-depth": 0, 
      "error-rate": 0.05 
    } 
  }, 
  "Next": "NEXT_STATE", 
  "TimeoutSeconds": 25
}
Permissions
Your state machine needs permission to call the Lambda API to invoke a function. To grant it 
permission, add the AWS managed policy AWSLambdaRole or a function-scoped inline policy 
to its role. For more information, see How AWS Step Functions Works with IAM in the AWS Step 
Functions Developer Guide.
The FunctionName  and Payload  parameters map to parameters in the Invoke (p. 1399 ) API operation. 
In addition to these, you can also specify the InvocationType  and ClientContext  parameters. For 
example, to invoke the function asynchronously and continue to the next state without waiting for a 
result, you can set InvocationType  to Event :
"InvocationType": "Event"
Instead of hard-coding the event payload in the state machine deﬁnition, you can use the input from the 
state machine execution. The following example uses the input speciﬁed when you run the state machine 
as the event payload:
"Payload.$": "$"
You can also invoke a function asynchronously and wait for it to make a callback with the AWS SDK. To 
do this, set the state's resource to arn:aws:states:::lambda:invoke.waitForTaskToken .
For more information, see Invoke Lambda with Step Functions in the AWS Step Functions Developer 
Guide .
Handling function and service errors
When your function or the Lambda service returns an error, you can retry the invocation or continue to a 
diﬀerent state based on the error type.
The following example shows an invoke task that retries on 5XX series Lambda API exceptions 
(ServiceException ), throttles (TooManyRequestsException ), runtime errors (Lambda.Unknown ), 
and a function-deﬁned error named function.MaxDepthError . It also catches an error named
function.DoublesRolledError  and continues to a state named CaughtException  when it occurs.
Example Example catch and retry pattern
...
"Invoke": { 
    "Type": "Task", 
    "Resource": "arn:aws:states:::lambda:invoke", 
1095AWS Lambda Developer Guide
AWS CloudFormation and AWS SAM
    "Retry": [ 
      { 
        "ErrorEquals": [  
            "function.MaxDepthError", 
            "Lambda.TooManyRequestsException", 
            "Lambda.ServiceException", 
            "Lambda.Unknown" 
          ], 
        "MaxAttempts": 5 
      } 
    ], 
    "Catch": [ 
      { 
        "ErrorEquals": [ "function.DoublesRolledError" ], 
        "Next": "CaughtException" 
      } 
    ],
    "Parameters": { 
      "FunctionName": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1", 
      ...
To catch or retry function errors, create a custom error type. The name of the error type must match the
errorType  in the formatted error response that Lambda returns when you throw an error.
For more information on error handling in Step Functions, see Handling Error Conditions Using a Step 
Functions State Machine in the AWS Step Functions Developer Guide.
AWS CloudFormation and AWS SAM
You can deﬁne state machines using a AWS CloudFormation template with AWS Serverless Application 
Model (AWS SAM). Using AWS SAM, you can deﬁne the state machine inline in the template or in a 
separate ﬁle. The following example shows a state machine that invokes a Lambda function that handles 
errors. It refers to a function resource deﬁned in the same template (not shown).
Example Example branching pattern in template.yml
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: An AWS Lambda application that uses AWS Step Functions.
Resources: 
  statemachine: 
    Type: AWS::Serverless::StateMachine 
    Properties: 
      DefinitionSubstitutions: 
        FunctionArn: !GetAtt function.Arn 
        Payload: | 
          { 
            "max-depth": 5, 
            "current-depth": 0, 
            "error-rate": 0.2 
          } 
      Definition: 
        StartAt: Invoke 
        States: 
          Invoke: 
            Type: Task 
            Resource: arn:aws:states:::lambda:invoke 
            Parameters: 
              FunctionName: "${FunctionArn}" 
              Payload: "${Payload}" 
              InvocationType: Event 
            Retry: 
            - ErrorEquals: 
1096AWS Lambda Developer Guide
AWS CloudFormation and AWS SAM
              - function.MaxDepthError 
              - function.MaxDepthError 
              - Lambda.TooManyRequestsException 
              - Lambda.ServiceException 
              - Lambda.Unknown 
              IntervalSeconds: 1 
              MaxAttempts: 5 
            Catch: 
            - ErrorEquals: 
              - function.DoublesRolledError 
              Next: CaughtException 
            - ErrorEquals: 
              - States.ALL 
              Next: UncaughtException 
            Next: Success 
          CaughtException: 
            Type: Pass 
            Result: The function returned an error. 
            End: true 
          UncaughtException: 
            Type: Pass 
            Result: Invocation failed. 
            End: true 
          Success: 
            Type: Pass 
            Result: Invocation succeeded! 
            End: true 
      Events: 
        scheduled: 
          Type: Schedule 
          Properties: 
            Description: Run every minute 
            Schedule: rate(1 minute) 
      Type: STANDARD 
      Policies: 
        - AWSLambdaRole 
      ...
This creates a state machine with the following structure:
For more information, see AWS::Serverless::StateMachine in the AWS Serverless Application Model 
Developer Guide .
1097AWS Lambda Developer Guide
Supported features and limitations
Improving startup performance with 
Lambda SnapStart
Lambda SnapStart for Java can improve startup performance for latency-sensitive applications by up to 
10x at no extra cost, typically with no changes to your function code. The largest contributor to startup 
latency (often referred to as cold start time) is the time that Lambda spends initializing the function, 
which includes loading the function's code, starting the runtime, and initializing the function code.
With SnapStart, Lambda initializes your function when you publish a function version. Lambda 
takes a Firecracker microVM snapshot of the memory and disk state of the initialized execution 
environment (p. 14), encrypts the snapshot, and caches it for low-latency access. When you invoke the 
function version for the ﬁrst time, and as the invocations scale up, Lambda resumes new execution 
environments from the cached snapshot instead of initializing them from scratch, improving startup 
latency.
Important
If your applications depend on uniqueness of state, you must evaluate your function code and 
verify that it is resilient to snapshot operations. For more information, see Handling uniqueness 
with Lambda SnapStart (p. 1105 ).
Supported features and limitations
SnapStart supports the Java 11 and Java 17 (java11  and java17 ) managed runtimes  (p. 41). Other 
managed runtimes (such as nodejs18.x  and python3.11 ), custom runtimes  (p. 60), and container 
images are not supported.
SnapStart does not support provisioned concurrency (p. 237), the arm64 architecture (p. 33), Amazon 
Elastic File System (Amazon EFS) (p. 738), or ephemeral storage greater than 512 MB.
To work with SnapStart, you can use the Lambda console, the AWS Command Line Interface (AWS CLI), 
the Lambda API, the AWS SDK for Java, AWS CloudFormation, AWS Serverless Application Model (AWS 
SAM), and AWS Cloud Development Kit (AWS CDK). For more information, see Activating and managing 
Lambda SnapStart (p. 1101 ).
Note
You can use SnapStart only on published function versions (p. 108) and aliases  (p. 104) that 
point to versions. You can't use SnapStart on a function's unpublished version ($LATEST).
Supported Regions
SnapStart is available in the following AWS Regions:
•US East (N. Virginia)
•US East (Ohio)
•US West (N. California)
•US West (Oregon)
•Africa (Cape Town)
•Asia Paciﬁc (Hong Kong)
1098AWS Lambda Developer Guide
Compatibility considerations
•Asia Paciﬁc (Jakarta)
•Asia Paciﬁc (Mumbai)
•Asia Paciﬁc (Osaka)
•Asia Paciﬁc (Seoul)
•Asia Paciﬁc (Singapore)
•Asia Paciﬁc (Sydney)
•Asia Paciﬁc (Tokyo)
•Canada (Central)
•Europe (Frankfurt)
•Europe (Ireland)
•Europe (London)
•Europe (Milan)
•Europe (Paris)
•Europe (Stockholm)
•Middle East (Bahrain)
•South America (São Paulo)
Compatibility considerations
With SnapStart, Lambda uses a single snapshot as the initial state for multiple execution environments. 
If your function uses any of the following during the initialization phase  (p. 15), then you might need to 
make some changes before using SnapStart:
Uniqueness
If your initialization code generates unique content that is included in the snapshot, then the 
content might not be unique when it is reused across execution environments. To maintain 
uniqueness when using SnapStart, you must generate unique content after initialization. This 
includes unique IDs, unique secrets, and entropy that's used to generate pseudorandomness. To 
learn how to restore uniqueness, see Handling uniqueness with Lambda SnapStart (p. 1105 ).
Network connections
The state of connections that your function establishes during the initialization phase isn't 
guaranteed when Lambda resumes your function from a snapshot. Validate the state of your 
network connections and re-establish them as necessary. In most cases, network connections 
that an AWS SDK establishes automatically resume. For other connections, review the best 
practices (p. 1112 ).
Temporary data
Some functions download or initialize ephemeral data, such as temporary credentials or cached 
timestamps, during the initialization phase. Refresh ephemeral data in the function handler before 
using it, even when not using SnapStart.
SnapStart pricing
There's no additional cost for SnapStart. You're charged based on the number of requests for your 
functions, the time that it takes your code to run, and the memory conﬁgured for your function. Duration 
is calculated from the time that your code begins running until it returns or otherwise ends, rounded up 
to the nearest 1 ms.
1099AWS Lambda Developer Guide
SnapStart and provisioned concurrency
Duration charges apply to code that runs in the function handler  (p. 440), initialization code that's 
declared outside of the handler, the time it takes for the runtime (JVM) to load, and any code that runs in 
a runtime hook  (p. 1107 ). For more information about how Lambda calculates duration, see Monitoring 
for Lambda SnapStart (p. 1109 ).
For functions conﬁgured with SnapStart, Lambda periodically recycles the execution environments and 
re-runs your initialization code. For resiliency, Lambda creates snapshots in multiple Availability Zones. 
Charges apply each time that Lambda re-runs your initialization code in another Availability Zone. For 
more information about how Lambda calculates charges, see AWS Lambda Pricing.
Comparing Lambda SnapStart and provisioned 
concurrency
Both Lambda SnapStart and provisioned concurrency (p. 237) can reduce cold starts and outlier latencies 
when a function scales up. SnapStart helps you improve startup performance by up to 10x at no 
extra cost. Provisioned concurrency keeps functions initialized and ready to respond in double-digit 
milliseconds. Conﬁguring provisioned concurrency incurs charges to your AWS account. Use provisioned 
concurrency if your application has strict cold start latency requirements. You can't use both SnapStart 
and provisioned concurrency on the same function version.
Note
SnapStart works best when used with function invocations at scale. Functions that are invoked 
infrequently might not experience the same performance improvements.
Additional resources
In addition to reading the other topics in this chapter, we also recommend that you try the Starting up 
faster with AWS Lambda SnapStart workshop and watch the Fast cold starts for your Java functions
session from AWS re:Invent 2022.
Topics
•Activating and managing Lambda SnapStart (p. 1101 )
•Handling uniqueness with Lambda SnapStart (p. 1105 )
•Runtime hooks for Lambda SnapStart (p. 1107 )
•Monitoring for Lambda SnapStart (p. 1109 )
•Security model for Lambda SnapStart (p. 1111 )
•Best practices for working with Lambda SnapStart (p. 1112 )
1100AWS Lambda Developer Guide
Activating SnapStart
Activating and managing Lambda SnapStart
To use SnapStart, activate SnapStart on a new or existing Lambda function. Then, publish and invoke a 
function version.
Topics
•Activating SnapStart (console) (p. 1101 )
•Activating SnapStart (AWS CLI) (p. 1101 )
•Activating SnapStart (API) (p. 1103 )
•Lambda SnapStart and function states (p. 1103 )
•Updating a snapshot  (p. 1104 )
•Using SnapStart with the AWS SDK for Java (p. 1104 )
•Using SnapStart with AWS CloudFormation, AWS SAM, and AWS CDK (p. 1104 )
•Deleting snapshots  (p. 1104 )
Activating SnapStart (console)
To activate SnapStart for a function
1. Open the Functions page of the Lambda console.
2. Choose the name of a function.
3. Choose Conﬁguration , and then choose General conﬁguration.
4. On the General conﬁguration pane, choose Edit.
5. On the Edit basic settings page, for SnapStart, choose Published versions.
6. Choose Save.
7. Publish a function version (p. 108). Lambda initializes your code, creates a snapshot of the initialized 
execution environment, and then caches the snapshot for low-latency access.
8. Invoke the function version (p. 109).
Activating SnapStart (AWS CLI)
To activate SnapStart for an existing function
1. Update the function conﬁguration by running the update-function-conﬁguration command with the
--snap-start option.
aws lambda update-function-configuration \ 
  --function-name my-function \ 
  --snap-start ApplyOn=PublishedVersions
2. Publish a function version with the publish-version command.
aws lambda publish-version \ 
  --function-name my-function
3. Conﬁrm that SnapStart is activated for the function version by running the get-function-
conﬁguration command and specifying the version number. The following example speciﬁes version 
1.
aws lambda get-function-configuration \ 
1101AWS Lambda Developer Guide
Activating SnapStart (AWS CLI)
  --function-name my-function: 1
If the response shows that OptimizationStatus  (p. 1601 ) is On and State  (p. 1373 ) is Active , then 
SnapStart is activated and a snapshot is available for the speciﬁed function version.
"SnapStart": {  
    "ApplyOn": "PublishedVersions", 
     "OptimizationStatus": "On"
 },
 "State": "Active" ,
4. Invoke the function version by running the invoke command and specifying the version. The 
following example invokes version 1.
aws lambda invoke \ 
  --cli-binary-format raw-in-base64-out \ 
  --function-name my-function: 1 \ 
  --payload '{ "name": "Bob" }' \ 
  response.json
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
To activate SnapStart when you create a new function
1. Create a function by running the create-function command with the --snap-start option. For --role, 
specify the Amazon Resource Name (ARN) of your execution role (p. 913).
aws lambda create-function \ 
  --function-name my-function \ 
  --runtime "java17" \ 
  --zip-file fileb://my-function.zip \ 
  --handler my-function.handler \ 
  --role arn:aws:iam::111122223333:role/lambda-ex  \ 
  --snap-start ApplyOn=PublishedVersions
2. Create a version with the publish-version command.
aws lambda publish-version \ 
  --function-name my-function
3. Conﬁrm that SnapStart is activated for the function version by running the get-function-
conﬁguration command and specifying the version number. The following example speciﬁes version 
1.
aws lambda get-function-configuration \ 
  --function-name my-function: 1
If the response shows that OptimizationStatus  (p. 1601 ) is On and State  (p. 1373 ) is Active , then 
SnapStart is activated and a snapshot is available for the speciﬁed function version.
"SnapStart": {  
     "ApplyOn": "PublishedVersions", 
      "OptimizationStatus": "On"
  }, 
   "State": "Active" ,
1102AWS Lambda Developer Guide
Activating SnapStart (API)
4. Invoke the function version by running the invoke command and specifying the version. The 
following example invokes version 1.
aws lambda invoke \ 
  --cli-binary-format raw-in-base64-out \ 
  --function-name my-function: 1 \ 
  --payload '{ "name": "Bob" }' \ 
  response.json
The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default 
setting, run aws configure set cli-binary-format raw-in-base64-out . For more 
information, see AWS CLI supported global command line options.
Activating SnapStart (API)
To activate SnapStart
1. Do one of the following:
• Create a new function with SnapStart activated by using the CreateFunction (p. 1304 ) API 
action with the SnapStart (p. 1600 ) parameter.
• Activate SnapStart for an existing function by using the UpdateFunctionConﬁguration (p. 1516 )
action with the SnapStart (p. 1600 ) parameter.
2. Publish a function version with the PublishVersion (p. 1454 ) action. Lambda initializes your code, 
creates a snapshot of the initialized execution environment, and then caches the snapshot for low-
latency access.
3. Conﬁrm that SnapStart is activated for the function version by using the
GetFunctionConﬁguration (p. 1368 ) action. Specify a version number to conﬁrm that SnapStart 
is activated for that version. If the response shows that OptimizationStatus  (p. 1601 ) is On and
State  (p. 1373 ) is Active, then SnapStart is activated and a snapshot is available for the speciﬁed 
function version.
"SnapStart": {  
        "ApplyOn": "PublishedVersions", 
         "OptimizationStatus": "On"
     }, 
      "State": "Active" ,
4. Invoke the function version with the Invoke (p. 1399 ) action.
Lambda SnapStart and function states
The following function states can occur when you use SnapStart. They can also occur when Lambda 
periodically recycles the execution environment and re-runs the initialization code for a function that's 
conﬁgured with SnapStart.
•Pending – Lambda is initializing your code and taking a snapshot of the initialized execution 
environment. Any invocations or other API actions that operate on the function version will fail.
•Active – Snapshot creation is complete and you can invoke the function. To use SnapStart, you must 
invoke the published function version, not the unpublished version ($LATEST).
•Inactive  – The function version hasn't been invoked for 14 days. When the function version becomes
Inactive , Lambda deletes the snapshot. If you invoke the function version after 14 days, Lambda 
returns a SnapStartNotReadyException  response and begins initializing a new snapshot. Wait 
until the function version reaches the Active state, and then invoke it again.
1103AWS Lambda Developer Guide
Updating a snapshot
•Failed – Lambda encountered an error when running the initialization code or creating the snapshot.
Updating a snapshot
Lambda creates a snapshot for each published function version. To update a snapshot, publish a new 
function version. Lambda automatically updates your snapshots with the latest runtime and security 
patches.
Using SnapStart with the AWS SDK for Java
To make AWS SDK calls from your function, Lambda generates an ephemeral set of credentials by 
assuming your function's execution role. These credentials are available as environment variables 
during your function's invocation. You don't need to provide credentials for the SDK directly in 
code. By default, the credential provider chain sequentially checks each place where you can set 
credentials and chooses the ﬁrst available—usually the environment variables (AWS_ACCESS_KEY_ID ,
AWS_SECRET_ACCESS_KEY , and AWS_SESSION_TOKEN ).
Note
When SnapStart is activated, the Java runtime automatically uses the container credentials 
(AWS_CONTAINER_CREDENTIALS_FULL_URI  and AWS_CONTAINER_AUTHORIZATION_TOKEN ) 
instead of the access key environment variables. This prevents credentials from expiring before 
the function is restored.
Using SnapStart with AWS CloudFormation, AWS 
SAM, and AWS CDK
•AWS CloudFormation: Declare the SnapStart entity in your template.
•AWS Serverless Application Model (AWS SAM): Declare the SnapStart property in your template.
•AWS Cloud Development Kit (AWS CDK): Use the SnapStartProperty type.
Deleting snapshots
Lambda deletes snapshots when:
•You delete the function or function version.
•You don't invoke the function version for 14 days. After 14 days without an invocation, the function 
version transitions to the Inactive (p. 1103 ) state. If you invoke the function version after 14 days, 
Lambda returns a SnapStartNotReadyException  response and begins initializing a new snapshot. 
Wait until the function version reaches the Active (p. 1103 ) state, and then invoke it again.
Lambda removes all resources associated with deleted snapshots in compliance with the General Data 
Protection Regulation (GDPR).
1104AWS Lambda Developer Guide
Handling uniqueness
Handling uniqueness with Lambda SnapStart
When invocations scale up on a SnapStart function, Lambda uses a single initialized snapshot to resume 
multiple execution environments. If your initialization code generates unique content that is included in 
the snapshot, then the content might not be unique when it is reused across execution environments. To 
maintain uniqueness when using SnapStart, you must generate unique content after initialization. This 
includes unique IDs, unique secrets, and entropy that's used to generate pseudorandomness.
We recommend the following best practices to help you maintain uniqueness in your code. Lambda 
also provides an open-source SnapStart scanning tool (p. 1106 ) to help check for code that assumes 
uniqueness. If you generate unique data during the initialization phase, then you can use a runtime 
hook  (p. 1107 ) to restore uniqueness. With runtime hooks, you can run speciﬁc code immediately before 
Lambda takes a snapshot or immediately after Lambda resumes a function from a snapshot.
Avoid saving state that depends on uniqueness 
during initialization
During the initialization phase  (p. 15) of your function, avoid caching data that's intended to be unique, 
such as generating a unique ID for logging. Instead, we recommend that you generate unique data inside 
your function handler or use a runtime hook  (p. 1107 ).
Example – Generating a unique ID in function handler
The following example demonstrates how to generate a UUID in the function handler.
import java.util.UUID; 
  public class Handler implements RequestHandler<String, String> { 
    private static UUID uniqueSandboxId = null; 
    @Override 
    public String handleRequest(String event, Context context) { 
       if (uniqueSandboxId == null) 
        uniqueSandboxId = UUID.randomUUID();
      System.out.println("Unique Sandbox Id: " + uniqueSandboxId); 
      return "Hello, World!"; 
    } 
  }
Use cryptographically secure pseudorandom number 
generators (CSPRNGs)
If your application depends on randomness, we recommend that you use cryptographically secure 
random number generators (CSPRNGs). The Lambda managed runtime for Java includes two built-
in CSPRNGs (OpenSSL 1.0.2 and java.security.SecureRandom ) that automatically maintain 
randomness with SnapStart. Software that always gets random numbers from /dev/random  or /dev/
urandom also maintains randomness with SnapStart.
Example – java.security.SecureRandom
The following example uses java.security.SecureRandom , which generates unique number 
sequences even when the function is restored from a snapshot.
import java.security.SecureRandom; 
  public class Handler implements RequestHandler<String, String> { 
     private static SecureRandom rng = new SecureRandom();
1105AWS Lambda Developer Guide
Scanning tool
    @Override 
    public String handleRequest(String event, Context context) { 
      for (int i = 0; i < 10; i++) { 
        System.out.println(rng.next()); 
      } 
      return "Hello, World!"; 
    } 
  }
SnapStart scanning tool
Lambda provides a scanning tool to help you check for code that assumes uniqueness. The SnapStart 
scanning tool is an open-source SpotBugs  plugin that runs a static analysis against a set of rules. The 
scanning tool helps identify potential code implementations that might break assumptions regarding 
uniqueness. For installation instructions and a list of checks that the scanning tool performs, see the
aws-lambda-snapstart-java-rules repository on GitHub.
To learn more about handling uniqueness with SnapStart, see Starting up faster with AWS Lambda 
SnapStart on the AWS Compute Blog.
1106AWS Lambda Developer Guide
Runtime hooks
Runtime hooks for Lambda SnapStart
You can use runtime hooks to implement code before Lambda creates a snapshot or after Lambda 
resumes a function from a snapshot. Runtime hooks are available as part of the open-source 
Coordinated Restore at Checkpoint (CRaC) project. CRaC is in development for the Open Java 
Development Kit (OpenJDK). For an example of how to use CRaC with a reference application, see the
CRaC  repository on GitHub. CRaC uses three main elements:
•Resource  – An interface with two methods, beforeCheckpoint()  and afterRestore() . Use 
these methods to implement the code that you want to run before a snapshot and after a restore.
•Context <R extends Resource>  – To receive notiﬁcations for checkpoints and restores, a
Resource  must be registered with a Context .
•Core – The coordination service, which provides the default global Context  via the static method
Core.getGlobalContext() .
For more information about Context  and Resource , see Package org.crac in the CRaC documentation.
Use the following steps to implement runtime hooks with the org.crac package. The Lambda runtime 
contains a customized CRaC context implementation that calls your runtime hooks before checkpointing 
and after restoring.
Step 1: Update the build conﬁguration
Add the org.crac  dependency to the build conﬁguration. The following example uses Gradle. For 
examples for other build systems, see the Apache Maven documentation.
dependencies { 
    compile group: 'com.amazonaws', name: 'aws-lambda-java-core', version: '1.2.1' 
    # All other project dependecies go here: 
    # ... 
    # Then, add the org.crac dependency: 
 implementation group: 'io.github.crac', name: 'org-crac', version: '0.1.3'
}
Step 2: Update the Lambda handler
The Lambda function handler  is the method in your function code that processes events. When your 
function is invoked, Lambda runs the handler method. Your function runs until the handler returns a 
response, exits, or times out.
For more information, see AWS Lambda function handler in Java (p. 440).
The following example handler shows how to run code before checkpointing (beforeCheckpoint() ) 
and after restoring (afterRestore() ). This handler also registers the Resource  to the runtime-
managed global Context .
Note
When Lambda creates a snapshot, your initialization code can run for up to 15 minutes. 
The time limit is 130 seconds or the conﬁgured function timeout (p. 74) (maximum 900 
seconds), whichever is higher. Your beforeCheckpoint()  runtime hooks count towards the 
initialization code time limit. When Lambda restores a snapshot, the runtime (JVM) must load 
and afterRestore()  runtime hooks must complete within the timeout limit (10 seconds). 
Otherwise, you'll get a SnapStartTimeoutException.
... 
1107AWS Lambda Developer Guide
Step 2: Update the Lambda handler
  import org.crac.Resource; 
  import org.crac.Core; 
  ...  
public class CRaCDemo implements RequestStreamHandler, Resource { 
    public CRaCDemo() { 
      Core.getGlobalContext().register(this); 
    } 
    public String handleRequest(String name, Context context) throws IOException { 
      System.out.println("Handler execution"); 
      return "Hello " + name; 
    } 
    @Override 
    public void beforeCheckpoint (org.crac.Context<? extends Resource> context) 
        throws Exception { 
      System.out.println("Before checkpoint"); 
    } 
    @Override 
    public void afterRestore (org.crac.Context<? extends Resource> context) 
        throws Exception { 
      System.out.println("After restore");
Context  maintains only a WeakReference  to the registered object. If a Resource  is garbage collected, 
runtime hooks do not run. Your code must maintain a strong reference to the Resource  to guarantee 
that the runtime hook runs.
Here are two examples of patterns to avoid:
Example – Object without a strong reference
Core.getGlobalContext().register( new MyResource() );
Example – Objects of anonymous classes
Core.getGlobalContext().register( new Resource() { 
    
   @Override 
   public void afterRestore(Context<? extends Resource> context) throws Exception { 
    // ... 
   } 
    
   @Override 
   public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { 
    // ... 
   }
} );
Instead, maintain a strong reference. In the following example, the registered resource isn't garbage 
collected and runtime hooks run consistently.
Example – Object with a strong reference
Resource myResource = new MyResource(); // This reference must be maintained to prevent the 
 registered resource from being garbage collected
Core.getGlobalContext().register( myResource );
1108AWS Lambda Developer Guide
Monitoring
Monitoring for Lambda SnapStart
You can monitor your Lambda SnapStart functions using Amazon CloudWatch, AWS X-Ray, and the
Lambda Telemetry API (p. 1017 ).
Note
The AWS_LAMBDA_LOG_GROUP_NAME  and AWS_LAMBDA_LOG_STREAM_NAME  environment 
variables  (p. 80) are not available in Lambda SnapStart functions.
CloudWatch for SnapStart
There are a few diﬀerences with the CloudWatch log stream (p. 969) format for SnapStart functions:
•Initialization logs – When a new execution environment is created, the REPORT  doesn't include the
Init Duration  ﬁeld. That's because Lambda initializes SnapStart functions when you create a 
version instead of during function invocation. For SnapStart functions, the Init Duration  ﬁeld is in 
the INIT_REPORT  record. This record shows duration details for the Init phase  (p. 15), including the 
duration of any beforeCheckpoint  runtime hooks  (p. 1107 ).
•Invocation logs – When a new execution environment is created, the REPORT  includes the Restore 
Duration  and Billed Restore Duration  ﬁelds:
•Restore Duration : The time it takes for Lambda to restore a snapshot, load the runtime (JVM), 
and run any afterRestore  runtime hooks. The process of restoring snapshots can include time 
spent on activities outside the MicroVM. This time is not reported in Restore Duration .
•Billed Restore Duration : The time it takes for Lambda to load the runtime (JVM) and run any
afterRestore  hooks. You are not charged for the time it takes to restore a snapshot.
Note
Duration charges apply to code that runs in the function handler  (p. 440), initialization 
code that's declared outside of the handler, the time it takes for the runtime (JVM) to load, 
and any code that runs in a runtime hook  (p. 1107 ). For more information, see SnapStart 
pricing  (p. 1099 ).
The cold start duration is the sum of Restore Duration  + Duration .
The following example is a Lambda Insights query that returns the latency percentiles for SnapStart 
functions. For more information about Lambda Insights queries, see Example workﬂow using queries to 
troubleshoot a function (p. 981).
filter @type = "REPORT" 
  | parse @log /\d+:\/aws\/lambda\/(?<function>.*)/ 
  | parse @message /Restore Duration: (?<restoreDuration>.*?) ms/ 
  | stats
count(*) as invocations,
pct(@duration+coalesce(@initDuration,0)+coalesce(restoreDuration,0), 50) as p50,
pct(@duration+coalesce(@initDuration,0)+coalesce(restoreDuration,0), 90) as p90,
pct(@duration+coalesce(@initDuration,0)+coalesce(restoreDuration,0), 99) as p99,
pct(@duration+coalesce(@initDuration,0)+coalesce(restoreDuration,0), 99.9) as p99.9
group by function, (ispresent(@initDuration) or ispresent(restoreDuration)) as coldstart 
  | sort by coldstart desc
X-Ray active tracing for SnapStart
You can use X-Ray (p. 973) to trace requests to Lambda SnapStart functions. There are a few diﬀerences 
with the X-Ray subsegments for SnapStart functions:
1109AWS Lambda Developer Guide
Telemetry API
•There is no Initialization  subsegment for SnapStart functions.
•The Restore subsegment shows the time it takes for Lambda to restore a snapshot, load the runtime 
(JVM), and run any afterRestore  runtime hooks  (p. 1107 ). The process of restoring snapshots 
can include time spent on activities outside the MicroVM. This time is not reported in the Restore
subsegment, but is included in the AWS::Lambda  segment in X-Ray traces.
Telemetry API events for SnapStart
Lambda sends the following SnapStart events to the Telemetry API (p. 1017 ):
•platform.restoreStart  (p. 1033 ) – Shows the time when the Restore  phase  (p. 15) started.
•platform.restoreRuntimeDone  (p. 1034 ) – Shows whether the Restore phase was successful. 
Lambda sends this message when the runtime sends a restore/next  runtime API request. There are 
three possible statuses: success, failure, and timeout.
•platform.restoreReport  (p. 1035 ) – Shows how long the Restore phase lasted and how many 
milliseconds you were billed for during this phase.
Amazon API Gateway and function URL metrics
If you create a web API using API Gateway (p. 634), then you can use the IntegrationLatency metric to 
measure end-to-end latency (the time between when API Gateway relays a request to the backend and 
when it receives a response from the backend).
If you're using a Lambda function URL (p. 189), then you can use the UrlRequestLatency (p. 207) metric 
to measure end-to-end latency (the time between when the function URL receives a request and when 
the function URL returns a response).
1110AWS Lambda Developer Guide
Security model
Security model for Lambda SnapStart
Lambda SnapStart supports encryption at rest. Lambda encrypts snapshots with an AWS KMS key. By 
default, Lambda uses an AWS managed key. If this default behavior suits your workﬂow, then you don't 
need to set up anything else. Otherwise, you can use the --kms-key-arn  option in the create-function
or update-function-conﬁguration command to provide an AWS KMS customer managed key. You 
might do this to control rotation of the KMS key or to meet the requirements of your organization for 
managing KMS keys. Customer managed keys incur standard AWS KMS charges. For more information, 
see AWS Key Management Service pricing.
When you delete a SnapStart function or function version, all Invoke requests to that function or 
function version fail. Lambda automatically deletes snapshots that are not invoked for 14 days. Lambda 
removes all resources associated with deleted snapshots in compliance with the General Data Protection 
Regulation (GDPR).
1111AWS Lambda Developer Guide
Best practices
Best practices for working with Lambda SnapStart
Topics
•Network connections (p. 1112 )
•Performance tuning (p. 1112 )
Network connections
The state of connections that your function establishes during the initialization phase isn't guaranteed 
when Lambda resumes your function from a snapshot. In most cases, network connections that an 
AWS SDK establishes automatically resume. For other connections, we recommend the following best 
practices.
Re-establish network connections
Always re-establish your network connections when your function resumes from a snapshot. We 
recommend that you re-establish network connections in the function handler. Alternatively, you can use 
an afterRestore  runtime hook  (p. 1107 ).
Don't use hostname as a unique execution environment identiﬁer
We recommend against using hostname  to identify your execution environment as a unique node 
or container in your applications. With SnapStart, a single snapshot is used as the initial state for 
multiple execution environments, and all execution environments return the same hostname  value 
for InetAddress.getLocalHost() . For applications that require a unique execution environment 
identity or hostname  value, we recommend that you generate a unique ID in the function handler. Or, 
use an afterRestore  runtime hook  (p. 1107 ) to generate a unique ID, and then use the unique ID as 
the identiﬁer for the execution environment.
Avoid binding connections to ﬁxed source ports
We recommend that you avoid binding network connections to ﬁxed source ports. Connections are re-
established when a function resumes from a snapshot, and network connections that are bound to a 
ﬁxed source port might fail.
Avoid using Java DNS cache
Lambda functions already cache DNS responses. If you use another DNS cache with SnapStart, then you 
might experience connection timeouts when the function resumes from a snapshot.
Performance tuning
Note
SnapStart works best when used with function invocations at scale. Functions that are invoked 
infrequently might not experience the same performance improvements.
To maximize the beneﬁts of SnapStart, we recommend that you preload classes that contribute to 
startup latency in your initialization code instead of in the function handler. This moves the latency 
associated with heavy class loading out of the invocation path, optimizing startup performance with 
SnapStart.
If you can't preload classes during initialization, then we recommend that you preload classes with 
dummy invocations. To do this, update the function handler code, as shown in the following example 
from the pet store function on the AWS Labs GitHub repository.
private static SpringLambdaContainerHandler<AwsProxyRequest, AwsProxyResponse> handler; 
1112AWS Lambda Developer Guide
Performance tuning
  static { 
      try { 
          handler = 
 SpringLambdaContainerHandler.getAwsProxyHandler(PetStoreSpringAppConfig.class); 
          // Use the onStartup method of the handler to register the custom filter 
          handler.onStartup(servletContext -> { 
              FilterRegistration.Dynamic registration = 
 servletContext.addFilter("CognitoIdentityFilter", CognitoIdentityFilter.class); 
              registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), 
 false, "/*"); 
          }); 
          // Send a fake Amazon API Gateway request to the handler to load classes ahead of 
 time 
          ApiGatewayRequestIdentity identity = new ApiGatewayRequestIdentity(); 
          identity.setApiKey("foo"); 
          identity.setAccountId("foo"); 
          identity.setAccessKey("foo"); 
          AwsProxyRequestContext reqCtx = new AwsProxyRequestContext(); 
          reqCtx.setPath("/pets"); 
          reqCtx.setStage("default"); 
          reqCtx.setAuthorizer(null); 
          reqCtx.setIdentity(identity); 
          AwsProxyRequest req = new AwsProxyRequest(); 
          req.setHttpMethod("GET"); 
          req.setPath("/pets"); 
          req.setBody(""); 
          req.setRequestContext(reqCtx); 
          Context ctx = new TestContext(); 
          handler.proxy(req, ctx); 
      } catch (ContainerInitializationException e) { 
          // if we fail here. We re-throw the exception to force another cold start 
          e.printStackTrace(); 
          throw new RuntimeException("Could not initialize Spring framework", e); 
      } 
  }
1113AWS Lambda Developer Guide
Lambda sample applications
The GitHub repository for this guide includes sample applications that demonstrate the use of various 
languages and AWS services. Each sample application includes scripts for easy deployment and cleanup, 
an AWS SAM template, and supporting resources.
Node.js
Sample Lambda applications in Node.js
•blank-nodejs – A Node.js function that shows the use of logging, environment variables, AWS X-
Ray tracing, layers, unit tests and the AWS SDK.
•nodejs-apig  – A function with a public API endpoint that processes an event from API Gateway and 
returns an HTTP response.
•rds-mysql – A function that relays queries to a MySQL for RDS Database. This sample includes a 
private VPC and database instance conﬁgured with a password in AWS Secrets Manager.
•efs-nodejs  – A function that uses an Amazon EFS ﬁle system in a Amazon VPC. This sample 
includes a VPC, ﬁle system, mount targets, and access point conﬁgured for use with Lambda.
•list-manager – A function processes events from an Amazon Kinesis data stream and update 
aggregate lists in Amazon DynamoDB. The function stores a record of each event in a MySQL 
for RDS Database in a private VPC. This sample includes a private VPC with a VPC endpoint for 
DynamoDB and a database instance.
•error-processor – A Node.js function generates errors for a speciﬁed percentage of requests. A 
CloudWatch Logs subscription invokes a second function when an error is recorded. The processor 
function uses the AWS SDK to gather details about the request and stores them in an Amazon S3 
bucket.
Python
Sample Lambda applications in Python
•blank-python – A Python function that shows the use of logging, environment variables, AWS X-
Ray tracing, layers, unit tests and the AWS SDK.
Ruby
Sample Lambda applications in Ruby
•blank-ruby – A Ruby function that shows the use of logging, environment variables, AWS X-Ray 
tracing, layers, unit tests and the AWS SDK.
•Ruby Code Samples for AWS Lambda – Code samples written in Ruby that demonstrate how to 
interact with AWS Lambda.
Java
Sample Lambda applications in Java
•java17-examples – A Java function that demonstrates how to use a Java record to represent an 
input event data object.
•java-basic – A collection of minimal Java functions with unit tests and variable logging 
conﬁguration.
1114AWS Lambda Developer Guide
•java-events – A collection of Java functions that contain skeleton code for how to handle events 
from various services such as Amazon API Gateway, Amazon SQS, and Amazon Kinesis. These 
functions use the latest version of the aws-lambda-java-events (p. 446) library (3.0.0 and newer). 
These examples do not require the AWS SDK as a dependency.
•s3-java – A Java function that processes notiﬁcation events from Amazon S3 and uses the Java 
Class Library (JCL) to create thumbnails from uploaded image ﬁles.
•Use API Gateway to invoke a Lambda function – A Java function that scans a Amazon DynamoDB 
table that contains employee information. It then uses Amazon Simple Notiﬁcation Service to 
send a text message to employees celebrating their work anniversaries. This example uses API 
Gateway to invoke the function.
Sample Spring applications in Lambda
•spring-cloud-function-samples – An example that shows how to use the Spring Cloud Function
framework to create AWS Lambda functions.
Go
Lambda provides the following sample applications for the Go runtime:
Sample Lambda applications in Go
•go-al2  – A hello world function that returns the public IP address. This app uses the
provided.al2  custom runtime.
•blank-go – A Go function that shows the use of Lambda's Go libraries, logging, environment 
variables, and the AWS SDK. This app uses the go1.x  runtime.
C#
Sample Lambda applications in C#
•blank-csharp – A C# function that shows the use of Lambda's .NET libraries, logging, environment 
variables, AWS X-Ray tracing, unit tests, and the AWS SDK.
•ec2-spot  – A function that manages spot instance requests in Amazon EC2.
PowerShell
Lambda provides the following sample applications for PowerShell:
•blank-powershell – A PowerShell function that shows the use of logging, environment variables, 
and the AWS SDK.
To deploy a sample application, follow the instructions in its README ﬁle. To learn more about the 
architecture and use cases of an application, read the topics in this chapter.
Topics
•Blank function sample application for AWS Lambda (p. 1116 )
•Error processor sample application for AWS Lambda (p. 1121 )
•List manager sample application for AWS Lambda (p. 1124 )
1115AWS Lambda Developer Guide
Blank function
Blank function sample application for AWS 
Lambda
The blank function sample application is a starter application that demonstrates common operations in 
Lambda with a function that calls the Lambda API. It shows the use of logging, environment variables, 
AWS X-Ray tracing, layers, unit tests and the AWS SDK. Explore this application to learn about building 
Lambda functions in your programming language, or use it as a starting point for your own projects.
Variants of this sample application are available for the following languages:
Variants
•Node.js – blank-nodejs.
•Python – blank-python.
•Ruby – blank-ruby.
•Java – blank-java.
•Go – blank-go.
•C# – blank-csharp.
•PowerShell – blank-powershell.
The examples in this topic highlight code from the Node.js version, but the details are generally 
applicable to all variants.
You can deploy the sample in a few minutes with the AWS CLI and AWS CloudFormation. Follow the 
instructions in the README  to download, conﬁgure, and deploy it in your account.
Sections
•Architecture and handler code (p. 1116 )
•Deployment automation with AWS CloudFormation and the AWS CLI (p. 1117 )
•Instrumentation with the AWS X-Ray (p. 1119 )
•Dependency management with layers (p. 1119 )
Architecture and handler code
The sample application consists of function code, an AWS CloudFormation template, and supporting 
resources. When you deploy the sample, you use the following AWS services:
•AWS Lambda – Runs function code, sends logs to CloudWatch Logs, and sends trace data to X-Ray. The 
function also calls the Lambda API to get details about the account's quotas and usage in the current 
Region.
•AWS X-Ray – Collects trace data, indexes traces for search, and generates a service map.
•Amazon CloudWatch – Stores logs and metrics.
•AWS Identity and Access Management (IAM) – Grants permission.
•Amazon Simple Storage Service (Amazon S3) – Stores the function's deployment package during 
deployment.
•AWS CloudFormation – Creates application resources and deploys function code.
Standard charges apply for each service. For more information, see AWS Pricing.
1116AWS Lambda Developer Guide
Deployment automation with AWS 
CloudFormation and the AWS CLI
The function code shows a basic workﬂow for processing an event. The handler takes an Amazon Simple 
Queue Service (Amazon SQS) event as input and iterates through the records that it contains, logging 
the contents of each message. It logs the contents of the event, the context object, and environment 
variables. Then it makes a call with the AWS SDK and passes the response back to the Lambda runtime.
Example blank-nodejs/function/index.js – Handler code
// Handler
exports.handler = async function(event, context) { 
  event.Records.forEach(record => { 
    console.log(record.body) 
  }) 
  console.log('## ENVIRONMENT VARIABLES: ' + serialize(process.env)) 
  console.log('## CONTEXT: ' + serialize(context)) 
  console.log('## EVENT: ' + serialize(event)) 
   
  return getAccountSettings()
}
// Use SDK client
var getAccountSettings = function(){ 
  return lambda.getAccountSettings().promise()
}
var serialize = function(object) { 
  return JSON.stringify(object, null, 2)
}
The input/output types for the handler and support for asynchronous programming vary per runtime. In 
this example, the handler method is async, so in Node.js this means that it must return a promise back 
to the runtime. The Lambda runtime waits for the promise to be resolved and returns the response to 
the invoker. If the function code or AWS SDK client return an error, the runtime formats the error into a 
JSON document and returns that.
The sample application doesn't include an Amazon SQS queue to send events, but uses an event from 
Amazon SQS (event.json) to illustrate how events are processed. To add an Amazon SQS queue to your 
application, see Using Lambda with Amazon SQS (p. 875).
Deployment automation with AWS CloudFormation 
and the AWS CLI
The sample application's resources are deﬁned in an AWS CloudFormation template and deployed with 
the AWS CLI. The project includes simple shell scripts that automate the process of setting up, deploying, 
invoking, and tearing down the application.
The application template uses an AWS Serverless Application Model (AWS SAM) resource type to deﬁne 
the model. AWS SAM simpliﬁes template authoring for serverless applications by automating the 
deﬁnition of execution roles, APIs, and other resources.
The template deﬁnes the resources in the application stack . This includes the function, its execution role, 
and a Lambda layer that provides the function's library dependencies. The stack does not include the 
bucket that the AWS CLI uses during deployment or the CloudWatch Logs log group.
Example blank-nodejs/template.yml – Serverless resources
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: An AWS Lambda application that calls the Lambda API.
Resources: 
1117AWS Lambda Developer Guide
Deployment automation with AWS 
CloudFormation and the AWS CLI
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler 
      Runtime: nodejs16.x 
      CodeUri: function/. 
      Description: Call the AWS Lambda API 
      Timeout: 10 
      # Function's execution role 
      Policies: 
        - AWSLambdaBasicExecutionRole 
        - AWSLambda_ReadOnlyAccess 
        - AWSXrayWriteOnlyAccess 
      Tracing: Active 
      Layers: 
        - !Ref libs 
  libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-nodejs-lib 
      Description: Dependencies for the blank sample app. 
      ContentUri: lib/. 
      CompatibleRuntimes: 
        - nodejs16.x
When you deploy the application, AWS CloudFormation applies the AWS SAM transform to the template 
to generate an AWS CloudFormation template with standard types such as AWS::Lambda::Function
and AWS::IAM::Role .
Example processed template
{ 
  "AWSTemplateFormatVersion": "2010-09-09", 
  "Description": "An AWS Lambda application that calls the Lambda API.", 
  "Resources": { 
    "function": { 
      "Type": " AWS::Lambda::Function ", 
      "Properties": { 
        "Layers": [ 
          { 
            "Ref": "libs32xmpl61b2" 
          } 
        ], 
        "TracingConfig": { 
          "Mode": "Active" 
        }, 
        "Code": { 
          "S3Bucket": "lambda-artifacts-6b000xmpl1e9bf2a", 
          "S3Key": "3d3axmpl473d249d039d2d7a37512db3" 
        }, 
        "Description": "Call the AWS Lambda API", 
        "Tags": [ 
          { 
            "Value": "SAM", 
            "Key": "lambda:createdBy" 
          } 
        ],
In this example, the Code property speciﬁes an object in an Amazon S3 bucket. This corresponds to the 
local path in the CodeUri property in the project template:
      CodeUri: function/.
1118AWS Lambda Developer Guide
Instrumentation with the AWS X-Ray
To upload the project ﬁles to Amazon S3, the deployment script uses commands in the AWS CLI. The
cloudformation package  command preprocesses the template, uploads artifacts, and replaces 
local paths with Amazon S3 object locations. The cloudformation deploy  command deploys the 
processed template with a AWS CloudFormation change set.
Example blank-nodejs/3-deploy.sh – Package and deploy
#!/bin/bash
set -eo pipefail
ARTIFACT_BUCKET=$(cat bucket-name.txt)
aws cloudformation package  --template-file template.yml --s3-bucket $ARTIFACT_BUCKET --
output-template-file out.yml
aws cloudformation deploy  --template-file out.yml --stack-name blank-nodejs --capabilities 
 CAPABILITY_NAMED_IAM
The ﬁrst time you run this script, it creates a AWS CloudFormation stack named blank-nodejs . If you 
make changes to the function code or template, you can run it again to update the stack.
The cleanup script ( blank-nodejs/5-cleanup.sh) deletes the stack and optionally deletes the deployment 
bucket and function logs.
Instrumentation with the AWS X-Ray
The sample function is conﬁgured for tracing with AWS X-Ray. With the tracing mode set to active, 
Lambda records timing information for a subset of invocations and sends it to X-Ray. X-Ray processes the 
data to generate a service map that shows a client node and two service nodes.
The ﬁrst service node (AWS::Lambda ) represents the Lambda service, which validates the invocation 
request and sends it to the function. The second node, AWS::Lambda::Function , represents the 
function itself.
To record additional detail, the sample function uses the X-Ray SDK. With minimal changes to the 
function code, the X-Ray SDK records details about calls made with the AWS SDK to AWS services.
Example blank-nodejs/function/index.js – Instrumentation
const AWSXRay = require('aws-xray-sdk-core')
const AWS = AWSXRay.captureAWS( require('aws-sdk') )
// Create client outside of handler to reuse
const lambda = new AWS.Lambda()
Instrumenting the AWS SDK client adds an additional node to the service map and more detail in traces. 
In this example, the service map shows the sample function calling the Lambda API to get details about 
storage and concurrency usage in the current Region.
The trace shows timing details for the invocation, with subsegments for function initialization, 
invocation, and overhead. The invocation subsegment has a subsegment for the AWS SDK call to the
GetAccountSettings  API operation.
You can include the X-Ray SDK and other libraries in your function's deployment package, or deploy 
them separately in a Lambda layer. For Node.js, Ruby, and Python, the Lambda runtime includes the AWS 
SDK in the execution environment.
Dependency management with layers
You can install libraries locally and include them in the deployment package that you upload to Lambda, 
but this has its drawbacks. Larger ﬁle sizes cause increased deployment times and can prevent you from 
1119AWS Lambda Developer Guide
Dependency management with layers
testing changes to your function code in the Lambda console. To keep the deployment package small 
and avoid uploading dependencies that haven't changed, the sample app creates a Lambda layer (p. 988)
and associates it with the function.
Example blank-nodejs/template.yml – Dependency layer
Resources: 
  function: 
    Type: AWS::Serverless::Function
    Properties: 
      Handler: index.handler 
      Runtime: nodejs16.x 
      CodeUri: function/. 
      Description: Call the AWS Lambda API 
      Timeout: 10 
      # Function's execution role 
      Policies: 
        - AWSLambdaBasicExecutionRole 
        - AWSLambda_ReadOnlyAccess 
        - AWSXrayWriteOnlyAccess 
      Tracing: Active 
       Layers: 
        - !Ref libs 
  libs: 
    Type: AWS::Serverless::LayerVersion
    Properties: 
      LayerName: blank-nodejs-lib 
      Description: Dependencies for the blank sample app. 
      ContentUri: lib/. 
      CompatibleRuntimes: 
        - nodejs16.x
The 2-build-layer.sh  script installs the function's dependencies with npm and places them in a 
folder with the structure required by the Lambda runtime (p. 991).
Example 2-build-layer.sh – Preparing the layer
#!/bin/bash
set -eo pipefail
mkdir -p lib/nodejs
rm -rf node_modules lib/nodejs/node_modules
npm install --production
mv node_modules lib/nodejs/
The ﬁrst time that you deploy the sample application, the AWS CLI packages the layer separately from 
the function code and deploys both. For subsequent deployments, the layer archive is only uploaded if 
the contents of the lib folder have changed.
1120AWS Lambda Developer Guide
Error processor
Error processor sample application for AWS 
Lambda
The Error Processor sample application demonstrates the use of AWS Lambda to handle events from an
Amazon CloudWatch Logs subscription (p. 669). CloudWatch Logs lets you invoke a Lambda function 
when a log entry matches a pattern. The subscription in this application monitors the log group of a 
function for entries that contain the word ERROR. It invokes a processor Lambda function in response. 
The processor function retrieves the full log stream and trace data for the request that caused the error, 
and stores them for later use.
Function code is available in the following ﬁles:
•Random error – random-error/index.js
•Processor – processor/index.js
You can deploy the sample in a few minutes with the AWS CLI and AWS CloudFormation. To download, 
conﬁgure, and deploy it in your account, follow the instructions in the README .
Sections
•Architecture and event structure (p. 1121 )
•Instrumentation with AWS X-Ray (p. 1122 )
•AWS CloudFormation template and additional resources (p. 1122 )
Architecture and event structure
The sample application uses the following AWS services.
•AWS Lambda – Runs function code, sends logs to CloudWatch Logs, and sends trace data to X-Ray.
•Amazon CloudWatch Logs – Collects logs, and invokes a function when a log entry matches a ﬁlter 
pattern.
•AWS X-Ray – Collects trace data, indexes traces for search, and generates a service map.
•Amazon Simple Storage Service (Amazon S3) – Stores deployment artifacts and application output.
Standard charges apply for each service.
A Lambda function in the application generates errors randomly. When CloudWatch Logs detects the 
word ERROR in the function's logs, it sends an event to the processor function for processing.
Example CloudWatch Logs message event
{ 
    "awslogs": { 
        "data": "H4sIAAAAAAAAAHWQT0/DMAzFv0vEkbLYcdJkt4qVXmCDteIAm1DbZKjS
+kdpB0Jo350MhsQFyVLsZ+unl/fJWjeO5asrPgbH5..." 
    }
}
When it's decoded, the data contains details about the log event. The function uses these details to 
identify the log stream, and parses the log message to get the ID of the request that caused the error.
1121AWS Lambda Developer Guide
Instrumentation with AWS X-Ray
Example decoded CloudWatch Logs event data
{ 
    "messageType": "DATA_MESSAGE", 
    "owner": "123456789012", 
    "logGroup": "/aws/lambda/lambda-error-processor-randomerror-1GD4SSDNACNP4", 
    "logStream": " 2019/04/04/[$LATEST]63311769a9d742f19cedf8d2e38995b9 ", 
    "subscriptionFilters": [ 
        "lambda-error-processor-subscription-15OPDVQ59CG07" 
    ], 
    "logEvents": [ 
        { 
            "id": "34664632210239891980253245280462376874059932423703429141", 
            "timestamp": 1554415868243, 
            "message": "2019-04-04T22:11:08.243Z\t 1d2c1444-efd1-43ec-
b16e-8fb2d37508b8 \tERROR\n" 
        } 
    ]
}
The processor function uses information from the CloudWatch Logs event to download the full log 
stream and X-Ray trace for a request that caused an error. It stores both in an Amazon S3 bucket. To 
allow the log stream and trace time to ﬁnalize, the function waits for a short period of time before 
accessing the data.
Instrumentation with AWS X-Ray
The application uses AWS X-Ray (p. 973) to trace function invocations and the calls that functions make 
to AWS services. X-Ray uses the trace data that it receives from functions to create a service map that 
helps you identify errors.
The two Node.js functions are conﬁgured for active tracing in the template, and are instrumented with 
the AWS X-Ray SDK for Node.js in code. With active tracing, Lambda tags adds a tracing header to 
incoming requests and sends a trace with timing details to X-Ray. Additionally, the random error function 
uses the X-Ray SDK to record the request ID and user information in annotations. The annotations are 
attached to the trace, and you can use them to locate the trace for a speciﬁc request.
The processor function gets the request ID from the CloudWatch Logs event, and uses the AWS SDK for 
JavaScript to search X-Ray for that request. It uses AWS SDK clients, which are instrumented with the X-
Ray SDK, to download the trace and log stream. Then it stores them in the output bucket. The X-Ray SDK 
records these calls, and they appear as subsegments in the trace.
AWS CloudFormation template and additional 
resources
The application is implemented in two Node.js modules and deployed with an AWS CloudFormation 
template and shell scripts. The template creates the processor function, the random error function, and 
the following supporting resources.
•Execution role – An IAM role that grants the functions permission to access other AWS services.
•Primer function – An additional function that invokes the random error function to create a log group.
•Custom resource – An AWS CloudFormation custom resource that invokes the primer function during 
deployment to ensure that the log group exists.
•CloudWatch Logs subscription – A subscription for the log stream that triggers the processor function 
when the word ERROR is logged.
•Resource-based policy – A permission statement on the processor function that allows CloudWatch 
Logs to invoke it.
1122AWS Lambda Developer Guide
AWS CloudFormation template and additional resources
•Amazon S3 bucket – A storage location for output from the processor function.
View the application template  on GitHub.
To work around a limitation of Lambda's integration with AWS CloudFormation, the template creates an 
additional function that runs during deployments. All Lambda functions come with a CloudWatch Logs 
log group that stores output from function executions. However, the log group isn't created until the 
function is invoked for the ﬁrst time.
To create the subscription, which depends on the existence of the log group, the application uses a third 
Lambda function to invoke the random error function. The template includes the code for the primer 
function inline. An AWS CloudFormation custom resource invokes it during deployment. DependsOn
properties ensure that the log stream and resource-based policy are created prior to the subscription.
1123AWS Lambda Developer Guide
List manager
List manager sample application for AWS Lambda
The list manager sample application demonstrates the use of AWS Lambda to process records in an 
Amazon Kinesis data stream. A Lambda event source mapping reads records from the stream in batches 
and invokes a Lambda function. The function uses information from the records to update documents in 
Amazon DynamoDB and stores the records it processes in Amazon Relational Database Service (Amazon 
RDS).
Clients send records to a Kinesis stream, which stores them and makes them available for processing. 
The Kinesis stream is used like a queue to buﬀer records until they can be processed. Unlike an Amazon 
SQS queue, records in a Kinesis stream are not deleted after they are processed, so multiple consumers 
can process the same data. Records in Kinesis are also processed in order, where queue items can be 
delivered out of order. Records are deleted from the stream after 7 days.
In addition to the function that processes events, the application includes a second function for 
performing administrative tasks on the database. Function code is available in the following ﬁles:
•Processor – processor/index.js
•Database admin – dbadmin/index.js
You can deploy the sample in a few minutes with the AWS CLI and AWS CloudFormation. To download, 
conﬁgure, and deploy it in your account, follow the instructions in the README .
Sections
•Architecture and event structure (p. 1124 )
•Instrumentation with AWS X-Ray (p. 1126 )
•AWS CloudFormation templates and additional resources (p. 1126 )
Architecture and event structure
The sample application uses the following AWS services:
•Kinesis – Receives events from clients and stores them temporarily for processing.
•AWS Lambda – Reads from the Kinesis stream and sends events to the function's handler code.
•DynamoDB – Stores lists generated by the application.
•Amazon RDS – Stores a copy of processed records in a relational database.
•AWS Secrets Manager – Stores the database password.
•Amazon VPC – Provides a private local network for communication between the function and 
database.
Pricing
Standard charges apply for each service.
The application processes JSON documents from clients that contain information necessary to update a 
list. It supports two types of list: tally and ranking. A tally contains values that are added to the current 
value for key if it exists. Each entry processed for a user increases the value of a key in the speciﬁed table.
The following example shows a document that increases the xp (experience points) value for a user's
stats  list.
Example record – Tally type
{ 
1124AWS Lambda Developer Guide
Architecture and event structure
  "title": "stats", 
  "user": "bill", 
  "type": "tally", 
  "entries": { 
    "xp": 83 
  }
}
A ranking  contains a list of entries where the value is the order in which they are ranked. A ranking 
can be updated with diﬀerent values that overwrite the current value, instead of incrementing it. The 
following example shows a ranking of favorite movies:
Example record – Ranking type
{ 
  "title": "favorite movies", 
  "user": "mike", 
  "type": "rank", 
  "entries": { 
    "blade runner": 1, 
    "the empire strikes back": 2, 
    "alien": 3 
  }
}
A Lambda event source mapping (p. 150) read records from the stream in batches and invokes the 
processor function. The event that the function handler received contains an array of objects that each 
contain details about a record, such as when it was received, details about the stream, and an encoded 
representation of the original record document.
Example events/kinesis.json – Record
{ 
  "Records": [ 
    { 
      "kinesis": { 
        "kinesisSchemaVersion": "1.0", 
        "partitionKey": "0", 
        "sequenceNumber": "49598630142999655949899443842509554952738656579378741250", 
         "data": 
 "eyJ0aXRsZSI6ICJmYXZvcml0ZSBtb3ZpZXMiLCAidXNlciI6ICJyZGx5c2N0IiwgInR5cGUiOiAicmFuayIsICJlbnRyaWVzIjogeyJibGFkZSBydW5uZXIiOiAyLCAidGhlIGVtcGlyZSBzdHJpa2VzIGJhY2siOiAzLCAiYWxpZW4iOiAxfX0=",
        "approximateArrivalTimestamp": 1570667770.615 
      }, 
      "eventSource": "aws:kinesis", 
      "eventVersion": "1.0", 
      "eventID": 
 "shardId-000000000000:49598630142999655949899443842509554952738656579378741250", 
      "eventName": "aws:kinesis:record", 
      "invokeIdentityArn": "arn:aws:iam::123456789012:role/list-manager-
processorRole-7FYXMPLH7IUS", 
      "awsRegion": "us-east-2", 
      "eventSourceARN": "arn:aws:kinesis:us-east-2:123456789012:stream/list-manager-
stream-87B3XMPLF1AZ" 
    }, 
    ...
When it's decoded, the data contains a record. The function uses the record to update the user's list and 
an aggregate list that stores accumulated values across all users. It also stores a copy of the event in the 
application's database.
1125AWS Lambda Developer Guide
Instrumentation with AWS X-Ray
Instrumentation with AWS X-Ray
The application uses AWS X-Ray (p. 973) to trace function invocations and the calls that functions make 
to AWS services. X-Ray uses the trace data that it receives from functions to create a service map that 
helps you identify errors.
The Node.js function is conﬁgured for active tracing in the template, and is instrumented with the AWS 
X-Ray SDK for Node.js in code. The X-Ray SDK records a subsegment for each call made with an AWS SDK 
or MySQL client.
The function uses the AWS SDK for JavaScript in Node.js to read and write to two tables for each record. 
The primary table stores the current state of each combination of list name and user. The aggregate 
table stores lists that combine data from multiple users.
AWS CloudFormation templates and additional 
resources
The application is implemented in Node.js modules and deployed with an AWS CloudFormation template 
and shell scripts. The application template creates two functions, a Kinesis stream, DynamoDB tables and 
the following supporting resources.
Application resources
•Execution role – An IAM role that grants the functions permission to access other AWS services.
•Lambda event source mapping – Reads records from the data stream and invokes the function.
View the application template  on GitHub.
A second template, template-vpcrds.yml, creates the Amazon VPC and database resources. While it is 
possible to create all of the resources in one template, separating them makes it easier to clean up the 
application and allows the database to be reused with multiple applications.
Infrastructure resources
•VPC – A virtual private cloud network with private subnets, a route table, and a VPC endpoint that 
allows the function to communicate with DynamoDB without an internet connection.
•Database – An Amazon RDS database instance and a subnet group that connects it to the VPC.
1126AWS Lambda Developer Guide
Using Lambda with an AWS SDK
AWS software development kits (SDKs) are available for many popular programming languages. Each 
SDK provides an API, code examples, and documentation that make it easier for developers to build 
applications in their preferred language.
SDK documentation Code examples
AWS SDK for C++ AWS SDK for C++ code examples
AWS SDK for Go AWS SDK for Go code examples
AWS SDK for Java AWS SDK for Java code examples
AWS SDK for JavaScript AWS SDK for JavaScript code examples
AWS SDK for Kotlin AWS SDK for Kotlin code examples
AWS SDK for .NET AWS SDK for .NET code examples
AWS SDK for PHP AWS SDK for PHP code examples
AWS SDK for Python (Boto3) AWS SDK for Python (Boto3) code examples
AWS SDK for Ruby AWS SDK for Ruby code examples
AWS SDK for Rust AWS SDK for Rust code examples
AWS SDK for Swift AWS SDK for Swift code examples
For examples speciﬁc to Lambda, see Code examples for Lambda using AWS SDKs (p. 1128 ).
Example availability
Can't ﬁnd what you need? Request a code example by using the Provide feedback link at the 
bottom of this page.
1127AWS Lambda Developer Guide
Code examples for Lambda using 
AWS SDKs
The following code examples show how to use Lambda with an AWS software development kit (SDK).
Actions  are code excerpts from larger programs and must be run in context. While actions show you how 
to call individual service functions, you can see actions in context in their related scenarios and cross-
service examples.
Scenarios  are code examples that show you how to accomplish a speciﬁc task by calling multiple 
functions within the same service.
Cross-service examples are sample applications that work across multiple AWS services.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Get started
Hello Lambda
The following code examples show how to get started using Lambda.
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
namespace LambdaActions;
using Amazon.Lambda;
public class HelloLambda
{ 
    static async Task Main(string[] args) 
    { 
        var lambdaClient = new AmazonLambdaClient(); 
        Console.WriteLine("Hello AWS Lambda"); 
        Console.WriteLine("Let's get started with AWS Lambda by listing your 
 existing Lambda functions:"); 
        var response = await lambdaClient.ListFunctionsAsync(); 
        response.Functions.ForEach(function => 
        { 
            Console.WriteLine($"{function.FunctionName}\t{function.Description}"); 
        }); 
    }
}
1128AWS Lambda Developer Guide
•For API details, see ListFunctions in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Code for the CMakeLists.txt CMake ﬁle.
# Set the minimum required version of CMake for this project.
cmake_minimum_required(VERSION 3.8)
# Set the AWS service components used by this project.
set(SERVICE_COMPONENTS lambda)
# Set this project's name.
project("hello_lambda")
# Set the C++ standard to use to build this target.
# At least C++ 11 is required for the AWS SDK for C++.
set(CMAKE_CXX_STANDARD 11)
# Use the MSVC variable to determine if this is a Windows build.
set(WINDOWS_BUILD ${MSVC})
if (WINDOWS_BUILD) # Set the location where CMake can find the installed libraries 
 for the AWS SDK. 
    string(REPLACE ";" "/aws-cpp-sdk-all;" SYSTEM_MODULE_PATH 
 "${CMAKE_SYSTEM_PREFIX_PATH}/aws-cpp-sdk-all") 
    list(APPEND CMAKE_PREFIX_PATH ${SYSTEM_MODULE_PATH})
endif ()
# Find the AWS SDK for C++ package.
find_package(AWSSDK REQUIRED COMPONENTS ${SERVICE_COMPONENTS})
if (WINDOWS_BUILD)  
     # Copy relevant AWS SDK for C++ libraries into the current binary directory 
 for running and debugging. 
     # set(BIN_SUB_DIR "/Debug") # if you are building from the command line you 
 may need to uncomment this  
                                    # and set the proper subdirectory to the 
 executables' location. 
     AWSSDK_CPY_DYN_LIBS(SERVICE_COMPONENTS "" 
 ${CMAKE_CURRENT_BINARY_DIR}${BIN_SUB_DIR})
endif ()
add_executable(${PROJECT_NAME} 
        hello_lambda.cpp)
target_link_libraries(${PROJECT_NAME} 
        ${AWSSDK_LINK_LIBRARIES})
Code for the hello_lambda.cpp source ﬁle.
#include <aws/core/Aws.h>
#include <aws/lambda/LambdaClient.h>
#include <aws/lambda/model/ListFunctionsRequest.h>
1129AWS Lambda Developer Guide
#include <iostream>
/* 
 *  A "Hello Lambda" starter application which initializes an AWS Lambda (Lambda) 
 client and lists the Lambda functions. 
 * 
 *  main function 
 * 
 *  Usage: 'hello_lambda' 
 * 
 */
int main(int argc, char **argv) { 
    Aws::SDKOptions options; 
    // Optionally change the log level for debugging.
//   options.loggingOptions.logLevel = Utils::Logging::LogLevel::Debug; 
    Aws::InitAPI(options); // Should only be called once. 
    int result = 0; 
    { 
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region (overrides config file). 
        // clientConfig.region = "us-east-1"; 
        Aws::Lambda::LambdaClient lambdaClient(clientConfig); 
        std::vector<Aws::String> functions; 
        Aws::String marker; // Used for pagination. 
        do { 
            Aws::Lambda::Model::ListFunctionsRequest request; 
            if (!marker.empty()) { 
                request.SetMarker(marker); 
            } 
            Aws::Lambda::Model::ListFunctionsOutcome outcome = 
 lambdaClient.ListFunctions( 
                    request); 
            if (outcome.IsSuccess()) { 
                const Aws::Lambda::Model::ListFunctionsResult &listFunctionsResult 
 = outcome.GetResult(); 
                std::cout << listFunctionsResult.GetFunctions().size() 
                          << " lambda functions were retrieved." << std::endl; 
                for (const Aws::Lambda::Model::FunctionConfiguration 
 &functionConfiguration: listFunctionsResult.GetFunctions()) { 
                    functions.push_back(functionConfiguration.GetFunctionName()); 
                    std::cout << functions.size() << "  " 
                              << functionConfiguration.GetDescription() << 
 std::endl; 
                    std::cout << "   " 
                              << 
 Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime( 
                                      functionConfiguration.GetRuntime()) << ": " 
                              << functionConfiguration.GetHandler() 
                              << std::endl; 
                } 
                marker = listFunctionsResult.GetNextMarker(); 
            } else { 
                std::cerr << "Error with Lambda::ListFunctions. " 
                          << outcome.GetError().GetMessage() 
                          << std::endl; 
                result = 1; 
                break; 
            } 
        } while (!marker.empty()); 
    } 
1130AWS Lambda Developer Guide
    Aws::ShutdownAPI(options); // Should only be called once. 
    return result;
}
•For API details, see ListFunctions in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
package main
import ( 
 "context" 
 "fmt" 
 "github.com/aws/aws-sdk-go-v2/aws" 
 "github.com/aws/aws-sdk-go-v2/config" 
 "github.com/aws/aws-sdk-go-v2/service/lambda"
)
// main uses the AWS SDK for Go (v2) to create an AWS Lambda client and list up to 
 10
// functions in your account.
// This example uses the default settings specified in your shared credentials
// and config files.
func main() { 
 sdkConfig, err := config.LoadDefaultConfig(context.TODO()) 
 if err != nil { 
  fmt.Println("Couldn't load default configuration. Have you set up your AWS 
 account?") 
  fmt.Println(err) 
  return 
 } 
 lambdaClient := lambda.NewFromConfig(sdkConfig) 
 maxItems := 10 
 fmt.Printf("Let's list up to %v functions for your account.\n", maxItems) 
 result, err := lambdaClient.ListFunctions(context.TODO(), 
 &lambda.ListFunctionsInput{ 
  MaxItems: aws.Int32(int32(maxItems)), 
 }) 
 if err != nil { 
  fmt.Printf("Couldn't list functions for your account. Here's why: %v\n", err) 
  return 
 } 
 if len(result.Functions) == 0 { 
  fmt.Println("You don't have any functions!") 
 } else { 
  for _, function := range result.Functions { 
   fmt.Printf("\t%v\n", *function.FunctionName) 
  } 
 }
}
1131AWS Lambda Developer Guide
Actions
•For API details, see ListFunctions in AWS SDK for Go API Reference.
Code examples
•Actions for Lambda using AWS SDKs (p. 1132 )
•Create a Lambda function using an AWS SDK (p. 1133 )
•Delete a Lambda function using an AWS SDK (p. 1142 )
•Get a Lambda function using an AWS SDK (p. 1148 )
•Invoke a Lambda function using an AWS SDK (p. 1153 )
•List Lambda functions using an AWS SDK (p. 1160 )
•Update Lambda function code using an AWS SDK (p. 1165 )
•Update Lambda function conﬁguration using an AWS SDK (p. 1172 )
•Scenarios for Lambda using AWS SDKs (p. 1177 )
•Get started creating and invoking Lambda functions using an AWS SDK (p. 1178 )
•Serverless snippets for Lambda using AWS SDKs (p. 1251 )
•Invoke a Lambda function from an Amazon S3 trigger (p. 1252 )
•Cross-service examples for Lambda using AWS SDKs (p. 1258 )
•Create an API Gateway REST API to track COVID-19 data (p. 1258 )
•Create a lending library REST API (p. 1259 )
•Create a messenger application with Step Functions (p. 1259 )
•Create a photo asset management application that lets users manage photos using 
labels  (p. 1260 )
•Create a websocket chat application with API Gateway (p. 1262 )
•Create an application that analyzes customer feedback and synthesizes audio (p. 1263 )
•Invoke a Lambda function from a browser (p. 1264 )
•Use API Gateway to invoke a Lambda function (p. 1264 )
•Use Step Functions to invoke Lambda functions (p. 1266 )
•Use scheduled events to invoke a Lambda function (p. 1266 )
Actions for Lambda using AWS SDKs
The following code examples demonstrate how to perform individual Lambda actions with AWS SDKs. 
These excerpts call the Lambda API and are code excerpts from larger programs that must be run in 
context. Each example includes a link to GitHub, where you can ﬁnd instructions for setting up and 
running the code.
The following examples include only the most commonly used actions. For a complete list, see the AWS 
Lambda API Reference.
Examples
•Create a Lambda function using an AWS SDK (p. 1133 )
•Delete a Lambda function using an AWS SDK (p. 1142 )
•Get a Lambda function using an AWS SDK (p. 1148 )
•Invoke a Lambda function using an AWS SDK (p. 1153 )
•List Lambda functions using an AWS SDK (p. 1160 )
•Update Lambda function code using an AWS SDK (p. 1165 )
1132AWS Lambda Developer Guide
Create a function
•Update Lambda function conﬁguration using an AWS SDK (p. 1172 )
Create a Lambda function using an AWS SDK
The following code examples show how to create a Lambda function.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Creates a new Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the function.</param> 
    /// <param name="s3Bucket">The Amazon Simple Storage Service (Amazon S3) 
    /// bucket where the zip file containing the code is located.</param> 
    /// <param name="s3Key">The Amazon S3 key of the zip file.</param> 
    /// <param name="role">The Amazon Resource Name (ARN) of a role with the 
    /// appropriate Lambda permissions.</param> 
    /// <param name="handler">The name of the handler function.</param> 
    /// <returns>The Amazon Resource Name (ARN) of the newly created 
    /// Lambda function.</returns> 
    public async Task<string> CreateLambdaFunctionAsync( 
        string functionName, 
        string s3Bucket, 
        string s3Key, 
        string role, 
        string handler) 
    { 
        // Defines the location for the function code. 
        // S3Bucket - The S3 bucket where the file containing 
        //            the source code is stored. 
        // S3Key    - The name of the file containing the code. 
        var functionCode = new FunctionCode 
        { 
            S3Bucket = s3Bucket, 
            S3Key = s3Key, 
        }; 
        var createFunctionRequest = new CreateFunctionRequest 
        { 
            FunctionName = functionName, 
            Description = "Created by the Lambda .NET API", 
            Code = functionCode, 
            Handler = handler, 
            Runtime = Runtime.Dotnet6, 
            Role = role, 
        }; 
        var reponse = await 
 _lambdaService.CreateFunctionAsync(createFunctionRequest); 
1133AWS Lambda Developer Guide
Create a function
        return reponse.FunctionArn; 
    }
•For API details, see CreateFunction in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
        Aws::Lambda::Model::CreateFunctionRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        request.SetDescription(LAMBDA_DESCRIPTION); // Optional.
#if USE_CPP_LAMBDA_FUNCTION 
        request.SetRuntime(Aws::Lambda::Model::Runtime::provided_al2); 
        request.SetTimeout(15); 
        request.SetMemorySize(128); 
        // Assume the AWS Lambda function was built in Docker with same 
 architecture 
        // as this code.
#if  defined(__x86_64__) 
        request.SetArchitectures({Aws::Lambda::Model::Architecture::x86_64});
#elif defined(__aarch64__) 
        request.SetArchitectures({Aws::Lambda::Model::Architecture::arm64});
#else
#error "Unimplemented architecture"
#endif // defined(architecture)
#else 
        request.SetRuntime(Aws::Lambda::Model::Runtime::python3_8);
#endif 
        request.SetRole(roleArn); 
        request.SetHandler(LAMBDA_HANDLER_NAME); 
        request.SetPublish(true); 
        Aws::Lambda::Model::FunctionCode code; 
        std::ifstream ifstream(INCREMENT_LAMBDA_CODE.c_str(), 
                               std::ios_base::in | std::ios_base::binary); 
        if (!ifstream.is_open()) { 
            std::cerr << "Error opening file " << INCREMENT_LAMBDA_CODE << "." << 
 std::endl;
#if USE_CPP_LAMBDA_FUNCTION 
            std::cerr 
                    << "The cpp Lambda function must be built following the 
 instructions in the cpp_lambda/README.md file. " 
                    << std::endl;
#endif 
            deleteIamRole(clientConfig); 
            return false; 
        } 
1134AWS Lambda Developer Guide
Create a function
        Aws::StringStream buffer; 
        buffer << ifstream.rdbuf(); 
        code.SetZipFile(Aws::Utils::ByteBuffer((unsigned char *) 
 buffer.str().c_str(), 
                                               buffer.str().length())); 
        request.SetCode(code); 
        Aws::Lambda::Model::CreateFunctionOutcome outcome = client.CreateFunction( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda function was successfully created. " << 
 seconds 
                      << " seconds elapsed." << std::endl; 
            break; 
        } 
        else { 
            std::cerr << "Error with CreateFunction. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
            deleteIamRole(clientConfig); 
            return false; 
        }
•For API details, see CreateFunction in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// CreateFunction creates a new Lambda function from code contained in the 
 zipPackage
// buffer. The specified handlerName must match the name of the file and function
// contained in the uploaded code. The role specified by iamRoleArn is assumed by
// Lambda and grants specific permissions.
// When the function already exists, types.StateActive is returned.
// When the function is created, a lambda.FunctionActiveV2Waiter is used to wait 
 until the
// function is active.
func (wrapper FunctionWrapper) CreateFunction(functionName string, handlerName 
 string, 
 iamRoleArn *string, zipPackage *bytes.Buffer) types.State { 
 var state types.State 
 _, err := wrapper.LambdaClient.CreateFunction(context.TODO(), 
 &lambda.CreateFunctionInput{ 
  Code:         &types.FunctionCode{ZipFile: zipPackage.Bytes()}, 
  FunctionName: aws.String(functionName), 
1135AWS Lambda Developer Guide
Create a function
  Role:         iamRoleArn, 
  Handler:      aws.String(handlerName), 
  Publish:      true, 
  Runtime:      types.RuntimePython38, 
 }) 
 if err != nil { 
  var resConflict *types.ResourceConflictException 
  if errors.As(err, &resConflict) { 
   log.Printf("Function %v already exists.\n", functionName) 
   state = types.StateActive 
  } else { 
   log.Panicf("Couldn't create function %v. Here's why: %v\n", functionName, err) 
  } 
 } else { 
  waiter := lambda.NewFunctionActiveV2Waiter(wrapper.LambdaClient) 
  funcOutput, err := waiter.WaitForOutput(context.TODO(), &lambda.GetFunctionInput{ 
   FunctionName: aws.String(functionName)}, 1*time.Minute) 
  if err != nil { 
   log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", 
 functionName, err) 
  } else { 
   state = funcOutput.Configuration.State 
  } 
 } 
 return state
}
•For API details, see CreateFunction in AWS SDK for Go API Reference.
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public static void createLambdaFunction(LambdaClient awsLambda, 
                                            String functionName, 
                                            String filePath, 
                                            String role, 
                                            String handler) { 
        try { 
            LambdaWaiter waiter = awsLambda.waiter(); 
            InputStream is = new FileInputStream(filePath); 
            SdkBytes fileToUpload = SdkBytes.fromInputStream(is); 
            FunctionCode code = FunctionCode.builder() 
                .zipFile(fileToUpload) 
                .build(); 
            CreateFunctionRequest functionRequest = CreateFunctionRequest.builder() 
                .functionName(functionName) 
                .description("Created by the Lambda Java API") 
                .code(code) 
                .handler(handler) 
                .runtime(Runtime.JAVA8) 
                .role(role) 
                .build(); 
1136AWS Lambda Developer Guide
Create a function
            // Create a Lambda function using a waiter. 
            CreateFunctionResponse functionResponse = 
 awsLambda.createFunction(functionRequest); 
            GetFunctionRequest getFunctionRequest = GetFunctionRequest.builder() 
                .functionName(functionName) 
                .build(); 
            WaiterResponse<GetFunctionResponse> waiterResponse = 
 waiter.waitUntilFunctionExists(getFunctionRequest); 
            waiterResponse.matched().response().ifPresent(System.out::println); 
            System.out.println("The function ARN is " + 
 functionResponse.functionArn()); 
        } catch(LambdaException | FileNotFoundException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    }
•For API details, see CreateFunction in AWS SDK for Java 2.x API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const createFunction = async (funcName, roleArn) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const code = await readFile(`${dirname}../functions/${funcName}.zip`); 
  const command = new CreateFunctionCommand({ 
    Code: { ZipFile: code }, 
    FunctionName: funcName, 
    Role: roleArn, 
    Architectures: [Architecture.arm64], 
    Handler: "index.handler", // Required when sending a .zip file 
    PackageType: PackageType.Zip, // Required when sending a .zip file 
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file 
  }); 
  return client.send(command);
};
•For API details, see CreateFunction in AWS SDK for JavaScript API Reference.
Kotlin
SDK for Kotlin
Note
This is prerelease documentation for a feature in preview release. It is subject to 
change.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1137AWS Lambda Developer Guide
Create a function
suspend fun createNewFunction( 
    myFunctionName: String, 
    s3BucketName: String, 
    myS3Key: String, 
    myHandler: String, 
    myRole: String
): String? { 
    val functionCode = FunctionCode { 
        s3Bucket = s3BucketName 
        s3Key = myS3Key 
    } 
    val request = CreateFunctionRequest { 
        functionName = myFunctionName 
        code = functionCode 
        description = "Created by the Lambda Kotlin API" 
        handler = myHandler 
        role = myRole 
        runtime = Runtime.Java8 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val functionResponse = awsLambda.createFunction(request) 
        awsLambda.waitUntilFunctionActive { 
            functionName = myFunctionName 
        } 
        return functionResponse.functionArn 
    }
}
•For API details, see CreateFunction in AWS SDK for Kotlin API reference.
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function createFunction($functionName, $role, $bucketName, $handler) 
    { 
        //This assumes the Lambda function is in an S3 bucket. 
        return $this->customWaiter(function () use ($functionName, $role, 
 $bucketName, $handler) { 
            return $this->lambdaClient->createFunction([ 
                'Code' => [ 
                    'S3Bucket' => $bucketName, 
                    'S3Key' => $functionName, 
                ], 
                'FunctionName' => $functionName, 
                'Role' => $role['Arn'], 
                'Runtime' => 'python3.9', 
                'Handler' => "$handler.lambda_handler", 
            ]); 
        }); 
    }
•For API details, see CreateFunction in AWS SDK for PHP API Reference.
1138AWS Lambda Developer Guide
Create a function
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def create_function(self, function_name, handler_name, iam_role, 
 deployment_package): 
        """ 
        Deploys a Lambda function. 
        :param function_name: The name of the Lambda function. 
        :param handler_name: The fully qualified name of the handler function. This 
                             must include the file name and the function name. 
        :param iam_role: The IAM role to use for the function. 
        :param deployment_package: The deployment package that contains the 
 function 
                                   code in .zip format. 
        :return: The Amazon Resource Name (ARN) of the newly created function. 
        """ 
        try: 
            response = self.lambda_client.create_function( 
                FunctionName=function_name, 
                Description="AWS Lambda doc example", 
                Runtime='python3.8', 
                Role=iam_role.arn, 
                Handler=handler_name, 
                Code={'ZipFile': deployment_package}, 
                Publish=True) 
            function_arn = response['FunctionArn'] 
            waiter = self.lambda_client.get_waiter('function_active_v2') 
            waiter.wait(FunctionName=function_name) 
            logger.info("Created function '%s' with ARN: '%s'.", 
                        function_name, response['FunctionArn']) 
        except ClientError: 
            logger.error("Couldn't create function %s.", function_name) 
            raise 
        else: 
            return function_arn
•For API details, see CreateFunction in AWS SDK for Python (Boto3) API Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
1139AWS Lambda Developer Guide
Create a function
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Deploys a Lambda function. 
  # 
  # @param function_name: The name of the Lambda function. 
  # @param handler_name: The fully qualified name of the handler function. This 
  #                      must include the file name and the function name. 
  # @param role_arn: The IAM role to use for the function. 
  # @param deployment_package: The deployment package that contains the function 
  #                            code in .zip format. 
  # @return: The Amazon Resource Name (ARN) of the newly created function. 
  def create_function(function_name, handler_name, role_arn, deployment_package) 
    response = @lambda_client.create_function({ 
                                                role: role_arn.to_s, 
                                                function_name: function_name, 
                                                handler: handler_name, 
                                                runtime: "ruby2.7", 
                                                code: { 
                                                  zip_file: deployment_package 
                                                }, 
                                                environment: { 
                                                  variables: { 
                                                    "LOG_LEVEL" => "info" 
                                                  } 
                                                } 
                                              }) 
    @lambda_client.wait_until(:function_active_v2, { function_name: function_name}) 
 do |w| 
      w.max_attempts = 5 
      w.delay = 5 
    end 
    response 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error creating #{function_name}:\n #{e.message}") 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to activate:\n 
 #{e.message}") 
  end
•For API details, see CreateFunction in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** 
     * Create a function, uploading from a zip file. 
     */ 
    pub async fn create_function(&self, zip_file: PathBuf) -> Result<String, 
 anyhow::Error> { 
1140AWS Lambda Developer Guide
Create a function
        let code = self.prepare_function(zip_file, None).await?; 
        let key = code.s3_key().unwrap().to_string(); 
        self.create_role().await; 
        let role = self 
            .iam_client 
            .create_role() 
            .role_name(self.role_name.clone()) 
            .assume_role_policy_document(ROLE_POLICY_DOCUMENT) 
            .send() 
            .await?; 
        info!("Created iam role, waiting 15s for it to become active"); 
        tokio::time::sleep(Duration::from_secs(15)).await; 
        info!("Creating lambda function {}", self.lambda_name); 
        let _ = self 
            .lambda_client 
            .create_function() 
            .function_name(self.lambda_name.clone()) 
            .code(code) 
            .role(role.role().unwrap().arn().unwrap()) 
            .runtime(aws_sdk_lambda::types::Runtime::Providedal2) 
            .handler("_unused") 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        self.lambda_client 
            .publish_version() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await?; 
        Ok(key) 
    } 
    /** 
     * Upload function code from a path to a zip file. 
     * The zip file must have an AL2 Linux-compatible binary called `bootstrap`. 
     * The easiest way to create such a zip is to use `cargo lambda build --output-
format Zip`. 
     */ 
    async fn prepare_function( 
        &self, 
        zip_file: PathBuf, 
        key: Option<String>, 
    ) -> Result<FunctionCode, anyhow::Error> { 
        let body = ByteStream::read_from().path(zip_file).build().await?; 
        let key = key.unwrap_or_else(|| format!("{}_code", self.lambda_name)); 
        info!("Uploading function code to s3://{}/{}", self.bucket, key); 
        let _ = self 
            .s3_client 
            .put_object() 
            .bucket(self.bucket.clone()) 
            .key(key.clone()) 
            .body(body) 
            .send() 
            .await?; 
1141AWS Lambda Developer Guide
Delete a function
        Ok(FunctionCode::builder() 
            .s3_bucket(self.bucket.clone()) 
            .s3_key(key) 
            .build()) 
    }
•For API details, see CreateFunction in AWS SDK for Rust API reference.
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        lo_lmd->createfunction( 
            iv_functionname = iv_function_name 
            iv_runtime = `python3.9` 
            iv_role = iv_role_arn 
            iv_handler = iv_handler 
            io_code = io_zip_file 
            iv_description = 'AWS Lambda code example' 
        ). 
        MESSAGE 'Lambda function created.' TYPE 'I'. 
      CATCH /aws1/cx_lmdcodesigningcfgno00. 
        MESSAGE 'Code signing configuration does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdcodestorageexcdex. 
        MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'. 
      CATCH /aws1/cx_lmdcodeverification00. 
        MESSAGE 'Code signature failed one or more validation checks for signature 
 mismatch or expiration.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvalidcodesigex. 
        MESSAGE 'Code signature failed the integrity check.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdresourceconflictex. 
        MESSAGE 'Resource already exists or another operation is in progress.' TYPE 
 'E'. 
      CATCH /aws1/cx_lmdresourcenotfoundex. 
        MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see CreateFunction in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Delete a Lambda function using an AWS SDK
The following code examples show how to delete a Lambda function.
1142AWS Lambda Developer Guide
Delete a function
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Delete an AWS Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to 
    /// delete.</param> 
    /// <returns>A Boolean value that indicates the success of the action.</
returns> 
    public async Task<bool> DeleteFunctionAsync(string functionName) 
    { 
        var request = new DeleteFunctionRequest 
        { 
            FunctionName = functionName, 
        }; 
        var response = await _lambdaService.DeleteFunctionAsync(request); 
        // A return value of NoContent means that the request was processed. 
        // In this case, the function was deleted, and the return value 
        // is intentionally blank. 
        return response.HttpStatusCode == System.Net.HttpStatusCode.NoContent; 
    }
•For API details, see DeleteFunction in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
    Aws::Lambda::Model::DeleteFunctionRequest request; 
    request.SetFunctionName(LAMBDA_NAME); 
    Aws::Lambda::Model::DeleteFunctionOutcome outcome = client.DeleteFunction( 
            request); 
1143AWS Lambda Developer Guide
Delete a function
    if (outcome.IsSuccess()) { 
        std::cout << "The lambda function was successfully deleted." << std::endl; 
    } 
    else { 
        std::cerr << "Error with Lambda::DeleteFunction. " 
                  << outcome.GetError().GetMessage() 
                  << std::endl; 
    }
•For API details, see DeleteFunction in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// DeleteFunction deletes the Lambda function specified by functionName.
func (wrapper FunctionWrapper) DeleteFunction(functionName string) { 
 _, err := wrapper.LambdaClient.DeleteFunction(context.TODO(), 
 &lambda.DeleteFunctionInput{ 
  FunctionName: aws.String(functionName), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't delete function %v. Here's why: %v\n", functionName, err) 
 }
}
•For API details, see DeleteFunction in AWS SDK for Go API Reference.
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public static void deleteLambdaFunction(LambdaClient awsLambda, String 
 functionName) { 
        try { 
            DeleteFunctionRequest request = DeleteFunctionRequest.builder() 
                .functionName(functionName) 
1144AWS Lambda Developer Guide
Delete a function
                .build(); 
            awsLambda.deleteFunction(request); 
            System.out.println("The "+functionName +" function was deleted"); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    }
•For API details, see DeleteFunction in AWS SDK for Java 2.x API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const deleteFunction = (funcName) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new DeleteFunctionCommand({ FunctionName: funcName }); 
  return client.send(command);
};
•For API details, see DeleteFunction in AWS SDK for JavaScript API Reference.
Kotlin
SDK for Kotlin
Note
This is prerelease documentation for a feature in preview release. It is subject to 
change.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
suspend fun delLambdaFunction(myFunctionName: String) { 
    val request = DeleteFunctionRequest { 
        functionName = myFunctionName 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        awsLambda.deleteFunction(request) 
        println("$myFunctionName was deleted") 
    }
}
•For API details, see DeleteFunction in AWS SDK for Kotlin API reference.
1145AWS Lambda Developer Guide
Delete a function
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function deleteFunction($functionName) 
    { 
        return $this->lambdaClient->deleteFunction([ 
            'FunctionName' => $functionName, 
        ]); 
    }
•For API details, see DeleteFunction in AWS SDK for PHP API Reference.
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def delete_function(self, function_name): 
        """ 
        Deletes a Lambda function. 
        :param function_name: The name of the function to delete. 
        """ 
        try: 
            self.lambda_client.delete_function(FunctionName=function_name) 
        except ClientError: 
            logger.exception("Couldn't delete function %s.", function_name) 
            raise
•For API details, see DeleteFunction in AWS SDK for Python (Boto3) API Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
1146AWS Lambda Developer Guide
Delete a function
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Deletes a Lambda function. 
  # @param function_name: The name of the function to delete. 
  def delete_function(function_name) 
    print "Deleting function: #{function_name}..." 
    @lambda_client.delete_function( 
      function_name: function_name 
    ) 
    print "Done!".green 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error deleting #{function_name}:\n #{e.message}") 
  end
•For API details, see DeleteFunction in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** Delete a function and its role, and if possible or necessary, its 
 associated code object and bucket. */ 
    pub async fn delete_function( 
        &self, 
        location: Option<String>, 
    ) -> ( 
        Result<DeleteFunctionOutput, anyhow::Error>, 
        Result<DeleteRoleOutput, anyhow::Error>, 
        Option<Result<DeleteObjectOutput, anyhow::Error>>, 
    ) { 
        info!("Deleting lambda function {}", self.lambda_name); 
        let delete_function = self 
            .lambda_client 
            .delete_function() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from); 
        info!("Deleting iam role {}", self.role_name); 
        let delete_role = self 
            .iam_client 
            .delete_role() 
            .role_name(self.role_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from); 
        let delete_object: Option<Result<DeleteObjectOutput, anyhow::Error>> = 
            if let Some(location) = location { 
                info!("Deleting object {location}"); 
1147AWS Lambda Developer Guide
Get a function
                Some( 
                    self.s3_client 
                        .delete_object() 
                        .bucket(self.bucket.clone()) 
                        .key(location) 
                        .send() 
                        .await 
                        .map_err(anyhow::Error::from), 
                ) 
            } else { 
                info!(?location, "Skipping delete object"); 
                None 
            }; 
        (delete_function, delete_role, delete_object) 
    }
•For API details, see DeleteFunction in AWS SDK for Rust API reference.
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        lo_lmd->deletefunction( iv_functionname = iv_function_name ). 
        MESSAGE 'Lambda function deleted.' TYPE 'I'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdresourceconflictex. 
        MESSAGE 'Resource already exists or another operation is in progress.' TYPE 
 'E'. 
      CATCH /aws1/cx_lmdresourcenotfoundex. 
        MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see DeleteFunction in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Get a Lambda function using an AWS SDK
The following code examples show how to get a Lambda function.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
1148AWS Lambda Developer Guide
Get a function
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Gets information about a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function for 
    /// which to retrieve information.</param> 
    /// <returns>Async Task.</returns> 
    public async Task<FunctionConfiguration> GetFunctionAsync(string functionName) 
    { 
        var functionRequest = new GetFunctionRequest 
        { 
            FunctionName = functionName, 
        }; 
        var response = await _lambdaService.GetFunctionAsync(functionRequest); 
        return response.Configuration; 
    }
•For API details, see GetFunction in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
        Aws::Lambda::Model::GetFunctionRequest request; 
        request.SetFunctionName(functionName); 
        Aws::Lambda::Model::GetFunctionOutcome outcome = 
 client.GetFunction(request); 
        if (outcome.IsSuccess()) { 
            std::cout << "Function retrieve.\n" << 
                      
 outcome.GetResult().GetConfiguration().Jsonize().View().WriteReadable() 
                      << std::endl; 
        } 
        else { 
            std::cerr << "Error with Lambda::GetFunction. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
1149AWS Lambda Developer Guide
Get a function
        }
•For API details, see GetFunction in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// GetFunction gets data about the Lambda function specified by functionName.
func (wrapper FunctionWrapper) GetFunction(functionName string) types.State { 
 var state types.State 
 funcOutput, err := wrapper.LambdaClient.GetFunction(context.TODO(), 
 &lambda.GetFunctionInput{ 
  FunctionName: aws.String(functionName), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't get function %v. Here's why: %v\n", functionName, err) 
 } else { 
  state = funcOutput.Configuration.State 
 } 
 return state
}
•For API details, see GetFunction in AWS SDK for Go API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const getFunction = (funcName) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new GetFunctionCommand({ FunctionName: funcName }); 
  return client.send(command);
};
•For API details, see GetFunction in AWS SDK for JavaScript API Reference.
1150AWS Lambda Developer Guide
Get a function
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function getFunction($functionName) 
    { 
        return $this->lambdaClient->getFunction([ 
            'FunctionName' => $functionName, 
        ]); 
    }
•For API details, see GetFunction in AWS SDK for PHP API Reference.
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def get_function(self, function_name): 
        """ 
        Gets data about a Lambda function. 
        :param function_name: The name of the function. 
        :return: The function data. 
        """ 
        response = None 
        try: 
            response = self.lambda_client.get_function(FunctionName=function_name) 
        except ClientError as err: 
            if err.response['Error']['Code'] == 'ResourceNotFoundException': 
                logger.info("Function %s does not exist.", function_name) 
            else: 
                logger.error( 
                    "Couldn't get function %s. Here's why: %s: %s", function_name, 
                    err.response['Error']['Code'], err.response['Error']
['Message']) 
                raise 
        return response
•For API details, see GetFunction in AWS SDK for Python (Boto3) API Reference.
1151AWS Lambda Developer Guide
Get a function
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Gets data about a Lambda function. 
  # 
  # @param function_name: The name of the function. 
  # @return response: The function data, or nil if no such function exists. 
  def get_function(function_name) 
    @lambda_client.get_function( 
      { 
        function_name: function_name 
      } 
    ) 
  rescue Aws::Lambda::Errors::ResourceNotFoundException => e 
    @logger.debug("Could not find function: #{function_name}:\n #{e.message}") 
    nil 
  end
•For API details, see GetFunction in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** Get the Lambda function with this Manager's name. */ 
    pub async fn get_function(&self) -> Result<GetFunctionOutput, anyhow::Error> { 
        info!("Getting lambda function"); 
        self.lambda_client 
            .get_function() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
    }
•For API details, see GetFunction in AWS SDK for Rust API reference.
1152AWS Lambda Developer Guide
Invoke a function
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        oo_result =  lo_lmd->getfunction( iv_functionname = iv_function_name ).     
   " oo_result is returned for testing purposes. " 
        MESSAGE 'Lambda function information retrieved.' TYPE 'I'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see GetFunction in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Invoke a Lambda function using an AWS SDK
The following code examples show how to invoke a Lambda function.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Invoke a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to 
    /// invoke.</param 
    /// <param name="parameters">The parameter values that will be passed to the 
 function.</param> 
    /// <returns>A System Threading Task.</returns> 
    public async Task<string> InvokeFunctionAsync( 
        string functionName, 
        string parameters) 
    { 
1153AWS Lambda Developer Guide
Invoke a function
        var payload = parameters; 
        var request = new InvokeRequest 
        { 
            FunctionName = functionName, 
            Payload = payload, 
        }; 
        var response = await _lambdaService.InvokeAsync(request); 
        MemoryStream stream = response.Payload; 
        string returnValue = System.Text.Encoding.UTF8.GetString(stream.ToArray()); 
        return returnValue; 
    }
•For API details, see Invoke in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
        Aws::Lambda::Model::InvokeRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        request.SetLogType(logType); 
        std::shared_ptr<Aws::IOStream> payload = 
 Aws::MakeShared<Aws::StringStream>( 
                "FunctionTest"); 
        *payload << jsonPayload.View().WriteReadable(); 
        request.SetBody(payload); 
        request.SetContentType("application/json"); 
        Aws::Lambda::Model::InvokeOutcome outcome = client.Invoke(request); 
        if (outcome.IsSuccess()) { 
            invokeResult = std::move(outcome.GetResult()); 
            result = true; 
            break; 
        } 
        else { 
            std::cerr << "Error with Lambda::InvokeRequest. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
            break; 
        }
•For API details, see Invoke in AWS SDK for C++ API Reference.
1154AWS Lambda Developer Guide
Invoke a function
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// Invoke invokes the Lambda function specified by functionName, passing the 
 parameters
// as a JSON payload. When getLog is true, types.LogTypeTail is specified, which 
 tells
// Lambda to include the last few log lines in the returned result.
func (wrapper FunctionWrapper) Invoke(functionName string, parameters any, getLog 
 bool) *lambda.InvokeOutput { 
 logType := types.LogTypeNone 
 if getLog { 
  logType = types.LogTypeTail 
 } 
 payload, err := json.Marshal(parameters) 
 if err != nil { 
  log.Panicf("Couldn't marshal parameters to JSON. Here's why %v\n", err) 
 } 
 invokeOutput, err := wrapper.LambdaClient.Invoke(context.TODO(), 
 &lambda.InvokeInput{ 
  FunctionName: aws.String(functionName), 
  LogType:      logType, 
  Payload:      payload, 
 }) 
 if err != nil { 
  log.Panicf("Couldn't invoke function %v. Here's why: %v\n", functionName, err) 
 } 
 return invokeOutput
}
•For API details, see Invoke in AWS SDK for Go API Reference.
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public static void invokeFunction(LambdaClient awsLambda, String functionName) 
 { 
        InvokeResponse res = null ; 
        try { 
1155AWS Lambda Developer Guide
Invoke a function
            // Need a SdkBytes instance for the payload. 
            JSONObject jsonObj = new JSONObject(); 
            jsonObj.put("inputValue", "2000"); 
            String json = jsonObj.toString(); 
            SdkBytes payload = SdkBytes.fromUtf8String(json) ; 
            // Setup an InvokeRequest. 
            InvokeRequest request = InvokeRequest.builder() 
                .functionName(functionName) 
                .payload(payload) 
                .build(); 
            res = awsLambda.invoke(request); 
            String value = res.payload().asUtf8String() ; 
            System.out.println(value); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    }
•For API details, see Invoke in AWS SDK for Java 2.x API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const invoke = async (funcName, payload) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new InvokeCommand({ 
    FunctionName: funcName, 
    Payload: JSON.stringify(payload), 
    LogType: LogType.Tail, 
  }); 
  const { Payload, LogResult } = await client.send(command); 
  const result = Buffer.from(Payload).toString(); 
  const logs = Buffer.from(LogResult, "base64").toString(); 
  return { logs, result };
};
•For API details, see Invoke in AWS SDK for JavaScript API Reference.
Kotlin
SDK for Kotlin
Note
This is prerelease documentation for a feature in preview release. It is subject to 
change.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1156AWS Lambda Developer Guide
Invoke a function
suspend fun invokeFunction(functionNameVal: String) { 
    val json = """{"inputValue":"1000"}""" 
    val byteArray = json.trimIndent().encodeToByteArray() 
    val request = InvokeRequest { 
        functionName = functionNameVal 
        logType = LogType.Tail 
        payload = byteArray 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val res = awsLambda.invoke(request) 
        println("${res.payload?.toString(Charsets.UTF_8)}") 
        println("The log result is ${res.logResult}") 
    }
}
•For API details, see Invoke in AWS SDK for Kotlin API reference.
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function invoke($functionName, $params, $logType = 'None') 
    { 
        return $this->lambdaClient->invoke([ 
            'FunctionName' => $functionName, 
            'Payload' => json_encode($params), 
            'LogType' => $logType, 
        ]); 
    }
•For API details, see Invoke in AWS SDK for PHP API Reference.
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def invoke_function(self, function_name, function_params, get_log=False): 
        """ 
        Invokes a Lambda function. 
        :param function_name: The name of the function to invoke. 
        :param function_params: The parameters of the function as a dict. This dict 
                                is serialized to JSON before it is sent to Lambda. 
1157AWS Lambda Developer Guide
Invoke a function
        :param get_log: When true, the last 4 KB of the execution log are included 
 in 
                        the response. 
        :return: The response from the function invocation. 
        """ 
        try: 
            response = self.lambda_client.invoke( 
                FunctionName=function_name, 
                Payload=json.dumps(function_params), 
                LogType='Tail' if get_log else 'None') 
            logger.info("Invoked function %s.", function_name) 
        except ClientError: 
            logger.exception("Couldn't invoke function %s.", function_name) 
            raise 
        return response
•For API details, see Invoke in AWS SDK for Python (Boto3) API Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Invokes a Lambda function. 
  # @param function_name [String] The name of the function to invoke. 
  # @param payload [nil] Payload containing runtime parameters. 
  # @return [Object] The response from the function invocation. 
  def invoke_function(function_name, payload = nil) 
    params = { function_name: function_name} 
    params[:payload] = payload unless payload.nil? 
    @lambda_client.invoke(params) 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error executing #{function_name}:\n #{e.message}") 
  end
•For API details, see Invoke in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1158AWS Lambda Developer Guide
Invoke a function
    /** Invoke the lambda function using calculator InvokeArgs. */ 
    pub async fn invoke(&self, args: InvokeArgs) -> Result<InvokeOutput, 
 anyhow::Error> { 
        info!(?args, "Invoking {}", self.lambda_name); 
        let payload = serde_json::to_string(&args)?; 
        debug!(?payload, "Sending payload"); 
        self.lambda_client 
            .invoke() 
            .function_name(self.lambda_name.clone()) 
            .payload(Blob::new(payload)) 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
    }
fn log_invoke_output(invoke: &InvokeOutput, message: &str) { 
    if let Some(payload) = invoke.payload().cloned() { 
        let payload = String::from_utf8(payload.into_inner()); 
        info!(?payload, message); 
    } else { 
        info!("Could not extract payload") 
    } 
    if let Some(logs) = invoke.log_result() { 
        debug!(?logs, "Invoked function logs") 
    } else { 
        debug!("Invoked function had no logs") 
    }
}
•For API details, see Invoke in AWS SDK for Rust API reference.
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        DATA(lv_json) = /aws1/cl_rt_util=>string_to_xstring( 
          `{`  && 
            `"action": "increment",`  && 
            `"number": 10` && 
          `}` 
        ). 
        oo_result =  lo_lmd->invoke(                  " oo_result is returned for 
 testing purposes. " 
                 iv_functionname = iv_function_name 
                 iv_payload = lv_json 
             ). 
        MESSAGE 'Lambda function invoked.' TYPE 'I'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvrequestcontex. 
        MESSAGE 'Unable to parse request body as JSON.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvalidzipfileex. 
        MESSAGE 'The deployment package could not be unzipped.' TYPE 'E'. 
      CATCH /aws1/cx_lmdrequesttoolargeex. 
        MESSAGE 'Invoke request body JSON input limit was exceeded by the request 
 payload.' TYPE 'E'. 
1159AWS Lambda Developer Guide
List functions
      CATCH /aws1/cx_lmdresourceconflictex. 
        MESSAGE 'Resource already exists or another operation is in progress.' TYPE 
 'E'. 
      CATCH /aws1/cx_lmdresourcenotfoundex. 
        MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
      CATCH /aws1/cx_lmdunsuppedmediatyp00. 
        MESSAGE 'Invoke request body does not have JSON as its content type.' TYPE 
 'E'. 
    ENDTRY.
•For API details, see Invoke in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
List Lambda functions using an AWS SDK
The following code examples show how to list Lambda functions.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Get a list of Lambda functions. 
    /// </summary> 
    /// <returns>A list of FunctionConfiguration objects.</returns> 
    public async Task<List<FunctionConfiguration>> ListFunctionsAsync() 
    { 
        var functionList = new List<FunctionConfiguration>(); 
        var functionPaginator = 
            _lambdaService.Paginators.ListFunctions(new ListFunctionsRequest()); 
        await foreach (var function in functionPaginator.Functions) 
        { 
            functionList.Add(function); 
        } 
        return functionList; 
    }
•For API details, see ListFunctions in AWS SDK for .NET API Reference.
1160AWS Lambda Developer Guide
List functions
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
    std::vector<Aws::String> functions; 
    Aws::String marker; 
    do { 
        Aws::Lambda::Model::ListFunctionsRequest request; 
        if (!marker.empty()) { 
            request.SetMarker(marker); 
        } 
        Aws::Lambda::Model::ListFunctionsOutcome outcome = client.ListFunctions( 
                request); 
        if (outcome.IsSuccess()) { 
            const Aws::Lambda::Model::ListFunctionsResult &result = 
 outcome.GetResult(); 
            std::cout << result.GetFunctions().size() 
                      << " lambda functions were retrieved." << std::endl; 
            for (const Aws::Lambda::Model::FunctionConfiguration 
 &functionConfiguration: result.GetFunctions()) { 
                functions.push_back(functionConfiguration.GetFunctionName()); 
                std::cout << functions.size() << "  " 
                          << functionConfiguration.GetDescription() << std::endl; 
                std::cout << "   " 
                          << Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime( 
                                  functionConfiguration.GetRuntime()) << ": " 
                          << functionConfiguration.GetHandler() 
                          << std::endl; 
            } 
            marker = result.GetNextMarker(); 
        } 
        else { 
            std::cerr << "Error with Lambda::ListFunctions. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        } 
    } while (!marker.empty());
•For API details, see ListFunctions in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1161AWS Lambda Developer Guide
List functions
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// ListFunctions lists up to maxItems functions for the account. This function uses 
 a
// lambda.ListFunctionsPaginator to paginate the results.
func (wrapper FunctionWrapper) ListFunctions(maxItems int) 
 []types.FunctionConfiguration { 
 var functions []types.FunctionConfiguration 
 paginator := lambda.NewListFunctionsPaginator(wrapper.LambdaClient, 
 &lambda.ListFunctionsInput{ 
  MaxItems: aws.Int32(int32(maxItems)), 
 }) 
 for paginator.HasMorePages() && len(functions) < maxItems { 
  pageOutput, err := paginator.NextPage(context.TODO()) 
  if err != nil { 
   log.Panicf("Couldn't list functions for your account. Here's why: %v\n", err) 
  } 
  functions = append(functions, pageOutput.Functions...) 
 } 
 return functions
}
•For API details, see ListFunctions in AWS SDK for Go API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const listFunctions = async () => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new ListFunctionsCommand({}); 
  return client.send(command);
};
•For API details, see ListFunctions in AWS SDK for JavaScript API Reference.
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1162AWS Lambda Developer Guide
List functions
    public function listFunctions($maxItems = 50, $marker = null) 
    { 
        if (is_null($marker)) { 
            return $this->lambdaClient->listFunctions([ 
                'MaxItems' => $maxItems, 
            ]); 
        } 
        return $this->lambdaClient->listFunctions([ 
            'Marker' => $marker, 
            'MaxItems' => $maxItems, 
        ]); 
    }
•For API details, see ListFunctions in AWS SDK for PHP API Reference.
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def list_functions(self): 
        """ 
        Lists the Lambda functions for the current account. 
        """ 
        try: 
            func_paginator = self.lambda_client.get_paginator('list_functions') 
            for func_page in func_paginator.paginate(): 
                for func in func_page['Functions']: 
                    print(func['FunctionName']) 
                    desc = func.get('Description') 
                    if desc: 
                        print(f"\t{desc}") 
                    print(f"\t{func['Runtime']}: {func['Handler']}") 
        except ClientError as err: 
            logger.error( 
                "Couldn't list functions. Here's why: %s: %s", 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise
•For API details, see ListFunctions in AWS SDK for Python (Boto3) API Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1163AWS Lambda Developer Guide
List functions
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Lists the Lambda functions for the current account. 
  def list_functions 
    functions = [] 
    @lambda_client.list_functions.each do |response| 
      response["functions"].each do |function| 
        functions.append(function["function_name"]) 
      end 
    end 
    functions 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error executing #{function_name}:\n #{e.message}") 
  end
•For API details, see ListFunctions in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** List all Lambda functions in the current Region. */ 
    pub async fn list_functions(&self) -> Result<ListFunctionsOutput, 
 anyhow::Error> { 
        info!("Listing lambda functions"); 
        self.lambda_client 
            .list_functions() 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
    }
•For API details, see ListFunctions in AWS SDK for Rust API reference.
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
1164AWS Lambda Developer Guide
Update function code
    TRY. 
        oo_result =  lo_lmd->listfunctions( ).       " oo_result is returned for 
 testing purposes. " 
        DATA(lt_functions) = oo_result->get_functions( ). 
        MESSAGE 'Retrieved list of Lambda functions.' TYPE 'I'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see ListFunctions in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Update Lambda function code using an AWS SDK
The following code examples show how to update Lambda function code.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Update an existing Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to update.</
param> 
    /// <param name="bucketName">The bucket where the zip file containing 
    /// the Lambda function code is stored.</param> 
    /// <param name="key">The key name of the source code file.</param> 
    /// <returns>Async Task.</returns> 
    public async Task UpdateFunctionCodeAsync( 
        string functionName, 
        string bucketName, 
        string key) 
    { 
        var functionCodeRequest = new UpdateFunctionCodeRequest 
        { 
            FunctionName = functionName, 
            Publish = true, 
            S3Bucket = bucketName, 
            S3Key = key, 
1165AWS Lambda Developer Guide
Update function code
        }; 
        var response = await 
 _lambdaService.UpdateFunctionCodeAsync(functionCodeRequest); 
        Console.WriteLine($"The Function was last modified at 
 {response.LastModified}."); 
    }
•For API details, see UpdateFunctionCode in AWS SDK for .NET API Reference.
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
        Aws::Lambda::Model::UpdateFunctionCodeRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        std::ifstream ifstream(CALCULATOR_LAMBDA_CODE.c_str(), 
                               std::ios_base::in | std::ios_base::binary); 
        if (!ifstream.is_open()) { 
            std::cerr << "Error opening file " << INCREMENT_LAMBDA_CODE << "." << 
 std::endl;
#if USE_CPP_LAMBDA_FUNCTION 
            std::cerr 
                    << "The cpp Lambda function must be built following the 
 instructions in the cpp_lambda/README.md file. " 
                    << std::endl;
#endif 
            deleteLambdaFunction(client); 
            deleteIamRole(clientConfig); 
            return false; 
        } 
        Aws::StringStream buffer; 
        buffer << ifstream.rdbuf(); 
        request.SetZipFile( 
                Aws::Utils::ByteBuffer((unsigned char *) buffer.str().c_str(), 
                                       buffer.str().length())); 
        request.SetPublish(true); 
        Aws::Lambda::Model::UpdateFunctionCodeOutcome outcome = 
 client.UpdateFunctionCode( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda code was successfully updated." << std::endl; 
        } 
        else { 
            std::cerr << "Error with Lambda::UpdateFunctionCode. " 
1166AWS Lambda Developer Guide
Update function code
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        }
•For API details, see UpdateFunctionCode in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// UpdateFunctionCode updates the code for the Lambda function specified by 
 functionName.
// The existing code for the Lambda function is entirely replaced by the code in 
 the
// zipPackage buffer. After the update action is called, a 
 lambda.FunctionUpdatedV2Waiter
// is used to wait until the update is successful.
func (wrapper FunctionWrapper) UpdateFunctionCode(functionName string, zipPackage 
 *bytes.Buffer) types.State { 
 var state types.State 
 _, err := wrapper.LambdaClient.UpdateFunctionCode(context.TODO(), 
 &lambda.UpdateFunctionCodeInput{ 
  FunctionName: aws.String(functionName), ZipFile: zipPackage.Bytes(), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't update code for function %v. Here's why: %v\n", 
 functionName, err) 
 } else { 
  waiter := lambda.NewFunctionUpdatedV2Waiter(wrapper.LambdaClient) 
  funcOutput, err := waiter.WaitForOutput(context.TODO(), &lambda.GetFunctionInput{ 
   FunctionName: aws.String(functionName)}, 1*time.Minute) 
  if err != nil { 
   log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", 
 functionName, err) 
  } else { 
   state = funcOutput.Configuration.State 
  } 
 } 
 return state
}
•For API details, see UpdateFunctionCode in AWS SDK for Go API Reference.
1167AWS Lambda Developer Guide
Update function code
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const updateFunctionCode = async (funcName, newFunc) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const code = await readFile(`${dirname}../functions/${newFunc}.zip`); 
  const command = new UpdateFunctionCodeCommand({ 
    ZipFile: code, 
    FunctionName: funcName, 
    Architectures: [Architecture.arm64], 
    Handler: "index.handler", // Required when sending a .zip file 
    PackageType: PackageType.Zip, // Required when sending a .zip file 
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file 
  }); 
  return client.send(command);
};
•For API details, see UpdateFunctionCode in AWS SDK for JavaScript API Reference.
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function updateFunctionCode($functionName, $s3Bucket, $s3Key) 
    { 
        return $this->lambdaClient->updateFunctionCode([ 
            'FunctionName' => $functionName, 
            'S3Bucket' => $s3Bucket, 
            'S3Key' => $s3Key, 
        ]); 
    }
•For API details, see UpdateFunctionCode in AWS SDK for PHP API Reference.
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
1168AWS Lambda Developer Guide
Update function code
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def update_function_code(self, function_name, deployment_package): 
        """ 
        Updates the code for a Lambda function by submitting a .zip archive that 
 contains 
        the code for the function. 
        :param function_name: The name of the function to update. 
        :param deployment_package: The function code to update, packaged as bytes 
 in 
                                   .zip format. 
        :return: Data about the update, including the status. 
        """ 
        try: 
            response = self.lambda_client.update_function_code( 
                FunctionName=function_name, ZipFile=deployment_package) 
        except ClientError as err: 
            logger.error( 
                "Couldn't update function %s. Here's why: %s: %s", function_name, 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise 
        else: 
            return response
•For API details, see UpdateFunctionCode in AWS SDK for Python (Boto3) API Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Updates the code for a Lambda function by submitting a .zip archive that 
 contains 
  # the code for the function. 
  # @param function_name: The name of the function to update. 
  # @param deployment_package: The function code to update, packaged as bytes in 
  #                            .zip format. 
  # @return: Data about the update, including the status. 
  def update_function_code(function_name, deployment_package) 
    @lambda_client.update_function_code( 
      function_name: function_name, 
      zip_file: deployment_package 
    ) 
    @lambda_client.wait_until(:function_updated_v2, { function_name: 
 function_name}) do |w| 
      w.max_attempts = 5 
      w.delay = 5 
1169AWS Lambda Developer Guide
Update function code
    end 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error updating function code for: #{function_name}:
\n #{e.message}") 
    nil 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to update:\n #{e.message}") 
  end
•For API details, see UpdateFunctionCode in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** Given a Path to a zip file, update the function's code and wait for the 
 update to finish. */ 
    pub async fn update_function_code( 
        &self, 
        zip_file: PathBuf, 
        key: String, 
    ) -> Result<UpdateFunctionCodeOutput, anyhow::Error> { 
        let function_code = self.prepare_function(zip_file, Some(key)).await?; 
        info!("Updating code for {}", self.lambda_name); 
        let update = self 
            .lambda_client 
            .update_function_code() 
            .function_name(self.lambda_name.clone()) 
            .s3_bucket(self.bucket.clone()) 
            .s3_key(function_code.s3_key().unwrap().to_string()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        Ok(update) 
    } 
    /** 
     * Upload function code from a path to a zip file. 
     * The zip file must have an AL2 Linux-compatible binary called `bootstrap`. 
     * The easiest way to create such a zip is to use `cargo lambda build --output-
format Zip`. 
     */ 
    async fn prepare_function( 
        &self, 
        zip_file: PathBuf, 
        key: Option<String>, 
    ) -> Result<FunctionCode, anyhow::Error> { 
        let body = ByteStream::read_from().path(zip_file).build().await?; 
1170AWS Lambda Developer Guide
Update function code
        let key = key.unwrap_or_else(|| format!("{}_code", self.lambda_name)); 
        info!("Uploading function code to s3://{}/{}", self.bucket, key); 
        let _ = self 
            .s3_client 
            .put_object() 
            .bucket(self.bucket.clone()) 
            .key(key.clone()) 
            .body(body) 
            .send() 
            .await?; 
        Ok(FunctionCode::builder() 
            .s3_bucket(self.bucket.clone()) 
            .s3_key(key) 
            .build()) 
    }
•For API details, see UpdateFunctionCode in AWS SDK for Rust API reference.
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        oo_result = lo_lmd->updatefunctioncode(     " oo_result is returned for 
 testing purposes. " 
              iv_functionname = iv_function_name 
              iv_zipfile = io_zip_file 
          ). 
        MESSAGE 'Lambda function code updated.' TYPE 'I'. 
      CATCH /aws1/cx_lmdcodesigningcfgno00. 
        MESSAGE 'Code signing configuration does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdcodestorageexcdex. 
        MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'. 
      CATCH /aws1/cx_lmdcodeverification00. 
        MESSAGE 'Code signature failed one or more validation checks for signature 
 mismatch or expiration.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvalidcodesigex. 
        MESSAGE 'Code signature failed the integrity check.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdresourceconflictex. 
        MESSAGE 'Resource already exists or another operation is in progress.' TYPE 
 'E'. 
      CATCH /aws1/cx_lmdresourcenotfoundex. 
        MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see UpdateFunctionCode in AWS SDK for SAP ABAP API reference.
1171AWS Lambda Developer Guide
Update function conﬁguration
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Update Lambda function conﬁguration using an AWS 
SDK
The following code examples show how to update Lambda function conﬁguration.
Action examples are code excerpts from larger programs and must be run in context. You can see this 
action in context in the following code example:
•Get started with functions (p. 1178 )
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /// <summary> 
    /// Update the code of a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the function to update.</param> 
    /// <param name="functionHandler">The code that performs the function's 
 actions.</param> 
    /// <param name="environmentVariables">A dictionary of environment variables.</
param> 
    /// <returns>A Boolean value indicating the success of the action.</returns> 
    public async Task<bool> UpdateFunctionConfigurationAsync( 
        string functionName, 
        string functionHandler, 
        Dictionary<string, string> environmentVariables) 
    { 
        var request = new UpdateFunctionConfigurationRequest 
        { 
            Handler = functionHandler, 
            FunctionName = functionName, 
            Environment = new Amazon.Lambda.Model.Environment { Variables = 
 environmentVariables }, 
        }; 
        var response = await 
 _lambdaService.UpdateFunctionConfigurationAsync(request); 
        Console.WriteLine(response.LastModified); 
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK; 
    }
•For API details, see UpdateFunctionConﬁguration in AWS SDK for .NET API Reference.
1172AWS Lambda Developer Guide
Update function conﬁguration
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
        Aws::Client::ClientConfiguration clientConfig; 
        // Optional: Set to the AWS Region in which the bucket was created 
 (overrides config file). 
        // clientConfig.region = "us-east-1"; 
    Aws::Lambda::LambdaClient client(clientConfig); 
        Aws::Lambda::Model::UpdateFunctionConfigurationRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        Aws::Lambda::Model::Environment environment; 
        environment.AddVariables("LOG_LEVEL", "DEBUG"); 
        request.SetEnvironment(environment); 
        Aws::Lambda::Model::UpdateFunctionConfigurationOutcome outcome = 
 client.UpdateFunctionConfiguration( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda configuration was successfully updated." 
                      << std::endl; 
            break; 
        } 
        else { 
            std::cerr << "Error with Lambda::UpdateFunctionConfiguration. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        }
•For API details, see UpdateFunctionConﬁguration in AWS SDK for C++ API Reference.
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// UpdateFunctionConfiguration updates a map of environment variables configured 
 for
// the Lambda function specified by functionName.
1173AWS Lambda Developer Guide
Update function conﬁguration
func (wrapper FunctionWrapper) UpdateFunctionConfiguration(functionName string, 
 envVars map[string]string) { 
 _, err := wrapper.LambdaClient.UpdateFunctionConfiguration(context.TODO(), 
 &lambda.UpdateFunctionConfigurationInput{ 
  FunctionName: aws.String(functionName), 
  Environment:  &types.Environment{Variables: envVars}, 
 }) 
 if err != nil { 
  log.Panicf("Couldn't update configuration for %v. Here's why: %v", functionName, 
 err) 
 }
}
•For API details, see UpdateFunctionConﬁguration in AWS SDK for Go API Reference.
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
const updateFunctionConfiguration = (funcName) => { 
  const client = new LambdaClient({}); 
  const config = readFileSync(`${dirname}../functions/config.json`).toString(); 
  const command = new UpdateFunctionConfigurationCommand({ 
    ...JSON.parse(config), 
    FunctionName: funcName, 
  }); 
  return client.send(command);
};
•For API details, see UpdateFunctionConﬁguration in AWS SDK for JavaScript API Reference.
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    public function updateFunctionConfiguration($functionName, $handler, 
 $environment = '') 
    { 
        return $this->lambdaClient->updateFunctionConfiguration([ 
            'FunctionName' => $functionName, 
            'Handler' => "$handler.lambda_handler", 
            'Environment' => $environment, 
        ]); 
    }
•For API details, see UpdateFunctionConﬁguration in AWS SDK for PHP API Reference.
1174AWS Lambda Developer Guide
Update function conﬁguration
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    def update_function_configuration(self, function_name, env_vars): 
        """ 
        Updates the environment variables for a Lambda function. 
        :param function_name: The name of the function to update. 
        :param env_vars: A dict of environment variables to update. 
        :return: Data about the update, including the status. 
        """ 
        try: 
            response = self.lambda_client.update_function_configuration( 
                FunctionName=function_name, Environment={'Variables': env_vars}) 
        except ClientError as err: 
            logger.error( 
                "Couldn't update function configuration %s. Here's why: %s: %s", 
 function_name, 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise 
        else: 
            return response
•For API details, see UpdateFunctionConﬁguration in AWS SDK for Python (Boto3) API 
Reference.
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
class LambdaWrapper 
  attr_accessor :lambda_client 
  def initialize 
    @lambda_client = Aws::Lambda::Client.new 
    @logger = Logger.new($stdout) 
    @logger.level = Logger::WARN 
  end 
  # Updates the environment variables for a Lambda function. 
  # @param function_name: The name of the function to update. 
  # @param log_level: The log level of the function. 
  # @return: Data about the update, including the status. 
  def update_function_configuration(function_name, log_level) 
    @lambda_client.update_function_configuration({ 
1175AWS Lambda Developer Guide
Update function conﬁguration
                                                   function_name: function_name, 
                                                   environment: { 
                                                     variables: { 
                                                       "LOG_LEVEL" => log_level 
                                                     } 
                                                   } 
                                                 }) 
    @lambda_client.wait_until(:function_updated_v2, { function_name: 
 function_name}) do |w| 
      w.max_attempts = 5 
      w.delay = 5 
    end 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error updating configurations for #{function_name}:
\n #{e.message}") 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to activate:\n 
 #{e.message}") 
  end
•For API details, see UpdateFunctionConﬁguration in AWS SDK for Ruby API Reference.
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    /** Update the environment for a function. */ 
    pub async fn update_function_configuration( 
        &self, 
        environment: Environment, 
    ) -> Result<UpdateFunctionConfigurationOutput, anyhow::Error> { 
        info!( 
            ?environment, 
            "Updating environment for {}", self.lambda_name 
        ); 
        let updated = self 
            .lambda_client 
            .update_function_configuration() 
            .function_name(self.lambda_name.clone()) 
            .environment(environment) 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        Ok(updated) 
    }
•For API details, see UpdateFunctionConﬁguration in AWS SDK for Rust API reference.
1176AWS Lambda Developer Guide
Scenarios
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        oo_result = lo_lmd->updatefunctionconfiguration(     " oo_result is 
 returned for testing purposes. " 
              iv_functionname = iv_function_name 
              iv_runtime = iv_runtime 
              iv_description  = 'Updated Lambda function' 
              iv_memorysize  = iv_memory_size 
          ). 
        MESSAGE 'Lambda function configuration/settings updated.' TYPE 'I'. 
      CATCH /aws1/cx_lmdcodesigningcfgno00. 
        MESSAGE 'Code signing configuration does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdcodeverification00. 
        MESSAGE 'Code signature failed one or more validation checks for signature 
 mismatch or expiration.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvalidcodesigex. 
        MESSAGE 'Code signature failed the integrity check.' TYPE 'E'. 
      CATCH /aws1/cx_lmdinvparamvalueex. 
        MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
      CATCH /aws1/cx_lmdresourceconflictex. 
        MESSAGE 'Resource already exists or another operation is in progress.' TYPE 
 'E'. 
      CATCH /aws1/cx_lmdresourcenotfoundex. 
        MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
      CATCH /aws1/cx_lmdserviceexception. 
        MESSAGE 'An internal problem was encountered by the AWS Lambda service.' 
 TYPE 'E'. 
      CATCH /aws1/cx_lmdtoomanyrequestsex. 
        MESSAGE 'The maximum request throughput was reached.' TYPE 'E'. 
    ENDTRY.
•For API details, see UpdateFunctionConﬁguration in AWS SDK for SAP ABAP API reference.
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Scenarios for Lambda using AWS SDKs
The following code examples show you how to implement common scenarios in Lambda with AWS SDKs. 
These scenarios show you how to accomplish speciﬁc tasks by calling multiple functions within Lambda. 
Each scenario includes a link to GitHub, where you can ﬁnd instructions on how to set up and run the 
code.
Examples
•Get started creating and invoking Lambda functions using an AWS SDK (p. 1178 )
1177AWS Lambda Developer Guide
Get started with functions
Get started creating and invoking Lambda functions 
using an AWS SDK
The following code examples show how to:
•Create an IAM role and Lambda function, then upload handler code.
•Invoke the function with a single parameter and get results.
•Update the function code and conﬁgure with an environment variable.
•Invoke the function with new parameters and get results. Display the returned execution log.
•List the functions for your account, then clean up resources.
For more information, see Create a Lambda function with the console.
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Create methods that perform Lambda actions.
namespace LambdaActions;
using Amazon.Lambda;
using Amazon.Lambda.Model;
/// <summary>
/// A class that implements AWS Lambda methods.
/// </summary>
public class LambdaWrapper
{ 
    private readonly IAmazonLambda _lambdaService; 
    /// <summary> 
    /// Constructor for the LambdaWrapper class. 
    /// </summary> 
    /// <param name="lambdaService">An initialized Lambda service client.</param> 
    public LambdaWrapper(IAmazonLambda lambdaService) 
    { 
        _lambdaService = lambdaService; 
    } 
    /// <summary> 
    /// Creates a new Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the function.</param> 
    /// <param name="s3Bucket">The Amazon Simple Storage Service (Amazon S3) 
    /// bucket where the zip file containing the code is located.</param> 
    /// <param name="s3Key">The Amazon S3 key of the zip file.</param> 
    /// <param name="role">The Amazon Resource Name (ARN) of a role with the 
    /// appropriate Lambda permissions.</param> 
    /// <param name="handler">The name of the handler function.</param> 
    /// <returns>The Amazon Resource Name (ARN) of the newly created 
    /// Lambda function.</returns> 
    public async Task<string> CreateLambdaFunctionAsync( 
        string functionName, 
        string s3Bucket, 
        string s3Key, 
1178AWS Lambda Developer Guide
Get started with functions
        string role, 
        string handler) 
    { 
        // Defines the location for the function code. 
        // S3Bucket - The S3 bucket where the file containing 
        //            the source code is stored. 
        // S3Key    - The name of the file containing the code. 
        var functionCode = new FunctionCode 
        { 
            S3Bucket = s3Bucket, 
            S3Key = s3Key, 
        }; 
        var createFunctionRequest = new CreateFunctionRequest 
        { 
            FunctionName = functionName, 
            Description = "Created by the Lambda .NET API", 
            Code = functionCode, 
            Handler = handler, 
            Runtime = Runtime.Dotnet6, 
            Role = role, 
        }; 
        var reponse = await 
 _lambdaService.CreateFunctionAsync(createFunctionRequest); 
        return reponse.FunctionArn; 
    } 
    /// <summary> 
    /// Delete an AWS Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to 
    /// delete.</param> 
    /// <returns>A Boolean value that indicates the success of the action.</
returns> 
    public async Task<bool> DeleteFunctionAsync(string functionName) 
    { 
        var request = new DeleteFunctionRequest 
        { 
            FunctionName = functionName, 
        }; 
        var response = await _lambdaService.DeleteFunctionAsync(request); 
        // A return value of NoContent means that the request was processed. 
        // In this case, the function was deleted, and the return value 
        // is intentionally blank. 
        return response.HttpStatusCode == System.Net.HttpStatusCode.NoContent; 
    } 
    /// <summary> 
    /// Gets information about a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function for 
    /// which to retrieve information.</param> 
    /// <returns>Async Task.</returns> 
    public async Task<FunctionConfiguration> GetFunctionAsync(string functionName) 
    { 
        var functionRequest = new GetFunctionRequest 
        { 
            FunctionName = functionName, 
        }; 
        var response = await _lambdaService.GetFunctionAsync(functionRequest); 
1179AWS Lambda Developer Guide
Get started with functions
        return response.Configuration; 
    } 
    /// <summary> 
    /// Invoke a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to 
    /// invoke.</param 
    /// <param name="parameters">The parameter values that will be passed to the 
 function.</param> 
    /// <returns>A System Threading Task.</returns> 
    public async Task<string> InvokeFunctionAsync( 
        string functionName, 
        string parameters) 
    { 
        var payload = parameters; 
        var request = new InvokeRequest 
        { 
            FunctionName = functionName, 
            Payload = payload, 
        }; 
        var response = await _lambdaService.InvokeAsync(request); 
        MemoryStream stream = response.Payload; 
        string returnValue = System.Text.Encoding.UTF8.GetString(stream.ToArray()); 
        return returnValue; 
    } 
    /// <summary> 
    /// Get a list of Lambda functions. 
    /// </summary> 
    /// <returns>A list of FunctionConfiguration objects.</returns> 
    public async Task<List<FunctionConfiguration>> ListFunctionsAsync() 
    { 
        var functionList = new List<FunctionConfiguration>(); 
        var functionPaginator = 
            _lambdaService.Paginators.ListFunctions(new ListFunctionsRequest()); 
        await foreach (var function in functionPaginator.Functions) 
        { 
            functionList.Add(function); 
        } 
        return functionList; 
    } 
    /// <summary> 
    /// Update an existing Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the Lambda function to update.</
param> 
    /// <param name="bucketName">The bucket where the zip file containing 
    /// the Lambda function code is stored.</param> 
    /// <param name="key">The key name of the source code file.</param> 
    /// <returns>Async Task.</returns> 
    public async Task UpdateFunctionCodeAsync( 
        string functionName, 
        string bucketName, 
        string key) 
    { 
        var functionCodeRequest = new UpdateFunctionCodeRequest 
        { 
            FunctionName = functionName, 
1180AWS Lambda Developer Guide
Get started with functions
            Publish = true, 
            S3Bucket = bucketName, 
            S3Key = key, 
        }; 
        var response = await 
 _lambdaService.UpdateFunctionCodeAsync(functionCodeRequest); 
        Console.WriteLine($"The Function was last modified at 
 {response.LastModified}."); 
    } 
    /// <summary> 
    /// Update the code of a Lambda function. 
    /// </summary> 
    /// <param name="functionName">The name of the function to update.</param> 
    /// <param name="functionHandler">The code that performs the function's 
 actions.</param> 
    /// <param name="environmentVariables">A dictionary of environment variables.</
param> 
    /// <returns>A Boolean value indicating the success of the action.</returns> 
    public async Task<bool> UpdateFunctionConfigurationAsync( 
        string functionName, 
        string functionHandler, 
        Dictionary<string, string> environmentVariables) 
    { 
        var request = new UpdateFunctionConfigurationRequest 
        { 
            Handler = functionHandler, 
            FunctionName = functionName, 
            Environment = new Amazon.Lambda.Model.Environment { Variables = 
 environmentVariables }, 
        }; 
        var response = await 
 _lambdaService.UpdateFunctionConfigurationAsync(request); 
        Console.WriteLine(response.LastModified); 
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK; 
    }
}
Create a function that runs the scenario.
global using LambdaActions;
global using LambdaScenarioCommon;
global using Amazon.Lambda;
global using Amazon.IdentityManagement;
global using System.Threading.Tasks;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Hosting;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Logging.Console;
global using Microsoft.Extensions.Logging.Debug;
using Amazon.IdentityManagement;
using Amazon.Lambda.Model;
using Microsoft.Extensions.Configuration;
1181AWS Lambda Developer Guide
Get started with functions
namespace LambdaBasics;
public class LambdaBasics
{ 
    private static ILogger logger = null!; 
    static async Task Main(string[] args) 
    { 
        // Set up dependency injection for the Amazon service. 
        using var host = Host.CreateDefaultBuilder(args) 
            .ConfigureLogging(logging => 
                logging.AddFilter("System", LogLevel.Debug) 
                    .AddFilter<DebugLoggerProvider>("Microsoft", 
 LogLevel.Information) 
                    .AddFilter<ConsoleLoggerProvider>("Microsoft", LogLevel.Trace)) 
            .ConfigureServices((_, services) => 
            services.AddAWSService<IAmazonLambda>() 
            .AddAWSService<IAmazonIdentityManagementService>() 
            .AddTransient<LambdaWrapper>() 
            .AddTransient<LambdaRoleWrapper>() 
            .AddTransient<UIWrapper>() 
        ) 
        .Build(); 
        var configuration = new ConfigurationBuilder() 
            .SetBasePath(Directory.GetCurrentDirectory()) 
            .AddJsonFile("settings.json") // Load test settings from .json file. 
            .AddJsonFile("settings.local.json", 
            true) // Optionally load local settings. 
        .Build(); 
        logger = LoggerFactory.Create(builder => { builder.AddConsole(); }) 
            .CreateLogger<LambdaBasics>(); 
        var lambdaWrapper = host.Services.GetRequiredService<LambdaWrapper>(); 
        var lambdaRoleWrapper = 
 host.Services.GetRequiredService<LambdaRoleWrapper>(); 
        var uiWrapper = host.Services.GetRequiredService<UIWrapper>(); 
        string functionName = configuration["FunctionName"]; 
        string roleName = configuration["RoleName"]; 
        string policyDocument = "{" + 
            " \"Version\": \"2012-10-17\"," + 
            " \"Statement\": [ " + 
            "    {" + 
            "        \"Effect\": \"Allow\"," + 
            "        \"Principal\": {" + 
            "            \"Service\": \"lambda.amazonaws.com\" " + 
            "    }," + 
            "        \"Action\": \"sts:AssumeRole\" " + 
            "    }" + 
            "]" + 
        "}"; 
        var incrementHandler = configuration["IncrementHandler"]; 
        var calculatorHandler = configuration["CalculatorHandler"]; 
        var bucketName = configuration["BucketName"]; 
        var incrementKey = configuration["IncrementKey"]; 
        var calculatorKey = configuration["CalculatorKey"]; 
        var policyArn = configuration["PolicyArn"]; 
        uiWrapper.DisplayLambdaBasicsOverview(); 
        // Create the policy to use with the AWS Lambda functions and then attach 
 the 
1182AWS Lambda Developer Guide
Get started with functions
        // policy to a new role. 
        var roleArn = await lambdaRoleWrapper.CreateLambdaRoleAsync(roleName, 
 policyDocument); 
        Console.WriteLine("Waiting for role to become active."); 
        uiWrapper.WaitABit(15, "Wait until the role is active before trying to use 
 it."); 
        // Attach the appropriate AWS Identity and Access Management (IAM) role 
 policy to the new role. 
        var success = await 
 lambdaRoleWrapper.AttachLambdaRolePolicyAsync(policyArn, roleName); 
        uiWrapper.WaitABit(10, "Allow time for the IAM policy to be attached to the 
 role."); 
        // Create the Lambda function using a zip file stored in an Amazon Simple 
 Storage Service 
        // (Amazon S3) bucket. 
        uiWrapper.DisplayTitle("Create Lambda Function"); 
        Console.WriteLine($"Creating the AWS Lambda function: {functionName}."); 
        var lambdaArn = await lambdaWrapper.CreateLambdaFunctionAsync( 
            functionName, 
            bucketName, 
            incrementKey, 
            roleArn, 
            incrementHandler); 
        Console.WriteLine("Waiting for the new function to be available."); 
        Console.WriteLine($"The AWS Lambda ARN is {lambdaArn}"); 
        // Get the Lambda function. 
        Console.WriteLine($"Getting the {functionName} AWS Lambda function."); 
        FunctionConfiguration config; 
        do 
        { 
            config = await lambdaWrapper.GetFunctionAsync(functionName); 
            Console.Write("."); 
        } 
        while (config.State != State.Active); 
        Console.WriteLine($"\nThe function, {functionName} has been created."); 
        Console.WriteLine($"The runtime of this Lambda function is 
 {config.Runtime}."); 
        uiWrapper.PressEnter(); 
        // List the Lambda functions. 
        uiWrapper.DisplayTitle("Listing all Lambda functions."); 
        var functions = await lambdaWrapper.ListFunctionsAsync(); 
        DisplayFunctionList(functions); 
        uiWrapper.DisplayTitle("Invoke increment function"); 
        Console.WriteLine("Now that it has been created, invoke the Lambda 
 increment function."); 
        string? value; 
        do 
        { 
            Console.Write("Enter a value to increment: "); 
            value = Console.ReadLine(); 
        } 
        while (string.IsNullOrEmpty(value)); 
        string functionParameters = "{" + 
            "\"action\": \"increment\", " + 
            "\"x\": \"" + value + "\"" + 
        "}"; 
1183AWS Lambda Developer Guide
Get started with functions
        var answer = await lambdaWrapper.InvokeFunctionAsync(functionName, 
 functionParameters); 
        Console.WriteLine($"{value} + 1 = {answer}."); 
        uiWrapper.DisplayTitle("Update function"); 
        Console.WriteLine("Now update the Lambda function code."); 
        await lambdaWrapper.UpdateFunctionCodeAsync(functionName, bucketName, 
 calculatorKey); 
        do 
        { 
            config = await lambdaWrapper.GetFunctionAsync(functionName); 
            Console.Write("."); 
        } 
        while (config.LastUpdateStatus == LastUpdateStatus.InProgress); 
        await lambdaWrapper.UpdateFunctionConfigurationAsync( 
            functionName, 
            calculatorHandler, 
            new Dictionary<string, string> { { "LOG_LEVEL", "DEBUG" } }); 
        do 
        { 
            config = await lambdaWrapper.GetFunctionAsync(functionName); 
            Console.Write("."); 
        } 
        while (config.LastUpdateStatus == LastUpdateStatus.InProgress); 
        uiWrapper.DisplayTitle("Call updated function"); 
        Console.WriteLine("Now call the updated function..."); 
        bool done = false; 
        do 
        { 
            string? opSelected; 
            Console.WriteLine("Select the operation to perform:"); 
            Console.WriteLine("\t1. add"); 
            Console.WriteLine("\t2. subtract"); 
            Console.WriteLine("\t3. multiply"); 
            Console.WriteLine("\t4. divide"); 
            Console.WriteLine("\tOr enter \"q\" to quit."); 
            Console.WriteLine("Enter the number (1, 2, 3, 4, or q) of the operation 
 you want to perform: "); 
            do 
            { 
                Console.Write("Your choice? "); 
                opSelected = Console.ReadLine(); 
            } 
            while (opSelected == string.Empty); 
            var operation = (opSelected) switch 
            { 
                "1" => "add", 
                "2" => "subtract", 
                "3" => "multiply", 
                "4" => "divide", 
                "q" => "quit", 
                _ => "add", 
            }; 
            if (operation == "quit") 
            { 
                done = true; 
            } 
1184AWS Lambda Developer Guide
Get started with functions
            else 
            { 
                // Get two numbers and an action from the user. 
                value = string.Empty; 
                do 
                { 
                    Console.Write("Enter the first value: "); 
                    value = Console.ReadLine(); 
                } 
                while (value == string.Empty); 
                string? value2; 
                do 
                { 
                    Console.Write("Enter a second value: "); 
                    value2 = Console.ReadLine(); 
                } 
                while (value2 == string.Empty); 
                functionParameters = "{" + 
                    "\"action\": \"" + operation + "\", " + 
                    "\"x\": \"" + value + "\"," + 
                    "\"y\": \"" + value2 + "\"" + 
                "}"; 
                answer = await lambdaWrapper.InvokeFunctionAsync(functionName, 
 functionParameters); 
                Console.WriteLine($"The answer when we {operation} the two numbers 
 is: {answer}."); 
            } 
            uiWrapper.PressEnter(); 
        } while (!done); 
        // Delete the function created earlier. 
        uiWrapper.DisplayTitle("Clean up resources"); 
        // Detach the IAM policy from the IAM role. 
        Console.WriteLine("First detach the IAM policy from the role."); 
        success = await lambdaRoleWrapper.DetachLambdaRolePolicyAsync(policyArn, 
 roleName); 
        uiWrapper.WaitABit(15, "Let's wait for the policy to be fully detached from 
 the role."); 
        Console.WriteLine("Delete the AWS Lambda function."); 
        success = await lambdaWrapper.DeleteFunctionAsync(functionName); 
        if (success) 
        { 
            Console.WriteLine($"The {functionName} function was deleted."); 
        } 
        else 
        { 
            Console.WriteLine($"Could not remove the function {functionName}"); 
        } 
        // Now delete the IAM role created for use with the functions 
        // created by the application. 
        Console.WriteLine("Now we can delete the role that we created."); 
        success = await lambdaRoleWrapper.DeleteLambdaRoleAsync(roleName); 
        if (success) 
        { 
            Console.WriteLine("The role has been successfully removed."); 
        } 
        else 
        { 
            Console.WriteLine("Couldn't delete the role."); 
1185AWS Lambda Developer Guide
Get started with functions
        } 
        Console.WriteLine("The Lambda Scenario is now complete."); 
        uiWrapper.PressEnter(); 
        // Displays a formatted list of existing functions returned by the 
        // LambdaMethods.ListFunctions. 
        void DisplayFunctionList(List<FunctionConfiguration> functions) 
        { 
            functions.ForEach(functionConfig => 
            { 
                
 Console.WriteLine($"{functionConfig.FunctionName}\t{functionConfig.Description}"); 
            }); 
        } 
    }
}
namespace LambdaActions;
using Amazon.IdentityManagement;
using Amazon.IdentityManagement.Model;
public class LambdaRoleWrapper
{ 
    private readonly IAmazonIdentityManagementService _lambdaRoleService; 
    public LambdaRoleWrapper(IAmazonIdentityManagementService lambdaRoleService) 
    { 
        _lambdaRoleService = lambdaRoleService; 
    } 
    /// <summary> 
    /// Attach an AWS Identity and Access Management (IAM) role policy to the 
    /// IAM role to be assumed by the AWS Lambda functions created for the 
 scenario. 
    /// </summary> 
    /// <param name="policyArn">The Amazon Resource Name (ARN) of the IAM policy.</
param> 
    /// <param name="roleName">The name of the IAM role to attach the IAM policy 
 to.</param> 
    /// <returns>A Boolean value indicating the success of the action.</returns> 
    public async Task<bool> AttachLambdaRolePolicyAsync(string policyArn, string 
 roleName) 
    { 
        var response = await _lambdaRoleService.AttachRolePolicyAsync(new 
 AttachRolePolicyRequest { PolicyArn = policyArn, RoleName = roleName }); 
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK; 
    } 
    /// <summary> 
    /// Create a new IAM role. 
    /// </summary> 
    /// <param name="roleName">The name of the IAM role to create.</param> 
    /// <param name="policyDocument">The policy document for the new IAM role.</
param> 
    /// <returns>A string representing the ARN for newly created role.</returns> 
    public async Task<string> CreateLambdaRoleAsync(string roleName, string 
 policyDocument) 
    { 
        var request = new CreateRoleRequest 
        { 
            AssumeRolePolicyDocument = policyDocument, 
            RoleName = roleName, 
        }; 
1186AWS Lambda Developer Guide
Get started with functions
        var response = await _lambdaRoleService.CreateRoleAsync(request); 
        return response.Role.Arn; 
    } 
    /// <summary> 
    /// Deletes an IAM role. 
    /// </summary> 
    /// <param name="roleName">The name of the role to delete.</param> 
    /// <returns>A Boolean value indicating the success of the operation.</returns> 
    public async Task<bool> DeleteLambdaRoleAsync(string roleName) 
    { 
        var request = new DeleteRoleRequest 
        { 
            RoleName = roleName, 
        }; 
        var response = await _lambdaRoleService.DeleteRoleAsync(request); 
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK; 
    } 
    public async Task<bool> DetachLambdaRolePolicyAsync(string policyArn, string 
 roleName) 
    { 
        var response = await _lambdaRoleService.DetachRolePolicyAsync(new 
 DetachRolePolicyRequest { PolicyArn = policyArn, RoleName = roleName }); 
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK; 
    }
}
namespace LambdaScenarioCommon;
public class UIWrapper
{ 
    public readonly string SepBar = new('-', Console.WindowWidth); 
    /// <summary> 
    /// Show information about the AWS Lambda Basics scenario. 
    /// </summary> 
    public void DisplayLambdaBasicsOverview() 
    { 
        Console.Clear(); 
        DisplayTitle("Welcome to AWS Lambda Basics"); 
        Console.WriteLine("This example application does the following:"); 
        Console.WriteLine("\t1. Creates an AWS Identity and Access Management (IAM) 
 role that will be assumed by the functions we create."); 
        Console.WriteLine("\t2. Attaches an IAM role policy that has Lambda 
 permissions."); 
        Console.WriteLine("\t3. Creates a Lambda function that increments the value 
 passed to it."); 
        Console.WriteLine("\t4. Calls the increment function and passes a value."); 
        Console.WriteLine("\t5. Updates the code so that the function is a simple 
 calculator."); 
        Console.WriteLine("\t6. Calls the calculator function with the values 
 entered."); 
        Console.WriteLine("\t7. Deletes the Lambda function."); 
        Console.WriteLine("\t7. Detaches the IAM role policy."); 
        Console.WriteLine("\t8. Deletes the IAM role."); 
        PressEnter(); 
    } 
    /// <summary> 
    /// Display a message and wait until the user presses enter. 
    /// </summary> 
    public void PressEnter() 
1187AWS Lambda Developer Guide
Get started with functions
    { 
        Console.Write("\nPress <Enter> to continue. "); 
        _ = Console.ReadLine(); 
        Console.WriteLine(); 
    } 
    /// <summary> 
    /// Pad a string with spaces to center it on the console display. 
    /// </summary> 
    /// <param name="strToCenter">The string to be centered.</param> 
    /// <returns>The padded string.</returns> 
    public string CenterString(string strToCenter) 
    { 
        var padAmount = (Console.WindowWidth - strToCenter.Length) / 2; 
        var leftPad = new string(' ', padAmount); 
        return $"{leftPad}{strToCenter}"; 
    } 
    /// <summary> 
    /// Display a line of hyphens, the centered text of the title and another 
    /// line of hyphens. 
    /// </summary> 
    /// <param name="strTitle">The string to be displayed.</param> 
    public void DisplayTitle(string strTitle) 
    { 
        Console.WriteLine(SepBar); 
        Console.WriteLine(CenterString(strTitle)); 
        Console.WriteLine(SepBar); 
    } 
    /// <summary> 
    /// Display a countdown and wait for a number of seconds. 
    /// </summary> 
    /// <param name="numSeconds">The number of seconds to wait.</param> 
    public void WaitABit(int numSeconds, string msg) 
    { 
        Console.WriteLine(msg); 
        // Wait for the requested number of seconds. 
        for (int i = numSeconds; i > 0; i--) 
        { 
            System.Threading.Thread.Sleep(1000); 
            Console.Write($"{i}..."); 
        } 
        PressEnter(); 
    }
}
Deﬁne a Lambda handler that increments a number.
using Amazon.Lambda.Core;
// Assembly attribute to enable the Lambda function's JSON input to be converted 
 into a .NET class.
[assembly: 
 LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]
namespace LambdaIncrement;
public class Function
{ 
1188AWS Lambda Developer Guide
Get started with functions
    /// <summary> 
    /// A simple function increments the integer parameter. 
    /// </summary> 
    /// <param name="input">A JSON string containing an action, which must be 
    /// "increment" and a string representing the value to increment.</param> 
    /// <param name="context">The context object passed by Lambda containing 
    /// information about invocation, function, and execution environment.</param> 
    /// <returns>A string representing the incremented value of the parameter.</
returns> 
    public int FunctionHandler(Dictionary<string, string> input, ILambdaContext 
 context) 
    { 
        if (input["action"] == "increment") 
        { 
            int inputValue = Convert.ToInt32(input["x"]); 
            return inputValue + 1; 
        } 
        else 
        { 
            return 0; 
        } 
    }
}
Deﬁne a second Lambda handler that performs arithmetic operations.
using Amazon.Lambda.Core;
using System.Diagnostics;
// Assembly attribute to enable the Lambda function's JSON input to be converted 
 into a .NET class.
[assembly: 
 LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]
namespace LambdaCalculator;
public class Function
{ 
    /// <summary> 
    /// A simple function that takes two number in string format and performs 
    /// the requested arithmetic function. 
    /// </summary> 
    /// <param name="input">JSON data containing an action, and x and y values. 
    /// Valid actions include: add, subtract, multiply, and divide.</param> 
    /// <param name="context">The context object passed by Lambda containing 
    /// information about invocation, function, and execution environment.</param> 
    /// <returns>A string representing the results of the calculation.</returns> 
    public int FunctionHandler(Dictionary<string, string> input, ILambdaContext 
 context) 
    { 
        var action = input["action"]; 
        int x = Convert.ToInt32(input["x"]); 
        int y = Convert.ToInt32(input["y"]); 
        int result; 
        switch (action) 
        { 
            case "add": 
                result = x + y; 
                break; 
            case "subtract": 
                result = x - y; 
                break; 
1189AWS Lambda Developer Guide
Get started with functions
            case "multiply": 
                result = x * y; 
                break; 
            case "divide": 
                if (y == 0) 
                { 
                    Console.Error.WriteLine("Divide by zero error."); 
                    result = 0; 
                } 
                else 
                    result = x / y; 
                break; 
            default: 
                Console.Error.WriteLine($"{action} is not a valid operation."); 
                result = 0; 
                break; 
        } 
        return result; 
    }
}
•For API details, see the following topics in AWS SDK for .NET API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
C++
SDK for C++
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
//! Get started with functions scenario.
/*! 
 \param clientConfig: AWS client configuration. 
 \return bool: Successful completion. 
 */
bool AwsDoc::Lambda::getStartedWithFunctionsScenario( 
        const Aws::Client::ClientConfiguration &clientConfig) { 
    Aws::Lambda::LambdaClient client(clientConfig); 
    // 1. Create an AWS Identity and Access Management (IAM) role for Lambda 
 function. 
    Aws::String roleArn; 
    if (!getIamRoleArn(roleArn, clientConfig)) { 
        return false; 
    } 
    // 2. Create a Lambda function. 
    int seconds = 0; 
    do { 
1190AWS Lambda Developer Guide
Get started with functions
        Aws::Lambda::Model::CreateFunctionRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        request.SetDescription(LAMBDA_DESCRIPTION); // Optional.
#if USE_CPP_LAMBDA_FUNCTION 
        request.SetRuntime(Aws::Lambda::Model::Runtime::provided_al2); 
        request.SetTimeout(15); 
        request.SetMemorySize(128); 
        // Assume the AWS Lambda function was built in Docker with same 
 architecture 
        // as this code.
#if  defined(__x86_64__) 
        request.SetArchitectures({Aws::Lambda::Model::Architecture::x86_64});
#elif defined(__aarch64__) 
        request.SetArchitectures({Aws::Lambda::Model::Architecture::arm64});
#else
#error "Unimplemented architecture"
#endif // defined(architecture)
#else 
        request.SetRuntime(Aws::Lambda::Model::Runtime::python3_8);
#endif 
        request.SetRole(roleArn); 
        request.SetHandler(LAMBDA_HANDLER_NAME); 
        request.SetPublish(true); 
        Aws::Lambda::Model::FunctionCode code; 
        std::ifstream ifstream(INCREMENT_LAMBDA_CODE.c_str(), 
                               std::ios_base::in | std::ios_base::binary); 
        if (!ifstream.is_open()) { 
            std::cerr << "Error opening file " << INCREMENT_LAMBDA_CODE << "." << 
 std::endl;
#if USE_CPP_LAMBDA_FUNCTION 
            std::cerr 
                    << "The cpp Lambda function must be built following the 
 instructions in the cpp_lambda/README.md file. " 
                    << std::endl;
#endif 
            deleteIamRole(clientConfig); 
            return false; 
        } 
        Aws::StringStream buffer; 
        buffer << ifstream.rdbuf(); 
        code.SetZipFile(Aws::Utils::ByteBuffer((unsigned char *) 
 buffer.str().c_str(), 
                                               buffer.str().length())); 
        request.SetCode(code); 
        Aws::Lambda::Model::CreateFunctionOutcome outcome = client.CreateFunction( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda function was successfully created. " << 
 seconds 
                      << " seconds elapsed." << std::endl; 
            break; 
        } 
        else if (outcome.GetError().GetErrorType() == 
                 Aws::Lambda::LambdaErrors::INVALID_PARAMETER_VALUE && 
                 outcome.GetError().GetMessage().find("role") >= 0) { 
            if ((seconds % 5) == 0) { // Log status every 10 seconds. 
                std::cout 
                        << "Waiting for the IAM role to become available as a 
 CreateFunction parameter. " 
                        << seconds 
1191AWS Lambda Developer Guide
Get started with functions
                        << " seconds elapsed." << std::endl; 
                std::cout << outcome.GetError().GetMessage() << std::endl; 
            } 
        } 
        else { 
            std::cerr << "Error with CreateFunction. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
            deleteIamRole(clientConfig); 
            return false; 
        } 
        ++seconds; 
        std::this_thread::sleep_for(std::chrono::seconds(1)); 
    } while (60 > seconds); 
    std::cout << "The current Lambda function increments 1 by an input." << 
 std::endl; 
    // 3.  Invoke the Lambda function. 
    { 
        int increment = askQuestionForInt("Enter an increment integer: "); 
        Aws::Lambda::Model::InvokeResult invokeResult; 
        Aws::Utils::Json::JsonValue jsonPayload; 
        jsonPayload.WithString("action", "increment"); 
        jsonPayload.WithInteger("number", increment); 
        if (invokeLambdaFunction(jsonPayload, Aws::Lambda::Model::LogType::Tail, 
                                 invokeResult, client)) { 
            Aws::Utils::Json::JsonValue jsonValue(invokeResult.GetPayload()); 
            Aws::Map<Aws::String, Aws::Utils::Json::JsonView> values = 
                    jsonValue.View().GetAllObjects(); 
            auto iter = values.find("result"); 
            if (iter != values.end() && iter->second.IsIntegerType()) { 
                { 
                    std::cout << INCREMENT_RESUlT_PREFIX 
                              << iter->second.AsInteger() << std::endl; 
                } 
            } 
            else { 
                std::cout << "There was an error in execution. Here is the log." 
                          << std::endl; 
                Aws::Utils::ByteBuffer buffer = 
 Aws::Utils::HashingUtils::Base64Decode( 
                        invokeResult.GetLogResult()); 
                std::cout << "With log " << buffer.GetUnderlyingData() << 
 std::endl; 
            } 
        } 
    } 
    std::cout 
            << "The Lambda function will now be updated with new code. Press return 
 to continue, "; 
    Aws::String answer; 
    std::getline(std::cin, answer); 
    // 4.  Update the Lambda function code. 
    { 
        Aws::Lambda::Model::UpdateFunctionCodeRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        std::ifstream ifstream(CALCULATOR_LAMBDA_CODE.c_str(), 
                               std::ios_base::in | std::ios_base::binary); 
        if (!ifstream.is_open()) { 
            std::cerr << "Error opening file " << INCREMENT_LAMBDA_CODE << "." << 
 std::endl;
1192AWS Lambda Developer Guide
Get started with functions
#if USE_CPP_LAMBDA_FUNCTION 
            std::cerr 
                    << "The cpp Lambda function must be built following the 
 instructions in the cpp_lambda/README.md file. " 
                    << std::endl;
#endif 
            deleteLambdaFunction(client); 
            deleteIamRole(clientConfig); 
            return false; 
        } 
        Aws::StringStream buffer; 
        buffer << ifstream.rdbuf(); 
        request.SetZipFile( 
                Aws::Utils::ByteBuffer((unsigned char *) buffer.str().c_str(), 
                                       buffer.str().length())); 
        request.SetPublish(true); 
        Aws::Lambda::Model::UpdateFunctionCodeOutcome outcome = 
 client.UpdateFunctionCode( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda code was successfully updated." << std::endl; 
        } 
        else { 
            std::cerr << "Error with Lambda::UpdateFunctionCode. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        } 
    } 
    std::cout 
            << "This function uses an environment variable to control the logging 
 level." 
            << std::endl; 
    std::cout 
            << "UpdateFunctionConfiguration will be used to set the LOG_LEVEL to 
 DEBUG." 
            << std::endl; 
    seconds = 0; 
    // 5.  Update the Lambda function configuration. 
    do { 
        ++seconds; 
        std::this_thread::sleep_for(std::chrono::seconds(1)); 
        Aws::Lambda::Model::UpdateFunctionConfigurationRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        Aws::Lambda::Model::Environment environment; 
        environment.AddVariables("LOG_LEVEL", "DEBUG"); 
        request.SetEnvironment(environment); 
        Aws::Lambda::Model::UpdateFunctionConfigurationOutcome outcome = 
 client.UpdateFunctionConfiguration( 
                request); 
        if (outcome.IsSuccess()) { 
            std::cout << "The lambda configuration was successfully updated." 
                      << std::endl; 
            break; 
        } 
            // RESOURCE_IN_USE: function code update not completed. 
        else if (outcome.GetError().GetErrorType() != 
                 Aws::Lambda::LambdaErrors::RESOURCE_IN_USE) { 
1193AWS Lambda Developer Guide
Get started with functions
            if ((seconds % 10) == 0) { // Log status every 10 seconds. 
                std::cout << "Lambda function update in progress . After " << 
 seconds 
                          << " seconds elapsed." << std::endl; 
            } 
        } 
        else { 
            std::cerr << "Error with Lambda::UpdateFunctionConfiguration. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        } 
    } while (0 < seconds); 
    if (0 > seconds) { 
        std::cerr << "Function failed to become active." << std::endl; 
    } 
    else { 
        std::cout << "Updated function active after " << seconds << " seconds." 
                  << std::endl; 
    } 
    std::cout 
            << "\nThe new code applies an arithmetic operator to two variables, x 
 an y." 
            << std::endl; 
    std::vector<Aws::String> operators = {"plus", "minus", "times", "divided-by"}; 
    for (size_t i = 0; i < operators.size(); ++i) { 
        std::cout << "   " << i + 1 << " " << operators[i] << std::endl; 
    } 
    // 6.  Invoke the updated Lambda function. 
    do { 
        int operatorIndex = askQuestionForIntRange("Select an operator index 1 - 4 
 ", 1, 
                                                   4); 
        int x = askQuestionForInt("Enter an integer for the x value "); 
        int y = askQuestionForInt("Enter an integer for the y value "); 
        Aws::Utils::Json::JsonValue calculateJsonPayload; 
        calculateJsonPayload.WithString("action", operators[operatorIndex - 1]); 
        calculateJsonPayload.WithInteger("x", x); 
        calculateJsonPayload.WithInteger("y", y); 
        Aws::Lambda::Model::InvokeResult calculatedResult; 
        if (invokeLambdaFunction(calculateJsonPayload, 
                                 Aws::Lambda::Model::LogType::Tail, 
                                 calculatedResult, client)) { 
            Aws::Utils::Json::JsonValue jsonValue(calculatedResult.GetPayload()); 
            Aws::Map<Aws::String, Aws::Utils::Json::JsonView> values = 
                    jsonValue.View().GetAllObjects(); 
            auto iter = values.find("result"); 
            if (iter != values.end() && iter->second.IsIntegerType()) { 
                std::cout << ARITHMETIC_RESUlT_PREFIX << x << " " 
                          << operators[operatorIndex - 1] << " " 
                          << y << " is " << iter->second.AsInteger() << std::endl; 
            } 
            else if (iter != values.end() && iter->second.IsFloatingPointType()) { 
                std::cout << ARITHMETIC_RESUlT_PREFIX << x << " " 
                          << operators[operatorIndex - 1] << " " 
                          << y << " is " << iter->second.AsDouble() << std::endl; 
            } 
            else { 
                std::cout << "There was an error in execution. Here is the log." 
                          << std::endl; 
                Aws::Utils::ByteBuffer buffer = 
 Aws::Utils::HashingUtils::Base64Decode( 
1194AWS Lambda Developer Guide
Get started with functions
                        calculatedResult.GetLogResult()); 
                std::cout << "With log " << buffer.GetUnderlyingData() << 
 std::endl; 
            } 
        } 
        answer = askQuestion("Would you like to try another operation? (y/n) "); 
    } while (answer == "y"); 
    std::cout 
            << "A list of the lambda functions will be retrieved. Press return to 
 continue, "; 
    std::getline(std::cin, answer); 
    // 7.  List the Lambda functions. 
    std::vector<Aws::String> functions; 
    Aws::String marker; 
    do { 
        Aws::Lambda::Model::ListFunctionsRequest request; 
        if (!marker.empty()) { 
            request.SetMarker(marker); 
        } 
        Aws::Lambda::Model::ListFunctionsOutcome outcome = client.ListFunctions( 
                request); 
        if (outcome.IsSuccess()) { 
            const Aws::Lambda::Model::ListFunctionsResult &result = 
 outcome.GetResult(); 
            std::cout << result.GetFunctions().size() 
                      << " lambda functions were retrieved." << std::endl; 
            for (const Aws::Lambda::Model::FunctionConfiguration 
 &functionConfiguration: result.GetFunctions()) { 
                functions.push_back(functionConfiguration.GetFunctionName()); 
                std::cout << functions.size() << "  " 
                          << functionConfiguration.GetDescription() << std::endl; 
                std::cout << "   " 
                          << Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime( 
                                  functionConfiguration.GetRuntime()) << ": " 
                          << functionConfiguration.GetHandler() 
                          << std::endl; 
            } 
            marker = result.GetNextMarker(); 
        } 
        else { 
            std::cerr << "Error with Lambda::ListFunctions. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        } 
    } while (!marker.empty()); 
    // 8.  Get a Lambda function. 
    if (!functions.empty()) { 
        std::stringstream question; 
        question << "Choose a function to retrieve between 1 and " << 
 functions.size() 
                 << " "; 
        int functionIndex = askQuestionForIntRange(question.str(), 1, 
                                                   
 static_cast<int>(functions.size())); 
        Aws::String functionName = functions[functionIndex - 1]; 
1195AWS Lambda Developer Guide
Get started with functions
        Aws::Lambda::Model::GetFunctionRequest request; 
        request.SetFunctionName(functionName); 
        Aws::Lambda::Model::GetFunctionOutcome outcome = 
 client.GetFunction(request); 
        if (outcome.IsSuccess()) { 
            std::cout << "Function retrieve.\n" << 
                      
 outcome.GetResult().GetConfiguration().Jsonize().View().WriteReadable() 
                      << std::endl; 
        } 
        else { 
            std::cerr << "Error with Lambda::GetFunction. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
        } 
    } 
    std::cout << "The resources will be deleted. Press return to continue, "; 
    std::getline(std::cin, answer); 
    // 9.  Delete the Lambda function. 
    bool result = deleteLambdaFunction(client); 
    // 10. Delete the IAM role. 
    return result && deleteIamRole(clientConfig);
}
//! Routine which invokes a Lambda function and returns the result.
/*! 
 \param jsonPayload: Payload for invoke function. 
 \param logType: Log type setting for invoke function. 
 \param invokeResult: InvokeResult object to receive the result. 
 \param client: Lambda client. 
 \return bool: Successful completion. 
 */
bool
AwsDoc::Lambda::invokeLambdaFunction(const Aws::Utils::Json::JsonValue 
 &jsonPayload, 
                                     Aws::Lambda::Model::LogType logType, 
                                     Aws::Lambda::Model::InvokeResult 
 &invokeResult, 
                                     const Aws::Lambda::LambdaClient &client) { 
    int seconds = 0; 
    bool result = false; 
    /* 
     * In this example, the Invoke function can be called before recently created 
 resources are 
     * available.  The Invoke function is called repeatedly until the resources are 
     * available. 
     */ 
    do { 
        Aws::Lambda::Model::InvokeRequest request; 
        request.SetFunctionName(LAMBDA_NAME); 
        request.SetLogType(logType); 
        std::shared_ptr<Aws::IOStream> payload = 
 Aws::MakeShared<Aws::StringStream>( 
                "FunctionTest"); 
        *payload << jsonPayload.View().WriteReadable(); 
        request.SetBody(payload); 
        request.SetContentType("application/json"); 
        Aws::Lambda::Model::InvokeOutcome outcome = client.Invoke(request); 
        if (outcome.IsSuccess()) { 
            invokeResult = std::move(outcome.GetResult()); 
1196AWS Lambda Developer Guide
Get started with functions
            result = true; 
            break; 
        } 
            // ACCESS_DENIED: because the role is not available yet. 
            // RESOURCE_CONFLICT: because the Lambda function is being created or 
 updated. 
        else if ((outcome.GetError().GetErrorType() == 
                  Aws::Lambda::LambdaErrors::ACCESS_DENIED) || 
                 (outcome.GetError().GetErrorType() == 
                  Aws::Lambda::LambdaErrors::RESOURCE_CONFLICT)) { 
            if ((seconds % 5) == 0) { // Log status every 10 seconds. 
                std::cout << "Waiting for the invoke api to be available, status " 
 << 
                          ((outcome.GetError().GetErrorType() == 
                            Aws::Lambda::LambdaErrors::ACCESS_DENIED ? 
                            "ACCESS_DENIED" : "RESOURCE_CONFLICT")) << ". " << 
 seconds 
                          << " seconds elapsed." << std::endl; 
            } 
        } 
        else { 
            std::cerr << "Error with Lambda::InvokeRequest. " 
                      << outcome.GetError().GetMessage() 
                      << std::endl; 
            break; 
        } 
        ++seconds; 
        std::this_thread::sleep_for(std::chrono::seconds(1)); 
    } while (seconds < 60); 
    return result;
}
•For API details, see the following topics in AWS SDK for C++ API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Create an interactive scenario that shows you how to get started with Lambda functions.
// GetStartedFunctionsScenario shows you how to use AWS Lambda to perform the 
 following
// actions:
//
//  1. Create an AWS Identity and Access Management (IAM) role and Lambda function, 
 then upload handler code.
1197AWS Lambda Developer Guide
Get started with functions
//  2. Invoke the function with a single parameter and get results.
//  3. Update the function code and configure with an environment variable.
//  4. Invoke the function with new parameters and get results. Display the 
 returned execution log.
//  5. List the functions for your account, then clean up resources.
type GetStartedFunctionsScenario struct { 
 sdkConfig       aws.Config 
 functionWrapper actions.FunctionWrapper 
 questioner      demotools.IQuestioner 
 helper          IScenarioHelper 
 isTestRun       bool
}
// NewGetStartedFunctionsScenario constructs a GetStartedFunctionsScenario instance 
 from a configuration.
// It uses the specified config to get a Lambda client and create wrappers for the 
 actions
// used in the scenario.
func NewGetStartedFunctionsScenario(sdkConfig aws.Config, questioner 
 demotools.IQuestioner, 
 helper IScenarioHelper) GetStartedFunctionsScenario { 
 lambdaClient := lambda.NewFromConfig(sdkConfig) 
 return GetStartedFunctionsScenario{ 
  sdkConfig:       sdkConfig, 
  functionWrapper: actions.FunctionWrapper{LambdaClient: lambdaClient}, 
  questioner:      questioner, 
  helper:          helper, 
 }
}
// Run runs the interactive scenario.
func (scenario GetStartedFunctionsScenario) Run() { 
 defer func() { 
  if r := recover(); r != nil { 
   log.Printf("Something went wrong with the demo.\n") 
  } 
 }() 
 log.Println(strings.Repeat("-", 88)) 
 log.Println("Welcome to the AWS Lambda get started with functions demo.") 
 log.Println(strings.Repeat("-", 88)) 
 role := scenario.GetOrCreateRole() 
 funcName := scenario.CreateFunction(role) 
 scenario.InvokeIncrement(funcName) 
 scenario.UpdateFunction(funcName) 
 scenario.InvokeCalculator(funcName) 
 scenario.ListFunctions() 
 scenario.Cleanup(role, funcName) 
 log.Println(strings.Repeat("-", 88)) 
 log.Println("Thanks for watching!") 
 log.Println(strings.Repeat("-", 88))
}
// GetOrCreateRole checks whether the specified role exists and returns it if it 
 does.
// Otherwise, a role is created that specifies Lambda as a trusted principal.
// The AWSLambdaBasicExecutionRole managed policy is attached to the role and the 
 role
// is returned.
func (scenario GetStartedFunctionsScenario) GetOrCreateRole() *iamtypes.Role { 
 var role *iamtypes.Role 
 iamClient := iam.NewFromConfig(scenario.sdkConfig) 
 log.Println("First, we need an IAM role that Lambda can assume.") 
1198AWS Lambda Developer Guide
Get started with functions
 roleName := scenario.questioner.Ask("Enter a name for the role:", 
 demotools.NotEmpty{}) 
 getOutput, err := iamClient.GetRole(context.TODO(), &iam.GetRoleInput{ 
  RoleName: aws.String(roleName)}) 
 if err != nil { 
  var noSuch *iamtypes.NoSuchEntityException 
  if errors.As(err, &noSuch) { 
   log.Printf("Role %v doesn't exist. Creating it....\n", roleName) 
  } else { 
   log.Panicf("Couldn't check whether role %v exists. Here's why: %v\n", 
    roleName, err) 
  } 
 } else { 
  role = getOutput.Role 
  log.Printf("Found role %v.\n", *role.RoleName) 
 } 
 if role == nil { 
  trustPolicy := PolicyDocument{ 
   Version: "2012-10-17", 
   Statement: []PolicyStatement{{ 
    Effect:    "Allow", 
    Principal: map[string]string{"Service": "lambda.amazonaws.com"}, 
    Action:    []string{"sts:AssumeRole"}, 
   }}, 
  } 
  policyArn := "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole" 
  createOutput, err := iamClient.CreateRole(context.TODO(), &iam.CreateRoleInput{ 
   AssumeRolePolicyDocument: aws.String(trustPolicy.String()), 
   RoleName:                 aws.String(roleName), 
  }) 
  if err != nil { 
   log.Panicf("Couldn't create role %v. Here's why: %v\n", roleName, err) 
  } 
  role = createOutput.Role 
  _, err = iamClient.AttachRolePolicy(context.TODO(), &iam.AttachRolePolicyInput{ 
   PolicyArn: aws.String(policyArn), 
   RoleName:  aws.String(roleName), 
  }) 
  if err != nil { 
   log.Panicf("Couldn't attach a policy to role %v. Here's why: %v\n", roleName, 
 err) 
  } 
  log.Printf("Created role %v.\n", *role.RoleName) 
  log.Println("Let's give AWS a few seconds to propagate resources...") 
  scenario.helper.Pause(10) 
 } 
 log.Println(strings.Repeat("-", 88)) 
 return role
}
// CreateFunction creates a Lambda function and uploads a handler written in 
 Python.
// The code for the Python handler is packaged as a []byte in .zip format.
func (scenario GetStartedFunctionsScenario) CreateFunction(role *iamtypes.Role) 
 string { 
 log.Println("Let's create a function that increments a number.\n" + 
  "The function uses the 'lambda_handler_basic.py' script found in the \n" + 
  "'handlers' directory of this project.") 
 funcName := scenario.questioner.Ask("Enter a name for the Lambda function:", 
 demotools.NotEmpty{}) 
 zipPackage := scenario.helper.CreateDeploymentPackage("lambda_handler_basic.py", 
 fmt.Sprintf("%v.py", funcName)) 
 log.Printf("Creating function %v and waiting for it to be ready.", funcName) 
 funcState := scenario.functionWrapper.CreateFunction(funcName, 
 fmt.Sprintf("%v.lambda_handler", funcName), 
  role.Arn, zipPackage) 
1199AWS Lambda Developer Guide
Get started with functions
 log.Printf("Your function is %v.", funcState) 
 log.Println(strings.Repeat("-", 88)) 
 return funcName
}
// InvokeIncrement invokes a Lambda function that increments a number. The function
// parameters are contained in a Go struct that is used to serialize the parameters 
 to
// a JSON payload that is passed to the function.
// The result payload is deserialized into a Go struct that contains an int value.
func (scenario GetStartedFunctionsScenario) InvokeIncrement(funcName string) { 
 parameters := actions.IncrementParameters{Action: "increment"} 
 log.Println("Let's invoke our function. This function increments a number.") 
 parameters.Number = scenario.questioner.AskInt("Enter a number to increment:", 
 demotools.NotEmpty{}) 
 log.Printf("Invoking %v with %v...\n", funcName, parameters.Number) 
 invokeOutput := scenario.functionWrapper.Invoke(funcName, parameters, false) 
 var payload actions.LambdaResultInt 
 err := json.Unmarshal(invokeOutput.Payload, &payload) 
 if err != nil { 
  log.Panicf("Couldn't unmarshal payload from invoking %v. Here's why: %v\n", 
   funcName, err) 
 } 
 log.Printf("Invoking %v with %v returned %v.\n", funcName, parameters.Number, 
 payload) 
 log.Println(strings.Repeat("-", 88))
}
// UpdateFunction updates the code for a Lambda function by uploading a simple 
 arithmetic
// calculator written in Python. The code for the Python handler is packaged as a
// []byte in .zip format.
// After the code is updated, the configuration is also updated with a new log
// level that instructs the handler to log additional information.
func (scenario GetStartedFunctionsScenario) UpdateFunction(funcName string) { 
 log.Println("Let's update the function to an arithmetic calculator.\n" + 
  "The function uses the 'lambda_handler_calculator.py' script found in the \n" + 
  "'handlers' directory of this project.") 
 scenario.questioner.Ask("Press Enter when you're ready.") 
 log.Println("Creating deployment package...") 
 zipPackage := 
 scenario.helper.CreateDeploymentPackage("lambda_handler_calculator.py", 
  fmt.Sprintf("%v.py", funcName)) 
 log.Println("...and updating the Lambda function and waiting for it to be ready.") 
 funcState := scenario.functionWrapper.UpdateFunctionCode(funcName, zipPackage) 
 log.Printf("Updated function %v. Its current state is %v.", funcName, funcState) 
 log.Println("This function uses an environment variable to control logging 
 level.") 
 log.Println("Let's set it to DEBUG to get the most logging.") 
 scenario.functionWrapper.UpdateFunctionConfiguration(funcName, 
  map[string]string{"LOG_LEVEL": "DEBUG"}) 
 log.Println(strings.Repeat("-", 88))
}
// InvokeCalculator invokes the Lambda calculator function. The parameters are 
 stored in a
// Go struct that is used to serialize the parameters to a JSON payload. That 
 payload is then passed
// to the function.
// The result payload is deserialized to a Go struct that stores the result as 
 either an
// int or float32, depending on the kind of operation that was specified.
func (scenario GetStartedFunctionsScenario) InvokeCalculator(funcName string) { 
 wantInvoke := true 
 choices := []string{"plus", "minus", "times", "divided-by"} 
 for wantInvoke { 
1200AWS Lambda Developer Guide
Get started with functions
  choice := scenario.questioner.AskChoice("Select an arithmetic operation:\n", 
 choices) 
  x := scenario.questioner.AskInt("Enter a value for x:", demotools.NotEmpty{}) 
  y := scenario.questioner.AskInt("Enter a value for y:", demotools.NotEmpty{}) 
  log.Printf("Invoking %v %v %v...", x, choices[choice], y) 
  calcParameters := actions.CalculatorParameters{ 
   Action: choices[choice], 
   X:      x, 
   Y:      y, 
  } 
  invokeOutput := scenario.functionWrapper.Invoke(funcName, calcParameters, true) 
  var payload any 
  if choice == 3 { // divide-by results in a float. 
   payload = actions.LambdaResultFloat{} 
  } else { 
   payload = actions.LambdaResultInt{} 
  } 
  err := json.Unmarshal(invokeOutput.Payload, &payload) 
  if err != nil { 
   log.Panicf("Couldn't unmarshal payload from invoking %v. Here's why: %v\n", 
    funcName, err) 
  } 
  log.Printf("Invoking %v with %v %v %v returned %v.\n", funcName, 
   calcParameters.X, calcParameters.Action, calcParameters.Y, payload) 
  scenario.questioner.Ask("Press Enter to see the logs from the call.") 
  logRes, err := base64.StdEncoding.DecodeString(*invokeOutput.LogResult) 
  if err != nil { 
   log.Panicf("Couldn't decode log result. Here's why: %v\n", err) 
  } 
  log.Println(string(logRes)) 
  wantInvoke = scenario.questioner.AskBool("Do you want to calculate again? (y/n)", 
 "y") 
 } 
 log.Println(strings.Repeat("-", 88))
}
// ListFunctions lists up to the specified number of functions for your account.
func (scenario GetStartedFunctionsScenario) ListFunctions() { 
 count := scenario.questioner.AskInt( 
  "Let's list functions for your account. How many do you want to see?", 
 demotools.NotEmpty{}) 
 functions := scenario.functionWrapper.ListFunctions(count) 
 log.Printf("Found %v functions:", len(functions)) 
 for _, function := range functions { 
  log.Printf("\t%v", *function.FunctionName) 
 } 
 log.Println(strings.Repeat("-", 88))
}
// Cleanup removes the IAM and Lambda resources created by the example.
func (scenario GetStartedFunctionsScenario) Cleanup(role *iamtypes.Role, funcName 
 string) { 
 if scenario.questioner.AskBool("Do you want to clean up resources created for this 
 example? (y/n)", 
  "y") { 
  iamClient := iam.NewFromConfig(scenario.sdkConfig) 
  policiesOutput, err := iamClient.ListAttachedRolePolicies(context.TODO(), 
   &iam.ListAttachedRolePoliciesInput{RoleName: role.RoleName}) 
  if err != nil { 
   log.Panicf("Couldn't get policies attached to role %v. Here's why: %v\n", 
    *role.RoleName, err) 
  } 
  for _, policy := range policiesOutput.AttachedPolicies { 
   _, err = iamClient.DetachRolePolicy(context.TODO(), &iam.DetachRolePolicyInput{ 
    PolicyArn: policy.PolicyArn, RoleName: role.RoleName, 
   }) 
1201AWS Lambda Developer Guide
Get started with functions
   if err != nil { 
    log.Panicf("Couldn't detach policy %v from role %v. Here's why: %v\n", 
     *policy.PolicyArn, *role.RoleName, err) 
   } 
  } 
  _, err = iamClient.DeleteRole(context.TODO(), &iam.DeleteRoleInput{RoleName: 
 role.RoleName}) 
  if err != nil { 
   log.Panicf("Couldn't delete role %v. Here's why: %v\n", *role.RoleName, err) 
  } 
  log.Printf("Deleted role %v.\n", *role.RoleName) 
  scenario.functionWrapper.DeleteFunction(funcName) 
  log.Printf("Deleted function %v.\n", funcName) 
 } else { 
  log.Println("Okay. Don't forget to delete the resources when you're done with 
 them.") 
 }
}
Create a struct that wraps individual Lambda actions.
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct { 
 LambdaClient *lambda.Client
}
// GetFunction gets data about the Lambda function specified by functionName.
func (wrapper FunctionWrapper) GetFunction(functionName string) types.State { 
 var state types.State 
 funcOutput, err := wrapper.LambdaClient.GetFunction(context.TODO(), 
 &lambda.GetFunctionInput{ 
  FunctionName: aws.String(functionName), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't get function %v. Here's why: %v\n", functionName, err) 
 } else { 
  state = funcOutput.Configuration.State 
 } 
 return state
}
// CreateFunction creates a new Lambda function from code contained in the 
 zipPackage
// buffer. The specified handlerName must match the name of the file and function
// contained in the uploaded code. The role specified by iamRoleArn is assumed by
// Lambda and grants specific permissions.
// When the function already exists, types.StateActive is returned.
// When the function is created, a lambda.FunctionActiveV2Waiter is used to wait 
 until the
// function is active.
func (wrapper FunctionWrapper) CreateFunction(functionName string, handlerName 
 string, 
 iamRoleArn *string, zipPackage *bytes.Buffer) types.State { 
 var state types.State 
 _, err := wrapper.LambdaClient.CreateFunction(context.TODO(), 
 &lambda.CreateFunctionInput{ 
  Code:         &types.FunctionCode{ZipFile: zipPackage.Bytes()}, 
1202AWS Lambda Developer Guide
Get started with functions
  FunctionName: aws.String(functionName), 
  Role:         iamRoleArn, 
  Handler:      aws.String(handlerName), 
  Publish:      true, 
  Runtime:      types.RuntimePython38, 
 }) 
 if err != nil { 
  var resConflict *types.ResourceConflictException 
  if errors.As(err, &resConflict) { 
   log.Printf("Function %v already exists.\n", functionName) 
   state = types.StateActive 
  } else { 
   log.Panicf("Couldn't create function %v. Here's why: %v\n", functionName, err) 
  } 
 } else { 
  waiter := lambda.NewFunctionActiveV2Waiter(wrapper.LambdaClient) 
  funcOutput, err := waiter.WaitForOutput(context.TODO(), &lambda.GetFunctionInput{ 
   FunctionName: aws.String(functionName)}, 1*time.Minute) 
  if err != nil { 
   log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", 
 functionName, err) 
  } else { 
   state = funcOutput.Configuration.State 
  } 
 } 
 return state
}
// UpdateFunctionCode updates the code for the Lambda function specified by 
 functionName.
// The existing code for the Lambda function is entirely replaced by the code in 
 the
// zipPackage buffer. After the update action is called, a 
 lambda.FunctionUpdatedV2Waiter
// is used to wait until the update is successful.
func (wrapper FunctionWrapper) UpdateFunctionCode(functionName string, zipPackage 
 *bytes.Buffer) types.State { 
 var state types.State 
 _, err := wrapper.LambdaClient.UpdateFunctionCode(context.TODO(), 
 &lambda.UpdateFunctionCodeInput{ 
  FunctionName: aws.String(functionName), ZipFile: zipPackage.Bytes(), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't update code for function %v. Here's why: %v\n", 
 functionName, err) 
 } else { 
  waiter := lambda.NewFunctionUpdatedV2Waiter(wrapper.LambdaClient) 
  funcOutput, err := waiter.WaitForOutput(context.TODO(), &lambda.GetFunctionInput{ 
   FunctionName: aws.String(functionName)}, 1*time.Minute) 
  if err != nil { 
   log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", 
 functionName, err) 
  } else { 
   state = funcOutput.Configuration.State 
  } 
 } 
 return state
}
// UpdateFunctionConfiguration updates a map of environment variables configured 
 for
// the Lambda function specified by functionName.
1203AWS Lambda Developer Guide
Get started with functions
func (wrapper FunctionWrapper) UpdateFunctionConfiguration(functionName string, 
 envVars map[string]string) { 
 _, err := wrapper.LambdaClient.UpdateFunctionConfiguration(context.TODO(), 
 &lambda.UpdateFunctionConfigurationInput{ 
  FunctionName: aws.String(functionName), 
  Environment:  &types.Environment{Variables: envVars}, 
 }) 
 if err != nil { 
  log.Panicf("Couldn't update configuration for %v. Here's why: %v", functionName, 
 err) 
 }
}
// ListFunctions lists up to maxItems functions for the account. This function uses 
 a
// lambda.ListFunctionsPaginator to paginate the results.
func (wrapper FunctionWrapper) ListFunctions(maxItems int) 
 []types.FunctionConfiguration { 
 var functions []types.FunctionConfiguration 
 paginator := lambda.NewListFunctionsPaginator(wrapper.LambdaClient, 
 &lambda.ListFunctionsInput{ 
  MaxItems: aws.Int32(int32(maxItems)), 
 }) 
 for paginator.HasMorePages() && len(functions) < maxItems { 
  pageOutput, err := paginator.NextPage(context.TODO()) 
  if err != nil { 
   log.Panicf("Couldn't list functions for your account. Here's why: %v\n", err) 
  } 
  functions = append(functions, pageOutput.Functions...) 
 } 
 return functions
}
// DeleteFunction deletes the Lambda function specified by functionName.
func (wrapper FunctionWrapper) DeleteFunction(functionName string) { 
 _, err := wrapper.LambdaClient.DeleteFunction(context.TODO(), 
 &lambda.DeleteFunctionInput{ 
  FunctionName: aws.String(functionName), 
 }) 
 if err != nil { 
  log.Panicf("Couldn't delete function %v. Here's why: %v\n", functionName, err) 
 }
}
// Invoke invokes the Lambda function specified by functionName, passing the 
 parameters
// as a JSON payload. When getLog is true, types.LogTypeTail is specified, which 
 tells
// Lambda to include the last few log lines in the returned result.
func (wrapper FunctionWrapper) Invoke(functionName string, parameters any, getLog 
 bool) *lambda.InvokeOutput { 
 logType := types.LogTypeNone 
 if getLog { 
  logType = types.LogTypeTail 
 } 
 payload, err := json.Marshal(parameters) 
 if err != nil { 
  log.Panicf("Couldn't marshal parameters to JSON. Here's why %v\n", err) 
 } 
1204AWS Lambda Developer Guide
Get started with functions
 invokeOutput, err := wrapper.LambdaClient.Invoke(context.TODO(), 
 &lambda.InvokeInput{ 
  FunctionName: aws.String(functionName), 
  LogType:      logType, 
  Payload:      payload, 
 }) 
 if err != nil { 
  log.Panicf("Couldn't invoke function %v. Here's why: %v\n", functionName, err) 
 } 
 return invokeOutput
}
// IncrementParameters is used to serialize parameters to the increment Lambda 
 handler.
type IncrementParameters struct { 
 Action string `json:"action"` 
 Number int    `json:"number"`
}
// CalculatorParameters is used to serialize parameters to the calculator Lambda 
 handler.
type CalculatorParameters struct { 
 Action string `json:"action"` 
 X      int    `json:"x"` 
 Y      int    `json:"y"`
}
// LambdaResultInt is used to deserialize an int result from a Lambda handler.
type LambdaResultInt struct { 
 Result int `json:"result"`
}
// LambdaResultFloat is used to deserialize a float32 result from a Lambda handler.
type LambdaResultFloat struct { 
 Result float32 `json:"result"`
}
Create a struct that implements functions to help run the scenario.
// IScenarioHelper abstracts I/O and wait functions from a scenario so that they
// can be mocked for unit testing.
type IScenarioHelper interface { 
 Pause(secs int) 
 CreateDeploymentPackage(sourceFile string, destinationFile string) *bytes.Buffer
}
// ScenarioHelper lets the caller specify the path to Lambda handler functions.
type ScenarioHelper struct { 
 HandlerPath string
}
// Pause waits for the specified number of seconds.
func (helper *ScenarioHelper) Pause(secs int) { 
 time.Sleep(time.Duration(secs) * time.Second)
}
// CreateDeploymentPackage creates an AWS Lambda deployment package from a source 
 file. The
// deployment package is stored in .zip format in a bytes.Buffer. The buffer can be
// used to pass a []byte to Lambda when creating the function.
1205AWS Lambda Developer Guide
Get started with functions
// The specified destinationFile is the name to give the file when it's deployed to 
 Lambda.
func (helper *ScenarioHelper) CreateDeploymentPackage(sourceFile string, 
 destinationFile string) *bytes.Buffer { 
 var err error 
 buffer := &bytes.Buffer{} 
 writer := zip.NewWriter(buffer) 
 zFile, err := writer.Create(destinationFile) 
 if err != nil { 
  log.Panicf("Couldn't create destination archive %v. Here's why: %v\n", 
 destinationFile, err) 
 } 
 sourceBody, err := os.ReadFile(fmt.Sprintf("%v/%v", helper.HandlerPath, 
 sourceFile)) 
 if err != nil { 
  log.Panicf("Couldn't read handler source file %v. Here's why: %v\n", 
   sourceFile, err) 
 } else { 
  _, err = zFile.Write(sourceBody) 
  if err != nil { 
   log.Panicf("Couldn't write handler %v to zip archive. Here's why: %v\n", 
    sourceFile, err) 
  } 
 } 
 err = writer.Close() 
 if err != nil { 
  log.Panicf("Couldn't close zip writer. Here's why: %v\n", err) 
 } 
 return buffer
}
Deﬁne a Lambda handler that increments a number.
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
def lambda_handler(event, context): 
    """ 
    Accepts an action and a single number, performs the specified action on the 
 number, 
    and returns the result. The only allowable action is 'increment'. 
    :param event: The event dict that contains the parameters sent when the 
 function 
                  is invoked. 
    :param context: The context in which the function is called. 
    :return: The result of the action. 
    """ 
    result = None 
    action = event.get('action') 
    if action == 'increment': 
        result = event.get('number', 0) + 1 
        logger.info('Calculated result of %s', result) 
    else: 
        logger.error("%s is not a valid action.", action) 
    response = {'result': result} 
    return response
1206AWS Lambda Developer Guide
Get started with functions
Deﬁne a second Lambda handler that performs arithmetic operations.
import logging
import os
logger = logging.getLogger()
# Define a list of Python lambda functions that are called by this AWS Lambda 
 function.
ACTIONS = { 
    'plus': lambda x, y: x + y, 
    'minus': lambda x, y: x - y, 
    'times': lambda x, y: x * y, 
    'divided-by': lambda x, y: x / y}
def lambda_handler(event, context): 
    """ 
    Accepts an action and two numbers, performs the specified action on the 
 numbers, 
    and returns the result. 
    :param event: The event dict that contains the parameters sent when the 
 function 
                  is invoked. 
    :param context: The context in which the function is called. 
    :return: The result of the specified action. 
    """ 
    # Set the log level based on a variable configured in the Lambda environment. 
    logger.setLevel(os.environ.get('LOG_LEVEL', logging.INFO)) 
    logger.debug('Event: %s', event) 
    action = event.get('action') 
    func = ACTIONS.get(action) 
    x = event.get('x') 
    y = event.get('y') 
    result = None 
    try: 
        if func is not None and x is not None and y is not None: 
            result = func(x, y) 
            logger.info("%s %s %s is %s", x, action, y, result) 
        else: 
            logger.error("I can't calculate %s %s %s.", x, action, y) 
    except ZeroDivisionError: 
        logger.warning("I can't divide %s by 0!", x) 
    response = {'result': result} 
    return response
•For API details, see the following topics in AWS SDK for Go API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
1207AWS Lambda Developer Guide
Get started with functions
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
/* 
 *  Lambda function names appear as: 
 * 
 *  arn:aws:lambda:us-west-2:335556666777:function:HelloFunction 
 * 
 *  To find this value, look at the function in the AWS Management Console. 
 * 
 *  Before running this Java code example, set up your development environment, 
 including your credentials. 
 * 
 *  For more information, see this documentation topic: 
 * 
 *  https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-
started.html 
 * 
 *  This example performs the following tasks: 
 * 
 * 1. Creates an AWS Lambda function. 
 * 2. Gets a specific AWS Lambda function. 
 * 3. Lists all Lambda functions. 
 * 4. Invokes a Lambda function. 
 * 5. Updates the Lambda function code and invokes it again. 
 * 6. Updates a Lambda function's configuration value. 
 * 7. Deletes a Lambda function. 
 */
public class LambdaScenario { 
    public static final String DASHES = new String(new char[80]).replace("\0", 
 "-"); 
    public static void main(String[] args) throws InterruptedException { 
        final String usage = "\n" + 
            "Usage:\n" + 
            "    <functionName> <filePath> <role> <handler> <bucketName> <key> \n
\n" + 
            "Where:\n" + 
            "    functionName - The name of the Lambda function. \n"+ 
            "    filePath - The path to the .zip or .jar where the code is located. 
 \n"+ 
            "    role - The AWS Identity and Access Management (IAM) service role 
 that has Lambda permissions. \n"+ 
            "    handler - The fully qualified method name (for example, 
 example.Handler::handleRequest). \n"+ 
            "    bucketName - The Amazon Simple Storage Service (Amazon S3) bucket 
 name that contains the .zip or .jar used to update the Lambda function's code. 
 \n"+ 
            "    key - The Amazon S3 key name that represents the .zip or .jar (for 
 example, LambdaHello-1.0-SNAPSHOT.jar)." ; 
        if (args.length != 6) { 
            System.out.println(usage); 
            System.exit(1); 
        } 
        String functionName = args[0]; 
        String filePath = args[1]; 
1208AWS Lambda Developer Guide
Get started with functions
        String role = args[2]; 
        String handler = args[3]; 
        String bucketName = args[4]; 
        String key = args[5]; 
        Region region = Region.US_WEST_2; 
        LambdaClient awsLambda = LambdaClient.builder() 
            .region(region) 
            .credentialsProvider(ProfileCredentialsProvider.create()) 
            .build(); 
        System.out.println(DASHES); 
        System.out.println("Welcome to the AWS Lambda example scenario."); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("1. Create an AWS Lambda function."); 
        String funArn = createLambdaFunction(awsLambda, functionName, filePath, 
 role, handler); 
        System.out.println("The AWS Lambda ARN is "+funArn); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("2. Get the "+functionName + " AWS Lambda function."); 
        getFunction(awsLambda, functionName); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("3. List all AWS Lambda functions."); 
        listFunctions(awsLambda); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("4. Invoke the Lambda function."); 
        System.out.println("*** Sleep for 1 min to get Lambda function ready."); 
        Thread.sleep(60000); 
        invokeFunction(awsLambda, functionName); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("5. Update the Lambda function code and invoke it 
 again."); 
        updateFunctionCode(awsLambda, functionName, bucketName, key); 
        System.out.println("*** Sleep for 1 min to get Lambda function ready."); 
        Thread.sleep(60000); 
        invokeFunction(awsLambda, functionName); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("6. Update a Lambda function's configuration value."); 
        updateFunctionConfiguration(awsLambda, functionName, handler); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("7. Delete the AWS Lambda function."); 
        LambdaScenario.deleteLambdaFunction(awsLambda, functionName); 
        System.out.println(DASHES); 
        System.out.println(DASHES); 
        System.out.println("The AWS Lambda scenario completed successfully"); 
        System.out.println(DASHES); 
        awsLambda.close(); 
    } 
    public static String createLambdaFunction(LambdaClient awsLambda, 
                                            String functionName, 
1209AWS Lambda Developer Guide
Get started with functions
                                            String filePath, 
                                            String role, 
                                            String handler) { 
        try { 
            LambdaWaiter waiter = awsLambda.waiter(); 
            InputStream is = new FileInputStream(filePath); 
            SdkBytes fileToUpload = SdkBytes.fromInputStream(is); 
            FunctionCode code = FunctionCode.builder() 
                .zipFile(fileToUpload) 
                .build(); 
            CreateFunctionRequest functionRequest = CreateFunctionRequest.builder() 
                .functionName(functionName) 
                .description("Created by the Lambda Java API") 
                .code(code) 
                .handler(handler) 
                .runtime(Runtime.JAVA8) 
                .role(role) 
                .build(); 
            // Create a Lambda function using a waiter 
            CreateFunctionResponse functionResponse = 
 awsLambda.createFunction(functionRequest); 
            GetFunctionRequest getFunctionRequest = GetFunctionRequest.builder() 
                .functionName(functionName) 
                .build(); 
            WaiterResponse<GetFunctionResponse> waiterResponse = 
 waiter.waitUntilFunctionExists(getFunctionRequest); 
            waiterResponse.matched().response().ifPresent(System.out::println); 
            return functionResponse.functionArn(); 
        } catch(LambdaException | FileNotFoundException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
        return ""; 
    } 
    public static void getFunction(LambdaClient awsLambda, String functionName) { 
        try { 
            GetFunctionRequest functionRequest = GetFunctionRequest.builder() 
                .functionName(functionName) 
                .build(); 
            GetFunctionResponse response = awsLambda.getFunction(functionRequest); 
            System.out.println("The runtime of this Lambda function is " 
 +response.configuration().runtime()); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    } 
    public static void listFunctions(LambdaClient awsLambda) { 
        try { 
            ListFunctionsResponse functionResult = awsLambda.listFunctions(); 
            List<FunctionConfiguration> list = functionResult.functions(); 
            for (FunctionConfiguration config: list) { 
                System.out.println("The function name is "+config.functionName()); 
            } 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
1210AWS Lambda Developer Guide
Get started with functions
            System.exit(1); 
        } 
    } 
    public static void invokeFunction(LambdaClient awsLambda, String functionName) 
 { 
        InvokeResponse res; 
        try { 
            // Need a SdkBytes instance for the payload. 
            JSONObject jsonObj = new JSONObject(); 
            jsonObj.put("inputValue", "2000"); 
            String json = jsonObj.toString(); 
            SdkBytes payload = SdkBytes.fromUtf8String(json) ; 
            InvokeRequest request = InvokeRequest.builder() 
                .functionName(functionName) 
                .payload(payload) 
                .build(); 
            res = awsLambda.invoke(request); 
            String value = res.payload().asUtf8String() ; 
            System.out.println(value); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    } 
    public static void updateFunctionCode(LambdaClient awsLambda, String 
 functionName, String bucketName, String key) { 
        try { 
            LambdaWaiter waiter = awsLambda.waiter(); 
            UpdateFunctionCodeRequest functionCodeRequest = 
 UpdateFunctionCodeRequest.builder() 
                .functionName(functionName) 
                .publish(true) 
                .s3Bucket(bucketName) 
                .s3Key(key) 
                .build(); 
            UpdateFunctionCodeResponse response = 
 awsLambda.updateFunctionCode(functionCodeRequest) ; 
            GetFunctionConfigurationRequest getFunctionConfigRequest = 
 GetFunctionConfigurationRequest.builder() 
                .functionName(functionName) 
                .build(); 
            WaiterResponse<GetFunctionConfigurationResponse> waiterResponse = 
 waiter.waitUntilFunctionUpdated(getFunctionConfigRequest); 
            waiterResponse.matched().response().ifPresent(System.out::println); 
            System.out.println("The last modified value is " 
 +response.lastModified()); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    } 
    public static void updateFunctionConfiguration(LambdaClient awsLambda, String 
 functionName, String handler ){ 
        try { 
            UpdateFunctionConfigurationRequest configurationRequest = 
 UpdateFunctionConfigurationRequest.builder() 
1211AWS Lambda Developer Guide
Get started with functions
                .functionName(functionName) 
                .handler(handler) 
                .runtime(Runtime.JAVA11 ) 
                .build(); 
            awsLambda.updateFunctionConfiguration(configurationRequest); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    } 
    public static void deleteLambdaFunction(LambdaClient awsLambda, String 
 functionName ) { 
        try { 
            DeleteFunctionRequest request = DeleteFunctionRequest.builder() 
                .functionName(functionName) 
                .build(); 
            awsLambda.deleteFunction(request); 
            System.out.println("The "+functionName +" function was deleted"); 
        } catch(LambdaException e) { 
            System.err.println(e.getMessage()); 
            System.exit(1); 
        } 
    }
}
•For API details, see the following topics in AWS SDK for Java 2.x API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
JavaScript
SDK for JavaScript (v3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Create an AWS Identity and Access Management (IAM) role that grants Lambda permission to 
write to logs.
    log(`Creating role (${NAME_ROLE_LAMBDA})...`); 
    const response = await createRole({ 
      AssumeRolePolicyDocument: parseString({ 
        Version: "2012-10-17", 
        Statement: [ 
          { 
            Effect: "Allow", 
            Principal: { 
              Service: "lambda.amazonaws.com", 
1212AWS Lambda Developer Guide
Get started with functions
            }, 
            Action: "sts:AssumeRole", 
          }, 
        ], 
      }), 
      RoleName: NAME_ROLE_LAMBDA, 
    });
import { AttachRolePolicyCommand, IAMClient } from "@aws-sdk/client-iam";
const client = new IAMClient({});
/** 
 * 
 * @param {string} policyArn 
 * @param {string} roleName 
 */
export const attachRolePolicy = (policyArn, roleName) => { 
  const command = new AttachRolePolicyCommand({ 
    PolicyArn: policyArn, 
    RoleName: roleName, 
  }); 
  return client.send(command);
};
Create a Lambda function and upload handler code.
const createFunction = async (funcName, roleArn) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const code = await readFile(`${dirname}../functions/${funcName}.zip`); 
  const command = new CreateFunctionCommand({ 
    Code: { ZipFile: code }, 
    FunctionName: funcName, 
    Role: roleArn, 
    Architectures: [Architecture.arm64], 
    Handler: "index.handler", // Required when sending a .zip file 
    PackageType: PackageType.Zip, // Required when sending a .zip file 
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file 
  }); 
  return client.send(command);
};
Invoke the function with a single parameter and get results.
const invoke = async (funcName, payload) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new InvokeCommand({ 
    FunctionName: funcName, 
    Payload: JSON.stringify(payload), 
    LogType: LogType.Tail, 
  }); 
  const { Payload, LogResult } = await client.send(command); 
  const result = Buffer.from(Payload).toString(); 
  const logs = Buffer.from(LogResult, "base64").toString(); 
  return { logs, result };
};
1213AWS Lambda Developer Guide
Get started with functions
Update the function code and conﬁgure its Lambda environment with an environment variable.
const updateFunctionCode = async (funcName, newFunc) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const code = await readFile(`${dirname}../functions/${newFunc}.zip`); 
  const command = new UpdateFunctionCodeCommand({ 
    ZipFile: code, 
    FunctionName: funcName, 
    Architectures: [Architecture.arm64], 
    Handler: "index.handler", // Required when sending a .zip file 
    PackageType: PackageType.Zip, // Required when sending a .zip file 
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file 
  }); 
  return client.send(command);
};
const updateFunctionConfiguration = (funcName) => { 
  const client = new LambdaClient({}); 
  const config = readFileSync(`${dirname}../functions/config.json`).toString(); 
  const command = new UpdateFunctionConfigurationCommand({ 
    ...JSON.parse(config), 
    FunctionName: funcName, 
  }); 
  return client.send(command);
};
List the functions for your account.
const listFunctions = async () => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new ListFunctionsCommand({}); 
  return client.send(command);
};
Delete the IAM role and the Lambda function.
import { DeleteRoleCommand, IAMClient } from "@aws-sdk/client-iam";
const client = new IAMClient({});
/** 
 * 
 * @param {string} roleName 
 */
export const deleteRole = (roleName) => { 
  const command = new DeleteRoleCommand({ RoleName: roleName }); 
  return client.send(command);
};
const deleteFunction = (funcName) => { 
  const client = createClientForDefaultRegion(LambdaClient); 
  const command = new DeleteFunctionCommand({ FunctionName: funcName }); 
  return client.send(command);
};
•For API details, see the following topics in AWS SDK for JavaScript API Reference.
•CreateFunction
1214AWS Lambda Developer Guide
Get started with functions
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
Kotlin
SDK for Kotlin
Note
This is prerelease documentation for a feature in preview release. It is subject to 
change.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
suspend fun main(args: Array<String>) { 
    val usage = """ 
        Usage: 
            <functionName> <role> <handler> <bucketName> <updatedBucketName> <key>  
        Where: 
            functionName - The name of the AWS Lambda function.  
            role - The AWS Identity and Access Management (IAM) service role that 
 has AWS Lambda permissions.  
            handler - The fully qualified method name (for example, 
 example.Handler::handleRequest).  
            bucketName - The Amazon Simple Storage Service (Amazon S3) bucket name 
 that contains the ZIP or JAR used for the Lambda function's code. 
            updatedBucketName - The Amazon S3 bucket name that contains the .zip 
 or .jar used to update the Lambda function's code.  
            key - The Amazon S3 key name that represents the .zip or .jar file (for 
 example, LambdaHello-1.0-SNAPSHOT.jar). 
            """ 
    if (args.size != 6) { 
        println(usage) 
        exitProcess(1) 
    } 
    val functionName = args[0] 
    val role = args[1] 
    val handler = args[2] 
    val bucketName = args[3] 
    val updatedBucketName = args[4] 
    val key = args[5] 
    println("Creating a Lambda function named $functionName.") 
    val funArn = createScFunction(functionName, bucketName, key, handler, role) 
    println("The AWS Lambda ARN is $funArn") 
    // Get a specific Lambda function. 
    println("Getting the $functionName AWS Lambda function.") 
    getFunction(functionName) 
    // List the Lambda functions. 
    println("Listing all AWS Lambda functions.") 
1215AWS Lambda Developer Guide
Get started with functions
    listFunctionsSc() 
    // Invoke the Lambda function. 
    println("*** Invoke the Lambda function.") 
    invokeFunctionSc(functionName) 
    // Update the AWS Lambda function code. 
    println("*** Update the Lambda function code.") 
    updateFunctionCode(functionName, updatedBucketName, key) 
    // println("*** Invoke the function again after updating the code.") 
    invokeFunctionSc(functionName) 
    // Update the AWS Lambda function configuration. 
    println("Update the run time of the function.") 
    UpdateFunctionConfiguration(functionName, handler) 
    // Delete the AWS Lambda function. 
    println("Delete the AWS Lambda function.") 
    delFunction(functionName)
}
suspend fun createScFunction( 
    myFunctionName: String, 
    s3BucketName: String, 
    myS3Key: String, 
    myHandler: String, 
    myRole: String
): String { 
    val functionCode = FunctionCode { 
        s3Bucket = s3BucketName 
        s3Key = myS3Key 
    } 
    val request = CreateFunctionRequest { 
        functionName = myFunctionName 
        code = functionCode 
        description = "Created by the Lambda Kotlin API" 
        handler = myHandler 
        role = myRole 
        runtime = Runtime.Java8 
    } 
    // Create a Lambda function using a waiter 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val functionResponse = awsLambda.createFunction(request) 
        awsLambda.waitUntilFunctionActive { 
            functionName = myFunctionName 
        } 
        return functionResponse.functionArn.toString() 
    }
}
suspend fun getFunction(functionNameVal: String) { 
    val functionRequest = GetFunctionRequest { 
        functionName = functionNameVal 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val response = awsLambda.getFunction(functionRequest) 
        println("The runtime of this Lambda function is 
 ${response.configuration?.runtime}") 
    }
}
1216AWS Lambda Developer Guide
Get started with functions
suspend fun listFunctionsSc() { 
    val request = ListFunctionsRequest { 
        maxItems = 10 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val response = awsLambda.listFunctions(request) 
        response.functions?.forEach { function -> 
            println("The function name is ${function.functionName}") 
        } 
    }
}
suspend fun invokeFunctionSc(functionNameVal: String) { 
    val json = """{"inputValue":"1000"}""" 
    val byteArray = json.trimIndent().encodeToByteArray() 
    val request = InvokeRequest { 
        functionName = functionNameVal 
        payload = byteArray 
        logType = LogType.Tail 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val res = awsLambda.invoke(request) 
        println("The function payload is ${res.payload?.toString(Charsets.UTF_8)}") 
    }
}
suspend fun updateFunctionCode(functionNameVal: String?, bucketName: String?, key: 
 String?) { 
    val functionCodeRequest = UpdateFunctionCodeRequest { 
        functionName = functionNameVal 
        publish = true 
        s3Bucket = bucketName 
        s3Key = key 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        val response = awsLambda.updateFunctionCode(functionCodeRequest) 
        awsLambda.waitUntilFunctionUpdated { 
            functionName = functionNameVal 
        } 
        println("The last modified value is " + response.lastModified) 
    }
}
suspend fun UpdateFunctionConfiguration(functionNameVal: String?, handlerVal: 
 String?) { 
    val configurationRequest = UpdateFunctionConfigurationRequest { 
        functionName = functionNameVal 
        handler = handlerVal 
        runtime = Runtime.Java11 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        awsLambda.updateFunctionConfiguration(configurationRequest) 
    }
}
suspend fun delFunction(myFunctionName: String) { 
1217AWS Lambda Developer Guide
Get started with functions
    val request = DeleteFunctionRequest { 
        functionName = myFunctionName 
    } 
    LambdaClient { region = "us-west-2" }.use { awsLambda -> 
        awsLambda.deleteFunction(request) 
        println("$myFunctionName was deleted") 
    }
}
•For API details, see the following topics in AWS SDK for Kotlin API reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
PHP
SDK for PHP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
namespace Lambda;
use Aws\S3\S3Client;
use GuzzleHttp\Psr7\Stream;
use Iam\IAMService;
class GettingStartedWithLambda
{ 
    public function run() 
    { 
        echo("\n"); 
        echo("--------------------------------------\n"); 
        print("Welcome to the AWS Lambda getting started demo using PHP!\n"); 
        echo("--------------------------------------\n"); 
        $clientArgs = [ 
            'region' => 'us-west-2', 
            'version' => 'latest', 
            'profile' => 'default', 
        ]; 
        $uniqid = uniqid(); 
        $iamService = new IAMService(); 
        $s3client = new S3Client($clientArgs); 
        $lambdaService = new LambdaService(); 
        echo "First, let's create a role to run our Lambda code.\n"; 
        $roleName = "test-lambda-role-$uniqid"; 
        $rolePolicyDocument = "{ 
            \"Version\": \"2012-10-17\", 
            \"Statement\": [ 
                { 
1218AWS Lambda Developer Guide
Get started with functions
                    \"Effect\": \"Allow\", 
                    \"Principal\": { 
                        \"Service\": \"lambda.amazonaws.com\" 
                    }, 
                    \"Action\": \"sts:AssumeRole\" 
                } 
            ] 
        }"; 
        $role = $iamService->createRole($roleName, $rolePolicyDocument); 
        echo "Created role {$role['RoleName']}.\n"; 
        $iamService->attachRolePolicy( 
            $role['RoleName'], 
            "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole" 
        ); 
        echo "Attached the AWSLambdaBasicExecutionRole to {$role['RoleName']}.\n"; 
        echo "\nNow let's create an S3 bucket and upload our Lambda code there.\n"; 
        $bucketName = "test-example-bucket-$uniqid"; 
        $s3client->createBucket([ 
            'Bucket' => $bucketName, 
        ]); 
        echo "Created bucket $bucketName.\n"; 
        $functionName = "doc_example_lambda_$uniqid"; 
        $codeBasic = __DIR__ . "/lambda_handler_basic.zip"; 
        $handler = "lambda_handler_basic"; 
        $file = file_get_contents($codeBasic); 
        $s3client->putObject([ 
            'Bucket' => $bucketName, 
            'Key' => $functionName, 
            'Body' => $file, 
        ]); 
        echo "Uploaded the Lambda code.\n"; 
        $createLambdaFunction = $lambdaService->createFunction($functionName, 
 $role, $bucketName, $handler); 
        // Wait until the function has finished being created. 
        do { 
            $getLambdaFunction = $lambdaService-
>getFunction($createLambdaFunction['FunctionName']); 
        } while ($getLambdaFunction['Configuration']['State'] == "Pending"); 
        echo "Created Lambda function {$getLambdaFunction['Configuration']
['FunctionName']}.\n"; 
        sleep(1); 
        echo "\nOk, let's invoke that Lambda code.\n"; 
        $basicParams = [ 
            'action' => 'increment', 
            'number' => 3, 
        ]; 
        /** @var Stream $invokeFunction */ 
        $invokeFunction = $lambdaService->invoke($functionName, $basicParams)
['Payload']; 
        $result = json_decode($invokeFunction->getContents())->result; 
        echo "After invoking the Lambda code with the input of 
 {$basicParams['number']} we received $result.\n"; 
        echo "\nSince that's working, let's update the Lambda code.\n"; 
        $codeCalculator = "lambda_handler_calculator.zip"; 
        $handlerCalculator = "lambda_handler_calculator"; 
        echo "First, put the new code into the S3 bucket.\n"; 
        $file = file_get_contents($codeCalculator); 
        $s3client->putObject([ 
            'Bucket' => $bucketName, 
1219AWS Lambda Developer Guide
Get started with functions
            'Key' => $functionName, 
            'Body' => $file, 
        ]); 
        echo "New code uploaded.\n"; 
        $lambdaService->updateFunctionCode($functionName, $bucketName, 
 $functionName); 
        // Wait for the Lambda code to finish updating. 
        do { 
            $getLambdaFunction = $lambdaService-
>getFunction($createLambdaFunction['FunctionName']); 
        } while ($getLambdaFunction['Configuration']['LastUpdateStatus'] !== 
 "Successful"); 
        echo "New Lambda code uploaded.\n"; 
        $environment = [ 
            'Variable' => ['Variables' => ['LOG_LEVEL' => 'DEBUG']], 
        ]; 
        $lambdaService->updateFunctionConfiguration($functionName, 
 $handlerCalculator, $environment); 
        do { 
            $getLambdaFunction = $lambdaService-
>getFunction($createLambdaFunction['FunctionName']); 
        } while ($getLambdaFunction['Configuration']['LastUpdateStatus'] !== 
 "Successful"); 
        echo "Lambda code updated with new handler and a LOG_LEVEL of DEBUG for 
 more information.\n"; 
        echo "Invoke the new code with some new data.\n"; 
        $calculatorParams = [ 
            'action' => 'plus', 
            'x' => 5, 
            'y' => 4, 
        ]; 
        $invokeFunction = $lambdaService->invoke($functionName, $calculatorParams, 
 "Tail"); 
        $result = json_decode($invokeFunction['Payload']->getContents())->result; 
        echo "Indeed, {$calculatorParams['x']} + {$calculatorParams['y']} does 
 equal $result.\n"; 
        echo "Here's the extra debug info: "; 
        echo base64_decode($invokeFunction['LogResult']) . "\n"; 
        echo "\nBut what happens if you try to divide by zero?\n"; 
        $divZeroParams = [ 
            'action' => 'divide', 
            'x' => 5, 
            'y' => 0, 
        ]; 
        $invokeFunction = $lambdaService->invoke($functionName, $divZeroParams, 
 "Tail"); 
        $result = json_decode($invokeFunction['Payload']->getContents())->result; 
        echo "You get a |$result| result.\n"; 
        echo "And an error message: "; 
        echo base64_decode($invokeFunction['LogResult']) . "\n"; 
        echo "\nHere's all the Lambda functions you have in this Region:\n"; 
        $listLambdaFunctions = $lambdaService->listFunctions(5); 
        $allLambdaFunctions = $listLambdaFunctions['Functions']; 
        $next = $listLambdaFunctions->get('NextMarker'); 
        while ($next != false) { 
            $listLambdaFunctions = $lambdaService->listFunctions(5, $next); 
            $next = $listLambdaFunctions->get('NextMarker'); 
            $allLambdaFunctions = array_merge($allLambdaFunctions, 
 $listLambdaFunctions['Functions']); 
        } 
        foreach ($allLambdaFunctions as $function) { 
1220AWS Lambda Developer Guide
Get started with functions
            echo "{$function['FunctionName']}\n"; 
        } 
        echo "\n\nAnd don't forget to clean up your data!\n"; 
        $lambdaService->deleteFunction($functionName); 
        echo "Deleted Lambda function.\n"; 
        $iamService->deleteRole($role['RoleName']); 
        echo "Deleted Role.\n"; 
        $deleteObjects = $s3client->listObjectsV2([ 
            'Bucket' => $bucketName, 
        ]); 
        $deleteObjects = $s3client->deleteObjects([ 
            'Bucket' => $bucketName, 
            'Delete' => [ 
                'Objects' => $deleteObjects['Contents'], 
            ] 
        ]); 
        echo "Deleted all objects from the S3 bucket.\n"; 
        $s3client->deleteBucket(['Bucket' => $bucketName]); 
        echo "Deleted the bucket.\n"; 
    }
}
•For API details, see the following topics in AWS SDK for PHP API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Deﬁne a Lambda handler that increments a number.
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
def lambda_handler(event, context): 
    """ 
    Accepts an action and a single number, performs the specified action on the 
 number, 
    and returns the result. The only allowable action is 'increment'. 
    :param event: The event dict that contains the parameters sent when the 
 function 
                  is invoked. 
    :param context: The context in which the function is called. 
1221AWS Lambda Developer Guide
Get started with functions
    :return: The result of the action. 
    """ 
    result = None 
    action = event.get('action') 
    if action == 'increment': 
        result = event.get('number', 0) + 1 
        logger.info('Calculated result of %s', result) 
    else: 
        logger.error("%s is not a valid action.", action) 
    response = {'result': result} 
    return response
Deﬁne a second Lambda handler that performs arithmetic operations.
import logging
import os
logger = logging.getLogger()
# Define a list of Python lambda functions that are called by this AWS Lambda 
 function.
ACTIONS = { 
    'plus': lambda x, y: x + y, 
    'minus': lambda x, y: x - y, 
    'times': lambda x, y: x * y, 
    'divided-by': lambda x, y: x / y}
def lambda_handler(event, context): 
    """ 
    Accepts an action and two numbers, performs the specified action on the 
 numbers, 
    and returns the result. 
    :param event: The event dict that contains the parameters sent when the 
 function 
                  is invoked. 
    :param context: The context in which the function is called. 
    :return: The result of the specified action. 
    """ 
    # Set the log level based on a variable configured in the Lambda environment. 
    logger.setLevel(os.environ.get('LOG_LEVEL', logging.INFO)) 
    logger.debug('Event: %s', event) 
    action = event.get('action') 
    func = ACTIONS.get(action) 
    x = event.get('x') 
    y = event.get('y') 
    result = None 
    try: 
        if func is not None and x is not None and y is not None: 
            result = func(x, y) 
            logger.info("%s %s %s is %s", x, action, y, result) 
        else: 
            logger.error("I can't calculate %s %s %s.", x, action, y) 
    except ZeroDivisionError: 
        logger.warning("I can't divide %s by 0!", x) 
    response = {'result': result} 
    return response
1222AWS Lambda Developer Guide
Get started with functions
Create functions that wrap Lambda actions.
class LambdaWrapper: 
    def __init__(self, lambda_client, iam_resource): 
        self.lambda_client = lambda_client 
        self.iam_resource = iam_resource 
    @staticmethod 
    def create_deployment_package(source_file, destination_file): 
        """ 
        Creates a Lambda deployment package in .zip format in an in-memory buffer. 
 This 
        buffer can be passed directly to Lambda when creating the function. 
        :param source_file: The name of the file that contains the Lambda handler 
                            function. 
        :param destination_file: The name to give the file when it's deployed to 
 Lambda. 
        :return: The deployment package. 
        """ 
        buffer = io.BytesIO() 
        with zipfile.ZipFile(buffer, 'w') as zipped: 
            zipped.write(source_file, destination_file) 
        buffer.seek(0) 
        return buffer.read() 
    def get_iam_role(self, iam_role_name): 
        """ 
        Get an AWS Identity and Access Management (IAM) role. 
        :param iam_role_name: The name of the role to retrieve. 
        :return: The IAM role. 
        """ 
        role = None 
        try: 
            temp_role = self.iam_resource.Role(iam_role_name) 
            temp_role.load() 
            role = temp_role 
            logger.info("Got IAM role %s", role.name) 
        except ClientError as err: 
            if err.response['Error']['Code'] == 'NoSuchEntity': 
                logger.info("IAM role %s does not exist.", iam_role_name) 
            else: 
                logger.error( 
                    "Couldn't get IAM role %s. Here's why: %s: %s", iam_role_name, 
                    err.response['Error']['Code'], err.response['Error']
['Message']) 
                raise 
        return role 
    def create_iam_role_for_lambda(self, iam_role_name): 
        """ 
        Creates an IAM role that grants the Lambda function basic permissions. If a 
        role with the specified name already exists, it is used for the demo. 
        :param iam_role_name: The name of the role to create. 
        :return: The role and a value that indicates whether the role is newly 
 created. 
        """ 
        role = self.get_iam_role(iam_role_name) 
        if role is not None: 
            return role, False 
        lambda_assume_role_policy = { 
            'Version': '2012-10-17', 
1223AWS Lambda Developer Guide
Get started with functions
            'Statement': [ 
                { 
                    'Effect': 'Allow', 
                    'Principal': { 
                        'Service': 'lambda.amazonaws.com' 
                    }, 
                    'Action': 'sts:AssumeRole' 
                } 
            ] 
        } 
        policy_arn = 'arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole' 
        try: 
            role = self.iam_resource.create_role( 
                RoleName=iam_role_name, 
                AssumeRolePolicyDocument=json.dumps(lambda_assume_role_policy)) 
            logger.info("Created role %s.", role.name) 
            role.attach_policy(PolicyArn=policy_arn) 
            logger.info("Attached basic execution policy to role %s.", role.name) 
        except ClientError as error: 
            if error.response['Error']['Code'] == 'EntityAlreadyExists': 
                role = self.iam_resource.Role(iam_role_name) 
                logger.warning("The role %s already exists. Using it.", 
 iam_role_name) 
            else: 
                logger.exception( 
                    "Couldn't create role %s or attach policy %s.", 
                    iam_role_name, policy_arn) 
                raise 
        return role, True 
    def get_function(self, function_name): 
        """ 
        Gets data about a Lambda function. 
        :param function_name: The name of the function. 
        :return: The function data. 
        """ 
        response = None 
        try: 
            response = self.lambda_client.get_function(FunctionName=function_name) 
        except ClientError as err: 
            if err.response['Error']['Code'] == 'ResourceNotFoundException': 
                logger.info("Function %s does not exist.", function_name) 
            else: 
                logger.error( 
                    "Couldn't get function %s. Here's why: %s: %s", function_name, 
                    err.response['Error']['Code'], err.response['Error']
['Message']) 
                raise 
        return response 
    def create_function(self, function_name, handler_name, iam_role, 
 deployment_package): 
        """ 
        Deploys a Lambda function. 
        :param function_name: The name of the Lambda function. 
        :param handler_name: The fully qualified name of the handler function. This 
                             must include the file name and the function name. 
        :param iam_role: The IAM role to use for the function. 
        :param deployment_package: The deployment package that contains the 
 function 
                                   code in .zip format. 
1224AWS Lambda Developer Guide
Get started with functions
        :return: The Amazon Resource Name (ARN) of the newly created function. 
        """ 
        try: 
            response = self.lambda_client.create_function( 
                FunctionName=function_name, 
                Description="AWS Lambda doc example", 
                Runtime='python3.8', 
                Role=iam_role.arn, 
                Handler=handler_name, 
                Code={'ZipFile': deployment_package}, 
                Publish=True) 
            function_arn = response['FunctionArn'] 
            waiter = self.lambda_client.get_waiter('function_active_v2') 
            waiter.wait(FunctionName=function_name) 
            logger.info("Created function '%s' with ARN: '%s'.", 
                        function_name, response['FunctionArn']) 
        except ClientError: 
            logger.error("Couldn't create function %s.", function_name) 
            raise 
        else: 
            return function_arn 
    def delete_function(self, function_name): 
        """ 
        Deletes a Lambda function. 
        :param function_name: The name of the function to delete. 
        """ 
        try: 
            self.lambda_client.delete_function(FunctionName=function_name) 
        except ClientError: 
            logger.exception("Couldn't delete function %s.", function_name) 
            raise 
    def invoke_function(self, function_name, function_params, get_log=False): 
        """ 
        Invokes a Lambda function. 
        :param function_name: The name of the function to invoke. 
        :param function_params: The parameters of the function as a dict. This dict 
                                is serialized to JSON before it is sent to Lambda. 
        :param get_log: When true, the last 4 KB of the execution log are included 
 in 
                        the response. 
        :return: The response from the function invocation. 
        """ 
        try: 
            response = self.lambda_client.invoke( 
                FunctionName=function_name, 
                Payload=json.dumps(function_params), 
                LogType='Tail' if get_log else 'None') 
            logger.info("Invoked function %s.", function_name) 
        except ClientError: 
            logger.exception("Couldn't invoke function %s.", function_name) 
            raise 
        return response 
    def update_function_code(self, function_name, deployment_package): 
        """ 
        Updates the code for a Lambda function by submitting a .zip archive that 
 contains 
        the code for the function. 
        :param function_name: The name of the function to update. 
        :param deployment_package: The function code to update, packaged as bytes 
 in 
1225AWS Lambda Developer Guide
Get started with functions
                                   .zip format. 
        :return: Data about the update, including the status. 
        """ 
        try: 
            response = self.lambda_client.update_function_code( 
                FunctionName=function_name, ZipFile=deployment_package) 
        except ClientError as err: 
            logger.error( 
                "Couldn't update function %s. Here's why: %s: %s", function_name, 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise 
        else: 
            return response 
    def update_function_configuration(self, function_name, env_vars): 
        """ 
        Updates the environment variables for a Lambda function. 
        :param function_name: The name of the function to update. 
        :param env_vars: A dict of environment variables to update. 
        :return: Data about the update, including the status. 
        """ 
        try: 
            response = self.lambda_client.update_function_configuration( 
                FunctionName=function_name, Environment={'Variables': env_vars}) 
        except ClientError as err: 
            logger.error( 
                "Couldn't update function configuration %s. Here's why: %s: %s", 
 function_name, 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise 
        else: 
            return response 
    def list_functions(self): 
        """ 
        Lists the Lambda functions for the current account. 
        """ 
        try: 
            func_paginator = self.lambda_client.get_paginator('list_functions') 
            for func_page in func_paginator.paginate(): 
                for func in func_page['Functions']: 
                    print(func['FunctionName']) 
                    desc = func.get('Description') 
                    if desc: 
                        print(f"\t{desc}") 
                    print(f"\t{func['Runtime']}: {func['Handler']}") 
        except ClientError as err: 
            logger.error( 
                "Couldn't list functions. Here's why: %s: %s", 
                err.response['Error']['Code'], err.response['Error']['Message']) 
            raise
Create a function that runs the scenario.
class UpdateFunctionWaiter(CustomWaiter): 
    """A custom waiter that waits until a function is successfully updated.""" 
    def __init__(self, client): 
        super().__init__( 
            'UpdateSuccess', 'GetFunction', 
            'Configuration.LastUpdateStatus', 
            {'Successful': WaitState.SUCCESS, 'Failed': WaitState.FAILURE}, 
            client) 
1226AWS Lambda Developer Guide
Get started with functions
    def wait(self, function_name): 
        self._wait(FunctionName=function_name)
def run_scenario(lambda_client, iam_resource, basic_file, calculator_file, 
 lambda_name): 
    """ 
    Runs the scenario. 
    :param lambda_client: A Boto3 Lambda client. 
    :param iam_resource: A Boto3 IAM resource. 
    :param basic_file: The name of the file that contains the basic Lambda handler. 
    :param calculator_file: The name of the file that contains the calculator 
 Lambda handler. 
    :param lambda_name: The name to give resources created for the scenario, such 
 as the 
                        IAM role and the Lambda function. 
    """ 
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s') 
    print('-'*88) 
    print("Welcome to the AWS Lambda getting started with functions demo.") 
    print('-'*88) 
    wrapper = LambdaWrapper(lambda_client, iam_resource) 
    print("Checking for IAM role for Lambda...") 
    iam_role, should_wait = wrapper.create_iam_role_for_lambda(lambda_name) 
    if should_wait: 
        logger.info("Giving AWS time to create resources...") 
        wait(10) 
    print(f"Looking for function {lambda_name}...") 
    function = wrapper.get_function(lambda_name) 
    if function is None: 
        print("Zipping the Python script into a deployment package...") 
        deployment_package = wrapper.create_deployment_package(basic_file, 
 f"{lambda_name}.py") 
        print(f"...and creating the {lambda_name} Lambda function.") 
        wrapper.create_function( 
            lambda_name, f'{lambda_name}.lambda_handler', iam_role, 
 deployment_package) 
    else: 
        print(f"Function {lambda_name} already exists.") 
    print('-'*88) 
    print(f"Let's invoke {lambda_name}. This function increments a number.") 
    action_params = { 
        'action': 'increment', 
        'number': q.ask("Give me a number to increment: ", q.is_int)} 
    print(f"Invoking {lambda_name}...") 
    response = wrapper.invoke_function(lambda_name, action_params) 
    print(f"Incrementing {action_params['number']} resulted in " 
          f"{json.load(response['Payload'])}") 
    print('-'*88) 
    print(f"Let's update the function to an arithmetic calculator.") 
    q.ask("Press Enter when you're ready.") 
    print("Creating a new deployment package...") 
    deployment_package = wrapper.create_deployment_package(calculator_file, 
 f"{lambda_name}.py") 
    print(f"...and updating the {lambda_name} Lambda function.") 
    update_waiter = UpdateFunctionWaiter(lambda_client) 
    wrapper.update_function_code(lambda_name, deployment_package) 
    update_waiter.wait(lambda_name) 
    print(f"This function uses an environment variable to control logging level.") 
1227AWS Lambda Developer Guide
Get started with functions
    print(f"Let's set it to DEBUG to get the most logging.") 
    wrapper.update_function_configuration( 
        lambda_name, {'LOG_LEVEL': logging.getLevelName(logging.DEBUG)}) 
    actions = ['plus', 'minus', 'times', 'divided-by'] 
    want_invoke = True 
    while want_invoke: 
        print(f"Let's invoke {lambda_name}. You can invoke these actions:") 
        for index, action in enumerate(actions): 
            print(f"{index + 1}: {action}") 
        action_params = {} 
        action_index = q.ask( 
            "Enter the number of the action you want to take: ", 
            q.is_int, q.in_range(1, len(actions))) 
        action_params['action'] = actions[action_index - 1] 
        print(f"You've chosen to invoke 'x {action_params['action']} y'.") 
        action_params['x'] = q.ask("Enter a value for x: ", q.is_int) 
        action_params['y'] = q.ask("Enter a value for y: ", q.is_int) 
        print(f"Invoking {lambda_name}...") 
        response = wrapper.invoke_function(lambda_name, action_params, True) 
        print(f"Calculating {action_params['x']} {action_params['action']} 
 {action_params['y']} " 
              f"resulted in {json.load(response['Payload'])}") 
        q.ask("Press Enter to see the logs from the call.") 
        print(base64.b64decode(response['LogResult']).decode()) 
        want_invoke = q.ask("That was fun. Shall we do it again? (y/n) ", 
 q.is_yesno) 
    print('-'*88) 
    if q.ask("Do you want to list all of the functions in your account? (y/n) ", 
 q.is_yesno): 
        wrapper.list_functions() 
    print('-'*88) 
    if q.ask("Ready to delete the function and role? (y/n) ", q.is_yesno): 
        for policy in iam_role.attached_policies.all(): 
            policy.detach_role(RoleName=iam_role.name) 
        iam_role.delete() 
        print(f"Deleted role {lambda_name}.") 
        wrapper.delete_function(lambda_name) 
        print(f"Deleted function {lambda_name}.") 
    print("\nThanks for watching!") 
    print('-'*88)
if __name__ == '__main__': 
    try: 
        run_scenario( 
            boto3.client('lambda'), boto3.resource('iam'), 
 'lambda_handler_basic.py', 
            'lambda_handler_calculator.py', 'doc_example_lambda_calculator') 
    except Exception: 
        logging.exception("Something went wrong with the demo!")
•For API details, see the following topics in AWS SDK for Python (Boto3) API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
1228AWS Lambda Developer Guide
Get started with functions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
Ruby
SDK for Ruby
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
Set up pre-requisite IAM permissions for a Lambda function capable of writing logs.
  # Get an AWS Identity and Access Management (IAM) role. 
  # 
  # @param iam_role_name: The name of the role to retrieve. 
  # @param action: Whether to create or destroy the IAM apparatus. 
  # @return: The IAM role. 
  def manage_iam(iam_role_name, action) 
    role_policy = { 
      'Version': "2012-10-17", 
      'Statement': [ 
        { 
          'Effect': "Allow", 
          'Principal': { 
            'Service': "lambda.amazonaws.com" 
          }, 
          'Action': "sts:AssumeRole" 
        } 
      ] 
    } 
    case action 
    when "create" 
      role = $iam_client.create_role( 
        role_name: iam_role_name, 
        assume_role_policy_document: role_policy.to_json 
      ) 
      $iam_client.attach_role_policy( 
        { 
          policy_arn: "arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole", 
          role_name: iam_role_name 
        } 
      ) 
      $iam_client.wait_until(:role_exists, { role_name: iam_role_name }) do |w| 
        w.max_attempts = 5 
        w.delay = 5 
      end 
      @logger.debug("Successfully created IAM role: #{role['role']['arn']}") 
      @logger.debug("Enforcing a 10-second sleep to allow IAM role to activate 
 fully.") 
      sleep(10) 
      return role, role_policy.to_json 
    when "destroy" 
      $iam_client.detach_role_policy( 
        { 
          policy_arn: "arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole", 
          role_name: iam_role_name 
        } 
      ) 
      $iam_client.delete_role( 
        role_name: iam_role_name 
1229AWS Lambda Developer Guide
Get started with functions
      ) 
      @logger.debug("Detached policy & deleted IAM role: #{iam_role_name}") 
    else 
      raise "Incorrect action provided. Must provide 'create' or 'destroy'" 
    end 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error creating role or attaching policy:\n 
 #{e.message}") 
  end
Deﬁne a Lambda handler that increments a number provided as an invocation parameter.
require "logger"
# A function that increments a whole number by one (1) and logs the result.
# Requires a manually-provided runtime parameter, 'number', which must be Int
#
# @param event [Hash] Parameters sent when the function is invoked
# @param context [Hash] Methods and properties that provide information
# about the invocation, function, and execution environment.
# @return incremented_number [String] The incremented number.
def lambda_handler(event:, context:) 
  logger = Logger.new($stdout) 
  log_level = ENV["LOG_LEVEL"] 
  logger.level = case log_level 
                 when "debug" 
                   Logger::DEBUG 
                 when "info" 
                   Logger::INFO 
                 else 
                   Logger::ERROR 
                 end 
  logger.debug("This is a debug log message.") 
  logger.info("This is an info log message. Code executed successfully!") 
  number = event["number"].to_i 
  incremented_number = number + 1 
  logger.info("You provided #{number.round} and it was incremented to 
 #{incremented_number.round}") 
  incremented_number.round.to_s
end
Zip your Lambda function into a deployment package.
  # Creates a Lambda deployment package in .zip format. 
  # This zip can be passed directly as a string to Lambda when creating the 
 function. 
  # 
  # @param source_file: The name of the object, without suffix, for the Lambda file 
 and zip. 
  # @return: The deployment package. 
  def create_deployment_package(source_file) 
    Dir.chdir(File.dirname(__FILE__)) 
    if File.exist?("lambda_function.zip") 
      File.delete("lambda_function.zip") 
      @logger.debug("Deleting old zip: lambda_function.zip") 
    end 
    Zip::File.open("lambda_function.zip", create: true) { 
      |zipfile| 
      zipfile.add("lambda_function.rb", "#{source_file}.rb") 
    } 
    @logger.debug("Zipping #{source_file}.rb into: lambda_function.zip.") 
1230AWS Lambda Developer Guide
Get started with functions
    File.read("lambda_function.zip").to_s 
  rescue StandardError => e 
    @logger.error("There was an error creating deployment package:\n #{e.message}") 
  end
Create a new Lambda function.
  # Deploys a Lambda function. 
  # 
  # @param function_name: The name of the Lambda function. 
  # @param handler_name: The fully qualified name of the handler function. This 
  #                      must include the file name and the function name. 
  # @param role_arn: The IAM role to use for the function. 
  # @param deployment_package: The deployment package that contains the function 
  #                            code in .zip format. 
  # @return: The Amazon Resource Name (ARN) of the newly created function. 
  def create_function(function_name, handler_name, role_arn, deployment_package) 
    response = @lambda_client.create_function({ 
                                                role: role_arn.to_s, 
                                                function_name: function_name, 
                                                handler: handler_name, 
                                                runtime: "ruby2.7", 
                                                code: { 
                                                  zip_file: deployment_package 
                                                }, 
                                                environment: { 
                                                  variables: { 
                                                    "LOG_LEVEL" => "info" 
                                                  } 
                                                } 
                                              }) 
    @lambda_client.wait_until(:function_active_v2, { function_name: function_name}) 
 do |w| 
      w.max_attempts = 5 
      w.delay = 5 
    end 
    response 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error creating #{function_name}:\n #{e.message}") 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to activate:\n 
 #{e.message}") 
  end
Invoke your Lambda function with optional runtime parameters.
  # Invokes a Lambda function. 
  # @param function_name [String] The name of the function to invoke. 
  # @param payload [nil] Payload containing runtime parameters. 
  # @return [Object] The response from the function invocation. 
  def invoke_function(function_name, payload = nil) 
    params = { function_name: function_name} 
    params[:payload] = payload unless payload.nil? 
    @lambda_client.invoke(params) 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error executing #{function_name}:\n #{e.message}") 
  end
Update your Lambda function's conﬁguration to inject a new environment variable.
1231AWS Lambda Developer Guide
Get started with functions
  # Updates the environment variables for a Lambda function. 
  # @param function_name: The name of the function to update. 
  # @param log_level: The log level of the function. 
  # @return: Data about the update, including the status. 
  def update_function_configuration(function_name, log_level) 
    @lambda_client.update_function_configuration({ 
                                                   function_name: function_name, 
                                                   environment: { 
                                                     variables: { 
                                                       "LOG_LEVEL" => log_level 
                                                     } 
                                                   } 
                                                 }) 
    @lambda_client.wait_until(:function_updated_v2, { function_name: 
 function_name}) do |w| 
      w.max_attempts = 5 
      w.delay = 5 
    end 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error updating configurations for #{function_name}:
\n #{e.message}") 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to activate:\n 
 #{e.message}") 
  end
Update your Lambda function's code with a diﬀerent deployment package containing diﬀerent 
code.
  # Updates the code for a Lambda function by submitting a .zip archive that 
 contains 
  # the code for the function. 
  # @param function_name: The name of the function to update. 
  # @param deployment_package: The function code to update, packaged as bytes in 
  #                            .zip format. 
  # @return: Data about the update, including the status. 
  def update_function_code(function_name, deployment_package) 
    @lambda_client.update_function_code( 
      function_name: function_name, 
      zip_file: deployment_package 
    ) 
    @lambda_client.wait_until(:function_updated_v2, { function_name: 
 function_name}) do |w| 
      w.max_attempts = 5 
      w.delay = 5 
    end 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error updating function code for: #{function_name}:
\n #{e.message}") 
    nil 
  rescue Aws::Waiters::Errors::WaiterFailed => e 
    @logger.error("Failed waiting for #{function_name} to update:\n #{e.message}") 
  end
List all existing Lambda functions using the built-in paginator.
  # Lists the Lambda functions for the current account. 
  def list_functions 
    functions = [] 
    @lambda_client.list_functions.each do |response| 
1232AWS Lambda Developer Guide
Get started with functions
      response["functions"].each do |function| 
        functions.append(function["function_name"]) 
      end 
    end 
    functions 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error executing #{function_name}:\n #{e.message}") 
  end
Delete a speciﬁc Lambda function.
  # Deletes a Lambda function. 
  # @param function_name: The name of the function to delete. 
  def delete_function(function_name) 
    print "Deleting function: #{function_name}..." 
    @lambda_client.delete_function( 
      function_name: function_name 
    ) 
    print "Done!".green 
  rescue Aws::Lambda::Errors::ServiceException => e 
    @logger.error("There was an error deleting #{function_name}:\n #{e.message}") 
  end
•For API details, see the following topics in AWS SDK for Ruby API Reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
The Cargo.toml with dependencies used in this scenario.
[package]
name = "lambda-code-examples"
version = "0.1.0"
edition = "2021"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/
manifest.html
[dependencies]
aws-config = { git = "https://github.com/awslabs/aws-sdk-rust", branch = "main" }
aws-sdk-ec2 = { git = "https://github.com/awslabs/aws-sdk-rust", branch = "main" }
1233AWS Lambda Developer Guide
Get started with functions
aws-sdk-iam = { git = "https://github.com/awslabs/aws-sdk-rust", branch = "main" }
aws-sdk-lambda = { git = "https://github.com/awslabs/aws-sdk-rust", branch = 
 "main" }
aws-sdk-s3 = { git = "https://github.com/awslabs/aws-sdk-rust", branch = "main" }
aws-smithy-types = { git = "https://github.com/awslabs/aws-sdk-rust", branch = 
 "main" }
aws-types = { git = "https://github.com/awslabs/aws-sdk-rust", branch = "main" }
clap = { version = "4.2.1", features = ["derive"] }
tokio = { version = "1.20.1", features = ["full"] }
tracing-subscriber = { version = "0.3.15", features = ["env-filter"] }
tracing = "0.1.37"
serde_json = "1.0.94"
anyhow = "1.0.71"
uuid = { version = "1.3.3", features = ["v4"] }
lambda_runtime = "0.8.0"
serde = "1.0.164"
A collection of utilities that streamline calling Lambda for this scenario. This ﬁle is src/ations.rs 
in the crate.
/* 
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. 
 * SPDX-License-Identifier: Apache-2.0. 
 */
use anyhow::anyhow;
use aws_sdk_iam::operation::delete_role::DeleteRoleOutput;
use aws_sdk_lambda::{ 
    operation::{ 
        delete_function::DeleteFunctionOutput, get_function::GetFunctionOutput, 
        invoke::InvokeOutput, list_functions::ListFunctionsOutput, 
        update_function_code::UpdateFunctionCodeOutput, 
        update_function_configuration::UpdateFunctionConfigurationOutput, 
    }, 
    primitives::ByteStream, 
    types::{Environment, FunctionCode, LastUpdateStatus, State},
};
use aws_sdk_s3::{ 
    operation::{delete_bucket::DeleteBucketOutput, 
 delete_object::DeleteObjectOutput}, 
    types::CreateBucketConfiguration,
};
use aws_smithy_types::Blob;
use serde::{ser::SerializeMap, Serialize};
use std::{path::PathBuf, str::FromStr, time::Duration};
use tracing::{debug, error, info, warn};
/* Operation describes  */
#[derive(Clone, Copy, Debug, Serialize)]
pub enum Operation { 
    #[serde(rename = "plus")] 
    Plus, 
    #[serde(rename = "minus")] 
    Minus, 
    #[serde(rename = "times")] 
    Times, 
    #[serde(rename = "divided-by")] 
    DividedBy,
}
impl FromStr for Operation { 
    type Err = anyhow::Error; 
1234AWS Lambda Developer Guide
Get started with functions
    fn from_str(s: &str) -> Result<Self, Self::Err> { 
        match s { 
            "plus" => Ok(Operation::Plus), 
            "minus" => Ok(Operation::Minus), 
            "times" => Ok(Operation::Times), 
            "divided-by" => Ok(Operation::DividedBy), 
            _ => Err(anyhow!("Unknown operation {s}")), 
        } 
    }
}
impl ToString for Operation { 
    fn to_string(&self) -> String { 
        match self { 
            Operation::Plus => "plus".to_string(), 
            Operation::Minus => "minus".to_string(), 
            Operation::Times => "times".to_string(), 
            Operation::DividedBy => "divided-by".to_string(), 
        } 
    }
}
/** 
 * InvokeArgs will be serialized as JSON and sent to the AWS Lambda handler. 
 */
#[derive(Debug)]
pub enum InvokeArgs { 
    Increment(i32), 
    Arithmetic(Operation, i32, i32),
}
impl Serialize for InvokeArgs { 
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> 
    where 
        S: serde::Serializer, 
    { 
        match self { 
            InvokeArgs::Increment(i) => serializer.serialize_i32(*i), 
            InvokeArgs::Arithmetic(o, i, j) => { 
                let mut map: S::SerializeMap = serializer.serialize_map(Some(3))?; 
                map.serialize_key(&"op".to_string())?; 
                map.serialize_value(&o.to_string())?; 
                map.serialize_key(&"i".to_string())?; 
                map.serialize_value(&i)?; 
                map.serialize_key(&"j".to_string())?; 
                map.serialize_value(&j)?; 
                map.end() 
            } 
        } 
    }
}
/** A policy document allowing Lambda to execute this function on the account's 
 behalf. */
const ROLE_POLICY_DOCUMENT: &str = r#"{ 
    "Version": "2012-10-17", 
    "Statement": [ 
        { 
            "Effect": "Allow", 
            "Principal": { "Service": "lambda.amazonaws.com" }, 
            "Action": "sts:AssumeRole" 
        } 
    ]
}"#;
/** 
1235AWS Lambda Developer Guide
Get started with functions
 * A LambdaManager gathers all the resources necessary to run the Lambda example 
 scenario. 
 * This includes instantiated aws_sdk clients and details of resource names. 
 */
pub struct LambdaManager { 
    iam_client: aws_sdk_iam::Client, 
    lambda_client: aws_sdk_lambda::Client, 
    s3_client: aws_sdk_s3::Client, 
    lambda_name: String, 
    role_name: String, 
    bucket: String, 
    own_bucket: bool,
}
// These unit type structs provide nominal typing on top of String parameters for 
 LambdaManager::new
pub struct LambdaName(pub String);
pub struct RoleName(pub String);
pub struct Bucket(pub String);
pub struct OwnBucket(pub bool);
impl LambdaManager { 
    pub fn new( 
        iam_client: aws_sdk_iam::Client, 
        lambda_client: aws_sdk_lambda::Client, 
        s3_client: aws_sdk_s3::Client, 
        lambda_name: LambdaName, 
        role_name: RoleName, 
        bucket: Bucket, 
        own_bucket: OwnBucket, 
    ) -> Self { 
        Self { 
            iam_client, 
            lambda_client, 
            s3_client, 
            lambda_name: lambda_name.0, 
            role_name: role_name.0, 
            bucket: bucket.0, 
            own_bucket: own_bucket.0, 
        } 
    } 
    /** 
     * Load the AWS configuration from the environment. 
     * Look up lambda_name and bucket if none are given, or generate a random name 
 if not present in the environment. 
     * If the bucket name is provided, the caller needs to have created the bucket. 
     * If the bucket name is generated, it will be created. 
     */ 
    pub async fn load_from_env(lambda_name: Option<String>, bucket: Option<String>) 
 -> Self { 
        let sdk_config = aws_config::load_from_env().await; 
        let lambda_name = LambdaName(lambda_name.unwrap_or_else(|| { 
            std::env::var("LAMBDA_NAME").unwrap_or_else(|_| 
 "rust_lambda_example".to_string()) 
        })); 
        let role_name = RoleName(format!("{}_role", lambda_name.0)); 
        let (bucket, own_bucket) = 
            match bucket { 
                Some(bucket) => (Bucket(bucket), false), 
                None => ( 
                    Bucket(std::env::var("LAMBDA_BUCKET").unwrap_or_else(|_| { 
                        format!("rust-lambda-example-{}", uuid::Uuid::new_v4()) 
                    })), 
                    true, 
                ), 
1236AWS Lambda Developer Guide
Get started with functions
            }; 
        let s3_client = aws_sdk_s3::Client::new(&sdk_config); 
        if own_bucket { 
            info!("Creating bucket for demo: {}", bucket.0); 
            s3_client 
                .create_bucket() 
                .bucket(bucket.0.clone()) 
                .create_bucket_configuration( 
                    CreateBucketConfiguration::builder() 
                        
 .location_constraint(aws_sdk_s3::types::BucketLocationConstraint::from( 
                            sdk_config.region().unwrap().as_ref(), 
                        )) 
                        .build(), 
                ) 
                .send() 
                .await 
                .unwrap(); 
        } 
        Self::new( 
            aws_sdk_iam::Client::new(&sdk_config), 
            aws_sdk_lambda::Client::new(&sdk_config), 
            s3_client, 
            lambda_name, 
            role_name, 
            bucket, 
            OwnBucket(own_bucket), 
        ) 
    } 
    // snippet-start:[lambda.rust.scenario.prepare_function] 
    /** 
     * Upload function code from a path to a zip file. 
     * The zip file must have an AL2 Linux-compatible binary called `bootstrap`. 
     * The easiest way to create such a zip is to use `cargo lambda build --output-
format Zip`. 
     */ 
    async fn prepare_function( 
        &self, 
        zip_file: PathBuf, 
        key: Option<String>, 
    ) -> Result<FunctionCode, anyhow::Error> { 
        let body = ByteStream::read_from().path(zip_file).build().await?; 
        let key = key.unwrap_or_else(|| format!("{}_code", self.lambda_name)); 
        info!("Uploading function code to s3://{}/{}", self.bucket, key); 
        let _ = self 
            .s3_client 
            .put_object() 
            .bucket(self.bucket.clone()) 
            .key(key.clone()) 
            .body(body) 
            .send() 
            .await?; 
        Ok(FunctionCode::builder() 
            .s3_bucket(self.bucket.clone()) 
            .s3_key(key) 
            .build()) 
    } 
    // snippet-end:[lambda.rust.scenario.prepare_function] 
1237AWS Lambda Developer Guide
Get started with functions
    // snippet-start:[lambda.rust.scenario.create_function] 
    /** 
     * Create a function, uploading from a zip file. 
     */ 
    pub async fn create_function(&self, zip_file: PathBuf) -> Result<String, 
 anyhow::Error> { 
        let code = self.prepare_function(zip_file, None).await?; 
        let key = code.s3_key().unwrap().to_string(); 
        self.create_role().await; 
        let role = self 
            .iam_client 
            .create_role() 
            .role_name(self.role_name.clone()) 
            .assume_role_policy_document(ROLE_POLICY_DOCUMENT) 
            .send() 
            .await?; 
        info!("Created iam role, waiting 15s for it to become active"); 
        tokio::time::sleep(Duration::from_secs(15)).await; 
        info!("Creating lambda function {}", self.lambda_name); 
        let _ = self 
            .lambda_client 
            .create_function() 
            .function_name(self.lambda_name.clone()) 
            .code(code) 
            .role(role.role().unwrap().arn().unwrap()) 
            .runtime(aws_sdk_lambda::types::Runtime::Providedal2) 
            .handler("_unused") 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        self.lambda_client 
            .publish_version() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await?; 
        Ok(key) 
    } 
    // snippet-end:[lambda.rust.scenario.create_function] 
    /** 
     * Create an IAM execution role for the managed Lambda function. 
     */ 
    async fn create_role(&self) { 
        info!("Creating execution role for function"); 
        if let Ok(_response) = self 
            .iam_client 
            .get_role() 
            .role_name(self.role_name.clone()) 
            .send() 
            .await 
        { 
            let delete_response = self 
                .iam_client 
                .delete_role() 
                .role_name(self.role_name.clone()) 
                .send() 
                .await; 
1238AWS Lambda Developer Guide
Get started with functions
            match delete_response { 
                Ok(_) => debug!("Deleted role first"), 
                Err(_) => { 
                    warn!("Failed to delete role, will probably fail to create the 
 new role") 
                } 
            } 
        } 
    } 
    /** 
     * Poll `is_function_ready` with a 1-second delay. It returns when the function 
 is ready or when there's an error checking the function's state. 
     */ 
    pub async fn wait_for_function_ready(&self) -> Result<(), anyhow::Error> { 
        info!("Waiting for function"); 
        while !self.is_function_ready(None).await? { 
            info!("Function is not ready, sleeping 1s"); 
            tokio::time::sleep(Duration::from_secs(1)).await; 
        } 
        Ok(()) 
    } 
    /** 
     * Check if a Lambda function is ready to be invoked. 
     * A Lambda function is ready for this scenario when its state is active and 
 its LastUpdateStatus is Successful. 
     * Additionally, if a sha256 is provided, the function must have that as its 
 current code hash. 
     * Any missing properties or failed requests will be reported as an Err. 
     */ 
    async fn is_function_ready( 
        &self, 
        expected_code_sha256: Option<&str>, 
    ) -> Result<bool, anyhow::Error> { 
        match self.get_function().await { 
            Ok(func) => { 
                if let Some(config) = func.configuration() { 
                    if let Some(state) = config.state() { 
                        info!(?state, "Checking if function is active"); 
                        if !matches!(state, State::Active) { 
                            return Ok(false); 
                        } 
                    } 
                    match config.last_update_status() { 
                        Some(last_update_status) => { 
                            info!(?last_update_status, "Checking if function is 
 ready"); 
                            match last_update_status { 
                                LastUpdateStatus::Successful => { 
                                    // continue 
                                } 
                                LastUpdateStatus::Failed | 
 LastUpdateStatus::InProgress => { 
                                    return Ok(false); 
                                } 
                                LastUpdateStatus::Unknown(status_variant) => { 
                                    warn!(?status_variant, "LastUpdateStatus 
 unknown"); 
                                    return Err(anyhow!( 
                                        "Unknown LastUpdateStatus, fn config is 
 {config:?}" 
                                    )); 
                                } 
                                _ => { 
                                    error!("Unmatched LastUpdateStatus"); 
1239AWS Lambda Developer Guide
Get started with functions
                                    return Err(anyhow!("Unmatched 
 LastUpdateStatus")); 
                                } 
                            } 
                        } 
                        None => { 
                            warn!("Missing last update status"); 
                            return Ok(false); 
                        } 
                    }; 
                    if expected_code_sha256.is_none() { 
                        return Ok(true); 
                    } 
                    if let Some(code_sha256) = config.code_sha256() { 
                        return Ok(code_sha256 == 
 expected_code_sha256.unwrap_or_default()); 
                    } 
                } 
            } 
            Err(e) => { 
                warn!(?e, "Could not get function while waiting"); 
            } 
        } 
        Ok(false) 
    } 
    // snippet-start:[lambda.rust.scenario.get_function] 
    /** Get the Lambda function with this Manager's name. */ 
    pub async fn get_function(&self) -> Result<GetFunctionOutput, anyhow::Error> { 
        info!("Getting lambda function"); 
        self.lambda_client 
            .get_function() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
    } 
    // snippet-end:[lambda.rust.scenario.get_function] 
    // snippet-start:[lambda.rust.scenario.list_functions] 
    /** List all Lambda functions in the current Region. */ 
    pub async fn list_functions(&self) -> Result<ListFunctionsOutput, 
 anyhow::Error> { 
        info!("Listing lambda functions"); 
        self.lambda_client 
            .list_functions() 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
    } 
    // snippet-end:[lambda.rust.scenario.list_functions] 
    // snippet-start:[lambda.rust.scenario.invoke] 
    /** Invoke the lambda function using calculator InvokeArgs. */ 
    pub async fn invoke(&self, args: InvokeArgs) -> Result<InvokeOutput, 
 anyhow::Error> { 
        info!(?args, "Invoking {}", self.lambda_name); 
        let payload = serde_json::to_string(&args)?; 
        debug!(?payload, "Sending payload"); 
        self.lambda_client 
            .invoke() 
            .function_name(self.lambda_name.clone()) 
            .payload(Blob::new(payload)) 
            .send() 
            .await 
            .map_err(anyhow::Error::from) 
1240AWS Lambda Developer Guide
Get started with functions
    } 
    // snippet-end:[lambda.rust.scenario.invoke] 
    // snippet-start:[lambda.rust.scenario.update_function_code] 
    /** Given a Path to a zip file, update the function's code and wait for the 
 update to finish. */ 
    pub async fn update_function_code( 
        &self, 
        zip_file: PathBuf, 
        key: String, 
    ) -> Result<UpdateFunctionCodeOutput, anyhow::Error> { 
        let function_code = self.prepare_function(zip_file, Some(key)).await?; 
        info!("Updating code for {}", self.lambda_name); 
        let update = self 
            .lambda_client 
            .update_function_code() 
            .function_name(self.lambda_name.clone()) 
            .s3_bucket(self.bucket.clone()) 
            .s3_key(function_code.s3_key().unwrap().to_string()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        Ok(update) 
    } 
    // snippet-end:[lambda.rust.scenario.update_function_code] 
    // snippet-start:[lambda.rust.scenario.update_function_configuration] 
    /** Update the environment for a function. */ 
    pub async fn update_function_configuration( 
        &self, 
        environment: Environment, 
    ) -> Result<UpdateFunctionConfigurationOutput, anyhow::Error> { 
        info!( 
            ?environment, 
            "Updating environment for {}", self.lambda_name 
        ); 
        let updated = self 
            .lambda_client 
            .update_function_configuration() 
            .function_name(self.lambda_name.clone()) 
            .environment(environment) 
            .send() 
            .await 
            .map_err(anyhow::Error::from)?; 
        self.wait_for_function_ready().await?; 
        Ok(updated) 
    } 
    // snippet-end:[lambda.rust.scenario.update_function_configuration] 
    // snippet-start:[lambda.rust.scenario.delete_function] 
    /** Delete a function and its role, and if possible or necessary, its 
 associated code object and bucket. */ 
    pub async fn delete_function( 
        &self, 
        location: Option<String>, 
    ) -> ( 
        Result<DeleteFunctionOutput, anyhow::Error>, 
        Result<DeleteRoleOutput, anyhow::Error>, 
        Option<Result<DeleteObjectOutput, anyhow::Error>>, 
    ) { 
1241AWS Lambda Developer Guide
Get started with functions
        info!("Deleting lambda function {}", self.lambda_name); 
        let delete_function = self 
            .lambda_client 
            .delete_function() 
            .function_name(self.lambda_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from); 
        info!("Deleting iam role {}", self.role_name); 
        let delete_role = self 
            .iam_client 
            .delete_role() 
            .role_name(self.role_name.clone()) 
            .send() 
            .await 
            .map_err(anyhow::Error::from); 
        let delete_object: Option<Result<DeleteObjectOutput, anyhow::Error>> = 
            if let Some(location) = location { 
                info!("Deleting object {location}"); 
                Some( 
                    self.s3_client 
                        .delete_object() 
                        .bucket(self.bucket.clone()) 
                        .key(location) 
                        .send() 
                        .await 
                        .map_err(anyhow::Error::from), 
                ) 
            } else { 
                info!(?location, "Skipping delete object"); 
                None 
            }; 
        (delete_function, delete_role, delete_object) 
    } 
    // snippet-end:[lambda.rust.scenario.delete_function] 
    pub async fn cleanup( 
        &self, 
        location: Option<String>, 
    ) -> ( 
        ( 
            Result<DeleteFunctionOutput, anyhow::Error>, 
            Result<DeleteRoleOutput, anyhow::Error>, 
            Option<Result<DeleteObjectOutput, anyhow::Error>>, 
        ), 
        Option<Result<DeleteBucketOutput, anyhow::Error>>, 
    ) { 
        let delete_function = self.delete_function(location).await; 
        let delete_bucket = if self.own_bucket { 
            info!("Deleting bucket {}", self.bucket); 
            if delete_function.2.is_none() || 
 delete_function.2.as_ref().unwrap().is_ok() { 
                Some( 
                    self.s3_client 
                        .delete_bucket() 
                        .bucket(self.bucket.clone()) 
                        .send() 
                        .await 
                        .map_err(anyhow::Error::from), 
                ) 
            } else { 
                None 
1242AWS Lambda Developer Guide
Get started with functions
            } 
        } else { 
            info!("No bucket to clean up"); 
            None 
        }; 
        (delete_function, delete_bucket) 
    }
}
/** 
 * Testing occurs primarily as an integration test running the `scenario` bin 
 successfully. 
 * Each action relies deeply on the internal workings and state of Amazon Simple 
 Storage Service (Amazon S3), Lambda, and IAM working together. 
 * It is therefore infeasible to mock the clients to test the individual actions. 
 */
#[cfg(test)]
mod test { 
    use super::{InvokeArgs, Operation}; 
    use serde_json::json; 
    /** Make sure that the JSON output of serializing InvokeArgs is what's expected 
 by the calculator. */ 
    #[test] 
    fn test_serialize() { 
        assert_eq!(json!(InvokeArgs::Increment(5)), 5); 
        assert_eq!( 
            json!(InvokeArgs::Arithmetic(Operation::Plus, 5, 7)).to_string(), 
            r#"{"i":5,"j":7,"op":"plus"}"#.to_string(), 
        ); 
    }
}
A binary to run the scenario from front to end, using command line ﬂags to control some 
behavior. This ﬁle is src/bin/scenario.rs in the crate.
/* 
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. 
 * SPDX-License-Identifier: Apache-2.0. 
 */
/*
## Service actions
Service actions wrap the SDK call, taking a client and any specific parameters 
 necessary for the call.
* CreateFunction
* GetFunction
* ListFunctions
* Invoke
* UpdateFunctionCode
* UpdateFunctionConfiguration
* DeleteFunction
## Scenario
A scenario runs at a command prompt and prints output to the user on the result 
 of each service action. A scenario can run in one of two ways: straight through, 
 printing out progress as it goes, or as an interactive question/answer script.
## Getting started with functions
1243AWS Lambda Developer Guide
Get started with functions
Use an SDK to manage AWS Lambda functions: create a function, invoke it, update its 
 code, invoke it again, view its output and logs, and delete it.
This scenario uses two Lambda handlers:
_Note: Handlers don't use AWS SDK API calls._
The increment handler is straightforward:
1. It accepts a number, increments it, and returns the new value.
2. It performs simple logging of the result.
The arithmetic handler is more complex:
1. It accepts a set of actions ['plus', 'minus', 'times', 'divided-by'] and two 
 numbers, and returns the result of the calculation.
2. It uses an environment variable to control log level (such as DEBUG, INFO, 
 WARNING, ERROR).
It logs a few things at different levels, such as: 
    * DEBUG: Full event data. 
    * INFO: The calculation result. 
    * WARN~ING~: When a divide by zero error occurs. 
    * This will be the typical `RUST_LOG` variable.
The steps of the scenario are:
1. Create an AWS Identity and Access Management (IAM) role that meets the following 
 requirements: 
    * Has an assume_role policy that grants 'lambda.amazonaws.com' the 
 'sts:AssumeRole' action. 
    * Attaches the 'arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole' managed role. 
    * _You must wait for ~10 seconds after the role is created before you can use 
 it!_
2. Create a function (CreateFunction) for the increment handler by packaging it as 
 a zip and doing one of the following: 
    * Adding it with CreateFunction Code.ZipFile. 
    * --or-- 
    * Uploading it to Amazon Simple Storage Service (Amazon S3) and adding it with 
 CreateFunction Code.S3Bucket/S3Key. 
    * _Note: Zipping the file does not have to be done in code._ 
    * If you have a waiter, use it to wait until the function is active. Otherwise, 
 call GetFunction until State is Active.
3. Invoke the function with a number and print the result.
4. Update the function (UpdateFunctionCode) to the arithmetic handler by packaging 
 it as a zip and doing one of the following: 
    * Adding it with UpdateFunctionCode ZipFile. 
    * --or-- 
    * Uploading it to Amazon S3 and adding it with UpdateFunctionCode S3Bucket/
S3Key.
5. Call GetFunction until Configuration.LastUpdateStatus is 'Successful' (or 
 'Failed').
6. Update the environment variable by calling UpdateFunctionConfiguration and pass 
 it a log level, such as: 
    * Environment={'Variables': {'RUST_LOG': 'TRACE'}}
7. Invoke the function with an action from the list and a couple of values. Include 
 LogType='Tail' to get logs in the result. Print the result of the calculation and 
 the log.
8. [Optional] Invoke the function to provoke a divide-by-zero error and show the 
 log result.
9. List all functions for the account, using pagination (ListFunctions).
10. Delete the function (DeleteFunction).
11. Delete the role.
Each step should use the function created in Service Actions to abstract calling 
 the SDK. 
 */
1244AWS Lambda Developer Guide
Get started with functions
use aws_sdk_lambda::{operation::invoke::InvokeOutput, types::Environment};
use clap::Parser;
use std::{collections::HashMap, path::PathBuf};
use tracing::{debug, info, warn};
use tracing_subscriber::EnvFilter;
use lambda_code_examples::actions::{ 
    InvokeArgs::{Arithmetic, Increment}, 
    LambdaManager, Operation,
};
#[derive(Debug, Parser)]
pub struct Opt { 
    /// The AWS Region. 
    #[structopt(short, long)] 
    pub region: Option<String>, 
    // The bucket to use for the FunctionCode. 
    #[structopt(short, long)] 
    pub bucket: Option<String>, 
    // The name of the Lambda function. 
    #[structopt(short, long)] 
    pub lambda_name: Option<String>, 
    // The number to increment. 
    #[structopt(short, long, default_value = "12")] 
    pub inc: i32, 
    // The left operand. 
    #[structopt(long, default_value = "19")] 
    pub num_a: i32, 
    // The right operand. 
    #[structopt(long, default_value = "23")] 
    pub num_b: i32, 
    // The arithmetic operation. 
    #[structopt(short, long, default_value = "plus")] 
    pub operation: Operation, 
    #[structopt(long)] 
    pub cleanup: Option<bool>, 
    #[structopt(long)] 
    pub no_cleanup: Option<bool>,
}
fn code_path(lambda: &str) -> PathBuf { 
    PathBuf::from(format!("../target/lambda/{lambda}/bootstrap.zip"))
}
// snippet-start:[lambda.rust.scenario.log_invoke_output]
fn log_invoke_output(invoke: &InvokeOutput, message: &str) { 
    if let Some(payload) = invoke.payload().cloned() { 
        let payload = String::from_utf8(payload.into_inner()); 
        info!(?payload, message); 
    } else { 
        info!("Could not extract payload") 
    } 
    if let Some(logs) = invoke.log_result() { 
        debug!(?logs, "Invoked function logs") 
    } else { 
        debug!("Invoked function had no logs") 
    }
1245AWS Lambda Developer Guide
Get started with functions
}
// snippet-end:[lambda.rust.scenario.log_invoke_output]
async fn main_block( 
    opt: &Opt, 
    manager: &LambdaManager, 
    code_location: String,
) -> Result<(), anyhow::Error> { 
    let invoke = manager.invoke(Increment(opt.inc)).await?; 
    log_invoke_output(&invoke, "Invoked function configured as increment"); 
    let update_code = manager 
        .update_function_code(code_path("arithmetic"), code_location.clone()) 
        .await?; 
    let code_sha256 = update_code.code_sha256().unwrap_or("Unknown SHA"); 
    info!(?code_sha256, "Updated function code with arithmetic.zip"); 
    let arithmetic_args = Arithmetic(opt.operation, opt.num_a, opt.num_b); 
    let invoke = manager.invoke(arithmetic_args).await?; 
    log_invoke_output(&invoke, "Invoked function configured as arithmetic"); 
    let update = manager 
        .update_function_configuration( 
            Environment::builder() 
                .set_variables(Some(HashMap::from([( 
                    "RUST_LOG".to_string(), 
                    "trace".to_string(), 
                )]))) 
                .build(), 
        ) 
        .await?; 
    let updated_environment = update.environment(); 
    info!(?updated_environment, "Updated function configuration"); 
    let invoke = manager 
        .invoke(Arithmetic(opt.operation, opt.num_a, opt.num_b)) 
        .await?; 
    log_invoke_output( 
        &invoke, 
        "Invoked function configured as arithmetic with increased logging", 
    ); 
    let invoke = manager 
        .invoke(Arithmetic(Operation::DividedBy, opt.num_a, 0)) 
        .await?; 
    log_invoke_output( 
        &invoke, 
        "Invoked function configured as arithmetic with divide by zero", 
    ); 
    Ok::<(), anyhow::Error>(())
}
#[tokio::main]
async fn main() { 
    tracing_subscriber::fmt() 
        .without_time() 
        .with_file(true) 
        .with_line_number(true) 
        .with_env_filter(EnvFilter::from_default_env()) 
        .init(); 
    let opt = Opt::parse(); 
    let manager = LambdaManager::load_from_env(opt.lambda_name.clone(), 
 opt.bucket.clone()).await; 
1246AWS Lambda Developer Guide
Get started with functions
    let key = match manager.create_function(code_path("increment")).await { 
        Ok(init) => { 
            info!(?init, "Created function, initially with increment.zip"); 
            let run_block = main_block(&opt, &manager, init.clone()).await; 
            info!(?run_block, "Finished running example, cleaning up"); 
            Some(init) 
        } 
        Err(err) => { 
            warn!(?err, "Error happened when initializing function"); 
            None 
        } 
    }; 
    if Some(false) == opt.cleanup || Some(true) == opt.no_cleanup { 
        info!("Skipping cleanup") 
    } else { 
        let delete = manager.cleanup(key).await; 
        info!(?delete, "Deleted function & cleaned up resources"); 
    }
}
•For API details, see the following topics in AWS SDK for Rust API reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
SAP ABAP
SDK for SAP ABAP
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the AWS Code Examples Repository.
    TRY. 
        "Create an AWS Identity and Access Management (IAM) role that grants AWS 
 Lambda permission to write to logs." 
        DATA(lv_policy_document) = `{` && 
            `"Version":"2012-10-17",` && 
                  `"Statement": [` && 
                    `{` && 
                      `"Effect": "Allow",` && 
                      `"Action": [` && 
                        `"sts:AssumeRole"` && 
                      `],` && 
                      `"Principal": {` && 
                        `"Service": [` && 
                          `"lambda.amazonaws.com"` && 
                        `]` && 
                      `}` && 
                    `}` && 
                  `]` && 
                `}`. 
1247AWS Lambda Developer Guide
Get started with functions
        TRY. 
            DATA(lo_create_role_output) =  lo_iam->createrole( 
                    iv_rolename = iv_role_name 
                    iv_assumerolepolicydocument = lv_policy_document 
                    iv_description = 'Grant lambda permission to write to logs' 
                ). 
            MESSAGE 'IAM role created.' TYPE 'I'. 
            WAIT UP TO 10 SECONDS.            " Make sure that the IAM role is 
 ready for use. " 
          CATCH /aws1/cx_iamentityalrdyexex. 
            MESSAGE 'IAM role already exists.' TYPE 'E'. 
          CATCH /aws1/cx_iaminvalidinputex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_iammalformedplydocex. 
            MESSAGE 'Policy document in the request is malformed.' TYPE 'E'. 
        ENDTRY. 
        TRY. 
            lo_iam->attachrolepolicy( 
                iv_rolename  = iv_role_name 
                iv_policyarn = 'arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole' 
            ). 
            MESSAGE 'Attached policy to the IAM role.' TYPE 'I'. 
          CATCH /aws1/cx_iaminvalidinputex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_iamnosuchentityex. 
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'. 
          CATCH /aws1/cx_iamplynotattachableex. 
            MESSAGE 'Service role policies can only be attached to the service-
linked role for their service.' TYPE 'E'. 
          CATCH /aws1/cx_iamunmodableentityex. 
            MESSAGE 'Service that depends on the service-linked role is not 
 modifiable.' TYPE 'E'. 
        ENDTRY. 
        " Create a Lambda function and upload handler code. " 
        " Lambda function performs 'increment' action on a number. " 
        TRY. 
            lo_lmd->createfunction( 
                 iv_functionname = iv_function_name 
                 iv_runtime = `python3.9` 
                 iv_role = lo_create_role_output->get_role( )->get_arn( ) 
                 iv_handler = iv_handler 
                 io_code = io_initial_zip_file 
                 iv_description = 'AWS Lambda code example' 
             ). 
            MESSAGE 'Lambda function created.' TYPE 'I'. 
          CATCH /aws1/cx_lmdcodestorageexcdex. 
            MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
        ENDTRY. 
        " Verify the function is in Active state " 
        WHILE lo_lmd->getfunction( iv_functionname = iv_function_name )-
>get_configuration( )->ask_state( ) <> 'Active'. 
          IF sy-index = 10. 
            EXIT.               " Maximum 10 seconds. " 
          ENDIF. 
          WAIT UP TO 1 SECONDS. 
        ENDWHILE. 
        "Invoke the function with a single parameter and get results." 
1248AWS Lambda Developer Guide
Get started with functions
        TRY. 
            DATA(lv_json) = /aws1/cl_rt_util=>string_to_xstring( 
              `{`  && 
                `"action": "increment",`  && 
                `"number": 10` && 
              `}` 
            ). 
            DATA(lo_initial_invoke_output) =  lo_lmd->invoke( 
                       iv_functionname = iv_function_name 
                       iv_payload = lv_json 
                   ). 
            ov_initial_invoke_payload = lo_initial_invoke_output->get_payload( ).   
         " ov_initial_invoke_payload is returned for testing purposes. " 
            DATA(lo_writer_json) = cl_sxml_string_writer=>create( type = 
 if_sxml=>co_xt_json ). 
            CALL TRANSFORMATION id SOURCE XML ov_initial_invoke_payload RESULT XML 
 lo_writer_json. 
            DATA(lv_result) = cl_abap_codepage=>convert_from( lo_writer_json-
>get_output( ) ). 
            MESSAGE 'Lambda function invoked.' TYPE 'I'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdinvrequestcontex. 
            MESSAGE 'Unable to parse request body as JSON.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
          CATCH /aws1/cx_lmdunsuppedmediatyp00. 
            MESSAGE 'Invoke request body does not have JSON as its content type.' 
 TYPE 'E'. 
        ENDTRY. 
        " Update the function code and configure its Lambda environment with an 
 environment variable. " 
        " Lambda function is updated to perform 'decrement' action also. " 
        TRY. 
            lo_lmd->updatefunctioncode( 
                  iv_functionname = iv_function_name 
                  iv_zipfile = io_updated_zip_file 
              ). 
            WAIT UP TO 10 SECONDS.            " Make sure that the update is 
 completed. " 
            MESSAGE 'Lambda function code updated.' TYPE 'I'. 
          CATCH /aws1/cx_lmdcodestorageexcdex. 
            MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
        ENDTRY. 
        TRY. 
            DATA lt_variables TYPE /aws1/
cl_lmdenvironmentvaria00=>tt_environmentvariables. 
            DATA ls_variable LIKE LINE OF lt_variables. 
            ls_variable-key = 'LOG_LEVEL'. 
            ls_variable-value = NEW /aws1/cl_lmdenvironmentvaria00( iv_value = 
 'info' ). 
            INSERT ls_variable INTO TABLE lt_variables. 
            lo_lmd->updatefunctionconfiguration( 
                  iv_functionname = iv_function_name 
                  io_environment = NEW /aws1/cl_lmdenvironment( it_variables = 
 lt_variables ) 
              ). 
            WAIT UP TO 10 SECONDS.            " Make sure that the update is 
 completed. " 
1249AWS Lambda Developer Guide
Get started with functions
            MESSAGE 'Lambda function configuration/settings updated.' TYPE 'I'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourceconflictex. 
            MESSAGE 'Resource already exists or another operation is in progress.' 
 TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
        ENDTRY. 
        "Invoke the function with new parameters and get results. Display the 
 execution log that's returned from the invocation." 
        TRY. 
            lv_json = /aws1/cl_rt_util=>string_to_xstring( 
              `{`  && 
                `"action": "decrement",`  && 
                `"number": 10` && 
              `}` 
            ). 
            DATA(lo_updated_invoke_output) =  lo_lmd->invoke( 
                       iv_functionname = iv_function_name 
                       iv_payload = lv_json 
                   ). 
            ov_updated_invoke_payload = lo_updated_invoke_output->get_payload( ).   
         " ov_updated_invoke_payload is returned for testing purposes. " 
            lo_writer_json = cl_sxml_string_writer=>create( type = 
 if_sxml=>co_xt_json ). 
            CALL TRANSFORMATION id SOURCE XML ov_updated_invoke_payload RESULT XML 
 lo_writer_json. 
            lv_result = cl_abap_codepage=>convert_from( lo_writer_json-
>get_output( ) ). 
            MESSAGE 'Lambda function invoked.' TYPE 'I'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdinvrequestcontex. 
            MESSAGE 'Unable to parse request body as JSON.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
          CATCH /aws1/cx_lmdunsuppedmediatyp00. 
            MESSAGE 'Invoke request body does not have JSON as its content type.' 
 TYPE 'E'. 
        ENDTRY. 
        " List the functions for your account. " 
        TRY. 
            DATA(lo_list_output) = lo_lmd->listfunctions( ). 
            DATA(lt_functions) = lo_list_output->get_functions( ). 
            MESSAGE 'Retrieved list of Lambda functions.' TYPE 'I'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
        ENDTRY. 
        " Delete the Lambda function. " 
        TRY. 
            lo_lmd->deletefunction( iv_functionname = iv_function_name ). 
            MESSAGE 'Lambda function deleted.' TYPE 'I'. 
          CATCH /aws1/cx_lmdinvparamvalueex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_lmdresourcenotfoundex. 
            MESSAGE 'The requested resource does not exist.' TYPE 'E'. 
        ENDTRY. 
        " Detach role policy. " 
        TRY. 
            lo_iam->detachrolepolicy( 
                iv_rolename  = iv_role_name 
1250AWS Lambda Developer Guide
Serverless snippets
                iv_policyarn = 'arn:aws:iam::aws:policy/service-role/
AWSLambdaBasicExecutionRole' 
            ). 
            MESSAGE 'Detached policy from the IAM role.' TYPE 'I'. 
          CATCH /aws1/cx_iaminvalidinputex. 
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'. 
          CATCH /aws1/cx_iamnosuchentityex. 
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'. 
          CATCH /aws1/cx_iamplynotattachableex. 
            MESSAGE 'Service role policies can only be attached to the service-
linked role for their service.' TYPE 'E'. 
          CATCH /aws1/cx_iamunmodableentityex. 
            MESSAGE 'Service that depends on the service-linked role is not 
 modifiable.' TYPE 'E'. 
        ENDTRY. 
        " Delete the IAM role. " 
        TRY. 
            lo_iam->deleterole( iv_rolename = iv_role_name ). 
            MESSAGE 'IAM role deleted.' TYPE 'I'. 
          CATCH /aws1/cx_iamnosuchentityex. 
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'. 
          CATCH /aws1/cx_iamunmodableentityex. 
            MESSAGE 'Service that depends on the service-linked role is not 
 modifiable.' TYPE 'E'. 
        ENDTRY. 
      CATCH /aws1/cx_rt_service_generic INTO lo_exception. 
        DATA(lv_error) = lo_exception->get_longtext( ). 
        MESSAGE lv_error TYPE 'E'. 
    ENDTRY.
•For API details, see the following topics in AWS SDK for SAP ABAP API reference.
•CreateFunction
•DeleteFunction
•GetFunction
•Invoke
•ListFunctions
•UpdateFunctionCode
•UpdateFunctionConﬁguration
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Serverless snippets for Lambda using AWS SDKs
The following code examples show how to use Lambda with AWS SDKs.
Examples
•Invoke a Lambda function from an Amazon S3 trigger (p. 1252 )
1251AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
Invoke a Lambda function from an Amazon S3 trigger
The following code examples show how to implement a Lambda function that receives an event 
triggered by uploading an object to an S3 bucket. The function retrieves the S3 bucket name and object 
key from the event parameter and calls the Amazon S3 API to retrieve and log the content type of the 
object.
.NET
AWS SDK for .NET
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using .NET.
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Amazon.S3;
using System;
using Amazon.Lambda.S3Events;
using System.Web;
// Assembly attribute to enable the Lambda function's JSON input to be converted 
 into a .NET class.
[assembly: 
 LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]
namespace S3Integration
{ 
    public class Function 
    { 
        private static AmazonS3Client _s3Client; 
        public Function() : this(null) 
        { 
        } 
        internal Function(AmazonS3Client s3Client) 
        { 
            _s3Client = s3Client ?? new AmazonS3Client(); 
        } 
        public async Task<string> Handler(S3Event evt, ILambdaContext context) 
        { 
            try 
            { 
                if (evt.Records.Count <= 0) 
                { 
                    context.Logger.LogLine("Empty S3 Event received"); 
                    return string.Empty; 
                } 
                var bucket = evt.Records[0].S3.Bucket.Name; 
                var key = HttpUtility.UrlDecode(evt.Records[0].S3.Object.Key); 
                context.Logger.LogLine($"Request is for {bucket} and {key}"); 
                var objectResult = await _s3Client.GetObjectAsync(bucket, key); 
                context.Logger.LogLine($"Returning {objectResult.Key}"); 
                return objectResult.Key; 
            } 
1252AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
            catch (Exception e) 
            { 
                context.Logger.LogLine($"Error processing request - {e.Message}"); 
                return string.Empty; 
            } 
        } 
    }
}
Go
SDK for Go V2
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Go.
package main
import ( 
 "context" 
 "log" 
 "github.com/aws/aws-lambda-go/events" 
 "github.com/aws/aws-lambda-go/lambda" 
 "github.com/aws/aws-sdk-go-v2/config" 
 "github.com/aws/aws-sdk-go-v2/service/s3"
)
func handler(ctx context.Context, s3Event events.S3Event) error { 
 sdkConfig, err := config.LoadDefaultConfig(ctx) 
 if err != nil { 
  log.Printf("failed to load default config: %s", err) 
  return err 
 } 
 s3Client := s3.NewFromConfig(sdkConfig) 
 for _, record := range s3Event.Records { 
  bucket := record.S3.Bucket.Name 
  key := record.S3.Object.URLDecodedKey 
  headOutput, err := s3Client.HeadObject(ctx, &s3.HeadObjectInput{ 
   Bucket: &bucket, 
   Key:    &key, 
  }) 
  if err != nil { 
   log.Printf("error getting head of object %s/%s: %s", bucket, key, err) 
   return err 
  } 
  log.Printf("successfully retrieved %s/%s of type %s", bucket, key, 
 *headOutput.ContentType) 
 } 
 return nil
}
func main() { 
 lambda.Start(handler)
}
1253AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
Java
SDK for Java 2.x
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Java.
package example;
import software.amazon.awssdk.services.s3.model.HeadObjectRequest;
import software.amazon.awssdk.services.s3.model.HeadObjectResponse;
import software.amazon.awssdk.services.s3.S3Client;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.S3Event;
import 
 com.amazonaws.services.lambda.runtime.events.models.s3.S3EventNotification.S3EventNotificationRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Handler implements RequestHandler<S3Event, String> { 
    private static final Logger logger = LoggerFactory.getLogger(Handler.class); 
    @Override 
    public String handleRequest(S3Event s3event, Context context) { 
        try { 
          S3EventNotificationRecord record = s3event.getRecords().get(0); 
          String srcBucket = record.getS3().getBucket().getName(); 
          String srcKey = record.getS3().getObject().getUrlDecodedKey(); 
          S3Client s3Client = S3Client.builder().build(); 
          HeadObjectResponse headObject = getHeadObject(s3Client, srcBucket, 
 srcKey); 
          logger.info("Successfully retrieved " + srcBucket + "/" + srcKey + " of 
 type " + headObject.contentType()); 
          return "Ok"; 
        } catch (Exception e) { 
          throw new RuntimeException(e); 
        } 
    } 
    private HeadObjectResponse getHeadObject(S3Client s3Client, String bucket, 
 String key) { 
        HeadObjectRequest headObjectRequest = HeadObjectRequest.builder() 
                .bucket(bucket) 
                .key(key) 
                .build(); 
        return s3Client.headObject(headObjectRequest); 
    }
}
1254AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
JavaScript
SDK for JavaScript (v2)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using JavaScript.
const aws = require('aws-sdk');
const s3 = new aws.S3({ apiVersion: '2006-03-01' });
exports.handler = async (event, context) => { 
    // Get the object from the event and show its content type 
    const bucket = event.Records[0].s3.bucket.name; 
    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' 
 ')); 
    const params = { 
        Bucket: bucket, 
        Key: key, 
    };  
    try { 
        const { ContentType } = await s3.headObject(params).promise(); 
        console.log('CONTENT TYPE:', ContentType); 
        return ContentType; 
    } catch (err) { 
        console.log(err); 
        const message = `Error getting object ${key} from bucket ${bucket}. Make 
 sure they exist and your bucket is in the same region as this function.`; 
        console.log(message); 
        throw new Error(message); 
    }
};
Consuming an S3 event with Lambda using TypeScript.
import { S3Event } from 'aws-lambda';
import { S3Client, HeadObjectCommand } from '@aws-sdk/client-s3';
const s3 = new S3Client({ region: process.env.AWS_REGION });
export const handler = async (event: S3Event): Promise<string | undefined> => { 
  // Get the object from the event and show its content type 
  const bucket = event.Records[0].s3.bucket.name; 
  const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' 
 ')); 
  const params = { 
    Bucket: bucket, 
    Key: key, 
  }; 
  try { 
    const { ContentType } = await s3.send(new HeadObjectCommand(params)); 
    console.log('CONTENT TYPE:', ContentType); 
    return ContentType; 
  } catch (err) { 
    console.log(err); 
    const message = `Error getting object ${key} from bucket ${bucket}. Make sure 
 they exist and your bucket is in the same region as this function.`; 
    console.log(message); 
    throw new Error(message); 
  }
1255AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
};
Python
SDK for Python (Boto3)
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Python.
import json
import urllib.parse
import boto3
print('Loading function')
s3 = boto3.client('s3')
def lambda_handler(event, context): 
    #print("Received event: " + json.dumps(event, indent=2)) 
    # Get the object from the event and show its content type 
    bucket = event['Records'][0]['s3']['bucket']['name'] 
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], 
 encoding='utf-8') 
    try: 
        response = s3.get_object(Bucket=bucket, Key=key) 
        print("CONTENT TYPE: " + response['ContentType']) 
        return response['ContentType'] 
    except Exception as e: 
        print(e) 
        print('Error getting object {} from bucket {}. Make sure they exist and 
 your bucket is in the same region as this function.'.format(key, bucket)) 
        raise e 
               
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Note
There's more on GitHub. Find the complete example and learn how to set up and run in 
the Serverless snippets repository.
Consuming an S3 event with Lambda using Rust.
use aws_lambda_events::event::s3::S3Event;
use aws_sdk_s3::{Client};
use lambda_runtime::{run, service_fn, Error, LambdaEvent};
/// Main function
#[tokio::main]
async fn main() -> Result<(), Error> { 
    tracing_subscriber::fmt() 
1256AWS Lambda Developer Guide
Invoke a Lambda function from an Amazon S3 trigger
        .with_max_level(tracing::Level::INFO) 
        .with_target(false) 
        .without_time() 
        .init(); 
    // Initialize the AWS SDK for Rust 
    let config = aws_config::load_from_env().await; 
    let s3_client = Client::new(&config); 
    let res = run(service_fn(|request: LambdaEvent<S3Event>| { 
        function_handler(&s3_client, request) 
    })).await; 
    res
}
async fn function_handler( 
    s3_client: &Client, 
    evt: LambdaEvent<S3Event>
) -> Result<(), Error> { 
    tracing::info!(records = ?evt.payload.records.len(), "Received request from 
 SQS"); 
    if evt.payload.records.len() == 0 { 
        tracing::info!("Empty S3 event received"); 
    } 
    let bucket = evt.payload.records[0].s3.bucket.name.as_ref().expect("Bucket name 
 to exist"); 
    let key = evt.payload.records[0].s3.object.key.as_ref().expect("Object key to 
 exist"); 
    tracing::info!("Request is for {} and object {}", bucket, key); 
    let s3_get_object_result = s3_client 
        .get_object() 
        .bucket(bucket) 
        .key(key) 
        .send() 
        .await; 
    match s3_get_object_result { 
        Ok(_) => tracing::info!("S3 Get Object success, the s3GetObjectResult 
 contains a 'body' property of type ByteStream"), 
        Err(_) => tracing::info!("Failure with S3 Get Object request") 
    } 
    Ok(())
}
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
1257AWS Lambda Developer Guide
Cross-service examples
Cross-service examples for Lambda using AWS 
SDKs
The following sample applications use AWS SDKs to combine Lambda with other AWS services. Each 
example includes a link to GitHub, where you can ﬁnd instructions on how to set up and run the 
application.
Examples
•Create an API Gateway REST API to track COVID-19 data (p. 1258 )
•Create a lending library REST API (p. 1259 )
•Create a messenger application with Step Functions (p. 1259 )
•Create a photo asset management application that lets users manage photos using labels (p. 1260 )
•Create a websocket chat application with API Gateway (p. 1262 )
•Create an application that analyzes customer feedback and synthesizes audio (p. 1263 )
•Invoke a Lambda function from a browser (p. 1264 )
•Use API Gateway to invoke a Lambda function (p. 1264 )
•Use Step Functions to invoke Lambda functions (p. 1266 )
•Use scheduled events to invoke a Lambda function (p. 1266 )
Create an API Gateway REST API to track COVID-19 
data
The following code example shows how to create a REST API that simulates a system to track daily cases 
of COVID-19 in the United States, using ﬁctional data.
Python
SDK for Python (Boto3)
Shows how to use AWS Chalice with the AWS SDK for Python (Boto3) to create a serverless 
REST API that uses Amazon API Gateway, AWS Lambda, and Amazon DynamoDB. The REST API 
simulates a system that tracks daily cases of COVID-19 in the United States, using ﬁctional data. 
Learn how to:
•Use AWS Chalice to deﬁne routes in Lambda functions that are called to handle REST requests 
that come through API Gateway.
•Use Lambda functions to retrieve and store data in a DynamoDB table to serve REST requests.
•Deﬁne table structure and security role resources in an AWS CloudFormation template.
•Use AWS Chalice and CloudFormation to package and deploy all necessary resources.
•Use CloudFormation to clean up all created resources.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•API Gateway
•AWS CloudFormation
•DynamoDB
•Lambda
1258AWS Lambda Developer Guide
Create a lending library REST API
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Create a lending library REST API
The following code example shows how to create a lending library where patrons can borrow and return 
books by using a REST API backed by an Amazon Aurora database.
Python
SDK for Python (Boto3)
Shows how to use the AWS SDK for Python (Boto3) with the Amazon Relational Database 
Service (Amazon RDS) API and AWS Chalice to create a REST API backed by an Amazon Aurora 
database. The web service is fully serverless and represents a simple lending library where 
patrons can borrow and return books. Learn how to:
•Create and manage a serverless Aurora database cluster.
•Use AWS Secrets Manager to manage database credentials.
•Implement a data storage layer that uses Amazon RDS to move data into and out of the 
database.
•Use AWS Chalice to deploy a serverless REST API to Amazon API Gateway and AWS Lambda.
•Use the Requests package to send requests to the web service.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•API Gateway
•Aurora
•Lambda
•Secrets Manager
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Create a messenger application with Step Functions
The following code example shows how to create an AWS Step Functions messenger application that 
retrieves message records from a database table.
Python
SDK for Python (Boto3)
Shows how to use the AWS SDK for Python (Boto3) with AWS Step Functions to create a 
messenger application that retrieves message records from an Amazon DynamoDB table and 
sends them with Amazon Simple Queue Service (Amazon SQS). The state machine integrates 
with an AWS Lambda function to scan the database for unsent messages.
•Create a state machine that retrieves and updates message records from an Amazon 
DynamoDB table.
•Update the state machine deﬁnition to also send messages to Amazon Simple Queue Service 
(Amazon SQS).
1259AWS Lambda Developer Guide
Create a serverless application to manage photos
•Start and stop state machine runs.
•Connect to Lambda, DynamoDB, and Amazon SQS from a state machine by using service 
integrations.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•DynamoDB
•Lambda
•Amazon SQS
•Step Functions
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Create a photo asset management application that 
lets users manage photos using labels
The following code examples show how to create a serverless application that lets users manage photos 
using labels.
.NET
AWS SDK for .NET
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
C++
SDK for C++
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
1260AWS Lambda Developer Guide
Create a serverless application to manage photos
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
Java
SDK for Java 2.x
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
JavaScript
SDK for JavaScript (v3)
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
Kotlin
SDK for Kotlin
Note
This is prerelease documentation for a feature in preview release. It is subject to 
change.
1261AWS Lambda Developer Guide
Create a websocket chat application
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
Rust
SDK for Rust
Note
This documentation is for an SDK in preview release. The SDK is subject to change and 
should not be used in production.
Shows how to develop a photo asset management application that detects labels in images 
using Amazon Rekognition and stores them for later retrieval.
For complete source code and instructions on how to set up and run, see the full example on 
GitHub .
For a deep dive into the origin of this example see the post on AWS Community.
Services used in this example
•DynamoDB
•Lambda
•Amazon Rekognition
•Amazon S3
•Amazon SNS
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Create a websocket chat application with API 
Gateway
The following code example shows how to create a chat application that is served by a websocket API 
built on Amazon API Gateway.
Python
SDK for Python (Boto3)
Shows how to use the AWS SDK for Python (Boto3) with Amazon API Gateway V2 to create a 
websocket API that integrates with AWS Lambda and Amazon DynamoDB.
1262AWS Lambda Developer Guide
Create an application to analyze customer feedback
•Create a websocket API served by API Gateway.
•Deﬁne a Lambda handler that stores connections in DynamoDB and posts messages to other 
chat participants.
•Connect to the websocket chat application and send messages with the Websockets package.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•API Gateway
•DynamoDB
•Lambda
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Create an application that analyzes customer 
feedback and synthesizes audio
The following code example shows how to create an application that analyzes customer comment cards, 
translates them from their original language, determines their sentiment, and generates an audio ﬁle 
from the translated text.
Ruby
SDK for Ruby
This example application analyzes and stores customer feedback cards. Speciﬁcally, it fulﬁlls the 
need of a ﬁctitious hotel in New York City. The hotel receives feedback from guests in various 
languages in the form of physical comment cards. That feedback is uploaded into the app 
through a web client. After an image of a comment card is uploaded, the following steps occur:
•Text is extracted from the image using Amazon Textract.
•Amazon Comprehend determines the sentiment of the extracted text and its language.
•The extracted text is translated to French using Amazon Translate.
•Amazon Polly synthesizes an audio ﬁle from the extracted text.
The full app can be deployed with the AWS CDK. For source code and deployment instructions, 
see the project in  GitHub .
Services used in this example
•Amazon Comprehend
•Lambda
•Amazon Polly
•Amazon Textract
•Amazon Translate
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
1263AWS Lambda Developer Guide
Invoke a Lambda function from a browser
Invoke a Lambda function from a browser
The following code example shows how to invoke an AWS Lambda function from a browser.
JavaScript
SDK for JavaScript (v2)
You can create a browser-based application that uses an AWS Lambda function to update an 
Amazon DynamoDB table with user selections.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•DynamoDB
•Lambda
SDK for JavaScript (v3)
You can create a browser-based application that uses an AWS Lambda function to update an 
Amazon DynamoDB table with user selections. This app uses AWS SDK for JavaScript v3.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•DynamoDB
•Lambda
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Use API Gateway to invoke a Lambda function
The following code examples show how to create an AWS Lambda function invoked by Amazon API 
Gateway.
Java
SDK for Java 2.x
Shows how to create an AWS Lambda function by using the Lambda Java runtime API. 
This example invokes diﬀerent AWS services to perform a speciﬁc use case. This example 
demonstrates how to create a Lambda function invoked by Amazon API Gateway that scans an 
Amazon DynamoDB table for work anniversaries and uses Amazon Simple Notiﬁcation Service 
(Amazon SNS) to send a text message to your employees that congratulates them at their one 
year anniversary date.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•API Gateway
1264AWS Lambda Developer Guide
Use API Gateway to invoke a Lambda function
•DynamoDB
•Lambda
•Amazon SNS
JavaScript
SDK for JavaScript (v3)
Shows how to create an AWS Lambda function by using the Lambda JavaScript runtime API. 
This example invokes diﬀerent AWS services to perform a speciﬁc use case. This example 
demonstrates how to create a Lambda function invoked by Amazon API Gateway that scans an 
Amazon DynamoDB table for work anniversaries and uses Amazon Simple Notiﬁcation Service 
(Amazon SNS) to send a text message to your employees that congratulates them at their one 
year anniversary date.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
This example is also available in the AWS SDK for JavaScript v3 developer guide.
Services used in this example
•API Gateway
•DynamoDB
•Lambda
•Amazon SNS
Python
SDK for Python (Boto3)
This example shows how to create and use an Amazon API Gateway REST API that targets 
an AWS Lambda function. The Lambda handler demonstrates how to route based on HTTP 
methods; how to get data from the query string, header, and body; and how to return a JSON 
response.
•Deploy a Lambda function.
•Create an API Gateway REST API.
•Create a REST resource that targets the Lambda function.
•Grant permission to let API Gateway invoke the Lambda function.
•Use the Requests package to send requests to the REST API.
•Clean up all resources created during the demo.
This example is best viewed on GitHub. For complete source code and instructions on how to set 
up and run, see the full example on GitHub .
Services used in this example
•API Gateway
•Lambda
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
1265AWS Lambda Developer Guide
Use Step Functions to invoke Lambda functions
Use Step Functions to invoke Lambda functions
The following code examples show how to create an AWS Step Functions state machine that invokes 
AWS Lambda functions in sequence.
Java
SDK for Java 2.x
Shows how to create an AWS serverless workﬂow by using AWS Step Functions and the AWS 
SDK for Java 2.x. Each workﬂow step is implemented using an AWS Lambda function.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•DynamoDB
•Lambda
•Amazon SES
•Step Functions
JavaScript
SDK for JavaScript (v3)
Shows how to create an AWS serverless workﬂow by using AWS Step Functions and the AWS 
SDK for JavaScript. Each workﬂow step is implemented using an AWS Lambda function.
Lambda is a compute service that enables you to run code without provisioning or managing 
servers. Step Functions is a serverless orchestration service that lets you combine Lambda 
functions and other AWS services to build business-critical applications.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
This example is also available in the AWS SDK for JavaScript v3 developer guide.
Services used in this example
•DynamoDB
•Lambda
•Amazon SES
•Step Functions
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
Use scheduled events to invoke a Lambda function
The following code examples show how to create an AWS Lambda function invoked by an Amazon 
EventBridge scheduled event.
1266AWS Lambda Developer Guide
Use scheduled events to invoke a Lambda function
Java
SDK for Java 2.x
Shows how to create an Amazon EventBridge scheduled event that invokes an AWS Lambda 
function. Conﬁgure EventBridge to use a cron expression to schedule when the Lambda function 
is invoked. In this example, you create a Lambda function by using the Lambda Java runtime 
API. This example invokes diﬀerent AWS services to perform a speciﬁc use case. This example 
demonstrates how to create an app that sends a mobile text message to your employees that 
congratulates them at the one year anniversary date.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
Services used in this example
•DynamoDB
•EventBridge
•Lambda
•Amazon SNS
JavaScript
SDK for JavaScript (v3)
Shows how to create an Amazon EventBridge scheduled event that invokes an AWS Lambda 
function. Conﬁgure EventBridge to use a cron expression to schedule when the Lambda function 
is invoked. In this example, you create a Lambda function by using the Lambda JavaScript 
runtime API. This example invokes diﬀerent AWS services to perform a speciﬁc use case. 
This example demonstrates how to create an app that sends a mobile text message to your 
employees that congratulates them at the one year anniversary date.
For complete source code and instructions on how to set up and run, see the full example on
GitHub .
This example is also available in the AWS SDK for JavaScript v3 developer guide.
Services used in this example
•DynamoDB
•EventBridge
•Lambda
•Amazon SNS
Python
SDK for Python (Boto3)
This example shows how to register an AWS Lambda function as the target of a scheduled 
Amazon EventBridge event. The Lambda handler writes a friendly message and the full event 
data to Amazon CloudWatch Logs for later retrieval.
•Deploys a Lambda function.
•Creates an EventBridge scheduled event and makes the Lambda function the target.
•Grants permission to let EventBridge invoke the Lambda function.
•Prints the latest data from CloudWatch Logs to show the result of the scheduled invocations.
•Cleans up all resources created during the demo.
1267AWS Lambda Developer Guide
Use scheduled events to invoke a Lambda function
This example is best viewed on GitHub. For complete source code and instructions on how to set 
up and run, see the full example on GitHub .
Services used in this example
•CloudWatch Logs
•EventBridge
•Lambda
For a complete list of AWS SDK developer guides and code examples, see Using Lambda with an AWS 
SDK (p. 1127 ). This topic also includes information about getting started and details about previous SDK 
versions.
1268AWS Lambda Developer Guide
Compute and storage
Lambda quotas
Important
New AWS accounts have reduced concurrency and memory quotas. AWS raises these quotas 
automatically based on your usage. You can also request a quota increase.
Compute and storage
Lambda sets quotas for the amount of compute and storage resources that you can use to run and store 
functions. Quotas for concurrent executions and storage apply per AWS Region. Elastic network interface 
(ENI) quotas apply per virtual private cloud (VPC), regardless of region. The following quotas can be 
increased from their default values. For more information, see Requesting a quota increase in the Service 
Quotas User Guide .
Resource Default quota Can be 
increased up 
to
Concurrent executions 1,000 Tens of 
thousands
Storage for uploaded functions (.zip ﬁle archives) 
and layers. Each function version and layer version 
consumes storage.
For best practices on managing your code 
storage, see  Monitoring Lambda code storage in 
Serverless Land.75 GB Terabytes
Storage for functions deﬁned as container images. 
These images are stored in Amazon ECR.See Amazon ECR service quotas.
Elastic network interfaces per virtual private cloud 
(VPC) (p. 85)
Note
This quota is shared with other services, 
such as Amazon Elastic File System 
(Amazon EFS). See Amazon VPC quotas.250 Thousands
For details on concurrency and how Lambda scales your function concurrency in response to traﬃc, see
Lambda function scaling (p. 220).
Function conﬁguration, deployment, and 
execution
The following quotas apply to function conﬁguration, deployment, and execution. Except as noted, they 
can't be changed.
1269AWS Lambda Developer Guide
Function conﬁguration, deployment, and execution
Note
The Lambda documentation, log messages, and console use the abbreviation MB (rather than 
MiB) to refer to 1024 KB.
Resource Quota
Function memory allocation (p. 72) 128 MB to 10,240 MB, in 1-MB 
increments.
Note:  Lambda allocates CPU power in 
proportion to the amount of memory 
conﬁgured. You can increase or 
decrease the memory and CPU power 
allocated to your function using the
Memory (MB) setting. At 1,769 MB, 
a function has the equivalent of one 
vCPU.
Function timeout 900 seconds (15 minutes)
Function environment variables (p. 77) 4 KB, for all environment variables 
associated with the function, in 
aggregate
Function resource-based policy (p. 929) 20 KB
Function layers (p. 988) ﬁve layers
Function burst concurrency (p. 243) 500 - 3000 (varies per Region)
Can be increased from default values. 
Service Quotas do not support changes 
in burst limits at this time. Contact AWS 
Support to inquire further.
Invocation payload (p. 135) (request and response) 6 MB each for request and response 
(synchronous)
20 MB for each streamed 
response (p. 110) (Synchronous. The 
payload size for streamed responses 
can be increased from default values. 
Contact AWS Support to inquire 
further.)
256 KB (asynchronous)
Bandwidth for streamed responses (p. 110) Uncapped for the ﬁrst 6 MB of your 
function's response
For responses larger than 6 MB, 2MBps 
for the remainder of the response
Deployment package (.zip ﬁle archive) (p. 18) size 50 MB (zipped, for direct upload)
250 MB (unzipped)
This quota applies to all the ﬁles you 
upload, including layers and custom 
runtimes.
1270AWS Lambda Developer Guide
Lambda API requests
Resource Quota
3 MB (console editor)
Container image settings (p. 126) size 16 KB
Container image  (p. 122) code package size10 GB (maximum uncompressed image 
size, including all layers)
Test events (console editor) 10
/tmp directory storage Between 512 MB and 10,240 MB, in 1-
MB increments
File descriptors 1,024
Execution processes/threads 1,024
Lambda API requests
The following quotas are associated with Lambda API requests.
Resource Quota
Invocation requests per function per Region (synchronous) Each instance of your execution 
environment can serve up to 10 
requests per second. In other words, the 
total invocation limit is 10 times your 
concurrency limit. See Lambda function 
scaling  (p. 220).
Invocation requests per function per Region (asynchronous) Each instance of your execution 
environment can serve an unlimited 
number of requests. In other words, the 
total invocation limit is based only on 
concurrency available to your function. 
See Lambda function scaling (p. 220).
Invocation requests per function version or alias (requests 
per second)10 x allocated provisioned 
concurrency (p. 234)
Note
This quota applies only to 
functions that use provisioned 
concurrency.
GetFunction (p. 1359 ) API requests 100 requests per second
GetPolicy (p. 1391 ) API requests 15 requests per second
Remainder of the control plane API requests (excludes 
invocation, GetFunction, and GetPolicy requests)15 requests per second
1271AWS Lambda Developer Guide
Other services
Other services
Quotas for other services, such as AWS Identity and Access Management (IAM), Amazon CloudFront 
(Lambda@Edge), and Amazon Virtual Private Cloud (Amazon VPC), can impact your Lambda functions. 
For more information, see AWS service quotas in the Amazon Web Services General Reference, and Using 
AWS Lambda with other services (p. 628).
1272AWS Lambda Developer Guide
AWS glossary
For the latest AWS terminology, see the AWS glossary in the AWS Glossary Reference.
1273AWS Lambda Developer Guide
Actions
API reference
This section contains the AWS Lambda API Reference documentation. When making the API calls, you 
will need to authenticate your request by providing a signature. AWS Lambda supports signature version 
4. For more information, see Signature Version 4 signing process in the Amazon Web Services General 
Reference.
For an overview of the service, see What is AWS Lambda? (p. 1).
You can use the AWS CLI to explore the AWS Lambda API. This guide provides several tutorials that use 
the AWS CLI.
Topics
•Actions (p. 1274 )
•Data Types (p. 1535 )
Actions
The following actions are supported:
•AddLayerVersionPermission (p. 1276 )
•AddPermission (p. 1280 )
•CreateAlias (p. 1285 )
•CreateCodeSigningConﬁg (p. 1289 )
•CreateEventSourceMapping (p. 1292 )
•CreateFunction (p. 1304 )
•CreateFunctionUrlConﬁg (p. 1317 )
•DeleteAlias  (p. 1321 )
•DeleteCodeSigningConﬁg  (p. 1323 )
•DeleteEventSourceMapping (p. 1325 )
•DeleteFunction (p. 1332 )
•DeleteFunctionCodeSigningConﬁg (p. 1334 )
•DeleteFunctionConcurrency (p. 1336 )
•DeleteFunctionEventInvokeConﬁg (p. 1338 )
•DeleteFunctionUrlConﬁg (p. 1340 )
•DeleteLayerVersion (p. 1342 )
•DeleteProvisionedConcurrencyConﬁg (p. 1344 )
•GetAccountSettings (p. 1346 )
•GetAlias  (p. 1348 )
•GetCodeSigningConﬁg  (p. 1351 )
•GetEventSourceMapping (p. 1353 )
•GetFunction (p. 1359 )
•GetFunctionCodeSigningConﬁg (p. 1363 )
•GetFunctionConcurrency (p. 1366 )
•GetFunctionConﬁguration (p. 1368 )
1274AWS Lambda Developer Guide
Actions
•GetFunctionEventInvokeConﬁg (p. 1376 )
•GetFunctionUrlConﬁg (p. 1379 )
•GetLayerVersion (p. 1382 )
•GetLayerVersionByArn (p. 1386 )
•GetLayerVersionPolicy (p. 1389 )
•GetPolicy (p. 1391 )
•GetProvisionedConcurrencyConﬁg (p. 1393 )
•GetRuntimeManagementConﬁg  (p. 1396 )
•Invoke (p. 1399 )
•InvokeAsync (p. 1405 )
•InvokeWithResponseStream (p. 1407 )
•ListAliases  (p. 1413 )
•ListCodeSigningConﬁgs  (p. 1416 )
•ListEventSourceMappings (p. 1418 )
•ListFunctionEventInvokeConﬁgs (p. 1422 )
•ListFunctions (p. 1425 )
•ListFunctionsByCodeSigningConﬁg (p. 1429 )
•ListFunctionUrlConﬁgs (p. 1431 )
•ListLayers (p. 1434 )
•ListLayerVersions (p. 1437 )
•ListProvisionedConcurrencyConﬁgs (p. 1440 )
•ListTags (p. 1443 )
•ListVersionsByFunction (p. 1445 )
•PublishLayerVersion (p. 1449 )
•PublishVersion (p. 1454 )
•PutFunctionCodeSigningConﬁg (p. 1463 )
•PutFunctionConcurrency (p. 1466 )
•PutFunctionEventInvokeConﬁg (p. 1469 )
•PutProvisionedConcurrencyConﬁg (p. 1473 )
•PutRuntimeManagementConﬁg  (p. 1476 )
•RemoveLayerVersionPermission (p. 1480 )
•RemovePermission (p. 1482 )
•TagResource (p. 1484 )
•UntagResource (p. 1486 )
•UpdateAlias  (p. 1488 )
•UpdateCodeSigningConﬁg  (p. 1492 )
•UpdateEventSourceMapping (p. 1495 )
•UpdateFunctionCode (p. 1506 )
•UpdateFunctionConﬁguration (p. 1516 )
•UpdateFunctionEventInvokeConﬁg (p. 1528 )
•UpdateFunctionUrlConﬁg (p. 1532 )
1275AWS Lambda Developer Guide
AddLayerVersionPermission
AddLayerVersionPermission
Adds permissions to the resource-based policy of a version of an AWS Lambda layer. Use this action 
to grant layer usage permission to other accounts. You can grant permission to a single account, all 
accounts in an organization, or all AWS accounts.
To revoke permission, call RemoveLayerVersionPermission (p. 1480 ) with the statement ID that you 
speciﬁed when you added it.
Request Syntax
POST /2018-10-31/layers/ LayerName /versions/ VersionNumber /policy?RevisionId= RevisionId
 HTTP/1.1
Content-type: application/json
{ 
   "Action": "string", 
   "OrganizationId ": "string", 
   "Principal ": "string", 
   "StatementId ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1276 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
RevisionId (p. 1276 )
Only update the policy if the revision ID matches the ID speciﬁed. Use this option to avoid modifying 
a policy that has changed since you last read it.
VersionNumber (p. 1276 )
The version number.
Required: Yes
Request Body
The request accepts the following data in JSON format.
Action (p. 1276 )
The API action that grants access to the layer. For example, lambda:GetLayerVersion .
Type: String
Length Constraints: Maximum length of 22.
1276AWS Lambda Developer Guide
AddLayerVersionPermission
Pattern: lambda:GetLayerVersion
Required: Yes
OrganizationId  (p. 1276 )
With the principal set to *, grant permission to all accounts in the speciﬁed organization.
Type: String
Length Constraints: Maximum length of 34.
Pattern: o-[a-z0-9]{10,32}
Required: No
Principal  (p. 1276 )
An account ID, or * to grant layer usage permission to all accounts in an organization, or all AWS 
accounts (if organizationId  is not speciﬁed). For the last case, make sure that you really do want 
all AWS accounts to have usage permission to this layer.
Type: String
Pattern: \d{12}|\*|arn:(aws[a-zA-Z-]*):iam::\d{12}:root
Required: Yes
StatementId  (p. 1276 )
An identiﬁer that distinguishes the policy from others on the same layer version.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 100.
Pattern: ([a-zA-Z0-9-_]+)
Required: Yes
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "RevisionId ": "string", 
   "Statement ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
RevisionId (p. 1277 )
A unique identiﬁer for the current revision of the policy.
Type: String
1277AWS Lambda Developer Guide
AddLayerVersionPermission
Statement  (p. 1277 )
The permission statement.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PolicyLengthExceededException
The permissions policy for the resource is too large. For more information, see Lambda quotas .
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
1278AWS Lambda Developer Guide
AddLayerVersionPermission
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1279AWS Lambda Developer Guide
AddPermission
AddPermission
Grants an AWS service, AWS account, or AWS organization permission to use a function. You can apply 
the policy at the function level, or specify a qualiﬁer to restrict access to a single version or alias. If you 
use a qualiﬁer, the invoker must use the full Amazon Resource Name (ARN) of that version or alias to 
invoke the function. Note: Lambda does not support adding policies to version $LATEST.
To grant permission to another account, specify the account ID as the Principal . To grant 
permission to an organization deﬁned in AWS Organizations, specify the organization ID as the
PrincipalOrgID . For AWS services, the principal is a domain-style identiﬁer that the service deﬁnes, 
such as s3.amazonaws.com  or sns.amazonaws.com . For AWS services, you can also specify the ARN 
of the associated resource as the SourceArn . If you grant permission to a service principal without 
specifying the source, other accounts could potentially conﬁgure resources in their account to invoke 
your Lambda function.
This operation adds a statement to a resource-based permissions policy for the function. For more 
information about function policies, see Using resource-based policies for Lambda.
Request Syntax
POST /2015-03-31/functions/ FunctionName /policy?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "Action": "string", 
   "EventSourceToken ": "string", 
   "FunctionUrlAuthType ": "string", 
   "Principal ": "string", 
   "PrincipalOrgID ": "string", 
   "RevisionId ": "string", 
   "SourceAccount ": "string", 
   "SourceArn ": "string", 
   "StatementId ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1280 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
1280AWS Lambda Developer Guide
AddPermission
Qualiﬁer  (p. 1280 )
Specify a version or alias to add permissions to a published version of the function.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following data in JSON format.
Action (p. 1280 )
The action that the principal can use on the function. For example, lambda:InvokeFunction  or
lambda:GetFunction .
Type: String
Pattern: (lambda:[*]|lambda:[a-zA-Z]+|[*])
Required: Yes
EventSourceToken (p. 1280 )
For Alexa Smart Home functions, a token that the invoker must supply.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Pattern: [a-zA-Z0-9._\-]+
Required: No
FunctionUrlAuthType (p. 1280 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Required: No
Principal  (p. 1280 )
The AWS service or AWS account that invokes the function. If you specify a service, use SourceArn
or SourceAccount  to limit who can invoke the function through that service.
Type: String
Pattern: [^\s]+
Required: Yes
PrincipalOrgID  (p. 1280 )
The identiﬁer for your organization in AWS Organizations. Use this to grant permissions to all the 
AWS accounts under this organization.
Type: String
1281AWS Lambda Developer Guide
AddPermission
Length Constraints: Minimum length of 12. Maximum length of 34.
Pattern: ^o-[a-z0-9]{10,32}$
Required: No
RevisionId (p. 1280 )
Update the policy only if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
modifying a policy that has changed since you last read it.
Type: String
Required: No
SourceAccount (p. 1280 )
For AWS service, the ID of the AWS account that owns the resource. Use this together with
SourceArn  to ensure that the speciﬁed account owns the resource. It is possible for an Amazon S3 
bucket to be deleted by its owner and recreated by another account.
Type: String
Length Constraints: Maximum length of 12.
Pattern: \d{12}
Required: No
SourceArn (p. 1280 )
For AWS services, the ARN of the AWS resource that invokes the function. For example, an Amazon 
S3 bucket or Amazon SNS topic.
Note that Lambda conﬁgures the comparison using the StringLike  operator.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
StatementId  (p. 1280 )
A statement identiﬁer that diﬀerentiates the statement from others in the same policy.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 100.
Pattern: ([a-zA-Z0-9-_]+)
Required: Yes
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "Statement ": "string"
1282AWS Lambda Developer Guide
AddPermission
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
Statement  (p. 1282 )
The permission statement that's added to the function policy.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PolicyLengthExceededException
The permissions policy for the resource is too large. For more information, see Lambda quotas .
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
1283AWS Lambda Developer Guide
AddPermission
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1284AWS Lambda Developer Guide
CreateAlias
CreateAlias
Creates an alias  for a Lambda function version. Use aliases to provide clients with a function identiﬁer 
that you can update to invoke a diﬀerent version.
You can also map an alias to split invocation requests between two versions. Use the RoutingConfig
parameter to specify a second version and the percentage of invocation requests that it receives.
Request Syntax
POST /2015-03-31/functions/ FunctionName /aliases HTTP/1.1
Content-type: application/json
{ 
   "Description ": "string", 
   "FunctionVersion ": "string", 
   "Name": "string", 
   "RoutingConfig ": {  
      "AdditionalVersionWeights ": {  
         " string" : number 
      } 
   }
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1285 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
Description  (p. 1285 )
A description of the alias.
Type: String
1285AWS Lambda Developer Guide
CreateAlias
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
FunctionVersion (p. 1285 )
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Required: Yes
Name  (p. 1285 )
The name of the alias.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
Required: Yes
RoutingConﬁg (p. 1285 )
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
Required: No
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "AliasArn ": "string", 
   "Description ": "string", 
   "FunctionVersion ": "string", 
   "Name": "string", 
   "RevisionId ": "string", 
   "RoutingConfig ": {  
      "AdditionalVersionWeights ": {  
         " string" : number 
      } 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
AliasArn  (p. 1286 )
The Amazon Resource Name (ARN) of the alias.
1286AWS Lambda Developer Guide
CreateAlias
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Description  (p. 1286 )
A description of the alias.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
FunctionVersion (p. 1286 )
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Name  (p. 1286 )
The name of the alias.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
RevisionId (p. 1286 )
A unique identiﬁer that changes when you update the alias.
Type: String
RoutingConﬁg (p. 1286 )
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
1287AWS Lambda Developer Guide
CreateAlias
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1288AWS Lambda Developer Guide
CreateCodeSigningConﬁg
CreateCodeSigningConﬁg
Creates a code signing conﬁguration. A code signing conﬁguration deﬁnes a list of allowed signing 
proﬁles and deﬁnes the code-signing validation policy (action to be taken if deployment validation 
checks fail).
Request Syntax
POST /2020-04-22/code-signing-configs/ HTTP/1.1
Content-type: application/json
{ 
   "AllowedPublishers ": {  
      "SigningProfileVersionArns ": [ "string" ] 
   }, 
   "CodeSigningPolicies ": {  
      "UntrustedArtifactOnDeployment ": "string" 
   }, 
   "Description ": "string"
}
URI Request Parameters
The request does not use any URI parameters.
Request Body
The request accepts the following data in JSON format.
AllowedPublishers (p. 1289 )
Signing proﬁles for this code signing conﬁguration.
Type: AllowedPublishers (p. 1543 ) object
Required: Yes
CodeSigningPolicies (p. 1289 )
The code signing policies deﬁne the actions to take if the validation checks fail.
Type: CodeSigningPolicies (p. 1547 ) object
Required: No
Description  (p. 1289 )
Descriptive name for this code signing conﬁguration.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
Response Syntax
HTTP/1.1 201
1289AWS Lambda Developer Guide
CreateCodeSigningConﬁg
Content-type: application/json
{ 
   "CodeSigningConfig ": {  
      "AllowedPublishers ": {  
         " SigningProfileVersionArns ": [ "string" ] 
      }, 
      "CodeSigningConfigArn ": "string", 
      "CodeSigningConfigId ": "string", 
      "CodeSigningPolicies ": {  
         " UntrustedArtifactOnDeployment ": "string" 
      }, 
      "Description ": "string", 
      "LastModified ": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
CodeSigningConﬁg  (p. 1289 )
The code signing conﬁguration.
Type: CodeSigningConﬁg  (p. 1545 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1290AWS Lambda Developer Guide
CreateCodeSigningConﬁg
1291AWS Lambda Developer Guide
CreateEventSourceMapping
CreateEventSourceMapping
Creates a mapping between an event source and an AWS Lambda function. Lambda reads items from the 
event source and invokes the function.
For details about how to conﬁgure diﬀerent event sources, see the following topics.
•Amazon DynamoDB Streams
•Amazon Kinesis
•Amazon SQS
•Amazon MQ and RabbitMQ
•Amazon MSK
•Apache Kafka
•Amazon DocumentDB
The following error handling options are available only for stream sources (DynamoDB and Kinesis):
•BisectBatchOnFunctionError  – If the function returns an error, split the batch in two and retry.
•DestinationConfig  – Send discarded records to an Amazon SQS queue or Amazon SNS topic.
•MaximumRecordAgeInSeconds  – Discard records older than the speciﬁed age. The default value is 
inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record expires
•MaximumRetryAttempts  – Discard records after the speciﬁed number of retries. The default value is 
inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record expires.
•ParallelizationFactor  – Process multiple batches from each shard concurrently.
For information about which conﬁguration parameters apply to each event source, see the following 
topics.
•Amazon DynamoDB Streams
•Amazon Kinesis
•Amazon SQS
•Amazon MQ and RabbitMQ
•Amazon MSK
•Apache Kafka
•Amazon DocumentDB
Request Syntax
POST /2015-03-31/event-source-mappings/ HTTP/1.1
Content-type: application/json
{ 
   "AmazonManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
1292AWS Lambda Developer Guide
CreateEventSourceMapping
         " Destination ": "string" 
      } 
   }, 
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "Enabled": boolean, 
   "EventSourceArn ": "string", 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
   "FunctionName ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "Queues": [ "string" ], 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SelfManagedEventSource ": {  
      "Endpoints ": {  
         " string" : [ "string" ] 
      } 
   }, 
   "SelfManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "StartingPosition ": "string", 
   "StartingPositionTimestamp ": number, 
   "Topics": [ "string" ], 
   "TumblingWindowInSeconds ": number
}
URI Request Parameters
The request does not use any URI parameters.
Request Body
The request accepts the following data in JSON format.
AmazonManagedKafkaEventSourceConﬁg (p. 1292 )
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
Required: No
1293AWS Lambda Developer Guide
CreateEventSourceMapping
BatchSize (p. 1292 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
•Amazon Kinesis – Default 100. Max 10,000.
•Amazon DynamoDB Streams – Default 100. Max 10,000.
•Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO 
queues the max is 10.
•Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
•Self-managed Apache Kafka – Default 100. Max 10,000.
•Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
•DocumentDB  – Default 100. Max 10,000.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
Required: No
BisectBatchOnFunctionError (p. 1292 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry.
Type: Boolean
Required: No
DestinationConﬁg  (p. 1292 )
(Kinesis and DynamoDB Streams only) A standard Amazon SQS queue or standard Amazon SNS 
topic destination for discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
DocumentDBEventSourceConﬁg (p. 1292 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
Required: No
Enabled (p. 1292 )
When true, the event source mapping is active. When false, Lambda pauses polling and invocation.
Default: True
Type: Boolean
Required: No
EventSourceArn (p. 1292 )
The Amazon Resource Name (ARN) of the event source.
•Amazon Kinesis – The ARN of the data stream or a stream consumer.
•Amazon DynamoDB Streams – The ARN of the stream.
•Amazon Simple Queue Service – The ARN of the queue.
1294AWS Lambda Developer Guide
CreateEventSourceMapping
•Amazon Managed Streaming for Apache Kafka – The ARN of the cluster.
•Amazon MQ – The ARN of the broker.
•Amazon DocumentDB – The ARN of the DocumentDB change stream.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
FilterCriteria  (p. 1292 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
Required: No
FunctionName (p. 1292 )
The name of the Lambda function.
Name formats
•Function name – MyFunction .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Version or Alias ARN – arn:aws:lambda:us-
west-2:123456789012:function:MyFunction:PROD .
•Partial ARN – 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it's limited 
to 64 characters in length.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
FunctionResponseTypes (p. 1292 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
Required: No
MaximumBatchingWindowInSeconds (p. 1292 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
1295AWS Lambda Developer Guide
CreateEventSourceMapping
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
Required: No
MaximumRecordAgeInSeconds (p. 1292 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is inﬁnite (-1).
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
Required: No
MaximumRetryAttempts (p. 1292 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of retries. The 
default value is inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record 
expires.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
Required: No
ParallelizationFactor (p. 1292 )
(Kinesis and DynamoDB Streams only) The number of batches to process from each shard 
concurrently.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Required: No
Queues  (p. 1292 )
(MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
Pattern: [\s\S]*
Required: No
1296AWS Lambda Developer Guide
CreateEventSourceMapping
ScalingConﬁg  (p. 1292 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
Required: No
SelfManagedEventSource (p. 1292 )
The self-managed Apache Kafka cluster to receive records from.
Type: SelfManagedEventSource (p. 1598 ) object
Required: No
SelfManagedKafkaEventSourceConﬁg (p. 1292 )
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
Required: No
SourceAccessConﬁgurations (p. 1292 )
An array of authentication protocols or VPC components required to secure your event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
Required: No
StartingPosition (p. 1292 )
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
Required: No
StartingPositionTimestamp (p. 1292 )
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
Required: No
Topics (p. 1292 )
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 249.
1297AWS Lambda Developer Guide
CreateEventSourceMapping
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
Required: No
TumblingWindowInSeconds (p. 1292 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
Required: No
Response Syntax
HTTP/1.1 202
Content-type: application/json
{ 
   "AmazonManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "EventSourceArn ": "string", 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
   "FunctionArn ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "LastModified ": number, 
   "LastProcessingResult ": "string", 
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "Queues": [ "string" ], 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SelfManagedEventSource ": {  
      "Endpoints ": {  
         " string" : [ "string" ] 
      } 
1298AWS Lambda Developer Guide
CreateEventSourceMapping
   }, 
   "SelfManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "StartingPosition ": "string", 
   "StartingPositionTimestamp ": number, 
   "State": "string", 
   "StateTransitionReason ": "string", 
   "Topics": [ "string" ], 
   "TumblingWindowInSeconds ": number, 
   "UUID": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 202 response.
The following data is returned in JSON format by the service.
AmazonManagedKafkaEventSourceConﬁg (p. 1298 )
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
BatchSize (p. 1298 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default 
is 100.
Related setting: When you set BatchSize  to a value greater than 10, you must set
MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
BisectBatchOnFunctionError (p. 1298 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry. The default value is false.
Type: Boolean
DestinationConﬁg  (p. 1298 )
(Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for 
discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
DocumentDBEventSourceConﬁg (p. 1298 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
1299AWS Lambda Developer Guide
CreateEventSourceMapping
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
EventSourceArn (p. 1298 )
The Amazon Resource Name (ARN) of the event source.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
FilterCriteria  (p. 1298 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
FunctionArn (p. 1298 )
The ARN of the Lambda function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionResponseTypes (p. 1298 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
LastModiﬁed  (p. 1298 )
The date that the event source mapping was last updated or that its state changed, in Unix time 
seconds.
Type: Timestamp
LastProcessingResult (p. 1298 )
The result of the last Lambda invocation of your function.
Type: String
MaximumBatchingWindowInSeconds (p. 1298 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
1300AWS Lambda Developer Guide
CreateEventSourceMapping
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
MaximumRecordAgeInSeconds (p. 1298 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is -1, which sets the maximum age to inﬁnite. When the value is set to inﬁnite, Lambda never 
discards old records.
Note
The minimum valid value for maximum record age is 60s. Although values less than 60 and 
greater than -1 fall within the parameter's absolute range, they are not allowed
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
MaximumRetryAttempts (p. 1298 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of 
retries. The default value is -1, which sets the maximum number of retries to inﬁnite. When 
MaximumRetryAttempts is inﬁnite, Lambda retries failed records until the record expires in the event 
source.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
ParallelizationFactor (p. 1298 )
(Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each 
shard. The default value is 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Queues  (p. 1298 )
(Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
Pattern: [\s\S]*
ScalingConﬁg  (p. 1298 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
SelfManagedEventSource (p. 1298 )
The self-managed Apache Kafka cluster for your event source.
Type: SelfManagedEventSource (p. 1598 ) object
SelfManagedKafkaEventSourceConﬁg (p. 1298 )
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
1301AWS Lambda Developer Guide
CreateEventSourceMapping
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
SourceAccessConﬁgurations (p. 1298 )
An array of the authentication protocol, VPC components, or virtual host to secure and deﬁne your 
event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
StartingPosition (p. 1298 )
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
StartingPositionTimestamp (p. 1298 )
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
State  (p. 1298 )
The state of the event source mapping. It can be one of the following: Creating , Enabling ,
Enabled , Disabling , Disabled , Updating , or Deleting .
Type: String
StateTransitionReason (p. 1298 )
Indicates whether a user or Lambda made the last change to the event source mapping.
Type: String
Topics (p. 1298 )
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 249.
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
TumblingWindowInSeconds (p. 1298 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
UUID  (p. 1298 )
The identiﬁer of the event source mapping.
Type: String
1302AWS Lambda Developer Guide
CreateEventSourceMapping
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1303AWS Lambda Developer Guide
CreateFunction
CreateFunction
Creates a Lambda function. To create a function, you need a deployment package and an execution role. 
The deployment package is a .zip ﬁle archive or container image that contains your function code. The 
execution role grants the function permission to use AWS services, such as Amazon CloudWatch Logs for 
log streaming and AWS X-Ray for request tracing.
If the deployment package is a container image, then you set the package type to Image. For a container 
image, the code property must include the URI of a container image in the Amazon ECR registry. You do 
not need to specify the handler and runtime properties.
If the deployment package is a .zip ﬁle archive, then you set the package type to Zip. For a .zip ﬁle 
archive, the code property speciﬁes the location of the .zip ﬁle. You must also specify the handler and 
runtime properties. The code in the deployment package must be compatible with the target instruction 
set architecture of the function (x86-64  or arm64). If you do not specify the architecture, then the 
default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. 
If your function connects to a VPC, this process can take a minute or so. During this time, you can't 
invoke or modify the function. The State , StateReason , and StateReasonCode  ﬁelds in the response 
from GetFunctionConﬁguration (p. 1368 ) indicate when the function is ready to invoke. For more 
information, see Lambda function states.
A function has an unpublished version, and can have published versions and aliases. The unpublished 
version changes when you update your function's code and conﬁguration. A published version is a 
snapshot of your function code and conﬁguration that can't be changed. An alias is a named resource 
that maps to a version, and can be changed to map to a diﬀerent version. Use the Publish  parameter to 
create version 1 of your function from its initial conﬁguration.
The other parameters let you conﬁgure version-speciﬁc and function-level settings. You can 
modify version-speciﬁc settings later with UpdateFunctionConﬁguration (p. 1516 ). Function-level 
settings apply to both the unpublished and published versions of the function, and include tags 
(TagResource (p. 1484 )) and per-function concurrency limits (PutFunctionConcurrency (p. 1466 )).
You can use code signing if your deployment package is a .zip ﬁle archive. To enable code signing 
for this function, specify the ARN of a code-signing conﬁguration. When a user attempts to deploy a 
code package with UpdateFunctionCode (p. 1506 ), Lambda checks that the code package has a valid 
signature from a trusted publisher. The code-signing conﬁguration includes set of signing proﬁles, which 
deﬁne the trusted publishers for this function.
If another AWS account or an AWS service invokes your function, use AddPermission (p. 1280 ) to grant 
permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can 
grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use Invoke (p. 1399 ). To invoke your function in response to events in 
other AWS services, create an event source mapping (CreateEventSourceMapping (p. 1292 )), or conﬁgure 
a function trigger in the other service. For more information, see Invoking Lambda functions.
Request Syntax
POST /2015-03-31/functions HTTP/1.1
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "Code": {  
      "ImageUri ": "string", 
      "S3Bucket ": "string", 
      "S3Key": "string", 
      "S3ObjectVersion ": "string", 
1304AWS Lambda Developer Guide
CreateFunction
      "ZipFile": blob
   }, 
   "CodeSigningConfigArn ": "string", 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfig ": {  
      "Command": [ "string" ], 
      "EntryPoint ": [ "string" ], 
      "WorkingDirectory ": "string" 
   }, 
   "KMSKeyArn ": "string", 
   "Layers": [ "string" ], 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "Publish": boolean, 
   "Role": "string", 
   "Runtime": "string", 
   "SnapStart ": {  
      "ApplyOn": "string" 
   }, 
   "Tags": {  
      "string" : "string"  
   }, 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ] 
   }
}
URI Request Parameters
The request does not use any URI parameters.
Request Body
The request accepts the following data in JSON format.
Architectures (p. 1304 )
The instruction set architecture that the function supports. Enter a string array with one of the valid 
values (arm64 or x86_64). The default value is x86_64 .
1305AWS Lambda Developer Guide
CreateFunction
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
Required: No
Code  (p. 1304 )
The code for the function.
Type: FunctionCode (p. 1566 ) object
Required: Yes
CodeSigningConﬁgArn  (p. 1304 )
To enable code signing for this function, specify the ARN of a code-signing conﬁguration. A code-
signing conﬁguration includes a set of signing proﬁles, which deﬁne the trusted publishers for this 
function.
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: No
DeadLetterConﬁg (p. 1304 )
A dead-letter queue conﬁguration that speciﬁes the queue or topic where Lambda sends 
asynchronous events when they fail processing. For more information, see Dead-letter queues.
Type: DeadLetterConﬁg (p. 1551 ) object
Required: No
Description  (p. 1304 )
A description of the function.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
Environment (p. 1304 )
Environment variables that are accessible from function code during execution.
Type: Environment (p. 1554 ) object
Required: No
EphemeralStorage  (p. 1304 )
The size of the function's /tmp directory in MB. The default value is 512, but can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
Required: No
1306AWS Lambda Developer Guide
CreateFunction
FileSystemConﬁgs (p. 1304 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
Required: No
FunctionName (p. 1304 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Handler (p. 1304 )
The name of the method within your code that Lambda calls to run your function. Handler is 
required if the deployment package is a .zip ﬁle archive. The format includes the ﬁle name. It can 
also include namespaces and other qualiﬁers, depending on the runtime. For more information, see
Lambda programming model.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
Required: No
ImageConﬁg  (p. 1304 )
Container image conﬁguration values that override the values in the container image Dockerﬁle.
Type: ImageConﬁg  (p. 1579 ) object
Required: No
KMSKeyArn (p. 1304 )
The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to 
encrypt your function's environment variables. When Lambda SnapStart is activated, Lambda also 
uses this key is to encrypt your function's snapshot. If you deploy your function using a container 
image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not 
the same key that's used to protect your container image in the Amazon Elastic Container Registry 
(Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
1307AWS Lambda Developer Guide
CreateFunction
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
Required: No
Layers (p. 1304 )
A list of function layers to add to the function's execution environment. Specify each layer by its 
ARN, including the version.
Type: Array of strings
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
Required: No
MemorySize (p. 1304 )
The amount of memory available to the function at runtime. Increasing the function memory also 
increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
Required: No
PackageType (p. 1304 )
The type of deployment package. Set to Image for container image and set to Zip for .zip ﬁle 
archive.
Type: String
Valid Values: Zip | Image
Required: No
Publish  (p. 1304 )
Set to true to publish the ﬁrst version of the function during creation.
Type: Boolean
Required: No
Role (p. 1304 )
The Amazon Resource Name (ARN) of the function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Required: Yes
Runtime  (p. 1304 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
1308AWS Lambda Developer Guide
CreateFunction
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Required: No
SnapStart (p. 1304 )
The function's SnapStart setting.
Type: SnapStart (p. 1600 ) object
Required: No
Tags (p. 1304 )
A list of tags to apply to the function.
Type: String to string map
Required: No
Timeout  (p. 1304 )
The amount of time (in seconds) that Lambda allows a function to run before stopping it. The 
default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda 
execution environment.
Type: Integer
Valid Range: Minimum value of 1.
Required: No
TracingConﬁg (p. 1304 )
Set Mode  to Active to sample and trace a subset of incoming requests with X-Ray.
Type: TracingConﬁg (p. 1604 ) object
Required: No
VpcConﬁg (p. 1304 )
For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets 
in the VPC. When you connect a function to a VPC, it can access resources and the internet only 
through that VPC. For more information, see Conﬁguring a Lambda function to access resources in a 
VPC.
Type: VpcConﬁg (p. 1606 ) object
Required: No
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
1309AWS Lambda Developer Guide
CreateFunction
   "Architectures ": [ "string" ], 
   "CodeSha256 ": "string", 
   "CodeSize ": number, 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionArn ": "string", 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfigResponse ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "ImageConfig ": {  
         " Command": [ "string" ], 
         " EntryPoint ": [ "string" ], 
         " WorkingDirectory ": "string" 
      } 
   }, 
   "KMSKeyArn ": "string", 
   "LastModified ": "string", 
   "LastUpdateStatus ": "string", 
   "LastUpdateStatusReason ": "string", 
   "LastUpdateStatusReasonCode ": "string", 
   "Layers": [  
      {  
         " Arn": "string", 
         " CodeSize ": number, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string" 
      } 
   ], 
   "MasterArn ": "string", 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "RuntimeVersionConfig ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "RuntimeVersionArn ": "string" 
   }, 
   "SigningJobArn ": "string", 
1310AWS Lambda Developer Guide
CreateFunction
   "SigningProfileVersionArn ": "string", 
   "SnapStart ": {  
      "ApplyOn": "string", 
      "OptimizationStatus ": "string" 
   }, 
   "State": "string", 
   "StateReason ": "string", 
   "StateReasonCode ": "string", 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "Version": "string", 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ], 
      "VpcId": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
Architectures (p. 1309 )
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
CodeSha256  (p. 1309 )
The SHA256 hash of the function's deployment package.
Type: String
CodeSize (p. 1309 )
The size of the function's deployment package, in bytes.
Type: Long
DeadLetterConﬁg (p. 1309 )
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Description  (p. 1309 )
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Environment (p. 1309 )
The function's environment variables. Omitted from AWS CloudTrail logs.
1311AWS Lambda Developer Guide
CreateFunction
Type: EnvironmentResponse (p. 1556 ) object
EphemeralStorage  (p. 1309 )
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
FileSystemConﬁgs (p. 1309 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
FunctionArn (p. 1309 )
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionName (p. 1309 )
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Handler (p. 1309 )
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
ImageConﬁgResponse (p. 1309 )
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
KMSKeyArn (p. 1309 )
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
LastModiﬁed  (p. 1309 )
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
1312AWS Lambda Developer Guide
CreateFunction
Type: String
LastUpdateStatus  (p. 1309 )
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
LastUpdateStatusReason (p. 1309 )
The reason for the last update that was performed on the function.
Type: String
LastUpdateStatusReasonCode (p. 1309 )
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Layers (p. 1309 )
The function's layers.
Type: Array of Layer (p. 1585 ) objects
MasterArn  (p. 1309 )
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
MemorySize (p. 1309 )
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
PackageType (p. 1309 )
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
RevisionId (p. 1309 )
The latest updated revision of the function or alias.
Type: String
1313AWS Lambda Developer Guide
CreateFunction
Role (p. 1309 )
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Runtime  (p. 1309 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
RuntimeVersionConﬁg (p. 1309 )
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
SigningJobArn  (p. 1309 )
The ARN of the signing job.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SigningProﬁleVersionArn (p. 1309 )
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SnapStart (p. 1309 )
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
State  (p. 1309 )
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
1314AWS Lambda Developer Guide
CreateFunction
StateReason (p. 1309 )
The reason for the function's current state.
Type: String
StateReasonCode (p. 1309 )
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
Timeout  (p. 1309 )
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
TracingConﬁg (p. 1309 )
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
Version (p. 1309 )
The version of the Lambda function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
VpcConﬁg (p. 1309 )
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Errors
CodeSigningConﬁgNotFoundException
The speciﬁed code signing conﬁguration does not exist.
HTTP Status Code: 404
CodeStorageExceededException
Your AWS account has exceeded its maximum total code size. For more information, see Lambda 
quotas .
1315AWS Lambda Developer Guide
CreateFunction
HTTP Status Code: 400
CodeVeriﬁcationFailedException
The code signature failed one or more of the validation checks for signature mismatch or expiry, and 
the code signing policy is set to ENFORCE. Lambda blocks the deployment.
HTTP Status Code: 400
InvalidCodeSignatureException
The code signature failed the integrity check. If the integrity check fails, then Lambda blocks 
deployment, even if the code signing policy is set to WARN.
HTTP Status Code: 400
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1316AWS Lambda Developer Guide
CreateFunctionUrlConﬁg
CreateFunctionUrlConﬁg
Creates a Lambda function URL with the speciﬁed conﬁguration parameters. A function URL is a 
dedicated HTTP(S) endpoint that you can use to invoke your function.
Request Syntax
POST /2021-10-31/functions/ FunctionName /url?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "AuthType ": "string", 
   "Cors": {  
      "AllowCredentials ": boolean, 
      "AllowHeaders ": [ "string" ], 
      "AllowMethods ": [ "string" ], 
      "AllowOrigins ": [ "string" ], 
      "ExposeHeaders ": [ "string" ], 
      "MaxAge": number
   }, 
   "InvokeMode ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1317 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1317 )
The alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))
Request Body
The request accepts the following data in JSON format.
1317AWS Lambda Developer Guide
CreateFunctionUrlConﬁg
AuthType (p. 1317 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Required: Yes
Cors  (p. 1317 )
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
Required: No
InvokeMode (p. 1317 )
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
Required: No
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "AuthType ": "string", 
   "Cors": {  
      "AllowCredentials ": boolean, 
      "AllowHeaders ": [ "string" ], 
      "AllowMethods ": [ "string" ], 
      "AllowOrigins ": [ "string" ], 
      "ExposeHeaders ": [ "string" ], 
      "MaxAge": number
   }, 
   "CreationTime ": "string", 
   "FunctionArn ": "string", 
   "FunctionUrl ": "string", 
   "InvokeMode ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
1318AWS Lambda Developer Guide
CreateFunctionUrlConﬁg
The following data is returned in JSON format by the service.
AuthType (p. 1318 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Cors  (p. 1318 )
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
CreationTime  (p. 1318 )
When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
FunctionArn (p. 1318 )
The Amazon Resource Name (ARN) of your function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionUrl (p. 1318 )
The HTTP URL endpoint for your function.
Type: String
Length Constraints: Minimum length of 40. Maximum length of 100.
InvokeMode (p. 1318 )
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
1319AWS Lambda Developer Guide
CreateFunctionUrlConﬁg
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1320AWS Lambda Developer Guide
DeleteAlias
DeleteAlias
Deletes a Lambda function alias .
Request Syntax
DELETE /2015-03-31/functions/ FunctionName /aliases/ Name HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1321 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Name  (p. 1321 )
The name of the alias.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
1321AWS Lambda Developer Guide
DeleteAlias
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1322AWS Lambda Developer Guide
DeleteCodeSigningConﬁg
DeleteCodeSigningConﬁg
Deletes the code signing conﬁguration. You can delete the code signing conﬁguration only if no function 
is using it.
Request Syntax
DELETE /2020-04-22/code-signing-configs/ CodeSigningConfigArn  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
CodeSigningConﬁgArn  (p. 1323 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
1323AWS Lambda Developer Guide
DeleteCodeSigningConﬁg
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1324AWS Lambda Developer Guide
DeleteEventSourceMapping
DeleteEventSourceMapping
Deletes an event source mapping. You can get the identiﬁer of a mapping from the output of
ListEventSourceMappings (p. 1418 ).
When you delete an event source mapping, it enters a Deleting  state and might not be completely 
deleted for several seconds.
Request Syntax
DELETE /2015-03-31/event-source-mappings/ UUID HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
UUID  (p. 1325 )
The identiﬁer of the event source mapping.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 202
Content-type: application/json
{ 
   "AmazonManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "EventSourceArn ": "string", 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
1325AWS Lambda Developer Guide
DeleteEventSourceMapping
   "FunctionArn ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "LastModified ": number, 
   "LastProcessingResult ": "string", 
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "Queues": [ "string" ], 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SelfManagedEventSource ": {  
      "Endpoints ": {  
         " string" : [ "string" ] 
      } 
   }, 
   "SelfManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "StartingPosition ": "string", 
   "StartingPositionTimestamp ": number, 
   "State": "string", 
   "StateTransitionReason ": "string", 
   "Topics": [ "string" ], 
   "TumblingWindowInSeconds ": number, 
   "UUID": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 202 response.
The following data is returned in JSON format by the service.
AmazonManagedKafkaEventSourceConﬁg (p. 1325 )
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
BatchSize (p. 1325 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default 
is 100.
Related setting: When you set BatchSize  to a value greater than 10, you must set
MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
1326AWS Lambda Developer Guide
DeleteEventSourceMapping
BisectBatchOnFunctionError (p. 1325 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry. The default value is false.
Type: Boolean
DestinationConﬁg  (p. 1325 )
(Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for 
discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
DocumentDBEventSourceConﬁg (p. 1325 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
EventSourceArn (p. 1325 )
The Amazon Resource Name (ARN) of the event source.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
FilterCriteria  (p. 1325 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
FunctionArn (p. 1325 )
The ARN of the Lambda function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionResponseTypes (p. 1325 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
LastModiﬁed  (p. 1325 )
The date that the event source mapping was last updated or that its state changed, in Unix time 
seconds.
Type: Timestamp
LastProcessingResult (p. 1325 )
The result of the last Lambda invocation of your function.
1327AWS Lambda Developer Guide
DeleteEventSourceMapping
Type: String
MaximumBatchingWindowInSeconds (p. 1325 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
MaximumRecordAgeInSeconds (p. 1325 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is -1, which sets the maximum age to inﬁnite. When the value is set to inﬁnite, Lambda never 
discards old records.
Note
The minimum valid value for maximum record age is 60s. Although values less than 60 and 
greater than -1 fall within the parameter's absolute range, they are not allowed
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
MaximumRetryAttempts (p. 1325 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of 
retries. The default value is -1, which sets the maximum number of retries to inﬁnite. When 
MaximumRetryAttempts is inﬁnite, Lambda retries failed records until the record expires in the event 
source.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
ParallelizationFactor (p. 1325 )
(Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each 
shard. The default value is 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Queues  (p. 1325 )
(Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
1328AWS Lambda Developer Guide
DeleteEventSourceMapping
Pattern: [\s\S]*
ScalingConﬁg  (p. 1325 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
SelfManagedEventSource (p. 1325 )
The self-managed Apache Kafka cluster for your event source.
Type: SelfManagedEventSource (p. 1598 ) object
SelfManagedKafkaEventSourceConﬁg (p. 1325 )
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
SourceAccessConﬁgurations (p. 1325 )
An array of the authentication protocol, VPC components, or virtual host to secure and deﬁne your 
event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
StartingPosition (p. 1325 )
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
StartingPositionTimestamp (p. 1325 )
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
State  (p. 1325 )
The state of the event source mapping. It can be one of the following: Creating , Enabling ,
Enabled , Disabling , Disabled , Updating , or Deleting .
Type: String
StateTransitionReason (p. 1325 )
Indicates whether a user or Lambda made the last change to the event source mapping.
Type: String
Topics (p. 1325 )
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
1329AWS Lambda Developer Guide
DeleteEventSourceMapping
Length Constraints: Minimum length of 1. Maximum length of 249.
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
TumblingWindowInSeconds (p. 1325 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
UUID  (p. 1325 )
The identiﬁer of the event source mapping.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceInUseException
The operation conﬂicts with the resource's availability. For example, you tried to update an event 
source mapping in the CREATING state, or you tried to delete an event source mapping currently 
UPDATING.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
1330AWS Lambda Developer Guide
DeleteEventSourceMapping
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1331AWS Lambda Developer Guide
DeleteFunction
DeleteFunction
Deletes a Lambda function. To delete a speciﬁc function version, use the Qualifier  parameter. 
Otherwise, all versions and aliases are deleted. This doesn't require the user to have explicit permissions 
for DeleteAlias  (p. 1321 ).
To delete Lambda event source mappings that invoke a function, use
DeleteEventSourceMapping (p. 1325 ). For AWS services and resources that invoke your function directly, 
delete the trigger in the service where you originally conﬁgured it.
Request Syntax
DELETE /2015-03-31/functions/ FunctionName ?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1332 )
The name of the Lambda function or version.
Name formats
•Function name – my-function  (name-only), my-function:1  (with version).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1332 )
Specify a version to delete. You can't delete a version that an alias references.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
1332AWS Lambda Developer Guide
DeleteFunction
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1333AWS Lambda Developer Guide
DeleteFunctionCodeSigningConﬁg
DeleteFunctionCodeSigningConﬁg
Removes the code signing conﬁguration from the function.
Request Syntax
DELETE /2020-06-30/functions/ FunctionName /code-signing-config HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1334 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
CodeSigningConﬁgNotFoundException
The speciﬁed code signing conﬁguration does not exist.
HTTP Status Code: 404
InvalidParameterValueException
One of the parameters in the request is not valid.
1334AWS Lambda Developer Guide
DeleteFunctionCodeSigningConﬁg
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1335AWS Lambda Developer Guide
DeleteFunctionConcurrency
DeleteFunctionConcurrency
Removes a concurrent execution limit from a function.
Request Syntax
DELETE /2017-10-31/functions/ FunctionName /concurrency HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1336 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
1336AWS Lambda Developer Guide
DeleteFunctionConcurrency
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1337AWS Lambda Developer Guide
DeleteFunctionEventInvokeConﬁg
DeleteFunctionEventInvokeConﬁg
Deletes the conﬁguration for asynchronous invocation for a function, version, or alias.
To conﬁgure options for asynchronous invocation, use PutFunctionEventInvokeConﬁg (p. 1469 ).
Request Syntax
DELETE /2019-09-25/functions/ FunctionName /event-invoke-config?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1338 )
The name of the Lambda function, version, or alias.
Name formats
•Function name - my-function  (name-only), my-function:v1  (with alias).
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN - 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1338 )
A version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
1338AWS Lambda Developer Guide
DeleteFunctionEventInvokeConﬁg
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1339AWS Lambda Developer Guide
DeleteFunctionUrlConﬁg
DeleteFunctionUrlConﬁg
Deletes a Lambda function URL. When you delete a function URL, you can't recover it. Creating a new 
function URL results in a diﬀerent URL address.
Request Syntax
DELETE /2021-10-31/functions/ FunctionName /url?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1340 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1340 )
The alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
1340AWS Lambda Developer Guide
DeleteFunctionUrlConﬁg
Errors
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1341AWS Lambda Developer Guide
DeleteLayerVersion
DeleteLayerVersion
Deletes a version of an AWS Lambda layer. Deleted versions can no longer be viewed or added to 
functions. To avoid breaking functions, a copy of the version remains in Lambda until no functions refer 
to it.
Request Syntax
DELETE /2018-10-31/layers/ LayerName /versions/ VersionNumber  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1342 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
VersionNumber (p. 1342 )
The version number.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
1342AWS Lambda Developer Guide
DeleteLayerVersion
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1343AWS Lambda Developer Guide
DeleteProvisionedConcurrencyConﬁg
DeleteProvisionedConcurrencyConﬁg
Deletes the provisioned concurrency conﬁguration for a function.
Request Syntax
DELETE /2019-09-30/functions/ FunctionName /provisioned-concurrency?Qualifier= Qualifier
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1344 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1344 )
The version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
1344AWS Lambda Developer Guide
DeleteProvisionedConcurrencyConﬁg
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1345AWS Lambda Developer Guide
GetAccountSettings
GetAccountSettings
Retrieves details about your account's limits  and usage in an AWS Region.
Request Syntax
GET /2016-08-19/account-settings/ HTTP/1.1
URI Request Parameters
The request does not use any URI parameters.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AccountLimit ": {  
      "CodeSizeUnzipped ": number, 
      "CodeSizeZipped ": number, 
      "ConcurrentExecutions ": number, 
      "TotalCodeSize ": number, 
      "UnreservedConcurrentExecutions ": number
   }, 
   "AccountUsage ": {  
      "FunctionCount ": number, 
      "TotalCodeSize ": number
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
AccountLimit (p. 1346 )
Limits that are related to concurrency and code storage.
Type: AccountLimit (p. 1538 ) object
AccountUsage (p. 1346 )
The number of functions and amount of storage in use.
Type: AccountUsage (p. 1539 ) object
Errors
ServiceException
The AWS Lambda service encountered an internal error.
1346AWS Lambda Developer Guide
GetAccountSettings
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1347AWS Lambda Developer Guide
GetAlias
GetAlias
Returns details about a Lambda function alias .
Request Syntax
GET /2015-03-31/functions/ FunctionName /aliases/ Name HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1348 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Name  (p. 1348 )
The name of the alias.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AliasArn ": "string", 
   "Description ": "string", 
   "FunctionVersion ": "string", 
1348AWS Lambda Developer Guide
GetAlias
   "Name": "string", 
   "RevisionId ": "string", 
   "RoutingConfig ": {  
      "AdditionalVersionWeights ": {  
         " string" : number 
      } 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
AliasArn  (p. 1348 )
The Amazon Resource Name (ARN) of the alias.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Description  (p. 1348 )
A description of the alias.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
FunctionVersion (p. 1348 )
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Name  (p. 1348 )
The name of the alias.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
RevisionId (p. 1348 )
A unique identiﬁer that changes when you update the alias.
Type: String
RoutingConﬁg (p. 1348 )
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
1349AWS Lambda Developer Guide
GetAlias
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1350AWS Lambda Developer Guide
GetCodeSigningConﬁg
GetCodeSigningConﬁg
Returns information about the speciﬁed code signing conﬁguration.
Request Syntax
GET /2020-04-22/code-signing-configs/ CodeSigningConfigArn  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
CodeSigningConﬁgArn  (p. 1351 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CodeSigningConfig ": {  
      "AllowedPublishers ": {  
         " SigningProfileVersionArns ": [ "string" ] 
      }, 
      "CodeSigningConfigArn ": "string", 
      "CodeSigningConfigId ": "string", 
      "CodeSigningPolicies ": {  
         " UntrustedArtifactOnDeployment ": "string" 
      }, 
      "Description ": "string", 
      "LastModified ": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
CodeSigningConﬁg  (p. 1351 )
The code signing conﬁguration
1351AWS Lambda Developer Guide
GetCodeSigningConﬁg
Type: CodeSigningConﬁg  (p. 1545 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1352AWS Lambda Developer Guide
GetEventSourceMapping
GetEventSourceMapping
Returns details about an event source mapping. You can get the identiﬁer of a mapping from the output 
of ListEventSourceMappings (p. 1418 ).
Request Syntax
GET /2015-03-31/event-source-mappings/ UUID HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
UUID  (p. 1353 )
The identiﬁer of the event source mapping.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AmazonManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "EventSourceArn ": "string", 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
   "FunctionArn ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "LastModified ": number, 
   "LastProcessingResult ": "string", 
1353AWS Lambda Developer Guide
GetEventSourceMapping
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "Queues": [ "string" ], 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SelfManagedEventSource ": {  
      "Endpoints ": {  
         " string" : [ "string" ] 
      } 
   }, 
   "SelfManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "StartingPosition ": "string", 
   "StartingPositionTimestamp ": number, 
   "State": "string", 
   "StateTransitionReason ": "string", 
   "Topics": [ "string" ], 
   "TumblingWindowInSeconds ": number, 
   "UUID": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
AmazonManagedKafkaEventSourceConﬁg (p. 1353 )
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
BatchSize (p. 1353 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default 
is 100.
Related setting: When you set BatchSize  to a value greater than 10, you must set
MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
BisectBatchOnFunctionError (p. 1353 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry. The default value is false.
1354AWS Lambda Developer Guide
GetEventSourceMapping
Type: Boolean
DestinationConﬁg  (p. 1353 )
(Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for 
discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
DocumentDBEventSourceConﬁg (p. 1353 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
EventSourceArn (p. 1353 )
The Amazon Resource Name (ARN) of the event source.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
FilterCriteria  (p. 1353 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
FunctionArn (p. 1353 )
The ARN of the Lambda function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionResponseTypes (p. 1353 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
LastModiﬁed  (p. 1353 )
The date that the event source mapping was last updated or that its state changed, in Unix time 
seconds.
Type: Timestamp
LastProcessingResult (p. 1353 )
The result of the last Lambda invocation of your function.
Type: String
MaximumBatchingWindowInSeconds (p. 1353 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
1355AWS Lambda Developer Guide
GetEventSourceMapping
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
MaximumRecordAgeInSeconds (p. 1353 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is -1, which sets the maximum age to inﬁnite. When the value is set to inﬁnite, Lambda never 
discards old records.
Note
The minimum valid value for maximum record age is 60s. Although values less than 60 and 
greater than -1 fall within the parameter's absolute range, they are not allowed
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
MaximumRetryAttempts (p. 1353 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of 
retries. The default value is -1, which sets the maximum number of retries to inﬁnite. When 
MaximumRetryAttempts is inﬁnite, Lambda retries failed records until the record expires in the event 
source.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
ParallelizationFactor (p. 1353 )
(Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each 
shard. The default value is 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Queues  (p. 1353 )
(Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
Pattern: [\s\S]*
ScalingConﬁg  (p. 1353 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
1356AWS Lambda Developer Guide
GetEventSourceMapping
Type: ScalingConﬁg  (p. 1597 ) object
SelfManagedEventSource (p. 1353 )
The self-managed Apache Kafka cluster for your event source.
Type: SelfManagedEventSource (p. 1598 ) object
SelfManagedKafkaEventSourceConﬁg (p. 1353 )
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
SourceAccessConﬁgurations (p. 1353 )
An array of the authentication protocol, VPC components, or virtual host to secure and deﬁne your 
event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
StartingPosition (p. 1353 )
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
StartingPositionTimestamp (p. 1353 )
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
State  (p. 1353 )
The state of the event source mapping. It can be one of the following: Creating , Enabling ,
Enabled , Disabling , Disabled , Updating , or Deleting .
Type: String
StateTransitionReason (p. 1353 )
Indicates whether a user or Lambda made the last change to the event source mapping.
Type: String
Topics (p. 1353 )
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 249.
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
TumblingWindowInSeconds (p. 1353 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
1357AWS Lambda Developer Guide
GetEventSourceMapping
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
UUID  (p. 1353 )
The identiﬁer of the event source mapping.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1358AWS Lambda Developer Guide
GetFunction
GetFunction
Returns information about the function or function version, with a link to download the deployment 
package that's valid for 10 minutes. If you specify a function version, only details that are speciﬁc to that 
version are returned.
Request Syntax
GET /2015-03-31/functions/ FunctionName ?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1359 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1359 )
Specify a version or alias to get details about a published version of the function.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Code": {  
      "ImageUri ": "string", 
      "Location ": "string", 
      "RepositoryType ": "string", 
      "ResolvedImageUri ": "string" 
1359AWS Lambda Developer Guide
GetFunction
   }, 
   "Concurrency ": {  
      "ReservedConcurrentExecutions ": number
   }, 
   "Configuration ": {  
      "Architectures ": [ "string" ], 
      "CodeSha256 ": "string", 
      "CodeSize ": number, 
      "DeadLetterConfig ": {  
         " TargetArn ": "string" 
      }, 
      "Description ": "string", 
      "Environment ": {  
         " Error": {  
            " ErrorCode ": "string", 
            " Message": "string" 
         }, 
         " Variables ": {  
            " string" : "string"  
         } 
      }, 
      "EphemeralStorage ": {  
         " Size": number
      }, 
      "FileSystemConfigs ": [  
         {  
            " Arn": "string", 
            " LocalMountPath ": "string" 
         } 
      ], 
      "FunctionArn ": "string", 
      "FunctionName ": "string", 
      "Handler": "string", 
      "ImageConfigResponse ": {  
         " Error": {  
            " ErrorCode ": "string", 
            " Message": "string" 
         }, 
         " ImageConfig ": {  
            " Command": [ "string" ], 
            " EntryPoint ": [ "string" ], 
            " WorkingDirectory ": "string" 
         } 
      }, 
      "KMSKeyArn ": "string", 
      "LastModified ": "string", 
      "LastUpdateStatus ": "string", 
      "LastUpdateStatusReason ": "string", 
      "LastUpdateStatusReasonCode ": "string", 
      "Layers": [  
         {  
            " Arn": "string", 
            " CodeSize ": number, 
            " SigningJobArn ": "string", 
            " SigningProfileVersionArn ": "string" 
         } 
      ], 
      "MasterArn ": "string", 
      "MemorySize ": number, 
      "PackageType ": "string", 
      "RevisionId ": "string", 
      "Role": "string", 
      "Runtime": "string", 
      "RuntimeVersionConfig ": {  
         " Error": {  
            " ErrorCode ": "string", 
1360AWS Lambda Developer Guide
GetFunction
            " Message": "string" 
         }, 
         " RuntimeVersionArn ": "string" 
      }, 
      "SigningJobArn ": "string", 
      "SigningProfileVersionArn ": "string", 
      "SnapStart ": {  
         " ApplyOn": "string", 
         " OptimizationStatus ": "string" 
      }, 
      "State": "string", 
      "StateReason ": "string", 
      "StateReasonCode ": "string", 
      "Timeout": number, 
      "TracingConfig ": {  
         " Mode": "string" 
      }, 
      "Version": "string", 
      "VpcConfig ": {  
         " SecurityGroupIds ": [ "string" ], 
         " SubnetIds ": [ "string" ], 
         " VpcId": "string" 
      } 
   }, 
   "Tags": {  
      "string" : "string"  
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Code  (p. 1359 )
The deployment package of the function or version.
Type: FunctionCodeLocation (p. 1568 ) object
Concurrency (p. 1359 )
The function's reserved concurrency.
Type: Concurrency (p. 1548 ) object
Conﬁguration  (p. 1359 )
The conﬁguration of the function or version.
Type: FunctionConﬁguration (p. 1569 ) object
Tags (p. 1359 )
The function's tags.
Type: String to string map
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
1361AWS Lambda Developer Guide
GetFunction
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1362AWS Lambda Developer Guide
GetFunctionCodeSigningConﬁg
GetFunctionCodeSigningConﬁg
Returns the code signing conﬁguration for the speciﬁed function.
Request Syntax
GET /2020-06-30/functions/ FunctionName /code-signing-config HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1363 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CodeSigningConfigArn ": "string", 
   "FunctionName ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
CodeSigningConﬁgArn  (p. 1363 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
1363AWS Lambda Developer Guide
GetFunctionCodeSigningConﬁg
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
FunctionName (p. 1363 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
1364AWS Lambda Developer Guide
GetFunctionCodeSigningConﬁg
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1365AWS Lambda Developer Guide
GetFunctionConcurrency
GetFunctionConcurrency
Returns details about the reserved concurrency conﬁguration for a function. To set a concurrency limit 
for a function, use PutFunctionConcurrency (p. 1466 ).
Request Syntax
GET /2019-09-30/functions/ FunctionName /concurrency HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1366 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "ReservedConcurrentExecutions ": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
ReservedConcurrentExecutions (p. 1366 )
The number of simultaneous executions that are reserved for the function.
1366AWS Lambda Developer Guide
GetFunctionConcurrency
Type: Integer
Valid Range: Minimum value of 0.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1367AWS Lambda Developer Guide
GetFunctionConﬁguration
GetFunctionConﬁguration
Returns the version-speciﬁc settings of a Lambda function or version. The output includes 
only options that can vary between versions of a function. To modify these settings, use
UpdateFunctionConﬁguration (p. 1516 ).
To get all of a function's details, including function-level settings, use GetFunction (p. 1359 ).
Request Syntax
GET /2015-03-31/functions/ FunctionName /configuration?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1368 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1368 )
Specify a version or alias to get details about a published version of the function.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "CodeSha256 ": "string", 
   "CodeSize ": number, 
1368AWS Lambda Developer Guide
GetFunctionConﬁguration
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionArn ": "string", 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfigResponse ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "ImageConfig ": {  
         " Command": [ "string" ], 
         " EntryPoint ": [ "string" ], 
         " WorkingDirectory ": "string" 
      } 
   }, 
   "KMSKeyArn ": "string", 
   "LastModified ": "string", 
   "LastUpdateStatus ": "string", 
   "LastUpdateStatusReason ": "string", 
   "LastUpdateStatusReasonCode ": "string", 
   "Layers": [  
      {  
         " Arn": "string", 
         " CodeSize ": number, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string" 
      } 
   ], 
   "MasterArn ": "string", 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "RuntimeVersionConfig ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "RuntimeVersionArn ": "string" 
   }, 
   "SigningJobArn ": "string", 
   "SigningProfileVersionArn ": "string", 
   "SnapStart ": {  
      "ApplyOn": "string", 
1369AWS Lambda Developer Guide
GetFunctionConﬁguration
      "OptimizationStatus ": "string" 
   }, 
   "State": "string", 
   "StateReason ": "string", 
   "StateReasonCode ": "string", 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "Version": "string", 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ], 
      "VpcId": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Architectures (p. 1368 )
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
CodeSha256  (p. 1368 )
The SHA256 hash of the function's deployment package.
Type: String
CodeSize (p. 1368 )
The size of the function's deployment package, in bytes.
Type: Long
DeadLetterConﬁg (p. 1368 )
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Description  (p. 1368 )
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Environment (p. 1368 )
The function's environment variables. Omitted from AWS CloudTrail logs.
Type: EnvironmentResponse (p. 1556 ) object
1370AWS Lambda Developer Guide
GetFunctionConﬁguration
EphemeralStorage  (p. 1368 )
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
FileSystemConﬁgs (p. 1368 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
FunctionArn (p. 1368 )
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionName (p. 1368 )
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Handler (p. 1368 )
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
ImageConﬁgResponse (p. 1368 )
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
KMSKeyArn (p. 1368 )
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
LastModiﬁed  (p. 1368 )
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
1371AWS Lambda Developer Guide
GetFunctionConﬁguration
Type: String
LastUpdateStatus  (p. 1368 )
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
LastUpdateStatusReason (p. 1368 )
The reason for the last update that was performed on the function.
Type: String
LastUpdateStatusReasonCode (p. 1368 )
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Layers (p. 1368 )
The function's layers.
Type: Array of Layer (p. 1585 ) objects
MasterArn  (p. 1368 )
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
MemorySize (p. 1368 )
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
PackageType (p. 1368 )
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
RevisionId (p. 1368 )
The latest updated revision of the function or alias.
Type: String
1372AWS Lambda Developer Guide
GetFunctionConﬁguration
Role (p. 1368 )
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Runtime  (p. 1368 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
RuntimeVersionConﬁg (p. 1368 )
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
SigningJobArn  (p. 1368 )
The ARN of the signing job.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SigningProﬁleVersionArn (p. 1368 )
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SnapStart (p. 1368 )
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
State  (p. 1368 )
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
1373AWS Lambda Developer Guide
GetFunctionConﬁguration
StateReason (p. 1368 )
The reason for the function's current state.
Type: String
StateReasonCode (p. 1368 )
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
Timeout  (p. 1368 )
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
TracingConﬁg (p. 1368 )
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
Version (p. 1368 )
The version of the Lambda function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
VpcConﬁg (p. 1368 )
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
1374AWS Lambda Developer Guide
GetFunctionConﬁguration
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1375AWS Lambda Developer Guide
GetFunctionEventInvokeConﬁg
GetFunctionEventInvokeConﬁg
Retrieves the conﬁguration for asynchronous invocation for a function, version, or alias.
To conﬁgure options for asynchronous invocation, use PutFunctionEventInvokeConﬁg (p. 1469 ).
Request Syntax
GET /2019-09-25/functions/ FunctionName /event-invoke-config?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1376 )
The name of the Lambda function, version, or alias.
Name formats
•Function name - my-function  (name-only), my-function:v1  (with alias).
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN - 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1376 )
A version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
1376AWS Lambda Developer Guide
GetFunctionEventInvokeConﬁg
      } 
   }, 
   "FunctionArn ": "string", 
   "LastModified ": number, 
   "MaximumEventAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
DestinationConﬁg  (p. 1376 )
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
FunctionArn (p. 1376 )
The Amazon Resource Name (ARN) of the function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
LastModiﬁed  (p. 1376 )
The date and time that the conﬁguration was last updated, in Unix time seconds.
Type: Timestamp
MaximumEventAgeInSeconds (p. 1376 )
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
MaximumRetryAttempts (p. 1376 )
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
1377AWS Lambda Developer Guide
GetFunctionEventInvokeConﬁg
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1378AWS Lambda Developer Guide
GetFunctionUrlConﬁg
GetFunctionUrlConﬁg
Returns details about a Lambda function URL.
Request Syntax
GET /2021-10-31/functions/ FunctionName /url?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1379 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1379 )
The alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AuthType ": "string", 
   "Cors": {  
      "AllowCredentials ": boolean, 
      "AllowHeaders ": [ "string" ], 
      "AllowMethods ": [ "string" ], 
      "AllowOrigins ": [ "string" ], 
      "ExposeHeaders ": [ "string" ], 
1379AWS Lambda Developer Guide
GetFunctionUrlConﬁg
      "MaxAge": number
   }, 
   "CreationTime ": "string", 
   "FunctionArn ": "string", 
   "FunctionUrl ": "string", 
   "InvokeMode ": "string", 
   "LastModifiedTime ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
AuthType (p. 1379 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Cors  (p. 1379 )
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
CreationTime  (p. 1379 )
When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
FunctionArn (p. 1379 )
The Amazon Resource Name (ARN) of your function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionUrl (p. 1379 )
The HTTP URL endpoint for your function.
Type: String
Length Constraints: Minimum length of 40. Maximum length of 100.
InvokeMode (p. 1379 )
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
1380AWS Lambda Developer Guide
GetFunctionUrlConﬁg
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
LastModiﬁedTime  (p. 1379 )
When the function URL conﬁguration was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1381AWS Lambda Developer Guide
GetLayerVersion
GetLayerVersion
Returns information about a version of an AWS Lambda layer, with a link to download the layer archive 
that's valid for 10 minutes.
Request Syntax
GET /2018-10-31/layers/ LayerName /versions/ VersionNumber  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1382 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
VersionNumber (p. 1382 )
The version number.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CompatibleArchitectures ": [ "string" ], 
   "CompatibleRuntimes ": [ "string" ], 
   "Content": {  
      "CodeSha256 ": "string", 
      "CodeSize ": number, 
      "Location ": "string", 
      "SigningJobArn ": "string", 
      "SigningProfileVersionArn ": "string" 
   }, 
   "CreatedDate ": "string", 
   "Description ": "string", 
   "LayerArn ": "string", 
   "LayerVersionArn ": "string", 
   "LicenseInfo ": "string", 
   "Version": number
}
1382AWS Lambda Developer Guide
GetLayerVersion
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
CompatibleArchitectures (p. 1382 )
A list of compatible instruction set architectures.
Type: Array of strings
Array Members: Maximum number of 2 items.
Valid Values: x86_64 | arm64
CompatibleRuntimes (p. 1382 )
The layer's compatible runtimes.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: Array of strings
Array Members: Maximum number of 15 items.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Content  (p. 1382 )
Details about the layer version.
Type: LayerVersionContentOutput (p. 1588 ) object
CreatedDate  (p. 1382 )
The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
Description  (p. 1382 )
The description of the version.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
LayerArn (p. 1382 )
The ARN of the layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+
1383AWS Lambda Developer Guide
GetLayerVersion
LayerVersionArn (p. 1382 )
The ARN of the layer version.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
LicenseInfo (p. 1382 )
The layer's software license.
Type: String
Length Constraints: Maximum length of 512.
Version (p. 1382 )
The version number.
Type: Long
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
1384AWS Lambda Developer Guide
GetLayerVersion
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1385AWS Lambda Developer Guide
GetLayerVersionByArn
GetLayerVersionByArn
Returns information about a version of an AWS Lambda layer, with a link to download the layer archive 
that's valid for 10 minutes.
Request Syntax
GET /2018-10-31/layers?find=LayerVersion&Arn= Arn HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
Arn (p. 1386 )
The ARN of the layer version.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CompatibleArchitectures ": [ "string" ], 
   "CompatibleRuntimes ": [ "string" ], 
   "Content": {  
      "CodeSha256 ": "string", 
      "CodeSize ": number, 
      "Location ": "string", 
      "SigningJobArn ": "string", 
      "SigningProfileVersionArn ": "string" 
   }, 
   "CreatedDate ": "string", 
   "Description ": "string", 
   "LayerArn ": "string", 
   "LayerVersionArn ": "string", 
   "LicenseInfo ": "string", 
   "Version": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
1386AWS Lambda Developer Guide
GetLayerVersionByArn
CompatibleArchitectures (p. 1386 )
A list of compatible instruction set architectures.
Type: Array of strings
Array Members: Maximum number of 2 items.
Valid Values: x86_64 | arm64
CompatibleRuntimes (p. 1386 )
The layer's compatible runtimes.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: Array of strings
Array Members: Maximum number of 15 items.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Content  (p. 1386 )
Details about the layer version.
Type: LayerVersionContentOutput (p. 1588 ) object
CreatedDate  (p. 1386 )
The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
Description  (p. 1386 )
The description of the version.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
LayerArn (p. 1386 )
The ARN of the layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+
LayerVersionArn (p. 1386 )
The ARN of the layer version.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
1387AWS Lambda Developer Guide
GetLayerVersionByArn
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
LicenseInfo (p. 1386 )
The layer's software license.
Type: String
Length Constraints: Maximum length of 512.
Version (p. 1386 )
The version number.
Type: Long
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1388AWS Lambda Developer Guide
GetLayerVersionPolicy
GetLayerVersionPolicy
Returns the permission policy for a version of an AWS Lambda layer. For more information, see
AddLayerVersionPermission (p. 1276 ).
Request Syntax
GET /2018-10-31/layers/ LayerName /versions/ VersionNumber /policy HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1389 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
VersionNumber (p. 1389 )
The version number.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Policy": "string", 
   "RevisionId ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Policy (p. 1389 )
The policy document.
Type: String
1389AWS Lambda Developer Guide
GetLayerVersionPolicy
RevisionId (p. 1389 )
A unique identiﬁer for the current revision of the policy.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1390AWS Lambda Developer Guide
GetPolicy
GetPolicy
Returns the resource-based IAM policy for a function, version, or alias.
Request Syntax
GET /2015-03-31/functions/ FunctionName /policy?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1391 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1391 )
Specify a version or alias to get the policy for that resource.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Policy": "string", 
   "RevisionId ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
1391AWS Lambda Developer Guide
GetPolicy
The following data is returned in JSON format by the service.
Policy (p. 1391 )
The resource-based policy.
Type: String
RevisionId (p. 1391 )
A unique identiﬁer for the current revision of the policy.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1392AWS Lambda Developer Guide
GetProvisionedConcurrencyConﬁg
GetProvisionedConcurrencyConﬁg
Retrieves the provisioned concurrency conﬁguration for a function's alias or version.
Request Syntax
GET /2019-09-30/functions/ FunctionName /provisioned-concurrency?Qualifier= Qualifier  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1393 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1393 )
The version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AllocatedProvisionedConcurrentExecutions ": number, 
   "AvailableProvisionedConcurrentExecutions ": number, 
   "LastModified ": "string", 
   "RequestedProvisionedConcurrentExecutions ": number, 
1393AWS Lambda Developer Guide
GetProvisionedConcurrencyConﬁg
   "Status": "string", 
   "StatusReason ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
AllocatedProvisionedConcurrentExecutions (p. 1393 )
The amount of provisioned concurrency allocated. When a weighted alias is used during linear 
and canary deployments, this value ﬂuctuates depending on the amount of concurrency that is 
provisioned for the function versions.
Type: Integer
Valid Range: Minimum value of 0.
AvailableProvisionedConcurrentExecutions (p. 1393 )
The amount of provisioned concurrency available.
Type: Integer
Valid Range: Minimum value of 0.
LastModiﬁed  (p. 1393 )
The date and time that a user last updated the conﬁguration, in ISO 8601 format.
Type: String
RequestedProvisionedConcurrentExecutions (p. 1393 )
The amount of provisioned concurrency requested.
Type: Integer
Valid Range: Minimum value of 1.
Status  (p. 1393 )
The status of the allocation process.
Type: String
Valid Values: IN_PROGRESS | READY | FAILED
StatusReason (p. 1393 )
For failed allocations, the reason that provisioned concurrency could not be allocated.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
1394AWS Lambda Developer Guide
GetProvisionedConcurrencyConﬁg
ProvisionedConcurrencyConﬁgNotFoundException
The speciﬁed conﬁguration does not exist.
HTTP Status Code: 404
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1395AWS Lambda Developer Guide
GetRuntimeManagementConﬁg
GetRuntimeManagementConﬁg
Retrieves the runtime management conﬁguration for a function's version. If the runtime update mode 
is Manual , this includes the ARN of the runtime version and the runtime update mode. If the runtime 
update mode is Auto  or Function update, this includes the runtime update mode and null is returned 
for the ARN. For more information, see Runtime updates .
Request Syntax
GET /2021-07-20/functions/ FunctionName /runtime-management-config?Qualifier= Qualifier
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1396 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1396 )
Specify a version of the function. This can be $LATEST or a published version number. If no value is 
speciﬁed, the conﬁguration for the $LATEST version is returned.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "FunctionArn ": "string", 
1396AWS Lambda Developer Guide
GetRuntimeManagementConﬁg
   "RuntimeVersionArn ": "string", 
   "UpdateRuntimeOn ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
FunctionArn (p. 1396 )
The Amazon Resource Name (ARN) of your function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
RuntimeVersionArn (p. 1396 )
The ARN of the runtime the function is conﬁgured to use. If the runtime update mode is Manual , the 
ARN is returned, otherwise null is returned.
Type: String
Length Constraints: Minimum length of 26. Maximum length of 2048.
Pattern: ^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}::runtime:.+$
UpdateRuntimeOn  (p. 1396 )
The current runtime update mode of the function.
Type: String
Valid Values: Auto | Manual | FunctionUpdate
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1397AWS Lambda Developer Guide
GetRuntimeManagementConﬁg
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1398AWS Lambda Developer Guide
Invoke
Invoke
Invokes a Lambda function. You can invoke a function synchronously (and wait for the response), or 
asynchronously. To invoke a function asynchronously, set InvocationType  to Event .
For synchronous invocation, details about the function response, including errors, are included in the 
response body and headers. For either invocation type, you can ﬁnd more information in the execution 
log and trace.
When an error occurs, your function may be invoked multiple times. Retry behavior varies by error type, 
client, event source, and invocation type. For example, if you invoke a function asynchronously and it 
returns an error, Lambda executes the function up to two more times. For more information, see Error 
handling and automatic retries in Lambda.
For asynchronous invocation, Lambda adds events to a queue before sending them to your function. 
If your function does not have enough capacity to keep up with the queue, events may be lost. 
Occasionally, your function may receive the same event multiple times, even if no error occurs. To retain 
events that were not processed, conﬁgure your function with a dead-letter queue.
The status code in the API response doesn't reﬂect function errors. Error codes are reserved 
for errors that prevent your function from executing, such as permissions errors, quota
errors, or issues with your function's code and conﬁguration. For example, Lambda returns
TooManyRequestsException  if running the function would cause you to exceed a concurrency 
limit at either the account level (ConcurrentInvocationLimitExceeded ) or function level 
(ReservedFunctionConcurrentInvocationLimitExceeded ).
For functions with a long timeout, your client might disconnect during synchronous invocation while it 
waits for a response. Conﬁgure your HTTP client, SDK, ﬁrewall, proxy, or operating system to allow for 
long connections with timeout or keep-alive settings.
This operation requires permission for the lambda:InvokeFunction action. For details on how to set up 
permissions for cross-account invocations, see Granting function access to other accounts.
Request Syntax
POST /2015-03-31/functions/ FunctionName /invocations?Qualifier= Qualifier  HTTP/1.1
X-Amz-Invocation-Type: InvocationType
X-Amz-Log-Type: LogType
X-Amz-Client-Context: ClientContext
Payload
URI Request Parameters
The request uses the following URI parameters.
ClientContext (p. 1399 )
Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the 
context object.
FunctionName (p. 1399 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
1399AWS Lambda Developer Guide
Invoke
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
InvocationType (p. 1399 )
Choose from the following options.
•RequestResponse  (default) – Invoke the function synchronously. Keep the connection open until 
the function returns a response or times out. The API response includes the function response and 
additional data.
•Event – Invoke the function asynchronously. Send events that fail multiple times to the function's 
dead-letter queue (if one is conﬁgured). The API response only includes a status code.
•DryRun – Validate parameter values and verify that the user or role has permission to invoke the 
function.
Valid Values: Event | RequestResponse | DryRun
LogType (p. 1399 )
Set to Tail to include the execution log in the response. Applies to synchronously invoked functions 
only.
Valid Values: None | Tail
Qualiﬁer  (p. 1399 )
Specify a version or alias to invoke a published version of the function.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following binary data.
Payload (p. 1399 )
The JSON that you want to provide to your Lambda function as input.
You can enter the JSON directly. For example, --payload '{ "key": "value" }' . You can also 
specify a ﬁle path. For example, --payload file://payload.json .
Response Syntax
HTTP/1.1 StatusCode
X-Amz-Function-Error: FunctionError
X-Amz-Log-Result: LogResult
X-Amz-Executed-Version: ExecutedVersion
1400AWS Lambda Developer Guide
Invoke
Payload
Response Elements
If the action is successful, the service sends back the following HTTP response.
StatusCode  (p. 1400 )
The HTTP status code is in the 200 range for a successful request. For the RequestResponse
invocation type, this status code is 200. For the Event invocation type, this status code is 202. For 
the DryRun invocation type, the status code is 204.
The response returns the following HTTP headers.
ExecutedVersion (p. 1400 )
The version of the function that executed. When you invoke a function with an alias, this indicates 
which version the alias resolved to.
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
FunctionError (p. 1400 )
If present, indicates that an error occurred during function execution. Details about the error are 
included in the response payload.
LogResult (p. 1400 )
The last 4 KB of the execution log, which is base64-encoded.
The response returns the following as the HTTP body.
Payload (p. 1400 )
The response from the function, or an error object.
Errors
EC2AccessDeniedException
Need additional permissions to conﬁgure VPC settings.
HTTP Status Code: 502
EC2ThrottledException
Amazon EC2 throttled AWS Lambda during Lambda function initialization using the execution role 
provided for the function.
HTTP Status Code: 502
EC2UnexpectedException
AWS Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda 
function.
HTTP Status Code: 502
1401AWS Lambda Developer Guide
Invoke
EFSIOException
An error occurred when reading from or writing to a connected ﬁle system.
HTTP Status Code: 410
EFSMountConnectivityException
The Lambda function couldn't make a network connection to the conﬁgured ﬁle system.
HTTP Status Code: 408
EFSMountFailureException
The Lambda function couldn't mount the conﬁgured ﬁle system due to a permission or conﬁguration 
issue.
HTTP Status Code: 403
EFSMountTimeoutException
The Lambda function made a network connection to the conﬁgured ﬁle system, but the mount 
operation timed out.
HTTP Status Code: 408
ENILimitReachedException
AWS Lambda couldn't create an elastic network interface in the VPC, speciﬁed as part of Lambda 
function conﬁguration, because the limit for network interfaces has been reached. For more 
information, see Lambda quotas .
HTTP Status Code: 502
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
InvalidRequestContentException
The request body could not be parsed as JSON.
HTTP Status Code: 400
InvalidRuntimeException
The runtime or runtime version speciﬁed is not supported.
HTTP Status Code: 502
InvalidSecurityGroupIDException
The security group ID provided in the Lambda function VPC conﬁguration is not valid.
HTTP Status Code: 502
InvalidSubnetIDException
The subnet ID provided in the Lambda function VPC conﬁguration is not valid.
HTTP Status Code: 502
InvalidZipFileException
AWS Lambda could not unzip the deployment package.
1402AWS Lambda Developer Guide
Invoke
HTTP Status Code: 502
KMSAccessDeniedException
Lambda couldn't decrypt the environment variables because AWS KMS access was denied. Check the 
Lambda function's KMS permissions.
HTTP Status Code: 502
KMSDisabledException
Lambda couldn't decrypt the environment variables because the AWS KMS key used is disabled. 
Check the Lambda function's KMS key settings.
HTTP Status Code: 502
KMSInvalidStateException
Lambda couldn't decrypt the environment variables because the state of the AWS KMS key used is 
not valid for Decrypt. Check the function's KMS key settings.
HTTP Status Code: 502
KMSNotFoundException
Lambda couldn't decrypt the environment variables because the AWS KMS key was not found. Check 
the function's KMS key settings.
HTTP Status Code: 502
RecursiveInvocationException
Lambda has detected your function being invoked in a recursive loop with other AWS resources and 
stopped your function's invocation.
HTTP Status Code: 400
RequestTooLargeException
The request payload exceeded the Invoke request body JSON input quota. For more information, 
see Lambda quotas .
HTTP Status Code: 413
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ResourceNotReadyException
The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to 
reestablish and try again.
HTTP Status Code: 502
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
1403AWS Lambda Developer Guide
Invoke
SnapStartException
The afterRestore()  runtime hook  encountered an error. For more information, check the Amazon 
CloudWatch logs.
HTTP Status Code: 400
SnapStartNotReadyException
Lambda is initializing your function. You can invoke the function when the function state becomes
Active .
HTTP Status Code: 409
SnapStartTimeoutException
Lambda couldn't restore the snapshot within the timeout limit.
HTTP Status Code: 408
SubnetIPAddressLimitReachedException
AWS Lambda couldn't set up VPC access for the Lambda function because one or more conﬁgured 
subnets has no available IP addresses.
HTTP Status Code: 502
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
UnsupportedMediaTypeException
The content type of the Invoke request body is not JSON.
HTTP Status Code: 415
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1404AWS Lambda Developer Guide
InvokeAsync
InvokeAsync
This action has been deprecated.
Important
For asynchronous function invocation, use Invoke (p. 1399 ).
Invokes a function asynchronously.
Request Syntax
POST /2014-11-13/functions/ FunctionName /invoke-async/ HTTP/1.1
InvokeArgs
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1405 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following binary data.
InvokeArgs (p. 1405 )
The JSON that you want to provide to your Lambda function as input.
Required: Yes
Response Syntax
HTTP/1.1 Status
Response Elements
If the action is successful, the service sends back the following HTTP response.
1405AWS Lambda Developer Guide
InvokeAsync
Status  (p. 1405 )
The status code.
Errors
InvalidRequestContentException
The request body could not be parsed as JSON.
HTTP Status Code: 400
InvalidRuntimeException
The runtime or runtime version speciﬁed is not supported.
HTTP Status Code: 502
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1406AWS Lambda Developer Guide
InvokeWithResponseStream
InvokeWithResponseStream
Conﬁgure your Lambda functions to stream response payloads back to clients. For more information, see
Conﬁguring a Lambda function to stream responses.
This operation requires permission for the lambda:InvokeFunction action. For details on how to set up 
permissions for cross-account invocations, see Granting function access to other accounts.
Request Syntax
POST /2021-11-15/functions/ FunctionName /response-streaming-invocations?Qualifier= Qualifier
 HTTP/1.1
X-Amz-Invocation-Type: InvocationType
X-Amz-Log-Type: LogType
X-Amz-Client-Context: ClientContext
Payload
URI Request Parameters
The request uses the following URI parameters.
ClientContext (p. 1407 )
Up to 3,583 bytes of base64-encoded data about the invoking client to pass to the function in the 
context object.
FunctionName (p. 1407 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
InvocationType (p. 1407 )
Use one of the following options:
•RequestResponse  (default) – Invoke the function synchronously. Keep the connection open until 
the function returns a response or times out. The API operation response includes the function 
response and additional data.
•DryRun – Validate parameter values and verify that the IAM user or role has permission to invoke 
the function.
Valid Values: RequestResponse | DryRun
1407AWS Lambda Developer Guide
InvokeWithResponseStream
LogType (p. 1407 )
Set to Tail to include the execution log in the response. Applies to synchronously invoked functions 
only.
Valid Values: None | Tail
Qualiﬁer  (p. 1407 )
The alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following binary data.
Payload (p. 1407 )
The JSON that you want to provide to your Lambda function as input.
You can enter the JSON directly. For example, --payload '{ "key": "value" }' . You can also 
specify a ﬁle path. For example, --payload file://payload.json .
Response Syntax
HTTP/1.1 StatusCode
X-Amz-Executed-Version: ExecutedVersion
Content-Type: ResponseStreamContentType
Content-type: application/json
{ 
   "InvokeComplete ": {  
      "ErrorCode ": "string", 
      "ErrorDetails ": "string", 
      "LogResult ": "string" 
   }, 
   "PayloadChunk ": {  
      "Payload": blob
   }
}
Response Elements
If the action is successful, the service sends back the following HTTP response.
StatusCode  (p. 1408 )
For a successful request, the HTTP status code is in the 200 range. For the RequestResponse
invocation type, this status code is 200. For the DryRun invocation type, this status code is 204.
The response returns the following HTTP headers.
ExecutedVersion (p. 1408 )
The version of the function that executed. When you invoke a function with an alias, this indicates 
which version the alias resolved to.
1408AWS Lambda Developer Guide
InvokeWithResponseStream
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
ResponseStreamContentType (p. 1408 )
The type of data the stream is returning.
The following data is returned in JSON format by the service.
InvokeComplete (p. 1408 )
An object that's returned when the stream has ended and all the payload chunks have been 
returned.
Type: InvokeWithResponseStreamCompleteEvent (p. 1583 ) object
PayloadChunk (p. 1408 )
A chunk of the streamed response payload.
Type: InvokeResponseStreamUpdate (p. 1582 ) object
Errors
EC2AccessDeniedException
Need additional permissions to conﬁgure VPC settings.
HTTP Status Code: 502
EC2ThrottledException
Amazon EC2 throttled AWS Lambda during Lambda function initialization using the execution role 
provided for the function.
HTTP Status Code: 502
EC2UnexpectedException
AWS Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda 
function.
HTTP Status Code: 502
EFSIOException
An error occurred when reading from or writing to a connected ﬁle system.
HTTP Status Code: 410
EFSMountConnectivityException
The Lambda function couldn't make a network connection to the conﬁgured ﬁle system.
HTTP Status Code: 408
EFSMountFailureException
The Lambda function couldn't mount the conﬁgured ﬁle system due to a permission or conﬁguration 
issue.
HTTP Status Code: 403
1409AWS Lambda Developer Guide
InvokeWithResponseStream
EFSMountTimeoutException
The Lambda function made a network connection to the conﬁgured ﬁle system, but the mount 
operation timed out.
HTTP Status Code: 408
ENILimitReachedException
AWS Lambda couldn't create an elastic network interface in the VPC, speciﬁed as part of Lambda 
function conﬁguration, because the limit for network interfaces has been reached. For more 
information, see Lambda quotas .
HTTP Status Code: 502
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
InvalidRequestContentException
The request body could not be parsed as JSON.
HTTP Status Code: 400
InvalidRuntimeException
The runtime or runtime version speciﬁed is not supported.
HTTP Status Code: 502
InvalidSecurityGroupIDException
The security group ID provided in the Lambda function VPC conﬁguration is not valid.
HTTP Status Code: 502
InvalidSubnetIDException
The subnet ID provided in the Lambda function VPC conﬁguration is not valid.
HTTP Status Code: 502
InvalidZipFileException
AWS Lambda could not unzip the deployment package.
HTTP Status Code: 502
KMSAccessDeniedException
Lambda couldn't decrypt the environment variables because AWS KMS access was denied. Check the 
Lambda function's KMS permissions.
HTTP Status Code: 502
KMSDisabledException
Lambda couldn't decrypt the environment variables because the AWS KMS key used is disabled. 
Check the Lambda function's KMS key settings.
HTTP Status Code: 502
KMSInvalidStateException
Lambda couldn't decrypt the environment variables because the state of the AWS KMS key used is 
not valid for Decrypt. Check the function's KMS key settings.
1410AWS Lambda Developer Guide
InvokeWithResponseStream
HTTP Status Code: 502
KMSNotFoundException
Lambda couldn't decrypt the environment variables because the AWS KMS key was not found. Check 
the function's KMS key settings.
HTTP Status Code: 502
RecursiveInvocationException
Lambda has detected your function being invoked in a recursive loop with other AWS resources and 
stopped your function's invocation.
HTTP Status Code: 400
RequestTooLargeException
The request payload exceeded the Invoke request body JSON input quota. For more information, 
see Lambda quotas .
HTTP Status Code: 413
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ResourceNotReadyException
The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to 
reestablish and try again.
HTTP Status Code: 502
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
SnapStartException
The afterRestore()  runtime hook  encountered an error. For more information, check the Amazon 
CloudWatch logs.
HTTP Status Code: 400
SnapStartNotReadyException
Lambda is initializing your function. You can invoke the function when the function state becomes
Active .
HTTP Status Code: 409
SnapStartTimeoutException
Lambda couldn't restore the snapshot within the timeout limit.
HTTP Status Code: 408
1411AWS Lambda Developer Guide
InvokeWithResponseStream
SubnetIPAddressLimitReachedException
AWS Lambda couldn't set up VPC access for the Lambda function because one or more conﬁgured 
subnets has no available IP addresses.
HTTP Status Code: 502
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
UnsupportedMediaTypeException
The content type of the Invoke request body is not JSON.
HTTP Status Code: 415
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1412AWS Lambda Developer Guide
ListAliases
ListAliases
Returns a list of aliases  for a Lambda function.
Request Syntax
GET /2015-03-31/functions/ FunctionName /aliases?
FunctionVersion= FunctionVersion &Marker= Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1413 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
FunctionVersion (p. 1413 )
Specify a function version to only list aliases that invoke that version.
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Marker (p. 1413 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1413 )
Limit the number of aliases returned.
Valid Range: Minimum value of 1. Maximum value of 10000.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
1413AWS Lambda Developer Guide
ListAliases
Content-type: application/json
{ 
   "Aliases": [  
      {  
         " AliasArn ": "string", 
         " Description ": "string", 
         " FunctionVersion ": "string", 
         " Name": "string", 
         " RevisionId ": "string", 
         " RoutingConfig ": {  
            " AdditionalVersionWeights ": {  
               " string" : number 
            } 
         } 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Aliases  (p. 1413 )
A list of aliases.
Type: Array of AliasConﬁguration  (p. 1540 ) objects
NextMarker (p. 1413 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
1414AWS Lambda Developer Guide
ListAliases
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1415AWS Lambda Developer Guide
ListCodeSigningConﬁgs
ListCodeSigningConﬁgs
Returns a list of code signing conﬁgurations. A request returns up to 10,000 conﬁgurations per call. You 
can use the MaxItems  parameter to return fewer conﬁgurations per call.
Request Syntax
GET /2020-04-22/code-signing-configs/?Marker= Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
Marker (p. 1416 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1416 )
Maximum number of items to return.
Valid Range: Minimum value of 1. Maximum value of 10000.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CodeSigningConfigs ": [  
      {  
         " AllowedPublishers ": {  
            " SigningProfileVersionArns ": [ "string" ] 
         }, 
         " CodeSigningConfigArn ": "string", 
         " CodeSigningConfigId ": "string", 
         " CodeSigningPolicies ": {  
            " UntrustedArtifactOnDeployment ": "string" 
         }, 
         " Description ": "string", 
         " LastModified ": "string" 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
1416AWS Lambda Developer Guide
ListCodeSigningConﬁgs
CodeSigningConﬁgs  (p. 1416 )
The code signing conﬁgurations
Type: Array of CodeSigningConﬁg  (p. 1545 ) objects
NextMarker (p. 1416 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1417AWS Lambda Developer Guide
ListEventSourceMappings
ListEventSourceMappings
Lists event source mappings. Specify an EventSourceArn  to show only event source mappings for a 
single event source.
Request Syntax
GET /2015-03-31/event-source-mappings/?
EventSourceArn= EventSourceArn &FunctionName= FunctionName &Marker= Marker&MaxItems= MaxItems
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
EventSourceArn (p. 1418 )
The Amazon Resource Name (ARN) of the event source.
•Amazon Kinesis – The ARN of the data stream or a stream consumer.
•Amazon DynamoDB Streams – The ARN of the stream.
•Amazon Simple Queue Service – The ARN of the queue.
•Amazon Managed Streaming for Apache Kafka – The ARN of the cluster.
•Amazon MQ – The ARN of the broker.
•Amazon DocumentDB – The ARN of the DocumentDB change stream.
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
FunctionName (p. 1418 )
The name of the Lambda function.
Name formats
•Function name – MyFunction .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Version or Alias ARN – arn:aws:lambda:us-
west-2:123456789012:function:MyFunction:PROD .
•Partial ARN – 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it's limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Marker (p. 1418 )
A pagination token returned by a previous call.
MaxItems  (p. 1418 )
The maximum number of event source mappings to return. Note that ListEventSourceMappings 
returns a maximum of 100 items in each response, even if you set the number higher.
Valid Range: Minimum value of 1. Maximum value of 10000.
1418AWS Lambda Developer Guide
ListEventSourceMappings
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "EventSourceMappings ": [  
      {  
         " AmazonManagedKafkaEventSourceConfig ": {  
            " ConsumerGroupId ": "string" 
         }, 
         " BatchSize ": number, 
         " BisectBatchOnFunctionError ": boolean, 
         " DestinationConfig ": {  
            " OnFailure ": {  
               " Destination ": "string" 
            }, 
            " OnSuccess ": {  
               " Destination ": "string" 
            } 
         }, 
         " DocumentDBEventSourceConfig ": {  
            " CollectionName ": "string", 
            " DatabaseName ": "string", 
            " FullDocument ": "string" 
         }, 
         " EventSourceArn ": "string", 
         " FilterCriteria ": {  
            " Filters": [  
               {  
                  " Pattern": "string" 
               } 
            ] 
         }, 
         " FunctionArn ": "string", 
         " FunctionResponseTypes ": [ "string" ], 
         " LastModified ": number, 
         " LastProcessingResult ": "string", 
         " MaximumBatchingWindowInSeconds ": number, 
         " MaximumRecordAgeInSeconds ": number, 
         " MaximumRetryAttempts ": number, 
         " ParallelizationFactor ": number, 
         " Queues": [ "string" ], 
         " ScalingConfig ": {  
            " MaximumConcurrency ": number
         }, 
         " SelfManagedEventSource ": {  
            " Endpoints ": {  
               " string" : [ "string" ] 
            } 
         }, 
         " SelfManagedKafkaEventSourceConfig ": {  
            " ConsumerGroupId ": "string" 
         }, 
         " SourceAccessConfigurations ": [  
            {  
               " Type": "string", 
               " URI": "string" 
            } 
         ], 
1419AWS Lambda Developer Guide
ListEventSourceMappings
         " StartingPosition ": "string", 
         " StartingPositionTimestamp ": number, 
         " State": "string", 
         " StateTransitionReason ": "string", 
         " Topics": [ "string" ], 
         " TumblingWindowInSeconds ": number, 
         " UUID": "string" 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
EventSourceMappings (p. 1419 )
A list of event source mappings.
Type: Array of EventSourceMappingConﬁguration (p. 1558 ) objects
NextMarker (p. 1419 )
A pagination token that's returned when the response doesn't contain all event source mappings.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
1420AWS Lambda Developer Guide
ListEventSourceMappings
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1421AWS Lambda Developer Guide
ListFunctionEventInvokeConﬁgs
ListFunctionEventInvokeConﬁgs
Retrieves a list of conﬁgurations for asynchronous invocation for a function.
To conﬁgure options for asynchronous invocation, use PutFunctionEventInvokeConﬁg (p. 1469 ).
Request Syntax
GET /2019-09-25/functions/ FunctionName /event-invoke-config/list?
Marker=Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1422 )
The name of the Lambda function.
Name formats
•Function name - my-function .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN - 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Marker (p. 1422 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1422 )
The maximum number of conﬁgurations to return.
Valid Range: Minimum value of 1. Maximum value of 50.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
1422AWS Lambda Developer Guide
ListFunctionEventInvokeConﬁgs
   "FunctionEventInvokeConfigs ": [  
      {  
         " DestinationConfig ": {  
            " OnFailure ": {  
               " Destination ": "string" 
            }, 
            " OnSuccess ": {  
               " Destination ": "string" 
            } 
         }, 
         " FunctionArn ": "string", 
         " LastModified ": number, 
         " MaximumEventAgeInSeconds ": number, 
         " MaximumRetryAttempts ": number
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
FunctionEventInvokeConﬁgs (p. 1422 )
A list of conﬁgurations.
Type: Array of FunctionEventInvokeConﬁg (p. 1575 ) objects
NextMarker (p. 1422 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
1423AWS Lambda Developer Guide
ListFunctionEventInvokeConﬁgs
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1424AWS Lambda Developer Guide
ListFunctions
ListFunctions
Returns a list of Lambda functions, with the version-speciﬁc conﬁguration of each. Lambda returns up to 
50 functions per call.
Set FunctionVersion  to ALL to include all published versions of each function in addition to the 
unpublished version.
Note
The ListFunctions  operation returns a subset of the FunctionConﬁguration (p. 1569 )
ﬁelds. To get the additional ﬁelds (State, StateReasonCode, StateReason, LastUpdateStatus, 
LastUpdateStatusReason, LastUpdateStatusReasonCode, RuntimeVersionConﬁg) for a function 
or version, use GetFunction (p. 1359 ).
Request Syntax
GET /2015-03-31/functions/?
FunctionVersion= FunctionVersion &Marker= Marker&MasterRegion= MasterRegion &MaxItems= MaxItems
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionVersion (p. 1425 )
Set to ALL to include entries for all published versions of each function.
Valid Values: ALL
Marker (p. 1425 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MasterRegion (p. 1425 )
For Lambda@Edge functions, the AWS Region of the master function. For example, us-east-1
ﬁlters the list of functions to include only Lambda@Edge functions replicated from a master 
function in US East (N. Virginia). If speciﬁed, you must set FunctionVersion  to ALL.
Pattern: ALL|[a-z]{2}(-gov)?-[a-z]+-\d{1}
MaxItems  (p. 1425 )
The maximum number of functions to return in the response. Note that ListFunctions  returns a 
maximum of 50 items in each response, even if you set the number higher.
Valid Range: Minimum value of 1. Maximum value of 10000.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
1425AWS Lambda Developer Guide
ListFunctions
Content-type: application/json
{ 
   "Functions ": [  
      {  
         " Architectures ": [ "string" ], 
         " CodeSha256 ": "string", 
         " CodeSize ": number, 
         " DeadLetterConfig ": {  
            " TargetArn ": "string" 
         }, 
         " Description ": "string", 
         " Environment ": {  
            " Error": {  
               " ErrorCode ": "string", 
               " Message": "string" 
            }, 
            " Variables ": {  
               " string" : "string"  
            } 
         }, 
         " EphemeralStorage ": {  
            " Size": number
         }, 
         " FileSystemConfigs ": [  
            {  
               " Arn": "string", 
               " LocalMountPath ": "string" 
            } 
         ], 
         " FunctionArn ": "string", 
         " FunctionName ": "string", 
         " Handler": "string", 
         " ImageConfigResponse ": {  
            " Error": {  
               " ErrorCode ": "string", 
               " Message": "string" 
            }, 
            " ImageConfig ": {  
               " Command": [ "string" ], 
               " EntryPoint ": [ "string" ], 
               " WorkingDirectory ": "string" 
            } 
         }, 
         " KMSKeyArn ": "string", 
         " LastModified ": "string", 
         " LastUpdateStatus ": "string", 
         " LastUpdateStatusReason ": "string", 
         " LastUpdateStatusReasonCode ": "string", 
         " Layers": [  
            {  
               " Arn": "string", 
               " CodeSize ": number, 
               " SigningJobArn ": "string", 
               " SigningProfileVersionArn ": "string" 
            } 
         ], 
         " MasterArn ": "string", 
         " MemorySize ": number, 
         " PackageType ": "string", 
         " RevisionId ": "string", 
         " Role": "string", 
         " Runtime": "string", 
         " RuntimeVersionConfig ": {  
            " Error": {  
               " ErrorCode ": "string", 
1426AWS Lambda Developer Guide
ListFunctions
               " Message": "string" 
            }, 
            " RuntimeVersionArn ": "string" 
         }, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string", 
         " SnapStart ": {  
            " ApplyOn": "string", 
            " OptimizationStatus ": "string" 
         }, 
         " State": "string", 
         " StateReason ": "string", 
         " StateReasonCode ": "string", 
         " Timeout": number, 
         " TracingConfig ": {  
            " Mode": "string" 
         }, 
         " Version": "string", 
         " VpcConfig ": {  
            " SecurityGroupIds ": [ "string" ], 
            " SubnetIds ": [ "string" ], 
            " VpcId": "string" 
         } 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Functions (p. 1425 )
A list of Lambda functions.
Type: Array of FunctionConﬁguration (p. 1569 ) objects
NextMarker (p. 1425 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1427AWS Lambda Developer Guide
ListFunctions
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1428AWS Lambda Developer Guide
ListFunctionsByCodeSigningConﬁg
ListFunctionsByCodeSigningConﬁg
List the functions that use the speciﬁed code signing conﬁguration. You can use this method prior to 
deleting a code signing conﬁguration, to verify that no functions are using it.
Request Syntax
GET /2020-04-22/code-signing-configs/ CodeSigningConfigArn /functions?
Marker=Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
CodeSigningConﬁgArn  (p. 1429 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
Marker (p. 1429 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1429 )
Maximum number of items to return.
Valid Range: Minimum value of 1. Maximum value of 10000.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "FunctionArns ": [ "string" ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
1429AWS Lambda Developer Guide
ListFunctionsByCodeSigningConﬁg
FunctionArns (p. 1429 )
The function ARNs.
Type: Array of strings
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
NextMarker (p. 1429 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1430AWS Lambda Developer Guide
ListFunctionUrlConﬁgs
ListFunctionUrlConﬁgs
Returns a list of Lambda function URLs for the speciﬁed function.
Request Syntax
GET /2021-10-31/functions/ FunctionName /urls?Marker= Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1431 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Marker (p. 1431 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1431 )
The maximum number of function URLs to return in the response. Note that
ListFunctionUrlConfigs  returns a maximum of 50 items in each response, even if you set the 
number higher.
Valid Range: Minimum value of 1. Maximum value of 50.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "FunctionUrlConfigs ": [  
1431AWS Lambda Developer Guide
ListFunctionUrlConﬁgs
      {  
         " AuthType ": "string", 
         " Cors": {  
            " AllowCredentials ": boolean, 
            " AllowHeaders ": [ "string" ], 
            " AllowMethods ": [ "string" ], 
            " AllowOrigins ": [ "string" ], 
            " ExposeHeaders ": [ "string" ], 
            " MaxAge": number
         }, 
         " CreationTime ": "string", 
         " FunctionArn ": "string", 
         " FunctionUrl ": "string", 
         " InvokeMode ": "string", 
         " LastModifiedTime ": "string" 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
FunctionUrlConﬁgs (p. 1431 )
A list of function URL conﬁgurations.
Type: Array of FunctionUrlConﬁg (p. 1577 ) objects
NextMarker (p. 1431 )
The pagination token that's included if more results are available.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
1432AWS Lambda Developer Guide
ListFunctionUrlConﬁgs
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1433AWS Lambda Developer Guide
ListLayers
ListLayers
Lists AWS Lambda layers and shows information about the latest version of each. Specify a runtime 
identiﬁer  to list only layers that indicate that they're compatible with that runtime. Specify a compatible 
architecture to include only layers that are compatible with that instruction set architecture.
Request Syntax
GET /2018-10-31/layers?
CompatibleArchitecture= CompatibleArchitecture &CompatibleRuntime= CompatibleRuntime &Marker= Marker&MaxItems= MaxItems
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
CompatibleArchitecture (p. 1434 )
The compatible instruction set architecture.
Valid Values: x86_64 | arm64
CompatibleRuntime (p. 1434 )
A runtime identiﬁer. For example, go1.x .
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Marker (p. 1434 )
A pagination token returned by a previous call.
MaxItems  (p. 1434 )
The maximum number of layers to return.
Valid Range: Minimum value of 1. Maximum value of 50.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Layers": [  
      {  
1434AWS Lambda Developer Guide
ListLayers
         " LatestMatchingVersion ": {  
            " CompatibleArchitectures ": [ "string" ], 
            " CompatibleRuntimes ": [ "string" ], 
            " CreatedDate ": "string", 
            " Description ": "string", 
            " LayerVersionArn ": "string", 
            " LicenseInfo ": "string", 
            " Version": number
         }, 
         " LayerArn ": "string", 
         " LayerName ": "string" 
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Layers (p. 1434 )
A list of function layers.
Type: Array of LayersListItem (p. 1586 ) objects
NextMarker (p. 1434 )
A pagination token returned when the response doesn't contain all layers.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
1435AWS Lambda Developer Guide
ListLayers
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1436AWS Lambda Developer Guide
ListLayerVersions
ListLayerVersions
Lists the versions of an AWS Lambda layer. Versions that have been deleted aren't listed. Specify a
runtime identiﬁer  to list only versions that indicate that they're compatible with that runtime. Specify a 
compatible architecture to include only layer versions that are compatible with that architecture.
Request Syntax
GET /2018-10-31/layers/ LayerName /versions?
CompatibleArchitecture= CompatibleArchitecture &CompatibleRuntime= CompatibleRuntime &Marker= Marker&MaxItems= MaxItems
 HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
CompatibleArchitecture (p. 1437 )
The compatible instruction set architecture.
Valid Values: x86_64 | arm64
CompatibleRuntime (p. 1437 )
A runtime identiﬁer. For example, go1.x .
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
LayerName (p. 1437 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
Marker (p. 1437 )
A pagination token returned by a previous call.
MaxItems  (p. 1437 )
The maximum number of versions to return.
Valid Range: Minimum value of 1. Maximum value of 50.
Request Body
The request does not have a request body.
1437AWS Lambda Developer Guide
ListLayerVersions
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "LayerVersions ": [  
      {  
         " CompatibleArchitectures ": [ "string" ], 
         " CompatibleRuntimes ": [ "string" ], 
         " CreatedDate ": "string", 
         " Description ": "string", 
         " LayerVersionArn ": "string", 
         " LicenseInfo ": "string", 
         " Version": number
      } 
   ], 
   "NextMarker ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
LayerVersions (p. 1438 )
A list of versions.
Type: Array of LayerVersionsListItem (p. 1589 ) objects
NextMarker (p. 1438 )
A pagination token returned when the response doesn't contain all versions.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1438AWS Lambda Developer Guide
ListLayerVersions
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1439AWS Lambda Developer Guide
ListProvisionedConcurrencyConﬁgs
ListProvisionedConcurrencyConﬁgs
Retrieves a list of provisioned concurrency conﬁgurations for a function.
Request Syntax
GET /2019-09-30/functions/ FunctionName /provisioned-concurrency?
List=ALL&Marker= Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1440 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Marker (p. 1440 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1440 )
Specify a number to limit the number of conﬁgurations returned.
Valid Range: Minimum value of 1. Maximum value of 50.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "NextMarker ": "string", 
   "ProvisionedConcurrencyConfigs ": [  
      {  
1440AWS Lambda Developer Guide
ListProvisionedConcurrencyConﬁgs
         " AllocatedProvisionedConcurrentExecutions ": number, 
         " AvailableProvisionedConcurrentExecutions ": number, 
         " FunctionArn ": "string", 
         " LastModified ": "string", 
         " RequestedProvisionedConcurrentExecutions ": number, 
         " Status": "string", 
         " StatusReason ": "string" 
      } 
   ]
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
NextMarker (p. 1440 )
The pagination token that's included if more results are available.
Type: String
ProvisionedConcurrencyConﬁgs (p. 1440 )
A list of provisioned concurrency conﬁgurations.
Type: Array of ProvisionedConcurrencyConﬁgListItem (p. 1593 ) objects
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
1441AWS Lambda Developer Guide
ListProvisionedConcurrencyConﬁgs
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1442AWS Lambda Developer Guide
ListTags
ListTags
Returns a function's tags. You can also view tags with GetFunction (p. 1359 ).
Request Syntax
GET /2017-03-31/tags/ ARN HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
ARN  (p. 1443 )
The function's Amazon Resource Name (ARN). Note: Lambda does not support adding tags to aliases 
or versions.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Tags": {  
      "string" : "string"  
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Tags (p. 1443 )
The function's tags.
Type: String to string map
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
1443AWS Lambda Developer Guide
ListTags
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1444AWS Lambda Developer Guide
ListVersionsByFunction
ListVersionsByFunction
Returns a list of versions, with the version-speciﬁc conﬁguration of each. Lambda returns up to 50 
versions per call.
Request Syntax
GET /2015-03-31/functions/ FunctionName /versions?Marker= Marker&MaxItems= MaxItems  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1445 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Marker (p. 1445 )
Specify the pagination token that's returned by a previous request to retrieve the next page of 
results.
MaxItems  (p. 1445 )
The maximum number of versions to return. Note that ListVersionsByFunction  returns a 
maximum of 50 items in each response, even if you set the number higher.
Valid Range: Minimum value of 1. Maximum value of 10000.
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "NextMarker ": "string", 
   "Versions ": [  
1445AWS Lambda Developer Guide
ListVersionsByFunction
      {  
         " Architectures ": [ "string" ], 
         " CodeSha256 ": "string", 
         " CodeSize ": number, 
         " DeadLetterConfig ": {  
            " TargetArn ": "string" 
         }, 
         " Description ": "string", 
         " Environment ": {  
            " Error": {  
               " ErrorCode ": "string", 
               " Message": "string" 
            }, 
            " Variables ": {  
               " string" : "string"  
            } 
         }, 
         " EphemeralStorage ": {  
            " Size": number
         }, 
         " FileSystemConfigs ": [  
            {  
               " Arn": "string", 
               " LocalMountPath ": "string" 
            } 
         ], 
         " FunctionArn ": "string", 
         " FunctionName ": "string", 
         " Handler": "string", 
         " ImageConfigResponse ": {  
            " Error": {  
               " ErrorCode ": "string", 
               " Message": "string" 
            }, 
            " ImageConfig ": {  
               " Command": [ "string" ], 
               " EntryPoint ": [ "string" ], 
               " WorkingDirectory ": "string" 
            } 
         }, 
         " KMSKeyArn ": "string", 
         " LastModified ": "string", 
         " LastUpdateStatus ": "string", 
         " LastUpdateStatusReason ": "string", 
         " LastUpdateStatusReasonCode ": "string", 
         " Layers": [  
            {  
               " Arn": "string", 
               " CodeSize ": number, 
               " SigningJobArn ": "string", 
               " SigningProfileVersionArn ": "string" 
            } 
         ], 
         " MasterArn ": "string", 
         " MemorySize ": number, 
         " PackageType ": "string", 
         " RevisionId ": "string", 
         " Role": "string", 
         " Runtime": "string", 
         " RuntimeVersionConfig ": {  
            " Error": {  
               " ErrorCode ": "string", 
               " Message": "string" 
            }, 
            " RuntimeVersionArn ": "string" 
         }, 
1446AWS Lambda Developer Guide
ListVersionsByFunction
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string", 
         " SnapStart ": {  
            " ApplyOn": "string", 
            " OptimizationStatus ": "string" 
         }, 
         " State": "string", 
         " StateReason ": "string", 
         " StateReasonCode ": "string", 
         " Timeout": number, 
         " TracingConfig ": {  
            " Mode": "string" 
         }, 
         " Version": "string", 
         " VpcConfig ": {  
            " SecurityGroupIds ": [ "string" ], 
            " SubnetIds ": [ "string" ], 
            " VpcId": "string" 
         } 
      } 
   ]
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
NextMarker (p. 1445 )
The pagination token that's included if more results are available.
Type: String
Versions (p. 1445 )
A list of Lambda function versions.
Type: Array of FunctionConﬁguration (p. 1569 ) objects
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1447AWS Lambda Developer Guide
ListVersionsByFunction
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1448AWS Lambda Developer Guide
PublishLayerVersion
PublishLayerVersion
Creates an AWS Lambda layer from a ZIP archive. Each time you call PublishLayerVersion  with the 
same layer name, a new version is created.
Add layers to your function with CreateFunction (p. 1304 ) or UpdateFunctionConﬁguration (p. 1516 ).
Request Syntax
POST /2018-10-31/layers/ LayerName /versions HTTP/1.1
Content-type: application/json
{ 
   "CompatibleArchitectures ": [ "string" ], 
   "CompatibleRuntimes ": [ "string" ], 
   "Content": {  
      "S3Bucket ": "string", 
      "S3Key": "string", 
      "S3ObjectVersion ": "string", 
      "ZipFile": blob
   }, 
   "Description ": "string", 
   "LicenseInfo ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1449 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
Request Body
The request accepts the following data in JSON format.
CompatibleArchitectures (p. 1449 )
A list of compatible instruction set architectures.
Type: Array of strings
Array Members: Maximum number of 2 items.
Valid Values: x86_64 | arm64
Required: No
CompatibleRuntimes (p. 1449 )
A list of compatible function runtimes. Used for ﬁltering with ListLayers (p. 1434 ) and
ListLayerVersions (p. 1437 ).
1449AWS Lambda Developer Guide
PublishLayerVersion
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: Array of strings
Array Members: Maximum number of 15 items.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Required: No
Content  (p. 1449 )
The function layer archive.
Type: LayerVersionContentInput (p. 1587 ) object
Required: Yes
Description  (p. 1449 )
The description of the version.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
LicenseInfo (p. 1449 )
The layer's software license. It can be any of the following:
•An SPDX license identiﬁer. For example, MIT.
•The URL of a license hosted on the internet. For example, https://opensource.org/
licenses/MIT .
•The full text of the license.
Type: String
Length Constraints: Maximum length of 512.
Required: No
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "CompatibleArchitectures ": [ "string" ], 
   "CompatibleRuntimes ": [ "string" ], 
   "Content": {  
      "CodeSha256 ": "string", 
      "CodeSize ": number, 
      "Location ": "string", 
      "SigningJobArn ": "string", 
1450AWS Lambda Developer Guide
PublishLayerVersion
      "SigningProfileVersionArn ": "string" 
   }, 
   "CreatedDate ": "string", 
   "Description ": "string", 
   "LayerArn ": "string", 
   "LayerVersionArn ": "string", 
   "LicenseInfo ": "string", 
   "Version": number
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
CompatibleArchitectures (p. 1450 )
A list of compatible instruction set architectures.
Type: Array of strings
Array Members: Maximum number of 2 items.
Valid Values: x86_64 | arm64
CompatibleRuntimes (p. 1450 )
The layer's compatible runtimes.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: Array of strings
Array Members: Maximum number of 15 items.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Content  (p. 1450 )
Details about the layer version.
Type: LayerVersionContentOutput (p. 1588 ) object
CreatedDate  (p. 1450 )
The date that the layer version was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
Description  (p. 1450 )
The description of the version.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
1451AWS Lambda Developer Guide
PublishLayerVersion
LayerArn (p. 1450 )
The ARN of the layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+
LayerVersionArn (p. 1450 )
The ARN of the layer version.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
LicenseInfo (p. 1450 )
The layer's software license.
Type: String
Length Constraints: Maximum length of 512.
Version (p. 1450 )
The version number.
Type: Long
Errors
CodeStorageExceededException
Your AWS account has exceeded its maximum total code size. For more information, see Lambda 
quotas .
HTTP Status Code: 400
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1452AWS Lambda Developer Guide
PublishLayerVersion
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1453AWS Lambda Developer Guide
PublishVersion
PublishVersion
Creates a version from the current code and conﬁguration of a function. Use versions to create a 
snapshot of your function code and conﬁguration that doesn't change.
AWS Lambda doesn't publish a version if the function's conﬁguration and code haven't changed since the 
last version. Use UpdateFunctionCode (p. 1506 ) or UpdateFunctionConﬁguration (p. 1516 ) to update 
the function before publishing a version.
Clients can invoke versions directly or with an alias. To create an alias, use CreateAlias (p. 1285 ).
Request Syntax
POST /2015-03-31/functions/ FunctionName /versions HTTP/1.1
Content-type: application/json
{ 
   "CodeSha256 ": "string", 
   "Description ": "string", 
   "RevisionId ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1454 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
CodeSha256  (p. 1454 )
Only publish a version if the hash value matches the value that's speciﬁed. Use this option to avoid 
publishing a version if the function code has changed since you last updated it. You can get the hash 
for the version that you uploaded from the output of UpdateFunctionCode (p. 1506 ).
Type: String
1454AWS Lambda Developer Guide
PublishVersion
Required: No
Description  (p. 1454 )
A description for the version to override the description in the function conﬁguration.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
RevisionId (p. 1454 )
Only update the function if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
publishing a version if the function conﬁguration has changed since you last updated it.
Type: String
Required: No
Response Syntax
HTTP/1.1 201
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "CodeSha256 ": "string", 
   "CodeSize ": number, 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionArn ": "string", 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfigResponse ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "ImageConfig ": {  
         " Command": [ "string" ], 
         " EntryPoint ": [ "string" ], 
1455AWS Lambda Developer Guide
PublishVersion
         " WorkingDirectory ": "string" 
      } 
   }, 
   "KMSKeyArn ": "string", 
   "LastModified ": "string", 
   "LastUpdateStatus ": "string", 
   "LastUpdateStatusReason ": "string", 
   "LastUpdateStatusReasonCode ": "string", 
   "Layers": [  
      {  
         " Arn": "string", 
         " CodeSize ": number, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string" 
      } 
   ], 
   "MasterArn ": "string", 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "RuntimeVersionConfig ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "RuntimeVersionArn ": "string" 
   }, 
   "SigningJobArn ": "string", 
   "SigningProfileVersionArn ": "string", 
   "SnapStart ": {  
      "ApplyOn": "string", 
      "OptimizationStatus ": "string" 
   }, 
   "State": "string", 
   "StateReason ": "string", 
   "StateReasonCode ": "string", 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "Version": "string", 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ], 
      "VpcId": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 201 response.
The following data is returned in JSON format by the service.
Architectures (p. 1455 )
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
1456AWS Lambda Developer Guide
PublishVersion
Valid Values: x86_64 | arm64
CodeSha256  (p. 1455 )
The SHA256 hash of the function's deployment package.
Type: String
CodeSize (p. 1455 )
The size of the function's deployment package, in bytes.
Type: Long
DeadLetterConﬁg (p. 1455 )
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Description  (p. 1455 )
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Environment (p. 1455 )
The function's environment variables. Omitted from AWS CloudTrail logs.
Type: EnvironmentResponse (p. 1556 ) object
EphemeralStorage  (p. 1455 )
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
FileSystemConﬁgs (p. 1455 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
FunctionArn (p. 1455 )
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionName (p. 1455 )
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
1457AWS Lambda Developer Guide
PublishVersion
Handler (p. 1455 )
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
ImageConﬁgResponse (p. 1455 )
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
KMSKeyArn (p. 1455 )
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
LastModiﬁed  (p. 1455 )
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
LastUpdateStatus  (p. 1455 )
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
LastUpdateStatusReason (p. 1455 )
The reason for the last update that was performed on the function.
Type: String
LastUpdateStatusReasonCode (p. 1455 )
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Layers (p. 1455 )
The function's layers.
Type: Array of Layer (p. 1585 ) objects
1458AWS Lambda Developer Guide
PublishVersion
MasterArn  (p. 1455 )
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
MemorySize (p. 1455 )
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
PackageType (p. 1455 )
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
RevisionId (p. 1455 )
The latest updated revision of the function or alias.
Type: String
Role (p. 1455 )
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Runtime  (p. 1455 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
RuntimeVersionConﬁg (p. 1455 )
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
SigningJobArn  (p. 1455 )
The ARN of the signing job.
Type: String
1459AWS Lambda Developer Guide
PublishVersion
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SigningProﬁleVersionArn (p. 1455 )
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SnapStart (p. 1455 )
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
State  (p. 1455 )
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
StateReason (p. 1455 )
The reason for the function's current state.
Type: String
StateReasonCode (p. 1455 )
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
Timeout  (p. 1455 )
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
TracingConﬁg (p. 1455 )
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
Version (p. 1455 )
The version of the Lambda function.
1460AWS Lambda Developer Guide
PublishVersion
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
VpcConﬁg (p. 1455 )
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Errors
CodeStorageExceededException
Your AWS account has exceeded its maximum total code size. For more information, see Lambda 
quotas .
HTTP Status Code: 400
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
1461AWS Lambda Developer Guide
PublishVersion
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1462AWS Lambda Developer Guide
PutFunctionCodeSigningConﬁg
PutFunctionCodeSigningConﬁg
Update the code signing conﬁguration for the function. Changes to the code signing conﬁguration take 
eﬀect the next time a user tries to deploy a code package to the function.
Request Syntax
PUT /2020-06-30/functions/ FunctionName /code-signing-config HTTP/1.1
Content-type: application/json
{ 
   "CodeSigningConfigArn ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1463 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
CodeSigningConﬁgArn  (p. 1463 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
1463AWS Lambda Developer Guide
PutFunctionCodeSigningConﬁg
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CodeSigningConfigArn ": "string", 
   "FunctionName ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
CodeSigningConﬁgArn  (p. 1464 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
FunctionName (p. 1464 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Errors
CodeSigningConﬁgNotFoundException
The speciﬁed code signing conﬁguration does not exist.
HTTP Status Code: 404
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
1464AWS Lambda Developer Guide
PutFunctionCodeSigningConﬁg
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1465AWS Lambda Developer Guide
PutFunctionConcurrency
PutFunctionConcurrency
Sets the maximum number of simultaneous executions for a function, and reserves capacity for that 
concurrency level.
Concurrency settings apply to the function as a whole, including all published versions and the 
unpublished version. Reserving concurrency both ensures that your function has capacity to process 
the speciﬁed number of events simultaneously, and prevents it from scaling beyond that level. Use
GetFunction (p. 1359 ) to see the current setting for a function.
Use GetAccountSettings (p. 1346 ) to see your Regional concurrency limit. You can reserve concurrency 
for as many functions as you like, as long as you leave at least 100 simultaneous executions unreserved 
for functions that aren't conﬁgured with a per-function limit. For more information, see Lambda function 
scaling .
Request Syntax
PUT /2017-10-31/functions/ FunctionName /concurrency HTTP/1.1
Content-type: application/json
{ 
   "ReservedConcurrentExecutions ": number
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1466 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
ReservedConcurrentExecutions (p. 1466 )
The number of simultaneous executions to reserve for the function.
Type: Integer
1466AWS Lambda Developer Guide
PutFunctionConcurrency
Valid Range: Minimum value of 0.
Required: Yes
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "ReservedConcurrentExecutions ": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
ReservedConcurrentExecutions (p. 1467 )
The number of concurrent executions that are reserved for this function. For more information, see
Managing Lambda reserved concurrency.
Type: Integer
Valid Range: Minimum value of 0.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
1467AWS Lambda Developer Guide
PutFunctionConcurrency
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1468AWS Lambda Developer Guide
PutFunctionEventInvokeConﬁg
PutFunctionEventInvokeConﬁg
Conﬁgures options for asynchronous invocation on a function, version, or alias. If a conﬁguration 
already exists for a function, version, or alias, this operation overwrites it. If you exclude any settings, 
they are removed. To set one option without aﬀecting existing settings for other options, use
UpdateFunctionEventInvokeConﬁg (p. 1528 ).
By default, Lambda retries an asynchronous invocation twice if the function returns an error. It retains 
events in a queue for up to six hours. When an event fails all processing attempts or stays in the 
asynchronous invocation queue for too long, Lambda discards it. To retain discarded events, conﬁgure a 
dead-letter queue with UpdateFunctionConﬁguration (p. 1516 ).
To send an invocation record to a queue, topic, function, or event bus, specify a destination . You can 
conﬁgure separate destinations for successful invocations (on-success) and events that fail all processing 
attempts (on-failure). You can conﬁgure destinations in addition to or instead of a dead-letter queue.
Request Syntax
PUT /2019-09-25/functions/ FunctionName /event-invoke-config?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "MaximumEventAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1469 )
The name of the Lambda function, version, or alias.
Name formats
•Function name - my-function  (name-only), my-function:v1  (with alias).
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN - 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
1469AWS Lambda Developer Guide
PutFunctionEventInvokeConﬁg
Qualiﬁer  (p. 1469 )
A version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following data in JSON format.
DestinationConﬁg  (p. 1469 )
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
MaximumEventAgeInSeconds (p. 1469 )
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
Required: No
MaximumRetryAttempts (p. 1469 )
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
1470AWS Lambda Developer Guide
PutFunctionEventInvokeConﬁg
   }, 
   "FunctionArn ": "string", 
   "LastModified ": number, 
   "MaximumEventAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
DestinationConﬁg  (p. 1470 )
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
FunctionArn (p. 1470 )
The Amazon Resource Name (ARN) of the function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
LastModiﬁed  (p. 1470 )
The date and time that the conﬁguration was last updated, in Unix time seconds.
Type: Timestamp
MaximumEventAgeInSeconds (p. 1470 )
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
MaximumRetryAttempts (p. 1470 )
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
1471AWS Lambda Developer Guide
PutFunctionEventInvokeConﬁg
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1472AWS Lambda Developer Guide
PutProvisionedConcurrencyConﬁg
PutProvisionedConcurrencyConﬁg
Adds a provisioned concurrency conﬁguration to a function's alias or version.
Request Syntax
PUT /2019-09-30/functions/ FunctionName /provisioned-concurrency?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "ProvisionedConcurrentExecutions ": number
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1473 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1473 )
The version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Required: Yes
Request Body
The request accepts the following data in JSON format.
ProvisionedConcurrentExecutions (p. 1473 )
The amount of provisioned concurrency to allocate for the version or alias.
Type: Integer
Valid Range: Minimum value of 1.
1473AWS Lambda Developer Guide
PutProvisionedConcurrencyConﬁg
Required: Yes
Response Syntax
HTTP/1.1 202
Content-type: application/json
{ 
   "AllocatedProvisionedConcurrentExecutions ": number, 
   "AvailableProvisionedConcurrentExecutions ": number, 
   "LastModified ": "string", 
   "RequestedProvisionedConcurrentExecutions ": number, 
   "Status": "string", 
   "StatusReason ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 202 response.
The following data is returned in JSON format by the service.
AllocatedProvisionedConcurrentExecutions (p. 1474 )
The amount of provisioned concurrency allocated. When a weighted alias is used during linear 
and canary deployments, this value ﬂuctuates depending on the amount of concurrency that is 
provisioned for the function versions.
Type: Integer
Valid Range: Minimum value of 0.
AvailableProvisionedConcurrentExecutions (p. 1474 )
The amount of provisioned concurrency available.
Type: Integer
Valid Range: Minimum value of 0.
LastModiﬁed  (p. 1474 )
The date and time that a user last updated the conﬁguration, in ISO 8601 format.
Type: String
RequestedProvisionedConcurrentExecutions (p. 1474 )
The amount of provisioned concurrency requested.
Type: Integer
Valid Range: Minimum value of 1.
Status  (p. 1474 )
The status of the allocation process.
Type: String
Valid Values: IN_PROGRESS | READY | FAILED
1474AWS Lambda Developer Guide
PutProvisionedConcurrencyConﬁg
StatusReason (p. 1474 )
For failed allocations, the reason that provisioned concurrency could not be allocated.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1475AWS Lambda Developer Guide
PutRuntimeManagementConﬁg
PutRuntimeManagementConﬁg
Sets the runtime management conﬁguration for a function's version. For more information, see Runtime 
updates .
Request Syntax
PUT /2021-07-20/functions/ FunctionName /runtime-management-config?Qualifier= Qualifier
 HTTP/1.1
Content-type: application/json
{ 
   "RuntimeVersionArn ": "string", 
   "UpdateRuntimeOn ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1476 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1476 )
Specify a version of the function. This can be $LATEST or a published version number. If no value is 
speciﬁed, the conﬁguration for the $LATEST version is returned.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following data in JSON format.
RuntimeVersionArn (p. 1476 )
The ARN of the runtime version you want the function to use.
1476AWS Lambda Developer Guide
PutRuntimeManagementConﬁg
Note
This is only required if you're using the Manual  runtime update mode.
Type: String
Length Constraints: Minimum length of 26. Maximum length of 2048.
Pattern: ^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}::runtime:.+$
Required: No
UpdateRuntimeOn  (p. 1476 )
Specify the runtime update mode.
•Auto (default)  - Automatically update to the most recent and secure runtime version using a Two-
phase runtime version rollout. This is the best choice for most customers to ensure they always 
beneﬁt from runtime updates.
•Function update - Lambda updates the runtime of your function to the most recent and secure 
runtime version when you update your function. This approach synchronizes runtime updates with 
function deployments, giving you control over when runtime updates are applied and allowing 
you to detect and mitigate rare runtime update incompatibilities early. When using this setting, 
you need to regularly update your functions to keep their runtime up-to-date.
•Manual  - You specify a runtime version in your function conﬁguration. The function will use this 
runtime version indeﬁnitely. In the rare case where a new runtime version is incompatible with an 
existing function, this allows you to roll back your function to an earlier runtime version. For more 
information, see Roll back a runtime version.
Type: String
Valid Values: Auto | Manual | FunctionUpdate
Required: Yes
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "FunctionArn ": "string", 
   "RuntimeVersionArn ": "string", 
   "UpdateRuntimeOn ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
FunctionArn (p. 1477 )
The ARN of the function
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
1477AWS Lambda Developer Guide
PutRuntimeManagementConﬁg
RuntimeVersionArn (p. 1477 )
The ARN of the runtime the function is conﬁgured to use. If the runtime update mode is manual , the 
ARN is returned, otherwise null is returned.
Type: String
Length Constraints: Minimum length of 26. Maximum length of 2048.
Pattern: ^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}::runtime:.+$
UpdateRuntimeOn  (p. 1477 )
The runtime update mode.
Type: String
Valid Values: Auto | Manual | FunctionUpdate
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
1478AWS Lambda Developer Guide
PutRuntimeManagementConﬁg
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1479AWS Lambda Developer Guide
RemoveLayerVersionPermission
RemoveLayerVersionPermission
Removes a statement from the permissions policy for a version of an AWS Lambda layer. For more 
information, see AddLayerVersionPermission (p. 1276 ).
Request Syntax
DELETE /2018-10-31/layers/ LayerName /versions/ VersionNumber /policy/ StatementId ?
RevisionId= RevisionId  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
LayerName (p. 1480 )
The name or Amazon Resource Name (ARN) of the layer.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: Yes
RevisionId (p. 1480 )
Only update the policy if the revision ID matches the ID speciﬁed. Use this option to avoid modifying 
a policy that has changed since you last read it.
StatementId  (p. 1480 )
The identiﬁer that was speciﬁed when the statement was added.
Length Constraints: Minimum length of 1. Maximum length of 100.
Pattern: ([a-zA-Z0-9-_]+)
Required: Yes
VersionNumber (p. 1480 )
The version number.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
1480AWS Lambda Developer Guide
RemoveLayerVersionPermission
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1481AWS Lambda Developer Guide
RemovePermission
RemovePermission
Revokes function-use permission from an AWS service or another AWS account. You can get the ID of the 
statement from the output of GetPolicy (p. 1391 ).
Request Syntax
DELETE /2015-03-31/functions/ FunctionName /policy/ StatementId ?
Qualifier= Qualifier &RevisionId= RevisionId  HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1482 )
The name of the Lambda function, version, or alias.
Name formats
•Function name – my-function  (name-only), my-function:v1  (with alias).
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1482 )
Specify a version or alias to remove permissions from a published version of the function.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
RevisionId (p. 1482 )
Update the policy only if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
modifying a policy that has changed since you last read it.
StatementId  (p. 1482 )
Statement ID of the permission to remove.
Length Constraints: Minimum length of 1. Maximum length of 100.
Pattern: ([a-zA-Z0-9-_.]+)
Required: Yes
Request Body
The request does not have a request body.
1482AWS Lambda Developer Guide
RemovePermission
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1483AWS Lambda Developer Guide
TagResource
TagResource
Adds tags to a function.
Request Syntax
POST /2017-03-31/tags/ ARN HTTP/1.1
Content-type: application/json
{ 
   "Tags": {  
      "string" : "string"  
   }
}
URI Request Parameters
The request uses the following URI parameters.
ARN  (p. 1484 )
The function's Amazon Resource Name (ARN).
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
Tags (p. 1484 )
A list of tags to apply to the function.
Type: String to string map
Required: Yes
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
1484AWS Lambda Developer Guide
TagResource
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1485AWS Lambda Developer Guide
UntagResource
UntagResource
Removes tags from a function.
Request Syntax
DELETE /2017-03-31/tags/ ARN?tagKeys= TagKeys HTTP/1.1
URI Request Parameters
The request uses the following URI parameters.
ARN  (p. 1486 )
The function's Amazon Resource Name (ARN).
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
TagKeys (p. 1486 )
A list of tag keys to remove from the function.
Required: Yes
Request Body
The request does not have a request body.
Response Syntax
HTTP/1.1 204
Response Elements
If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
1486AWS Lambda Developer Guide
UntagResource
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1487AWS Lambda Developer Guide
UpdateAlias
UpdateAlias
Updates the conﬁguration of a Lambda function alias .
Request Syntax
PUT /2015-03-31/functions/ FunctionName /aliases/ Name HTTP/1.1
Content-type: application/json
{ 
   "Description ": "string", 
   "FunctionVersion ": "string", 
   "RevisionId ": "string", 
   "RoutingConfig ": {  
      "AdditionalVersionWeights ": {  
         " string" : number 
      } 
   }
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1488 )
The name of the Lambda function.
Name formats
•Function name - MyFunction .
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Partial ARN - 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Name  (p. 1488 )
The name of the alias.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
Required: Yes
Request Body
The request accepts the following data in JSON format.
1488AWS Lambda Developer Guide
UpdateAlias
Description  (p. 1488 )
A description of the alias.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
FunctionVersion (p. 1488 )
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Required: No
RevisionId (p. 1488 )
Only update the alias if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
modifying an alias that has changed since you last read it.
Type: String
Required: No
RoutingConﬁg (p. 1488 )
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AliasArn ": "string", 
   "Description ": "string", 
   "FunctionVersion ": "string", 
   "Name": "string", 
   "RevisionId ": "string", 
   "RoutingConfig ": {  
      "AdditionalVersionWeights ": {  
         " string" : number 
      } 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
1489AWS Lambda Developer Guide
UpdateAlias
AliasArn  (p. 1489 )
The Amazon Resource Name (ARN) of the alias.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Description  (p. 1489 )
A description of the alias.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
FunctionVersion (p. 1489 )
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Name  (p. 1489 )
The name of the alias.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
RevisionId (p. 1489 )
A unique identiﬁer that changes when you update the alias.
Type: String
RoutingConﬁg (p. 1489 )
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
1490AWS Lambda Developer Guide
UpdateAlias
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1491AWS Lambda Developer Guide
UpdateCodeSigningConﬁg
UpdateCodeSigningConﬁg
Update the code signing conﬁguration. Changes to the code signing conﬁguration take eﬀect the next 
time a user tries to deploy a code package to the function.
Request Syntax
PUT /2020-04-22/code-signing-configs/ CodeSigningConfigArn  HTTP/1.1
Content-type: application/json
{ 
   "AllowedPublishers ": {  
      "SigningProfileVersionArns ": [ "string" ] 
   }, 
   "CodeSigningPolicies ": {  
      "UntrustedArtifactOnDeployment ": "string" 
   }, 
   "Description ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
CodeSigningConﬁgArn  (p. 1492 )
The The Amazon Resource Name (ARN) of the code signing conﬁguration.
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
Request Body
The request accepts the following data in JSON format.
AllowedPublishers (p. 1492 )
Signing proﬁles for this code signing conﬁguration.
Type: AllowedPublishers (p. 1543 ) object
Required: No
CodeSigningPolicies (p. 1492 )
The code signing policy.
Type: CodeSigningPolicies (p. 1547 ) object
Required: No
Description  (p. 1492 )
Descriptive name for this code signing conﬁguration.
Type: String
1492AWS Lambda Developer Guide
UpdateCodeSigningConﬁg
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "CodeSigningConfig ": {  
      "AllowedPublishers ": {  
         " SigningProfileVersionArns ": [ "string" ] 
      }, 
      "CodeSigningConfigArn ": "string", 
      "CodeSigningConfigId ": "string", 
      "CodeSigningPolicies ": {  
         " UntrustedArtifactOnDeployment ": "string" 
      }, 
      "Description ": "string", 
      "LastModified ": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
CodeSigningConﬁg  (p. 1493 )
The code signing conﬁguration
Type: CodeSigningConﬁg  (p. 1545 ) object
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
1493AWS Lambda Developer Guide
UpdateCodeSigningConﬁg
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1494AWS Lambda Developer Guide
UpdateEventSourceMapping
UpdateEventSourceMapping
Updates an event source mapping. You can change the function that AWS Lambda invokes, or pause 
invocation and resume later from the same location.
For details about how to conﬁgure diﬀerent event sources, see the following topics.
•Amazon DynamoDB Streams
•Amazon Kinesis
•Amazon SQS
•Amazon MQ and RabbitMQ
•Amazon MSK
•Apache Kafka
•Amazon DocumentDB
The following error handling options are available only for stream sources (DynamoDB and Kinesis):
•BisectBatchOnFunctionError  – If the function returns an error, split the batch in two and retry.
•DestinationConfig  – Send discarded records to an Amazon SQS queue or Amazon SNS topic.
•MaximumRecordAgeInSeconds  – Discard records older than the speciﬁed age. The default value is 
inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record expires
•MaximumRetryAttempts  – Discard records after the speciﬁed number of retries. The default value is 
inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record expires.
•ParallelizationFactor  – Process multiple batches from each shard concurrently.
For information about which conﬁguration parameters apply to each event source, see the following 
topics.
•Amazon DynamoDB Streams
•Amazon Kinesis
•Amazon SQS
•Amazon MQ and RabbitMQ
•Amazon MSK
•Apache Kafka
•Amazon DocumentDB
Request Syntax
PUT /2015-03-31/event-source-mappings/ UUID HTTP/1.1
Content-type: application/json
{ 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
1495AWS Lambda Developer Guide
UpdateEventSourceMapping
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "Enabled": boolean, 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
   "FunctionName ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "TumblingWindowInSeconds ": number
}
URI Request Parameters
The request uses the following URI parameters.
UUID  (p. 1495 )
The identiﬁer of the event source mapping.
Required: Yes
Request Body
The request accepts the following data in JSON format.
BatchSize (p. 1495 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
•Amazon Kinesis – Default 100. Max 10,000.
•Amazon DynamoDB Streams – Default 100. Max 10,000.
•Amazon Simple Queue Service – Default 10. For standard queues the max is 10,000. For FIFO 
queues the max is 10.
•Amazon Managed Streaming for Apache Kafka – Default 100. Max 10,000.
•Self-managed Apache Kafka – Default 100. Max 10,000.
•Amazon MQ (ActiveMQ and RabbitMQ) – Default 100. Max 10,000.
•DocumentDB  – Default 100. Max 10,000.
1496AWS Lambda Developer Guide
UpdateEventSourceMapping
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
Required: No
BisectBatchOnFunctionError (p. 1495 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry.
Type: Boolean
Required: No
DestinationConﬁg  (p. 1495 )
(Kinesis and DynamoDB Streams only) A standard Amazon SQS queue or standard Amazon SNS 
topic destination for discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
DocumentDBEventSourceConﬁg (p. 1495 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
Required: No
Enabled (p. 1495 )
When true, the event source mapping is active. When false, Lambda pauses polling and invocation.
Default: True
Type: Boolean
Required: No
FilterCriteria  (p. 1495 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
Required: No
FunctionName (p. 1495 )
The name of the Lambda function.
Name formats
•Function name – MyFunction .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:MyFunction .
•Version or Alias ARN – arn:aws:lambda:us-
west-2:123456789012:function:MyFunction:PROD .
•Partial ARN – 123456789012:function:MyFunction .
The length constraint applies only to the full ARN. If you specify only the function name, it's limited 
to 64 characters in length.
1497AWS Lambda Developer Guide
UpdateEventSourceMapping
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
FunctionResponseTypes (p. 1495 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
Required: No
MaximumBatchingWindowInSeconds (p. 1495 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
Required: No
MaximumRecordAgeInSeconds (p. 1495 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is inﬁnite (-1).
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
Required: No
MaximumRetryAttempts (p. 1495 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of retries. The 
default value is inﬁnite (-1). When set to inﬁnite (-1), failed records are retried until the record 
expires.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
1498AWS Lambda Developer Guide
UpdateEventSourceMapping
Required: No
ParallelizationFactor (p. 1495 )
(Kinesis and DynamoDB Streams only) The number of batches to process from each shard 
concurrently.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Required: No
ScalingConﬁg  (p. 1495 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
Required: No
SourceAccessConﬁgurations (p. 1495 )
An array of authentication protocols or VPC components required to secure your event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
Required: No
TumblingWindowInSeconds (p. 1495 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
Required: No
Response Syntax
HTTP/1.1 202
Content-type: application/json
{ 
   "AmazonManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "BatchSize ": number, 
   "BisectBatchOnFunctionError ": boolean, 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "DocumentDBEventSourceConfig ": {  
      "CollectionName ": "string", 
1499AWS Lambda Developer Guide
UpdateEventSourceMapping
      "DatabaseName ": "string", 
      "FullDocument ": "string" 
   }, 
   "EventSourceArn ": "string", 
   "FilterCriteria ": {  
      "Filters": [  
         {  
            " Pattern": "string" 
         } 
      ] 
   }, 
   "FunctionArn ": "string", 
   "FunctionResponseTypes ": [ "string" ], 
   "LastModified ": number, 
   "LastProcessingResult ": "string", 
   "MaximumBatchingWindowInSeconds ": number, 
   "MaximumRecordAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number, 
   "ParallelizationFactor ": number, 
   "Queues": [ "string" ], 
   "ScalingConfig ": {  
      "MaximumConcurrency ": number
   }, 
   "SelfManagedEventSource ": {  
      "Endpoints ": {  
         " string" : [ "string" ] 
      } 
   }, 
   "SelfManagedKafkaEventSourceConfig ": {  
      "ConsumerGroupId ": "string" 
   }, 
   "SourceAccessConfigurations ": [  
      {  
         " Type": "string", 
         " URI": "string" 
      } 
   ], 
   "StartingPosition ": "string", 
   "StartingPositionTimestamp ": number, 
   "State": "string", 
   "StateTransitionReason ": "string", 
   "Topics": [ "string" ], 
   "TumblingWindowInSeconds ": number, 
   "UUID": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 202 response.
The following data is returned in JSON format by the service.
AmazonManagedKafkaEventSourceConﬁg (p. 1499 )
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
BatchSize (p. 1499 )
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
1500AWS Lambda Developer Guide
UpdateEventSourceMapping
Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default 
is 100.
Related setting: When you set BatchSize  to a value greater than 10, you must set
MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
BisectBatchOnFunctionError (p. 1499 )
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry. The default value is false.
Type: Boolean
DestinationConﬁg  (p. 1499 )
(Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for 
discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
DocumentDBEventSourceConﬁg (p. 1499 )
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
EventSourceArn (p. 1499 )
The Amazon Resource Name (ARN) of the event source.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
FilterCriteria  (p. 1499 )
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
FunctionArn (p. 1499 )
The ARN of the Lambda function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionResponseTypes (p. 1499 )
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
1501AWS Lambda Developer Guide
UpdateEventSourceMapping
LastModiﬁed  (p. 1499 )
The date that the event source mapping was last updated or that its state changed, in Unix time 
seconds.
Type: Timestamp
LastProcessingResult (p. 1499 )
The result of the last Lambda invocation of your function.
Type: String
MaximumBatchingWindowInSeconds (p. 1499 )
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
MaximumRecordAgeInSeconds (p. 1499 )
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is -1, which sets the maximum age to inﬁnite. When the value is set to inﬁnite, Lambda never 
discards old records.
Note
The minimum valid value for maximum record age is 60s. Although values less than 60 and 
greater than -1 fall within the parameter's absolute range, they are not allowed
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
MaximumRetryAttempts (p. 1499 )
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of 
retries. The default value is -1, which sets the maximum number of retries to inﬁnite. When 
MaximumRetryAttempts is inﬁnite, Lambda retries failed records until the record expires in the event 
source.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
ParallelizationFactor (p. 1499 )
(Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each 
shard. The default value is 1.
Type: Integer
1502AWS Lambda Developer Guide
UpdateEventSourceMapping
Valid Range: Minimum value of 1. Maximum value of 10.
Queues  (p. 1499 )
(Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
Pattern: [\s\S]*
ScalingConﬁg  (p. 1499 )
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
SelfManagedEventSource (p. 1499 )
The self-managed Apache Kafka cluster for your event source.
Type: SelfManagedEventSource (p. 1598 ) object
SelfManagedKafkaEventSourceConﬁg (p. 1499 )
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
SourceAccessConﬁgurations (p. 1499 )
An array of the authentication protocol, VPC components, or virtual host to secure and deﬁne your 
event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
StartingPosition (p. 1499 )
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
StartingPositionTimestamp (p. 1499 )
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
State  (p. 1499 )
The state of the event source mapping. It can be one of the following: Creating , Enabling ,
Enabled , Disabling , Disabled , Updating , or Deleting .
Type: String
StateTransitionReason (p. 1499 )
Indicates whether a user or Lambda made the last change to the event source mapping.
1503AWS Lambda Developer Guide
UpdateEventSourceMapping
Type: String
Topics (p. 1499 )
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 249.
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
TumblingWindowInSeconds (p. 1499 )
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
UUID  (p. 1499 )
The identiﬁer of the event source mapping.
Type: String
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceInUseException
The operation conﬂicts with the resource's availability. For example, you tried to update an event 
source mapping in the CREATING state, or you tried to delete an event source mapping currently 
UPDATING.
HTTP Status Code: 400
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
1504AWS Lambda Developer Guide
UpdateEventSourceMapping
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1505AWS Lambda Developer Guide
UpdateFunctionCode
UpdateFunctionCode
Updates a Lambda function's code. If code signing is enabled for the function, the code package must be 
signed by a trusted publisher. For more information, see Conﬁguring code signing for Lambda.
If the function's package type is Image, then you must specify the code package in ImageUri  as the URI 
of a container image in the Amazon ECR registry.
If the function's package type is Zip, then you must specify the deployment package as a .zip ﬁle 
archive. Enter the Amazon S3 bucket and key of the code .zip ﬁle location. You can also provide the 
function code inline using the ZipFile  ﬁeld.
The code in the deployment package must be compatible with the target instruction set architecture of 
the function (x86-64  or arm64 ).
The function's code is locked when you publish a version. You can't modify the code of a published 
version, only the unpublished version.
Note
For a function deﬁned as a container image, Lambda resolves the image tag to an image digest. 
In Amazon ECR, if you update the image tag to a new image, Lambda does not automatically 
update the function.
Request Syntax
PUT /2015-03-31/functions/ FunctionName /code HTTP/1.1
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "DryRun": boolean, 
   "ImageUri ": "string", 
   "Publish": boolean, 
   "RevisionId ": "string", 
   "S3Bucket ": "string", 
   "S3Key": "string", 
   "S3ObjectVersion ": "string", 
   "ZipFile": blob
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1506 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
1506AWS Lambda Developer Guide
UpdateFunctionCode
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
Architectures (p. 1506 )
The instruction set architecture that the function supports. Enter a string array with one of the valid 
values (arm64 or x86_64). The default value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
Required: No
DryRun (p. 1506 )
Set to true to validate the request parameters and access permissions without modifying the 
function code.
Type: Boolean
Required: No
ImageUri  (p. 1506 )
URI of a container image in the Amazon ECR registry. Do not use for a function deﬁned with a .zip 
ﬁle archive.
Type: String
Required: No
Publish  (p. 1506 )
Set to true to publish a new version of the function after updating the code. This has the same eﬀect 
as calling PublishVersion (p. 1454 ) separately.
Type: Boolean
Required: No
RevisionId (p. 1506 )
Update the function only if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
modifying a function that has changed since you last read it.
Type: String
Required: No
S3Bucket (p. 1506 )
An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a diﬀerent 
AWS account. Use only with a function deﬁned with a .zip ﬁle archive deployment package.
1507AWS Lambda Developer Guide
UpdateFunctionCode
Type: String
Length Constraints: Minimum length of 3. Maximum length of 63.
Pattern: ^[0-9A-Za-z\.\-_]*(?<!\.)$
Required: No
S3Key (p. 1506 )
The Amazon S3 key of the deployment package. Use only with a function deﬁned with a .zip ﬁle 
archive deployment package.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
S3ObjectVersion (p. 1506 )
For versioned objects, the version of the deployment package object to use.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
ZipFile (p. 1506 )
The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the 
encoding for you. Use only with a function deﬁned with a .zip ﬁle archive deployment package.
Type: Base64-encoded binary data object
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "CodeSha256 ": "string", 
   "CodeSize ": number, 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
1508AWS Lambda Developer Guide
UpdateFunctionCode
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionArn ": "string", 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfigResponse ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "ImageConfig ": {  
         " Command": [ "string" ], 
         " EntryPoint ": [ "string" ], 
         " WorkingDirectory ": "string" 
      } 
   }, 
   "KMSKeyArn ": "string", 
   "LastModified ": "string", 
   "LastUpdateStatus ": "string", 
   "LastUpdateStatusReason ": "string", 
   "LastUpdateStatusReasonCode ": "string", 
   "Layers": [  
      {  
         " Arn": "string", 
         " CodeSize ": number, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string" 
      } 
   ], 
   "MasterArn ": "string", 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "RuntimeVersionConfig ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "RuntimeVersionArn ": "string" 
   }, 
   "SigningJobArn ": "string", 
   "SigningProfileVersionArn ": "string", 
   "SnapStart ": {  
      "ApplyOn": "string", 
      "OptimizationStatus ": "string" 
   }, 
   "State": "string", 
   "StateReason ": "string", 
   "StateReasonCode ": "string", 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "Version": "string", 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ], 
      "VpcId": "string" 
   }
1509AWS Lambda Developer Guide
UpdateFunctionCode
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Architectures (p. 1508 )
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
CodeSha256  (p. 1508 )
The SHA256 hash of the function's deployment package.
Type: String
CodeSize (p. 1508 )
The size of the function's deployment package, in bytes.
Type: Long
DeadLetterConﬁg (p. 1508 )
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Description  (p. 1508 )
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Environment (p. 1508 )
The function's environment variables. Omitted from AWS CloudTrail logs.
Type: EnvironmentResponse (p. 1556 ) object
EphemeralStorage  (p. 1508 )
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
FileSystemConﬁgs (p. 1508 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
1510AWS Lambda Developer Guide
UpdateFunctionCode
FunctionArn (p. 1508 )
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionName (p. 1508 )
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Handler (p. 1508 )
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
ImageConﬁgResponse (p. 1508 )
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
KMSKeyArn (p. 1508 )
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
LastModiﬁed  (p. 1508 )
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
LastUpdateStatus  (p. 1508 )
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
LastUpdateStatusReason (p. 1508 )
The reason for the last update that was performed on the function.
Type: String
1511AWS Lambda Developer Guide
UpdateFunctionCode
LastUpdateStatusReasonCode (p. 1508 )
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Layers (p. 1508 )
The function's layers.
Type: Array of Layer (p. 1585 ) objects
MasterArn  (p. 1508 )
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
MemorySize (p. 1508 )
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
PackageType (p. 1508 )
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
RevisionId (p. 1508 )
The latest updated revision of the function or alias.
Type: String
Role (p. 1508 )
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Runtime  (p. 1508 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
1512AWS Lambda Developer Guide
UpdateFunctionCode
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
RuntimeVersionConﬁg (p. 1508 )
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
SigningJobArn  (p. 1508 )
The ARN of the signing job.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SigningProﬁleVersionArn (p. 1508 )
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SnapStart (p. 1508 )
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
State  (p. 1508 )
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
StateReason (p. 1508 )
The reason for the function's current state.
Type: String
StateReasonCode (p. 1508 )
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
1513AWS Lambda Developer Guide
UpdateFunctionCode
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
Timeout  (p. 1508 )
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
TracingConﬁg (p. 1508 )
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
Version (p. 1508 )
The version of the Lambda function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
VpcConﬁg (p. 1508 )
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Errors
CodeSigningConﬁgNotFoundException
The speciﬁed code signing conﬁguration does not exist.
HTTP Status Code: 404
CodeStorageExceededException
Your AWS account has exceeded its maximum total code size. For more information, see Lambda 
quotas .
HTTP Status Code: 400
CodeVeriﬁcationFailedException
The code signature failed one or more of the validation checks for signature mismatch or expiry, and 
the code signing policy is set to ENFORCE. Lambda blocks the deployment.
HTTP Status Code: 400
InvalidCodeSignatureException
The code signature failed the integrity check. If the integrity check fails, then Lambda blocks 
deployment, even if the code signing policy is set to WARN.
HTTP Status Code: 400
1514AWS Lambda Developer Guide
UpdateFunctionCode
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1515AWS Lambda Developer Guide
UpdateFunctionConﬁguration
UpdateFunctionConﬁguration
Modify the version-speciﬁc settings of a Lambda function.
When you update a function, Lambda provisions an instance of the function and its supporting resources. 
If your function connects to a VPC, this process can take a minute. During this time, you can't modify 
the function, but you can still invoke it. The LastUpdateStatus , LastUpdateStatusReason , and
LastUpdateStatusReasonCode  ﬁelds in the response from GetFunctionConﬁguration (p. 1368 )
indicate when the update is complete and the function is processing events with the new conﬁguration. 
For more information, see Lambda function states.
These settings can vary between versions of a function and are locked when you publish a version. You 
can't modify the conﬁguration of a published version, only the unpublished version.
To conﬁgure function concurrency, use PutFunctionConcurrency (p. 1466 ). To grant invoke permissions to 
an AWS account or AWS service, use AddPermission (p. 1280 ).
Request Syntax
PUT /2015-03-31/functions/ FunctionName /configuration HTTP/1.1
Content-type: application/json
{ 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "Handler": "string", 
   "ImageConfig ": {  
      "Command": [ "string" ], 
      "EntryPoint ": [ "string" ], 
      "WorkingDirectory ": "string" 
   }, 
   "KMSKeyArn ": "string", 
   "Layers": [ "string" ], 
   "MemorySize ": number, 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "SnapStart ": {  
      "ApplyOn": "string" 
   }, 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
1516AWS Lambda Developer Guide
UpdateFunctionConﬁguration
      "SubnetIds ": [ "string" ] 
   }
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1516 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Request Body
The request accepts the following data in JSON format.
DeadLetterConﬁg (p. 1516 )
A dead-letter queue conﬁguration that speciﬁes the queue or topic where Lambda sends 
asynchronous events when they fail processing. For more information, see Dead-letter queues.
Type: DeadLetterConﬁg (p. 1551 ) object
Required: No
Description  (p. 1516 )
A description of the function.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
Environment (p. 1516 )
Environment variables that are accessible from function code during execution.
Type: Environment (p. 1554 ) object
Required: No
1517AWS Lambda Developer Guide
UpdateFunctionConﬁguration
EphemeralStorage  (p. 1516 )
The size of the function's /tmp directory in MB. The default value is 512, but can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
Required: No
FileSystemConﬁgs (p. 1516 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
Required: No
Handler (p. 1516 )
The name of the method within your code that Lambda calls to run your function. Handler is 
required if the deployment package is a .zip ﬁle archive. The format includes the ﬁle name. It can 
also include namespaces and other qualiﬁers, depending on the runtime. For more information, see
Lambda programming model.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
Required: No
ImageConﬁg  (p. 1516 )
Container image conﬁguration values that override the values in the container image Docker ﬁle.
Type: ImageConﬁg  (p. 1579 ) object
Required: No
KMSKeyArn (p. 1516 )
The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to 
encrypt your function's environment variables. When Lambda SnapStart is activated, Lambda also 
uses this key is to encrypt your function's snapshot. If you deploy your function using a container 
image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not 
the same key that's used to protect your container image in the Amazon Elastic Container Registry 
(Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
Required: No
Layers (p. 1516 )
A list of function layers to add to the function's execution environment. Specify each layer by its 
ARN, including the version.
Type: Array of strings
Length Constraints: Minimum length of 1. Maximum length of 140.
1518AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
Required: No
MemorySize (p. 1516 )
The amount of memory available to the function at runtime. Increasing the function memory also 
increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
Required: No
RevisionId (p. 1516 )
Update the function only if the revision ID matches the ID that's speciﬁed. Use this option to avoid 
modifying a function that has changed since you last read it.
Type: String
Required: No
Role (p. 1516 )
The Amazon Resource Name (ARN) of the function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Required: No
Runtime  (p. 1516 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Required: No
SnapStart (p. 1516 )
The function's SnapStart setting.
Type: SnapStart (p. 1600 ) object
Required: No
Timeout  (p. 1516 )
The amount of time (in seconds) that Lambda allows a function to run before stopping it. The 
default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda 
execution environment.
1519AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Type: Integer
Valid Range: Minimum value of 1.
Required: No
TracingConﬁg (p. 1516 )
Set Mode  to Active to sample and trace a subset of incoming requests with X-Ray.
Type: TracingConﬁg (p. 1604 ) object
Required: No
VpcConﬁg (p. 1516 )
For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets 
in the VPC. When you connect a function to a VPC, it can access resources and the internet only 
through that VPC. For more information, see Conﬁguring a Lambda function to access resources in a 
VPC.
Type: VpcConﬁg (p. 1606 ) object
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "Architectures ": [ "string" ], 
   "CodeSha256 ": "string", 
   "CodeSize ": number, 
   "DeadLetterConfig ": {  
      "TargetArn ": "string" 
   }, 
   "Description ": "string", 
   "Environment ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "Variables ": {  
         " string" : "string"  
      } 
   }, 
   "EphemeralStorage ": {  
      "Size": number
   }, 
   "FileSystemConfigs ": [  
      {  
         " Arn": "string", 
         " LocalMountPath ": "string" 
      } 
   ], 
   "FunctionArn ": "string", 
   "FunctionName ": "string", 
   "Handler": "string", 
   "ImageConfigResponse ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
1520AWS Lambda Developer Guide
UpdateFunctionConﬁguration
      }, 
      "ImageConfig ": {  
         " Command": [ "string" ], 
         " EntryPoint ": [ "string" ], 
         " WorkingDirectory ": "string" 
      } 
   }, 
   "KMSKeyArn ": "string", 
   "LastModified ": "string", 
   "LastUpdateStatus ": "string", 
   "LastUpdateStatusReason ": "string", 
   "LastUpdateStatusReasonCode ": "string", 
   "Layers": [  
      {  
         " Arn": "string", 
         " CodeSize ": number, 
         " SigningJobArn ": "string", 
         " SigningProfileVersionArn ": "string" 
      } 
   ], 
   "MasterArn ": "string", 
   "MemorySize ": number, 
   "PackageType ": "string", 
   "RevisionId ": "string", 
   "Role": "string", 
   "Runtime": "string", 
   "RuntimeVersionConfig ": {  
      "Error": {  
         " ErrorCode ": "string", 
         " Message": "string" 
      }, 
      "RuntimeVersionArn ": "string" 
   }, 
   "SigningJobArn ": "string", 
   "SigningProfileVersionArn ": "string", 
   "SnapStart ": {  
      "ApplyOn": "string", 
      "OptimizationStatus ": "string" 
   }, 
   "State": "string", 
   "StateReason ": "string", 
   "StateReasonCode ": "string", 
   "Timeout": number, 
   "TracingConfig ": {  
      "Mode": "string" 
   }, 
   "Version": "string", 
   "VpcConfig ": {  
      "SecurityGroupIds ": [ "string" ], 
      "SubnetIds ": [ "string" ], 
      "VpcId": "string" 
   }
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
Architectures (p. 1520 )
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
1521AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
CodeSha256  (p. 1520 )
The SHA256 hash of the function's deployment package.
Type: String
CodeSize (p. 1520 )
The size of the function's deployment package, in bytes.
Type: Long
DeadLetterConﬁg (p. 1520 )
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Description  (p. 1520 )
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Environment (p. 1520 )
The function's environment variables. Omitted from AWS CloudTrail logs.
Type: EnvironmentResponse (p. 1556 ) object
EphemeralStorage  (p. 1520 )
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
Type: EphemeralStorage  (p. 1557 ) object
FileSystemConﬁgs (p. 1520 )
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
FunctionArn (p. 1520 )
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionName (p. 1520 )
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
1522AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Handler (p. 1520 )
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
ImageConﬁgResponse (p. 1520 )
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
KMSKeyArn (p. 1520 )
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
LastModiﬁed  (p. 1520 )
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
LastUpdateStatus  (p. 1520 )
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
LastUpdateStatusReason (p. 1520 )
The reason for the last update that was performed on the function.
Type: String
LastUpdateStatusReasonCode (p. 1520 )
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Layers (p. 1520 )
The function's layers.
1523AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Type: Array of Layer (p. 1585 ) objects
MasterArn  (p. 1520 )
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
MemorySize (p. 1520 )
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
PackageType (p. 1520 )
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
RevisionId (p. 1520 )
The latest updated revision of the function or alias.
Type: String
Role (p. 1520 )
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Runtime  (p. 1520 )
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
RuntimeVersionConﬁg (p. 1520 )
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
SigningJobArn  (p. 1520 )
The ARN of the signing job.
1524AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SigningProﬁleVersionArn (p. 1520 )
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
SnapStart (p. 1520 )
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
State  (p. 1520 )
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
StateReason (p. 1520 )
The reason for the function's current state.
Type: String
StateReasonCode (p. 1520 )
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
Timeout  (p. 1520 )
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
TracingConﬁg (p. 1520 )
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
1525AWS Lambda Developer Guide
UpdateFunctionConﬁguration
Version (p. 1520 )
The version of the Lambda function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
VpcConﬁg (p. 1520 )
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Errors
CodeSigningConﬁgNotFoundException
The speciﬁed code signing conﬁguration does not exist.
HTTP Status Code: 404
CodeVeriﬁcationFailedException
The code signature failed one or more of the validation checks for signature mismatch or expiry, and 
the code signing policy is set to ENFORCE. Lambda blocks the deployment.
HTTP Status Code: 400
InvalidCodeSignatureException
The code signature failed the integrity check. If the integrity check fails, then Lambda blocks 
deployment, even if the code signing policy is set to WARN.
HTTP Status Code: 400
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
PreconditionFailedException
The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call 
the GetFunction  or the GetAlias  API operation to retrieve the latest RevisionId for your resource.
HTTP Status Code: 412
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
1526AWS Lambda Developer Guide
UpdateFunctionConﬁguration
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1527AWS Lambda Developer Guide
UpdateFunctionEventInvokeConﬁg
UpdateFunctionEventInvokeConﬁg
Updates the conﬁguration for asynchronous invocation for a function, version, or alias.
To conﬁgure options for asynchronous invocation, use PutFunctionEventInvokeConﬁg (p. 1469 ).
Request Syntax
POST /2019-09-25/functions/ FunctionName /event-invoke-config?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "MaximumEventAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1528 )
The name of the Lambda function, version, or alias.
Name formats
•Function name - my-function  (name-only), my-function:v1  (with alias).
•Function ARN - arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN - 123456789012:function:my-function .
You can append a version number or alias to any of the formats. The length constraint applies only 
to the full ARN. If you specify only the function name, it is limited to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1528 )
A version number or alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (|[a-zA-Z0-9$_-]+)
Request Body
The request accepts the following data in JSON format.
1528AWS Lambda Developer Guide
UpdateFunctionEventInvokeConﬁg
DestinationConﬁg  (p. 1528 )
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
MaximumEventAgeInSeconds (p. 1528 )
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
Required: No
MaximumRetryAttempts (p. 1528 )
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "DestinationConfig ": {  
      "OnFailure ": {  
         " Destination ": "string" 
      }, 
      "OnSuccess ": {  
         " Destination ": "string" 
      } 
   }, 
   "FunctionArn ": "string", 
   "LastModified ": number, 
   "MaximumEventAgeInSeconds ": number, 
   "MaximumRetryAttempts ": number
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
The following data is returned in JSON format by the service.
1529AWS Lambda Developer Guide
UpdateFunctionEventInvokeConﬁg
DestinationConﬁg  (p. 1529 )
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
FunctionArn (p. 1529 )
The Amazon Resource Name (ARN) of the function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
LastModiﬁed  (p. 1529 )
The date and time that the conﬁguration was last updated, in Unix time seconds.
Type: Timestamp
MaximumEventAgeInSeconds (p. 1529 )
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
MaximumRetryAttempts (p. 1529 )
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
1530AWS Lambda Developer Guide
UpdateFunctionEventInvokeConﬁg
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
1531AWS Lambda Developer Guide
UpdateFunctionUrlConﬁg
UpdateFunctionUrlConﬁg
Updates the conﬁguration for a Lambda function URL.
Request Syntax
PUT /2021-10-31/functions/ FunctionName /url?Qualifier= Qualifier  HTTP/1.1
Content-type: application/json
{ 
   "AuthType ": "string", 
   "Cors": {  
      "AllowCredentials ": boolean, 
      "AllowHeaders ": [ "string" ], 
      "AllowMethods ": [ "string" ], 
      "AllowOrigins ": [ "string" ], 
      "ExposeHeaders ": [ "string" ], 
      "MaxAge": number
   }, 
   "InvokeMode ": "string"
}
URI Request Parameters
The request uses the following URI parameters.
FunctionName (p. 1532 )
The name of the Lambda function.
Name formats
•Function name – my-function .
•Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
•Partial ARN – 123456789012:function:my-function .
The length constraint applies only to the full ARN. If you specify only the function name, it is limited 
to 64 characters in length.
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
Qualiﬁer  (p. 1532 )
The alias name.
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (^\$LATEST$)|((?!^[0-9]+$)([a-zA-Z0-9-_]+))
Request Body
The request accepts the following data in JSON format.
1532AWS Lambda Developer Guide
UpdateFunctionUrlConﬁg
AuthType (p. 1532 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Required: No
Cors  (p. 1532 )
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
Required: No
InvokeMode (p. 1532 )
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
Required: No
Response Syntax
HTTP/1.1 200
Content-type: application/json
{ 
   "AuthType ": "string", 
   "Cors": {  
      "AllowCredentials ": boolean, 
      "AllowHeaders ": [ "string" ], 
      "AllowMethods ": [ "string" ], 
      "AllowOrigins ": [ "string" ], 
      "ExposeHeaders ": [ "string" ], 
      "MaxAge": number
   }, 
   "CreationTime ": "string", 
   "FunctionArn ": "string", 
   "FunctionUrl ": "string", 
   "InvokeMode ": "string", 
   "LastModifiedTime ": "string"
}
Response Elements
If the action is successful, the service sends back an HTTP 200 response.
1533AWS Lambda Developer Guide
UpdateFunctionUrlConﬁg
The following data is returned in JSON format by the service.
AuthType (p. 1533 )
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Cors  (p. 1533 )
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
CreationTime  (p. 1533 )
When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
FunctionArn (p. 1533 )
The Amazon Resource Name (ARN) of your function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
FunctionUrl (p. 1533 )
The HTTP URL endpoint for your function.
Type: String
Length Constraints: Minimum length of 40. Maximum length of 100.
InvokeMode (p. 1533 )
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
LastModiﬁedTime  (p. 1533 )
When the function URL conﬁguration was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
1534AWS Lambda Developer Guide
Data Types
Errors
InvalidParameterValueException
One of the parameters in the request is not valid.
HTTP Status Code: 400
ResourceConﬂictException
The resource already exists, or another operation is in progress.
HTTP Status Code: 409
ResourceNotFoundException
The resource speciﬁed in the request does not exist.
HTTP Status Code: 404
ServiceException
The AWS Lambda service encountered an internal error.
HTTP Status Code: 500
TooManyRequestsException
The request throughput limit was exceeded. For more information, see Lambda quotas .
HTTP Status Code: 429
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS Command Line Interface
•AWS SDK for .NET
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for JavaScript
•AWS SDK for PHP V3
•AWS SDK for Python
•AWS SDK for Ruby V3
Data Types
The following data types are supported:
•AccountLimit (p. 1538 )
•AccountUsage (p. 1539 )
•AliasConﬁguration  (p. 1540 )
•AliasRoutingConﬁguration (p. 1542 )
•AllowedPublishers (p. 1543 )
1535AWS Lambda Developer Guide
Data Types
•AmazonManagedKafkaEventSourceConﬁg (p. 1544 )
•CodeSigningConﬁg  (p. 1545 )
•CodeSigningPolicies (p. 1547 )
•Concurrency (p. 1548 )
•Cors  (p. 1549 )
•DeadLetterConﬁg (p. 1551 )
•DestinationConﬁg  (p. 1552 )
•DocumentDBEventSourceConﬁg (p. 1553 )
•Environment (p. 1554 )
•EnvironmentError (p. 1555 )
•EnvironmentResponse (p. 1556 )
•EphemeralStorage  (p. 1557 )
•EventSourceMappingConﬁguration (p. 1558 )
•FileSystemConﬁg (p. 1563 )
•Filter  (p. 1564 )
•FilterCriteria  (p. 1565 )
•FunctionCode (p. 1566 )
•FunctionCodeLocation (p. 1568 )
•FunctionConﬁguration (p. 1569 )
•FunctionEventInvokeConﬁg (p. 1575 )
•FunctionUrlConﬁg (p. 1577 )
•ImageConﬁg  (p. 1579 )
•ImageConﬁgError (p. 1580 )
•ImageConﬁgResponse (p. 1581 )
•InvokeResponseStreamUpdate (p. 1582 )
•InvokeWithResponseStreamCompleteEvent (p. 1583 )
•InvokeWithResponseStreamResponseEvent (p. 1584 )
•Layer (p. 1585 )
•LayersListItem (p. 1586 )
•LayerVersionContentInput (p. 1587 )
•LayerVersionContentOutput (p. 1588 )
•LayerVersionsListItem (p. 1589 )
•OnFailure (p. 1591 )
•OnSuccess (p. 1592 )
•ProvisionedConcurrencyConﬁgListItem (p. 1593 )
•RuntimeVersionConﬁg (p. 1595 )
•RuntimeVersionError (p. 1596 )
•ScalingConﬁg  (p. 1597 )
•SelfManagedEventSource (p. 1598 )
•SelfManagedKafkaEventSourceConﬁg (p. 1599 )
•SnapStart (p. 1600 )
•SnapStartResponse (p. 1601 )
•SourceAccessConﬁguration (p. 1602 )
•TracingConﬁg (p. 1604 )
•TracingConﬁgResponse (p. 1605 )
•VpcConﬁg (p. 1606 )
1536AWS Lambda Developer Guide
Data Types
•VpcConﬁgResponse (p. 1607 )
1537AWS Lambda Developer Guide
AccountLimit
AccountLimit
Limits that are related to concurrency and storage. All ﬁle and storage sizes are in bytes.
Contents
CodeSizeUnzipped
The maximum size of a function's deployment package and layers when they're extracted.
Type: Long
Required: No
CodeSizeZipped
The maximum size of a deployment package when it's uploaded directly to Lambda. Use Amazon S3 
for larger ﬁles.
Type: Long
Required: No
ConcurrentExecutions
The maximum number of simultaneous function executions.
Type: Integer
Required: No
TotalCodeSize
The amount of storage space that you can use for all deployment packages and layer archives.
Type: Long
Required: No
UnreservedConcurrentExecutions
The maximum number of simultaneous function executions, minus the capacity that's reserved for 
individual functions with PutFunctionConcurrency (p. 1466 ).
Type: Integer
Valid Range: Minimum value of 0.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1538AWS Lambda Developer Guide
AccountUsage
AccountUsage
The number of functions and amount of storage in use.
Contents
FunctionCount
The number of Lambda functions.
Type: Long
Required: No
TotalCodeSize
The amount of storage space, in bytes, that's being used by deployment packages and layer archives.
Type: Long
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1539AWS Lambda Developer Guide
AliasConﬁguration
AliasConﬁguration
Provides conﬁguration information about a Lambda function alias .
Contents
AliasArn
The Amazon Resource Name (ARN) of the alias.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
Description
A description of the alias.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
FunctionVersion
The function version that the alias invokes.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Required: No
Name
The name of the alias.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 128.
Pattern: (?!^[0-9]+$)([a-zA-Z0-9-_]+)
Required: No
RevisionId
A unique identiﬁer that changes when you update the alias.
Type: String
Required: No
RoutingConﬁg
The routing conﬁguration of the alias.
Type: AliasRoutingConﬁguration (p. 1542 ) object
1540AWS Lambda Developer Guide
AliasConﬁguration
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1541AWS Lambda Developer Guide
AliasRoutingConﬁguration
AliasRoutingConﬁguration
The traﬃc-shifting conﬁguration of a Lambda function alias.
Contents
AdditionalVersionWeights
The second version, and the percentage of traﬃc that's routed to it.
Type: String to double map
Key Length Constraints: Minimum length of 1. Maximum length of 1024.
Key Pattern: [0-9]+
Valid Range: Minimum value of 0.0. Maximum value of 1.0.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1542AWS Lambda Developer Guide
AllowedPublishers
AllowedPublishers
List of signing proﬁles that can sign a code package.
Contents
SigningProﬁleVersionArns
The Amazon Resource Name (ARN) for each of the signing proﬁles. A signing proﬁle deﬁnes a 
trusted user who can sign a code package.
Type: Array of strings
Array Members: Minimum number of 1 item. Maximum number of 20 items.
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: Yes
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1543AWS Lambda Developer Guide
AmazonManagedKafkaEventSourceConﬁg
AmazonManagedKafkaEventSourceConﬁg
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Contents
ConsumerGroupId
The identiﬁer for the Kafka consumer group to join. The consumer group ID must be unique among 
all your Kafka event sources. After creating a Kafka event source mapping with the consumer group 
ID speciﬁed, you cannot update this value. For more information, see Customizable consumer group 
ID.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 200.
Pattern: [a-zA-Z0-9-\/*:_+=.@-]*
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1544AWS Lambda Developer Guide
CodeSigningConﬁg
CodeSigningConﬁg
Details about a Code signing conﬁguration.
Contents
AllowedPublishers
List of allowed publishers.
Type: AllowedPublishers (p. 1543 ) object
Required: Yes
CodeSigningConﬁgArn
The Amazon Resource Name (ARN) of the Code signing conﬁguration.
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
Required: Yes
CodeSigningConﬁgId
Unique identifer for the Code signing conﬁguration.
Type: String
Pattern: csc-[a-zA-Z0-9-_\.]{17}
Required: Yes
CodeSigningPolicies
The code signing policy controls the validation failure action for signature mismatch or expiry.
Type: CodeSigningPolicies (p. 1547 ) object
Required: Yes
LastModiﬁed
The date and time that the Code signing conﬁguration was last modiﬁed, in ISO-8601 format (YYYY-
MM-DDThh:mm:ss.sTZD).
Type: String
Required: Yes
Description
Code signing conﬁguration description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
1545AWS Lambda Developer Guide
CodeSigningConﬁg
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1546AWS Lambda Developer Guide
CodeSigningPolicies
CodeSigningPolicies
Code signing conﬁguration policies  specify the validation failure action for signature mismatch or expiry.
Contents
UntrustedArtifactOnDeployment
Code signing conﬁguration policy for deployment validation failure. If you set the policy to
Enforce, Lambda blocks the deployment request if signature validation checks fail. If you set the 
policy to Warn, Lambda allows the deployment and creates a CloudWatch log.
Default value: Warn
Type: String
Valid Values: Warn | Enforce
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1547AWS Lambda Developer Guide
Concurrency
Concurrency
Contents
ReservedConcurrentExecutions
The number of concurrent executions that are reserved for this function. For more information, see
Managing Lambda reserved concurrency.
Type: Integer
Valid Range: Minimum value of 0.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1548AWS Lambda Developer Guide
Cors
Cors
The cross-origin resource sharing (CORS) settings for your Lambda function URL. Use CORS to grant 
access to your function URL from any origin. You can also use CORS to control access for speciﬁc HTTP 
headers and methods in requests to your function URL.
Contents
AllowCredentials
Whether to allow cookies or other credentials in requests to your function URL. The default is
false .
Type: Boolean
Required: No
AllowHeaders
The HTTP headers that origins can include in requests to your function URL. For example: Date ,
Keep-Alive , X-Custom-Header .
Type: Array of strings
Array Members: Maximum number of 100 items.
Length Constraints: Maximum length of 1024.
Pattern: .*
Required: No
AllowMethods
The HTTP methods that are allowed when calling your function URL. For example: GET, POST ,
DELETE, or the wildcard character (*).
Type: Array of strings
Array Members: Maximum number of 6 items.
Length Constraints: Maximum length of 6.
Pattern: .*
Required: No
AllowOrigins
The origins that can access your function URL. You can list any number of speciﬁc origins, separated 
by a comma. For example: https://www.example.com , http://localhost:60905 .
Alternatively, you can grant access to all origins using the wildcard character (*).
Type: Array of strings
Array Members: Maximum number of 100 items.
Length Constraints: Minimum length of 1. Maximum length of 253.
Pattern: .*
1549AWS Lambda Developer Guide
Cors
Required: No
ExposeHeaders
The HTTP headers in your function response that you want to expose to origins that call your 
function URL. For example: Date , Keep-Alive , X-Custom-Header .
Type: Array of strings
Array Members: Maximum number of 100 items.
Length Constraints: Maximum length of 1024.
Pattern: .*
Required: No
MaxAge
The maximum amount of time, in seconds, that web browsers can cache results of a preﬂight 
request. By default, this is set to 0, which means that the browser doesn't cache results.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 86400.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1550AWS Lambda Developer Guide
DeadLetterConﬁg
DeadLetterConﬁg
The dead-letter queue for failed asynchronous invocations.
Contents
TargetArn
The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
Type: String
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1551AWS Lambda Developer Guide
DestinationConﬁg
DestinationConﬁg
A conﬁguration object that speciﬁes the destination of an event after Lambda processes it.
Contents
OnFailure
The destination conﬁguration for failed invocations.
Type: OnFailure (p. 1591 ) object
Required: No
OnSuccess
The destination conﬁguration for successful invocations.
Type: OnSuccess (p. 1592 ) object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1552AWS Lambda Developer Guide
DocumentDBEventSourceConﬁg
DocumentDBEventSourceConﬁg
Speciﬁc conﬁguration settings for a DocumentDB event source.
Contents
CollectionName
The name of the collection to consume within the database. If you do not specify a collection, 
Lambda consumes all collections.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 57.
Pattern: (^(?!(system\x2e)))(^[_a-zA-Z0-9])([^$]*)
Required: No
DatabaseName
The name of the database to consume within the DocumentDB cluster.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 63.
Pattern: [^ /\.$\x22]*
Required: No
FullDocument
Determines what DocumentDB sends to your event stream during document update operations. If 
set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the 
entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
Type: String
Valid Values: UpdateLookup | Default
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1553AWS Lambda Developer Guide
Environment
Environment
A function's environment variable settings. You can use environment variables to adjust your function's 
behavior without updating code. An environment variable is a pair of strings that are stored in a 
function's version-speciﬁc conﬁguration.
Contents
Variables
Environment variable key-value pairs. For more information, see Using Lambda environment 
variables .
Type: String to string map
Key Pattern: [a-zA-Z]([a-zA-Z0-9_])+
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1554AWS Lambda Developer Guide
EnvironmentError
EnvironmentError
Error messages for environment variables that couldn't be applied.
Contents
ErrorCode
The error code.
Type: String
Required: No
Message
The error message.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1555AWS Lambda Developer Guide
EnvironmentResponse
EnvironmentResponse
The results of an operation to update or read environment variables. If the operation succeeds, the 
response contains the environment variables. If it fails, the response contains details about the error.
Contents
Error
Error messages for environment variables that couldn't be applied.
Type: EnvironmentError (p. 1555 ) object
Required: No
Variables
Environment variable key-value pairs. Omitted from AWS CloudTrail logs.
Type: String to string map
Key Pattern: [a-zA-Z]([a-zA-Z0-9_])+
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1556AWS Lambda Developer Guide
EphemeralStorage
EphemeralStorage
The size of the function's /tmp directory in MB. The default value is 512, but it can be any whole number 
between 512 and 10,240 MB.
Contents
Size
The size of the function's /tmp directory.
Type: Integer
Valid Range: Minimum value of 512. Maximum value of 10240.
Required: Yes
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1557AWS Lambda Developer Guide
EventSourceMappingConﬁguration
EventSourceMappingConﬁguration
A mapping between an AWS resource and a Lambda function. For details, see
CreateEventSourceMapping (p. 1292 ).
Contents
AmazonManagedKafkaEventSourceConﬁg
Speciﬁc conﬁguration settings for an Amazon Managed Streaming for Apache Kafka (Amazon MSK) 
event source.
Type: AmazonManagedKafkaEventSourceConﬁg (p. 1544 ) object
Required: No
BatchSize
The maximum number of records in each batch that Lambda pulls from your stream or queue and 
sends to your function. Lambda passes all of the records in the batch to the function in a single call, 
up to the payload limit for synchronous invocation (6 MB).
Default value: Varies by service. For Amazon SQS, the default is 10. For all other services, the default 
is 100.
Related setting: When you set BatchSize  to a value greater than 10, you must set
MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10000.
Required: No
BisectBatchOnFunctionError
(Kinesis and DynamoDB Streams only) If the function returns an error, split the batch in two and 
retry. The default value is false.
Type: Boolean
Required: No
DestinationConﬁg
(Kinesis and DynamoDB Streams only) An Amazon SQS queue or Amazon SNS topic destination for 
discarded records.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
DocumentDBEventSourceConﬁg
Speciﬁc conﬁguration settings for a DocumentDB event source.
Type: DocumentDBEventSourceConﬁg (p. 1553 ) object
Required: No
EventSourceArn
The Amazon Resource Name (ARN) of the event source.
1558AWS Lambda Developer Guide
EventSourceMappingConﬁguration
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
FilterCriteria
An object that deﬁnes the ﬁlter criteria that determine whether Lambda should process an event. 
For more information, see Lambda event ﬁltering.
Type: FilterCriteria  (p. 1565 ) object
Required: No
FunctionArn
The ARN of the Lambda function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
FunctionResponseTypes
(Kinesis, DynamoDB Streams, and Amazon SQS) A list of current response type enums applied to the 
event source mapping.
Type: Array of strings
Array Members: Minimum number of 0 items. Maximum number of 1 item.
Valid Values: ReportBatchItemFailures
Required: No
LastModiﬁed
The date that the event source mapping was last updated or that its state changed, in Unix time 
seconds.
Type: Timestamp
Required: No
LastProcessingResult
The result of the last Lambda invocation of your function.
Type: String
Required: No
MaximumBatchingWindowInSeconds
The maximum amount of time, in seconds, that Lambda spends gathering records before invoking 
the function. You can conﬁgure MaximumBatchingWindowInSeconds  to any value from 0 seconds 
to 300 seconds in increments of seconds.
For streams and Amazon SQS event sources, the default batching window is 0 seconds. 
For Amazon MSK, Self-managed Apache Kafka, Amazon MQ, and DocumentDB event 
sources, the default batching window is 500 ms. Note that because you can only change
1559AWS Lambda Developer Guide
EventSourceMappingConﬁguration
MaximumBatchingWindowInSeconds  in increments of seconds, you cannot revert back to the 500 
ms default batching window after you have changed it. To restore the default batching window, you 
must create a new event source mapping.
Related setting: For streams and Amazon SQS event sources, when you set BatchSize  to a value 
greater than 10, you must set MaximumBatchingWindowInSeconds  to at least 1.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 300.
Required: No
MaximumRecordAgeInSeconds
(Kinesis and DynamoDB Streams only) Discard records older than the speciﬁed age. The default 
value is -1, which sets the maximum age to inﬁnite. When the value is set to inﬁnite, Lambda never 
discards old records.
Note
The minimum valid value for maximum record age is 60s. Although values less than 60 and 
greater than -1 fall within the parameter's absolute range, they are not allowed
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 604800.
Required: No
MaximumRetryAttempts
(Kinesis and DynamoDB Streams only) Discard records after the speciﬁed number of 
retries. The default value is -1, which sets the maximum number of retries to inﬁnite. When 
MaximumRetryAttempts is inﬁnite, Lambda retries failed records until the record expires in the event 
source.
Type: Integer
Valid Range: Minimum value of -1. Maximum value of 10000.
Required: No
ParallelizationFactor
(Kinesis and DynamoDB Streams only) The number of batches to process concurrently from each 
shard. The default value is 1.
Type: Integer
Valid Range: Minimum value of 1. Maximum value of 10.
Required: No
Queues
(Amazon MQ) The name of the Amazon MQ broker destination queue to consume.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 1000.
Pattern: [\s\S]*
1560AWS Lambda Developer Guide
EventSourceMappingConﬁguration
Required: No
ScalingConﬁg
(Amazon SQS only) The scaling conﬁguration for the event source. For more information, see
Conﬁguring maximum concurrency for Amazon SQS event sources.
Type: ScalingConﬁg  (p. 1597 ) object
Required: No
SelfManagedEventSource
The self-managed Apache Kafka cluster for your event source.
Type: SelfManagedEventSource (p. 1598 ) object
Required: No
SelfManagedKafkaEventSourceConﬁg
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Type: SelfManagedKafkaEventSourceConﬁg (p. 1599 ) object
Required: No
SourceAccessConﬁgurations
An array of the authentication protocol, VPC components, or virtual host to secure and deﬁne your 
event source.
Type: Array of SourceAccessConﬁguration (p. 1602 ) objects
Array Members: Minimum number of 0 items. Maximum number of 22 items.
Required: No
StartingPosition
The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon 
DynamoDB Stream event sources. AT_TIMESTAMP  is supported only for Amazon Kinesis streams, 
Amazon DocumentDB, Amazon MSK, and self-managed Apache Kafka.
Type: String
Valid Values: TRIM_HORIZON | LATEST | AT_TIMESTAMP
Required: No
StartingPositionTimestamp
With StartingPosition  set to AT_TIMESTAMP , the time from which to start reading, in Unix time 
seconds. StartingPositionTimestamp  cannot be in the future.
Type: Timestamp
Required: No
State
The state of the event source mapping. It can be one of the following: Creating , Enabling ,
Enabled , Disabling , Disabled , Updating , or Deleting .
Type: String
Required: No
1561AWS Lambda Developer Guide
EventSourceMappingConﬁguration
StateTransitionReason
Indicates whether a user or Lambda made the last change to the event source mapping.
Type: String
Required: No
Topics
The name of the Kafka topic.
Type: Array of strings
Array Members: Fixed number of 1 item.
Length Constraints: Minimum length of 1. Maximum length of 249.
Pattern: ^[^.]([a-zA-Z0-9\-_.]+)
Required: No
TumblingWindowInSeconds
(Kinesis and DynamoDB Streams only) The duration in seconds of a processing window for 
DynamoDB and Kinesis Streams event sources. A value of 0 seconds indicates no tumbling window.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 900.
Required: No
UUID
The identiﬁer of the event source mapping.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1562AWS Lambda Developer Guide
FileSystemConﬁg
FileSystemConﬁg
Details about the connection between a Lambda function and an Amazon EFS ﬁle system.
Contents
Arn
The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the ﬁle 
system.
Type: String
Length Constraints: Maximum length of 200.
Pattern: arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-
z]+-\d{1}:\d{12}:access-point/fsap-[a-f0-9]{17}
Required: Yes
LocalMountPath
The path where the function can access the ﬁle system, starting with /mnt/ .
Type: String
Length Constraints: Maximum length of 160.
Pattern: ^/mnt/[a-zA-Z0-9-_.]+$
Required: Yes
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1563AWS Lambda Developer Guide
Filter
Filter
A structure within a FilterCriteria  object that deﬁnes an event ﬁltering pattern.
Contents
Pattern
A ﬁlter pattern. For more information on the syntax of a ﬁlter pattern, see  Filter rule syntax .
Type: String
Length Constraints: Minimum length of 0. Maximum length of 4096.
Pattern: .*
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1564AWS Lambda Developer Guide
FilterCriteria
FilterCriteria
An object that contains the ﬁlters for an event source.
Contents
Filters
A list of ﬁlters.
Type: Array of Filter  (p. 1564 ) objects
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1565AWS Lambda Developer Guide
FunctionCode
FunctionCode
The code for the Lambda function. You can either specify an object in Amazon S3, upload a .zip ﬁle 
archive deployment package directly, or specify the URI of a container image.
Contents
ImageUri
URI of a container image in the Amazon ECR registry.
Type: String
Required: No
S3Bucket
An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a diﬀerent 
AWS account.
Type: String
Length Constraints: Minimum length of 3. Maximum length of 63.
Pattern: ^[0-9A-Za-z\.\-_]*(?<!\.)$
Required: No
S3Key
The Amazon S3 key of the deployment package.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
S3ObjectVersion
For versioned objects, the version of the deployment package object to use.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
ZipFile
The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the 
encoding for you.
Type: Base64-encoded binary data object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
1566AWS Lambda Developer Guide
FunctionCode
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1567AWS Lambda Developer Guide
FunctionCodeLocation
FunctionCodeLocation
Details about a function's deployment package.
Contents
ImageUri
URI of a container image in the Amazon ECR registry.
Type: String
Required: No
Location
A presigned URL that you can use to download the deployment package.
Type: String
Required: No
RepositoryType
The service that's hosting the ﬁle.
Type: String
Required: No
ResolvedImageUri
The resolved URI for the image.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1568AWS Lambda Developer Guide
FunctionConﬁguration
FunctionConﬁguration
Details about a function's conﬁguration.
Contents
Architectures
The instruction set architecture that the function supports. Architecture is a string array with one of 
the valid values. The default architecture value is x86_64 .
Type: Array of strings
Array Members: Fixed number of 1 item.
Valid Values: x86_64 | arm64
Required: No
CodeSha256
The SHA256 hash of the function's deployment package.
Type: String
Required: No
CodeSize
The size of the function's deployment package, in bytes.
Type: Long
Required: No
DeadLetterConﬁg
The function's dead letter queue.
Type: DeadLetterConﬁg (p. 1551 ) object
Required: No
Description
The function's description.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
Environment
The function's environment variables. Omitted from AWS CloudTrail logs.
Type: EnvironmentResponse (p. 1556 ) object
Required: No
EphemeralStorage
The size of the function’s /tmp directory in MB. The default value is 512, but it can be any whole 
number between 512 and 10,240 MB.
1569AWS Lambda Developer Guide
FunctionConﬁguration
Type: EphemeralStorage  (p. 1557 ) object
Required: No
FileSystemConﬁgs
Connection settings for an Amazon EFS ﬁle system.
Type: Array of FileSystemConﬁg (p. 1563 ) objects
Array Members: Maximum number of 1 item.
Required: No
FunctionArn
The function's Amazon Resource Name (ARN).
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
FunctionName
The name of the function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 170.
Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?
(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
Handler
The function that Lambda calls to begin running your function.
Type: String
Length Constraints: Maximum length of 128.
Pattern: [^\s]+
Required: No
ImageConﬁgResponse
The function's image conﬁguration values.
Type: ImageConﬁgResponse (p. 1581 ) object
Required: No
KMSKeyArn
The AWS KMS key that's used to encrypt the function's environment variables. When Lambda 
SnapStart is activated, this key is also used to encrypt the function's snapshot. This key is returned 
only if you've conﬁgured a customer managed key.
Type: String
1570AWS Lambda Developer Guide
FunctionConﬁguration
Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
Required: No
LastModiﬁed
The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
Required: No
LastUpdateStatus
The status of the last update that was performed on the function. This is ﬁrst set to Successful
after function creation completes.
Type: String
Valid Values: Successful | Failed | InProgress
Required: No
LastUpdateStatusReason
The reason for the last update that was performed on the function.
Type: String
Required: No
LastUpdateStatusReasonCode
The reason code for the last update that was performed on the function.
Type: String
Valid Values: EniLimitExceeded | InsufficientRolePermissions | 
InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | 
InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | 
InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | 
DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | 
EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
Required: No
Layers
The function's layers.
Type: Array of Layer (p. 1585 ) objects
Required: No
MasterArn
For Lambda@Edge functions, the ARN of the main function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
1571AWS Lambda Developer Guide
FunctionConﬁguration
MemorySize
The amount of memory available to the function at runtime.
Type: Integer
Valid Range: Minimum value of 128. Maximum value of 10240.
Required: No
PackageType
The type of deployment package. Set to Image for container image and set Zip for .zip ﬁle archive.
Type: String
Valid Values: Zip | Image
Required: No
RevisionId
The latest updated revision of the function or alias.
Type: String
Required: No
Role
The function's execution role.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
Required: No
Runtime
The identiﬁer of the function's runtime . Runtime is required if the deployment package is a .zip ﬁle 
archive.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: String
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Required: No
RuntimeVersionConﬁg
The ARN of the runtime and any errors that occured.
Type: RuntimeVersionConﬁg (p. 1595 ) object
Required: No
1572AWS Lambda Developer Guide
FunctionConﬁguration
SigningJobArn
The ARN of the signing job.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
SigningProﬁleVersionArn
The ARN of the signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
SnapStart
Set ApplyOn  to PublishedVersions  to create a snapshot of the initialized execution environment 
when you publish a function version. For more information, see Improving startup performance with 
Lambda SnapStart.
Type: SnapStartResponse (p. 1601 ) object
Required: No
State
The current state of the function. When the state is Inactive , you can reactivate the function by 
invoking it.
Type: String
Valid Values: Pending | Active | Inactive | Failed
Required: No
StateReason
The reason for the function's current state.
Type: String
Required: No
StateReasonCode
The reason code for the function's current state. When the code is Creating , you can't invoke or 
modify the function.
Type: String
Valid Values: Idle | Creating | Restoring | EniLimitExceeded | 
InsufficientRolePermissions | InvalidConfiguration | InternalError 
| SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | 
ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied 
| KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError 
| EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | 
InvalidRuntime | InvalidZipFileException | FunctionError
1573AWS Lambda Developer Guide
FunctionConﬁguration
Required: No
Timeout
The amount of time in seconds that Lambda allows a function to run before stopping it.
Type: Integer
Valid Range: Minimum value of 1.
Required: No
TracingConﬁg
The function's AWS X-Ray tracing conﬁguration.
Type: TracingConﬁgResponse (p. 1605 ) object
Required: No
Version
The version of the Lambda function.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Pattern: (\$LATEST|[0-9]+)
Required: No
VpcConﬁg
The function's networking conﬁguration.
Type: VpcConﬁgResponse (p. 1607 ) object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1574AWS Lambda Developer Guide
FunctionEventInvokeConﬁg
FunctionEventInvokeConﬁg
Contents
DestinationConﬁg
A destination for events after they have been sent to a function for processing.
Destinations
•Function - The Amazon Resource Name (ARN) of a Lambda function.
•Queue  - The ARN of a standard SQS queue.
•Topic - The ARN of a standard SNS topic.
•Event Bus - The ARN of an Amazon EventBridge event bus.
Type: DestinationConﬁg  (p. 1552 ) object
Required: No
FunctionArn
The Amazon Resource Name (ARN) of the function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
LastModiﬁed
The date and time that the conﬁguration was last updated, in Unix time seconds.
Type: Timestamp
Required: No
MaximumEventAgeInSeconds
The maximum age of a request that Lambda sends to a function for processing.
Type: Integer
Valid Range: Minimum value of 60. Maximum value of 21600.
Required: No
MaximumRetryAttempts
The maximum number of times to retry when the function returns an error.
Type: Integer
Valid Range: Minimum value of 0. Maximum value of 2.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
1575AWS Lambda Developer Guide
FunctionEventInvokeConﬁg
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1576AWS Lambda Developer Guide
FunctionUrlConﬁg
FunctionUrlConﬁg
Details about a Lambda function URL.
Contents
AuthType
The type of authentication that your function URL uses. Set to AWS_IAM if you want to restrict 
access to authenticated users only. Set to NONE if you want to bypass IAM authentication to create a 
public endpoint. For more information, see Security and auth model for Lambda function URLs.
Type: String
Valid Values: NONE | AWS_IAM
Required: Yes
CreationTime
When the function URL was created, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
Type: String
Required: Yes
FunctionArn
The Amazon Resource Name (ARN) of your function.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: Yes
FunctionUrl
The HTTP URL endpoint for your function.
Type: String
Length Constraints: Minimum length of 40. Maximum length of 100.
Required: Yes
LastModiﬁedTime
When the function URL conﬁguration was last updated, in ISO-8601 format (YYYY-MM-
DDThh:mm:ss.sTZD).
Type: String
Required: Yes
Cors
The cross-origin resource sharing (CORS) settings for your function URL.
Type: Cors  (p. 1549 ) object
Required: No
1577AWS Lambda Developer Guide
FunctionUrlConﬁg
InvokeMode
Use one of the following options:
•BUFFERED  – This is the default option. Lambda invokes your function using the Invoke  API 
operation. Invocation results are available when the payload is complete. The maximum payload 
size is 6 MB.
•RESPONSE_STREAM  – Your function streams payload results as they become available. Lambda 
invokes your function using the InvokeWithResponseStream  API operation. The maximum 
response payload size is 20 MB, however, you can request a quota increase.
Type: String
Valid Values: BUFFERED | RESPONSE_STREAM
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1578AWS Lambda Developer Guide
ImageConﬁg
ImageConﬁg
Conﬁguration values that override the container image Dockerﬁle settings. For more information, see
Container image settings.
Contents
Command
Speciﬁes parameters that you want to pass in with ENTRYPOINT.
Type: Array of strings
Array Members: Maximum number of 1500 items.
Required: No
EntryPoint
Speciﬁes the entry point to their application, which is typically the location of the runtime 
executable.
Type: Array of strings
Array Members: Maximum number of 1500 items.
Required: No
WorkingDirectory
Speciﬁes the working directory.
Type: String
Length Constraints: Maximum length of 1000.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1579AWS Lambda Developer Guide
ImageConﬁgError
ImageConﬁgError
Error response to GetFunctionConfiguration .
Contents
ErrorCode
Error code.
Type: String
Required: No
Message
Error message.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1580AWS Lambda Developer Guide
ImageConﬁgResponse
ImageConﬁgResponse
Response to a GetFunctionConfiguration  request.
Contents
Error
Error response to GetFunctionConfiguration .
Type: ImageConﬁgError (p. 1580 ) object
Required: No
ImageConﬁg
Conﬁguration values that override the container image Dockerﬁle.
Type: ImageConﬁg  (p. 1579 ) object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1581AWS Lambda Developer Guide
InvokeResponseStreamUpdate
InvokeResponseStreamUpdate
A chunk of the streamed response payload.
Contents
Payload
Data returned by your Lambda function.
Type: Base64-encoded binary data object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1582AWS Lambda Developer Guide
InvokeWithResponseStreamCompleteEvent
InvokeWithResponseStreamCompleteEvent
A response conﬁrming that the event stream is complete.
Contents
ErrorCode
An error code.
Type: String
Required: No
ErrorDetails
The details of any returned error.
Type: String
Required: No
LogResult
The last 4 KB of the execution log, which is base64-encoded.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1583AWS Lambda Developer Guide
InvokeWithResponseStreamResponseEvent
InvokeWithResponseStreamResponseEvent
An object that includes a chunk of the response payload. When the stream has ended, Lambda includes a
InvokeComplete  object.
Contents
InvokeComplete
An object that's returned when the stream has ended and all the payload chunks have been 
returned.
Type: InvokeWithResponseStreamCompleteEvent (p. 1583 ) object
Required: No
PayloadChunk
A chunk of the streamed response payload.
Type: InvokeResponseStreamUpdate (p. 1582 ) object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1584AWS Lambda Developer Guide
Layer
Layer
An AWS Lambda layer.
Contents
Arn
The Amazon Resource Name (ARN) of the function layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
Required: No
CodeSize
The size of the layer archive in bytes.
Type: Long
Required: No
SigningJobArn
The Amazon Resource Name (ARN) of a signing job.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
SigningProﬁleVersionArn
The Amazon Resource Name (ARN) for a signing proﬁle version.
Type: String
Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1585AWS Lambda Developer Guide
LayersListItem
LayersListItem
Details about an AWS Lambda layer.
Contents
LatestMatchingVersion
The newest version of the layer.
Type: LayerVersionsListItem (p. 1589 ) object
Required: No
LayerArn
The Amazon Resource Name (ARN) of the function layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+
Required: No
LayerName
The name of the layer.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: (arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+)|
[a-zA-Z0-9-_]+
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1586AWS Lambda Developer Guide
LayerVersionContentInput
LayerVersionContentInput
A ZIP archive that contains the contents of an AWS Lambda layer. You can specify either an Amazon S3 
location, or upload a layer archive directly.
Contents
S3Bucket
The Amazon S3 bucket of the layer archive.
Type: String
Length Constraints: Minimum length of 3. Maximum length of 63.
Pattern: ^[0-9A-Za-z\.\-_]*(?<!\.)$
Required: No
S3Key
The Amazon S3 key of the layer archive.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
S3ObjectVersion
For versioned objects, the version of the layer archive object to use.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 1024.
Required: No
ZipFile
The base64-encoded contents of the layer archive. AWS SDK and AWS CLI clients handle the 
encoding for you.
Type: Base64-encoded binary data object
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1587AWS Lambda Developer Guide
LayerVersionContentOutput
LayerVersionContentOutput
Details about a version of an AWS Lambda layer.
Contents
CodeSha256
The SHA-256 hash of the layer archive.
Type: String
Required: No
CodeSize
The size of the layer archive in bytes.
Type: Long
Required: No
Location
A link to the layer archive in Amazon S3 that is valid for 10 minutes.
Type: String
Required: No
SigningJobArn
The Amazon Resource Name (ARN) of a signing job.
Type: String
Required: No
SigningProﬁleVersionArn
The Amazon Resource Name (ARN) for a signing proﬁle version.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1588AWS Lambda Developer Guide
LayerVersionsListItem
LayerVersionsListItem
Details about a version of an AWS Lambda layer.
Contents
CompatibleArchitectures
A list of compatible instruction set architectures.
Type: Array of strings
Array Members: Maximum number of 2 items.
Valid Values: x86_64 | arm64
Required: No
CompatibleRuntimes
The layer's compatible runtimes.
The following list includes deprecated runtimes. For more information, see Runtime deprecation 
policy.
Type: Array of strings
Array Members: Maximum number of 15 items.
Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | 
nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | 
python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 
| dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-
edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | 
python3.10 | java17 | ruby3.2 | python3.11
Required: No
CreatedDate
The date that the version was created, in ISO 8601 format. For example,
2018-11-27T15:10:45.123+0000 .
Type: String
Required: No
Description
The description of the version.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 256.
Required: No
LayerVersionArn
The ARN of the layer version.
Type: String
1589AWS Lambda Developer Guide
LayerVersionsListItem
Length Constraints: Minimum length of 1. Maximum length of 140.
Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:
[0-9]+
Required: No
LicenseInfo
The layer's open-source license.
Type: String
Length Constraints: Maximum length of 512.
Required: No
Version
The version number.
Type: Long
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1590AWS Lambda Developer Guide
OnFailure
OnFailure
A destination for events that failed processing.
Contents
Destination
The Amazon Resource Name (ARN) of the destination resource.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 350.
Pattern: ^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1591AWS Lambda Developer Guide
OnSuccess
OnSuccess
A destination for events that were processed successfully.
Contents
Destination
The Amazon Resource Name (ARN) of the destination resource.
Type: String
Length Constraints: Minimum length of 0. Maximum length of 350.
Pattern: ^$|arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-
\d{1})?:(\d{12})?:(.*)
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1592AWS Lambda Developer Guide
ProvisionedConcurrencyConﬁgListItem
ProvisionedConcurrencyConﬁgListItem
Details about the provisioned concurrency conﬁguration for a function alias or version.
Contents
AllocatedProvisionedConcurrentExecutions
The amount of provisioned concurrency allocated. When a weighted alias is used during linear 
and canary deployments, this value ﬂuctuates depending on the amount of concurrency that is 
provisioned for the function versions.
Type: Integer
Valid Range: Minimum value of 0.
Required: No
AvailableProvisionedConcurrentExecutions
The amount of provisioned concurrency available.
Type: Integer
Valid Range: Minimum value of 0.
Required: No
FunctionArn
The Amazon Resource Name (ARN) of the alias or version.
Type: String
Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:
\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
Required: No
LastModiﬁed
The date and time that a user last updated the conﬁguration, in ISO 8601 format.
Type: String
Required: No
RequestedProvisionedConcurrentExecutions
The amount of provisioned concurrency requested.
Type: Integer
Valid Range: Minimum value of 1.
Required: No
Status
The status of the allocation process.
Type: String
Valid Values: IN_PROGRESS | READY | FAILED
1593AWS Lambda Developer Guide
ProvisionedConcurrencyConﬁgListItem
Required: No
StatusReason
For failed allocations, the reason that provisioned concurrency could not be allocated.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1594AWS Lambda Developer Guide
RuntimeVersionConﬁg
RuntimeVersionConﬁg
The ARN of the runtime and any errors that occured.
Contents
Error
Error response when Lambda is unable to retrieve the runtime version for a function.
Type: RuntimeVersionError (p. 1596 ) object
Required: No
RuntimeVersionArn
The ARN of the runtime version you want the function to use.
Type: String
Length Constraints: Minimum length of 26. Maximum length of 2048.
Pattern: ^arn:(aws[a-zA-Z-]*):lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-
\d{1}::runtime:.+$
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1595AWS Lambda Developer Guide
RuntimeVersionError
RuntimeVersionError
Any error returned when the runtime version information for the function could not be retrieved.
Contents
ErrorCode
The error code.
Type: String
Required: No
Message
The error message.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1596AWS Lambda Developer Guide
ScalingConﬁg
ScalingConﬁg
(Amazon SQS only) The scaling conﬁguration for the event source. To remove the conﬁguration, pass an 
empty value.
Contents
MaximumConcurrency
Limits the number of concurrent instances that the Amazon SQS event source can invoke.
Type: Integer
Valid Range: Minimum value of 2. Maximum value of 1000.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1597AWS Lambda Developer Guide
SelfManagedEventSource
SelfManagedEventSource
The self-managed Apache Kafka cluster for your event source.
Contents
Endpoints
The list of bootstrap servers for your Kafka brokers in the following format:
"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"] .
Type: String to array of strings map
Map Entries: Maximum number of 2 items.
Valid Keys: KAFKA_BOOTSTRAP_SERVERS
Array Members: Minimum number of 1 item. Maximum number of 10 items.
Length Constraints: Minimum length of 1. Maximum length of 300.
Pattern: ^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|
[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]):[0-9]{1,5}
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1598AWS Lambda Developer Guide
SelfManagedKafkaEventSourceConﬁg
SelfManagedKafkaEventSourceConﬁg
Speciﬁc conﬁguration settings for a self-managed Apache Kafka event source.
Contents
ConsumerGroupId
The identiﬁer for the Kafka consumer group to join. The consumer group ID must be unique among 
all your Kafka event sources. After creating a Kafka event source mapping with the consumer group 
ID speciﬁed, you cannot update this value. For more information, see Customizable consumer group 
ID.
Type: String
Length Constraints: Minimum length of 1. Maximum length of 200.
Pattern: [a-zA-Z0-9-\/*:_+=.@-]*
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1599AWS Lambda Developer Guide
SnapStart
SnapStart
The function's Lambda SnapStart setting. Set ApplyOn  to PublishedVersions  to create a snapshot of 
the initialized execution environment when you publish a function version.
Contents
ApplyOn
Set to PublishedVersions  to create a snapshot of the initialized execution environment when you 
publish a function version.
Type: String
Valid Values: PublishedVersions | None
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1600AWS Lambda Developer Guide
SnapStartResponse
SnapStartResponse
The function's SnapStart setting.
Contents
ApplyOn
When set to PublishedVersions , Lambda creates a snapshot of the execution environment when 
you publish a function version.
Type: String
Valid Values: PublishedVersions | None
Required: No
OptimizationStatus
When you provide a qualiﬁed Amazon Resource Name (ARN), this response element indicates 
whether SnapStart is activated for the speciﬁed function version.
Type: String
Valid Values: On | Off
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1601AWS Lambda Developer Guide
SourceAccessConﬁguration
SourceAccessConﬁguration
To secure and deﬁne access to your event source, you can specify the authentication protocol, VPC 
components, or virtual host.
Contents
Type
The type of authentication protocol, VPC components, or virtual host for your event source. For 
example: "Type":"SASL_SCRAM_512_AUTH" .
•BASIC_AUTH  – (Amazon MQ) The AWS Secrets Manager secret that stores your broker credentials.
•BASIC_AUTH  – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for 
SASL/PLAIN authentication of your Apache Kafka brokers.
•VPC_SUBNET  – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda 
connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
•VPC_SECURITY_GROUP  – (Self-managed Apache Kafka) The VPC security group used to manage 
access to your self-managed Apache Kafka brokers.
•SASL_SCRAM_256_AUTH  – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret 
key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
•SASL_SCRAM_512_AUTH  – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN 
of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka 
brokers.
•VIRTUAL_HOST  –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. 
Lambda uses this RabbitMQ host as the event source. This property cannot be speciﬁed in an 
UpdateEventSourceMapping API call.
•CLIENT_CERTIFICATE_TLS_AUTH  – (Amazon MSK, self-managed Apache Kafka) The Secrets 
Manager ARN of your secret key containing the certiﬁcate chain (X.509 PEM), private key (PKCS#8 
PEM), and private key password (optional) used for mutual TLS authentication of your MSK/
Apache Kafka brokers.
•SERVER_ROOT_CA_CERTIFICATE  – (Self-managed Apache Kafka) The Secrets Manager ARN of 
your secret key containing the root CA certiﬁcate (X.509 PEM) used for TLS encryption of your 
Apache Kafka brokers.
Type: String
Valid Values: BASIC_AUTH | VPC_SUBNET | VPC_SECURITY_GROUP | SASL_SCRAM_512_AUTH 
| SASL_SCRAM_256_AUTH | VIRTUAL_HOST | CLIENT_CERTIFICATE_TLS_AUTH | 
SERVER_ROOT_CA_CERTIFICATE
Required: No
URI
The value for your chosen conﬁguration in Type. For example: "URI": 
"arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName" .
Type: String
Length Constraints: Minimum length of 1. Maximum length of 200.
Pattern: [a-zA-Z0-9-\/*:_+=.@-]*
Required: No
1602AWS Lambda Developer Guide
SourceAccessConﬁguration
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1603AWS Lambda Developer Guide
TracingConﬁg
TracingConﬁg
The function's AWS X-Ray tracing conﬁguration. To sample and record incoming requests, set Mode  to
Active .
Contents
Mode
The tracing mode.
Type: String
Valid Values: Active | PassThrough
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1604AWS Lambda Developer Guide
TracingConﬁgResponse
TracingConﬁgResponse
The function's AWS X-Ray tracing conﬁguration.
Contents
Mode
The tracing mode.
Type: String
Valid Values: Active | PassThrough
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1605AWS Lambda Developer Guide
VpcConﬁg
VpcConﬁg
The VPC security groups and subnets that are attached to a Lambda function. For more information, see
Conﬁguring a Lambda function to access resources in a VPC.
Contents
SecurityGroupIds
A list of VPC security group IDs.
Type: Array of strings
Array Members: Maximum number of 5 items.
Required: No
SubnetIds
A list of VPC subnet IDs.
Type: Array of strings
Array Members: Maximum number of 16 items.
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
1606AWS Lambda Developer Guide
VpcConﬁgResponse
VpcConﬁgResponse
The VPC security groups and subnets that are attached to a Lambda function.
Contents
SecurityGroupIds
A list of VPC security group IDs.
Type: Array of strings
Array Members: Maximum number of 5 items.
Required: No
SubnetIds
A list of VPC subnet IDs.
Type: Array of strings
Array Members: Maximum number of 16 items.
Required: No
VpcId
The ID of the VPC.
Type: String
Required: No
See Also
For more information about using this API in one of the language-speciﬁc AWS SDKs, see the following:
•AWS SDK for C++
•AWS SDK for Go
•AWS SDK for Java V2
•AWS SDK for Ruby V3
Certiﬁcate errors when using an SDK
Because AWS SDKs use the CA certiﬁcates from your computer, changes to the certiﬁcates on the AWS 
servers can cause connection failures when you attempt to use an SDK. You can prevent these failures by 
keeping your computer's CA certiﬁcates and operating system up-to-date. If you encounter this issue in a 
corporate environment and do not manage your own computer, you might need to ask an administrator 
to assist with the update process. The following list shows minimum operating system and Java versions:
•Microsoft Windows versions that have updates from January 2005 or later installed contain at least 
one of the required CAs in their trust list.
•Mac OS X 10.4 with Java for Mac OS X 10.4 Release 5 (February 2007), Mac OS X 10.5 (October 2007), 
and later versions contain at least one of the required CAs in their trust list.
1607AWS Lambda Developer Guide
Common Errors
•Red Hat Enterprise Linux 5 (March 2007), 6, and 7 and CentOS 5, 6, and 7 all contain at least one of 
the required CAs in their default trusted CA list.
•Java 1.4.2_12 (May 2006), 5 Update 2 (March 2005), and all later versions, including Java 6 (December 
2006), 7, and 8, contain at least one of the required CAs in their default trusted CA list.
When accessing the AWS Lambda management console or AWS Lambda API endpoints, whether through 
browsers or programmatically, you will need to ensure your client machines support any of the following 
CAs:
•Amazon Root CA 1
•Starﬁeld Services Root Certiﬁcate Authority - G2
•Starﬁeld Class 2 Certiﬁcation Authority
Root certiﬁcates from the ﬁrst two authorities are available from Amazon trust services, but keeping 
your computer up-to-date is the more straightforward solution. To learn more about ACM-provided 
certiﬁcates, see AWS Certiﬁcate Manager FAQs.
Common Errors
This section lists the errors common to the API actions of all AWS services. For errors speciﬁc to an API 
action for this service, see the topic for that API action.
AccessDeniedException
You do not have suﬃcient access to perform this action.
HTTP Status Code: 400
IncompleteSignature
The request signature does not conform to AWS standards.
HTTP Status Code: 400
InternalFailure
The request processing has failed because of an unknown error, exception or failure.
HTTP Status Code: 500
InvalidAction
The action or operation requested is invalid. Verify that the action is typed correctly.
HTTP Status Code: 400
InvalidClientTokenId
The X.509 certiﬁcate or AWS access key ID provided does not exist in our records.
HTTP Status Code: 403
NotAuthorized
You do not have permission to perform this action.
HTTP Status Code: 400
OptInRequired
The AWS access key ID needs a subscription for the service.
1608AWS Lambda Developer Guide
Common Parameters
HTTP Status Code: 403
RequestExpired
The request reached the service more than 15 minutes after the date stamp on the request or more 
than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp 
on the request is more than 15 minutes in the future.
HTTP Status Code: 400
ServiceUnavailable
The request has failed due to a temporary failure of the server.
HTTP Status Code: 503
ThrottlingException
The request was denied due to request throttling.
HTTP Status Code: 400
ValidationError
The input fails to satisfy the constraints speciﬁed by an AWS service.
HTTP Status Code: 400
Common Parameters
The following list contains the parameters that all actions use for signing Signature Version 4 requests 
with a query string. Any action-speciﬁc parameters are listed in the topic for that action. For more 
information about Signature Version 4, see Signing AWS API requests in the IAM User Guide .
Action
The action to be performed.
Type: string
Required: Yes
Version
The API version that the request is written for, expressed in the format YYYY-MM-DD.
Type: string
Required: Yes
X-Amz-Algorithm
The hash algorithm that you used to create the request signature.
Condition: Specify this parameter when you include authentication information in a query string 
instead of in the HTTP authorization header.
Type: string
Valid Values: AWS4-HMAC-SHA256
Required: Conditional
1609AWS Lambda Developer Guide
Common Parameters
X-Amz-Credential
The credential scope value, which is a string that includes your access key, the date, the region you 
are targeting, the service you are requesting, and a termination string ("aws4_request"). The value is 
expressed in the following format: access_key /YYYYMMDD/region /service/aws4_request.
For more information, see Create a signed AWS API request in the IAM User Guide .
Condition: Specify this parameter when you include authentication information in a query string 
instead of in the HTTP authorization header.
Type: string
Required: Conditional
X-Amz-Date
The date that is used to create the signature. The format must be ISO 8601 basic format 
(YYYYMMDD'T'HHMMSS'Z'). For example, the following date time is a valid X-Amz-Date value:
20120325T120000Z .
Condition: X-Amz-Date is optional for all requests; it can be used to override the date used for 
signing requests. If the Date header is speciﬁed in the ISO 8601 basic format, X-Amz-Date is not 
required. When X-Amz-Date is used, it always overrides the value of the Date header. For more 
information, see Elements of an AWS API request signature in the IAM User Guide .
Type: string
Required: Conditional
X-Amz-Security-Token
The temporary security token that was obtained through a call to AWS Security Token Service (AWS 
STS). For a list of services that support temporary security credentials from AWS STS, see AWS 
services that work with IAM in the IAM User Guide .
Condition: If you're using temporary security credentials from AWS STS, you must include the 
security token.
Type: string
Required: Conditional
X-Amz-Signature
Speciﬁes the hex-encoded signature that was calculated from the string to sign and the derived 
signing key.
Condition: Specify this parameter when you include authentication information in a query string 
instead of in the HTTP authorization header.
Type: string
Required: Conditional
X-Amz-SignedHeaders
Speciﬁes all the HTTP headers that were included as part of the canonical request. For more 
information about specifying signed headers, see Create a signed AWS API request in the IAM User 
Guide .
Condition: Specify this parameter when you include authentication information in a query string 
instead of in the HTTP authorization header.
1610AWS Lambda Developer Guide
Common Parameters
Type: string
Required: Conditional
1611AWS Lambda Developer Guide
Document history
The following table describes the important changes to the AWS Lambda Developer Guide since May 
2018. For notiﬁcation about updates to this documentation, subscribe to the RSS feed.
Change Description Date
Testing serverless functions and 
applicationsLearn about techniques to 
debug and automate testing 
serverless functions in the 
cloud. There is now a testing 
chapter and resources included 
in the Python and Typescript 
language sections. For details, 
see Testing serverless functions 
and applications .June 16, 2023
Ruby 3.2 runtime Lambda now supports a new 
runtime for Ruby 3.2. For more 
information, see Building 
Lambda functions with Ruby.June 7, 2023
Response streaming Lambda now supports streaming 
responses from functions. 
For more information, see
Conﬁguring a Lambda function 
to stream responses.April 6, 2023
Asynchronous invocation metricsLambda releases asynchronous 
invocation metrics. For more 
information, see Asynchronous 
invocation metrics.February 9, 2023
Runtime version controls Lambda releases new runtime 
versions that include security 
updates, bug ﬁxes, and new 
features. You can now control 
when your functions get 
updated to the new runtime 
versions. For more information, 
see Lambda runtime updates .January 23, 2023
Lambda SnapStart Use Lambda SnapStart to 
reduce startup time for Java 
functions without provisioning 
additional resources or 
implementing complex 
performance optimizations. For 
more information, see Improving 
startup performance with with 
Lambda SnapStart.November 28, 2022
Node.js 18 runtime Lambda now supports a new 
runtime for Node.js 18. Node.js 
18 uses Amazon Linux 2. For November 18, 2022
1612AWS Lambda Developer Guide
details, see Building Lambda 
functions with Node.js.
lambda:SourceFunctionArn 
condition keyFor an AWS resource, the
lambda:SourceFunctionArn
condition key ﬁlters access to 
the resource by the ARN of a 
Lambda function. For details, see
Working with Lambda execution 
environment credentials.July 1, 2022
Node.js 16 runtime Lambda now supports a new 
runtime for Node.js 16. Node.js 
16 uses Amazon Linux 2. For 
details, see Building Lambda 
functions with Node.js.May 11, 2022
Lambda function URLsLambda now supports function 
URLs, which are dedicated 
HTTP(S) endpoints for Lambda 
functions. For details, see
Lambda function URLs.April 6, 2022
Shared test events in the AWS 
Lambda consoleLambda now supports sharing 
test events with other users 
in the same AWS account. For 
details, see Testing Lambda 
functions in the console.March 16, 2022
PrincipalOrgId in resource-based 
policiesLambda now supports granting 
permissions to an organization 
in AWS Organizations. For 
details, see Using resource-based 
policies for AWS Lambda.March 11, 2022
.NET 6 runtime Lambda now supports a new 
runtime for .NET 6. For details, 
see Lambda runtimes .February 23, 2022
Event ﬁltering for Kinesis, 
DynamoDB, and Amazon SQS 
event sourcesLambda now supports event 
ﬁltering for Kinesis, DynamoDB, 
and Amazon SQS event sources. 
For details, see Lambda event 
ﬁltering .November 24, 2021
mTLS authentication for 
Amazon MSK and self-managed 
Apache Kafka event sourcesLambda now supports mTLS 
authentication for Amazon MSK 
and self-managed Apache Kafka 
event sources. For details, see
Using Lambda with Amazon 
MSK .November 19, 2021
Lambda on Graviton2Lambda now supports Graviton2 
for functions using arm64 
architecture. For details, 
see Lambda instruction set 
architectures.September 29, 2021
1613AWS Lambda Developer Guide
Python 3.9 runtimeLambda now supports a new 
runtime for Python 3.9. For 
details, see Lambda runtimes .August 16, 2021
New runtime versions for 
Node.js, Python, and JavaNew runtime versions are 
available for Node.js, Python, 
and Java. For details, see
Lambda runtimes .July 21, 2021
Support for RabbitMQ as an 
event source on LambdaLambda now supports Amazon 
MQ for RabbitMQ as an 
event source. Amazon MQ is 
a managed message broker 
service for Apache ActiveMQ and 
RabbitMQ that makes it easy 
to set up and operate message 
brokers in the cloud. For details, 
see Using Lambda with Amazon 
MQ.July 7, 2021
SASL/PLAIN authentication for 
self-managed Kafka on LambdaSASL/PLAIN is now a supported 
authentication mechanism 
for self-managed Kafka event 
sources on Lambda Customers 
already using SASL/PLAIN on 
their self-managed Kafka cluster 
can now easily use Lambda to 
build consumer applications 
without having to modify the 
way they authenticate. For 
details, see Using Lambda with 
self-managed Apache Kafka.June 29, 2021
Lambda Extensions APIGeneral availability for 
Lambda extensions. Use 
extensions to augment your 
Lambda functions. You can use 
extensions provided by Lambda 
Partners, or you can create your 
own Lambda extensions. For 
details, see Lambda Extensions 
API.May 24, 2021
New Lambda console 
experience (p. 1612 )The Lambda console has 
been redesigned to improve 
performance and consistency.March 2, 2021
Node.js 14 runtime Lambda now supports a new 
runtime for Node.js 14. Node.js 
14 uses Amazon Linux 2. For 
details, see Building Lambda 
functions with Node.js.January 27, 2021
1614AWS Lambda Developer Guide
Lambda container imagesLambda now supports functions 
deﬁned as container images. You 
can combine the ﬂexibility of 
container tooling with the agility 
and operational simplicity of 
Lambda to build applications. 
For details, see  Using container 
images with Lambda .December 1, 2020
Code signing for Lambda 
functionsLambda now supports code 
signing. Administrators can 
conﬁgure Lambda functions 
to accept only signed code on 
deployment. Lambda checks 
the signatures to ensure that 
the code is not altered or 
tampered. Additionally, Lambda 
ensures that the code is signed 
by trusted developers before 
accepting the deployment. For 
details, see Conﬁguring code 
signing for Lambda .November 23, 2020
Preview: Lambda Runtime Logs 
APILambda now supports the 
Runtime Logs API. Lambda 
extensions can use the Logs API 
to subscribe to log streams in 
the execution environment. For 
details, see Lambda Runtime 
Logs API .November 12, 2020
New event source to for Amazon 
MQLambda now supports Amazon 
MQ as an event source. Use a 
Lambda function to process 
records from your Amazon MQ 
message broker. For details, see
Using Lambda with Amazon MQ.November 5, 2020
Preview: Lambda Extensions APIUse Lambda extensions 
to augment your Lambda 
functions. You can use 
extensions provided by Lambda 
Partners, or you can create your 
own Lambda extensions. For 
details, see Lambda Extensions 
API.October 8, 2020
Support for Java 8 and custom 
runtimes on AL2Lambda now supports Java 8 
and custom runtimes on Amazon 
Linux 2. For details, see Lambda 
runtimes .August 12, 2020
1615AWS Lambda Developer Guide
New event source for Amazon 
Managed Streaming for Apache 
KafkaLambda now supports Amazon 
MSK as an event source. Use a 
Lambda function with Amazon 
MSK to process records in a 
Kafka topic. For details, see
Using Lambda with Amazon 
MSK .August 11, 2020
IAM condition keys for Amazon 
VPC settingsYou can now use Lambda-
speciﬁc condition keys for VPC 
settings. For example, you can 
require that all functions in your 
organization are connected to 
a VPC. You can also specify the 
subnets and security groups 
that the function's users can 
and can't use. For details, 
see Conﬁguring VPC for IAM 
functions.August 10, 2020
Concurrency settings for Kinesis 
HTTP/2 stream consumersYou can now use the following 
concurrency settings for 
Kinesis consumers with 
enhanced fan-out (HTTP/2 
streams): ParallelizationFactor, 
MaximumRetryAttempts, 
MaximumRecordAgeInSeconds, 
DestinationConﬁg, and 
BisectBatchOnFunctionError. For 
details, see Using AWS Lambda 
with Amazon Kinesis.July 7, 2020
Batch window for Kinesis 
HTTP/2 stream consumersYou can now conﬁgure 
a batch window 
(MaximumBatchingWindowInSeconds) 
for HTTP/2 streams. Lambda 
reads records from the stream 
until it has gathered a full 
batch, or until the batch window 
expires. For details, see Using 
AWS Lambda with Amazon 
Kinesis .June 18, 2020
Support for Amazon EFS ﬁle 
systemsYou can now connect an Amazon 
EFS ﬁle system to your Lambda 
functions for shared network 
ﬁle access. For details, see
Conﬁguring ﬁle system access 
for Lambda functions.June 16, 2020
1616AWS Lambda Developer Guide
AWS CDK sample applications in 
the Lambda consoleThe Lambda console now 
includes sample applications 
that use the AWS Cloud 
Development Kit (AWS CDK) 
for TypeScript. The AWS CDK 
is a framework that enables 
you to deﬁne your application 
resources in TypeScript, Python, 
Java, or .NET. For a tutorial 
on creating applications, see
Creating an application with 
continuous delivery in the 
Lambda console.June 1, 2020
Support for .NET Core 3.1.0 
runtime in AWS LambdaAWS Lambda now supports 
the .NET Core 3.1.0 runtime. For 
details, see .NET Core CLI.March 31, 2020
Support for API Gateway HTTP 
APIsUpdated and expanded 
documentation for using 
Lambda with API Gateway, 
including support for HTTP APIs. 
Added a sample application 
that creates an API and function 
with AWS CloudFormation. For 
details, see Using Lambda with 
Amazon API Gateway.March 23, 2020
Ruby 2.7 A new runtime is available for 
Ruby 2.7, ruby2.7, which is 
the ﬁrst Ruby runtime to use 
Amazon Linux 2. For details, see
Building Lambda functions with 
Ruby.February 19, 2020
Concurrency metricsLambda now reports the
ConcurrentExecutions
metric for all functions, aliases, 
and versions. You can view 
a graph for this metric on 
the monitoring page for 
your function. Previously,
ConcurrentExecutions  was 
only reported at the account 
level and for functions that 
use reserved concurrency. 
For details, see AWS Lambda 
function metrics.February 18, 2020
1617AWS Lambda Developer Guide
Update to function statesFunction states are now 
enforced for all functions by 
default. When you connect 
a function to a VPC, Lambda 
creates shared elastic network 
interfaces. This enables 
your function to scale up 
without creating additional 
network interfaces. During 
this time, you can't perform 
additional operations on the 
function, including updating its 
conﬁguration and publishing 
versions. In some cases, 
invocation is also impacted. 
Details about a function's 
current state are available from 
the Lambda API.
This update is being released 
in phases. For details, see
Updated Lambda states lifecycle 
for VPC networking on the 
AWS Compute Blog. For more 
information about states, see
AWS Lambda function states.January 24, 2020
Updates to function 
conﬁguration API outputAdded reason codes 
to StateReasonCode
(InvalidSubnet, 
InvalidSecurityGroup) and 
LastUpdateStatusReasonCode 
(SubnetOutOfIPAddresses, 
InvalidSubnet, 
InvalidSecurityGroup) for 
functions that connect to a 
VPC. For more information 
about states, see AWS Lambda 
function states.January 20, 2020
Provisioned concurrencyYou can now allocate 
provisioned concurrency for 
a function version or alias. 
Provisioned concurrency 
enables a function to scale 
without ﬂuctuations in latency. 
For details, see Managing 
concurrency for a Lambda 
function.December 3, 2019
1618AWS Lambda Developer Guide
Create a database proxyYou can now use the Lambda 
console to create a database 
proxy for a Lambda function. 
A database proxy enables 
a function to reach high 
concurrency levels without 
exhausting database 
connections. For details, see
Conﬁguring database access for 
a Lambda function.December 3, 2019
Percentiles support for the 
duration metricYou can now ﬁlter the duration 
metric based on percentiles. 
For details, see AWS Lambda 
metrics .November 26, 2019
Increased concurrency for 
stream event sourcesA new option for DynamoDB 
stream and Kinesis stream event 
source mappings enables you to 
process more than one batch at 
a time from each shard. When 
you increase the number of 
concurrent batches per shard, 
your function's concurrency can 
be up to 10 times the number 
of shards in your stream. For 
details, see Lambda event source 
mapping .November 25, 2019
Function statesWhen you create or update a 
function, it enters a pending 
state while Lambda provisions 
resources to support it. If you 
connect your function to a 
VPC, Lambda can create a 
shared elastic network interface 
right away, instead of creating 
network interfaces when your 
function is invoked. This results 
in better performance for 
VPC-connected functions, but 
might require an update to your 
automation. For details, see AWS 
Lambda function states.November 25, 2019
Error handling options for 
asynchronous invocationNew conﬁguration options are 
available for asynchronous 
invocation. You can conﬁgure 
Lambda to limit retries and set a 
maximum event age. For details, 
see Conﬁguring error handling 
for asynchronous invocation.November 25, 2019
1619AWS Lambda Developer Guide
Error handling for stream event 
sourcesNew conﬁguration options 
are available for event source 
mappings that read from 
streams. You can conﬁgure
DynamoDB stream and Kinesis 
stream event source mappings 
to limit retries and set a 
maximum record age. When 
errors occur, you can conﬁgure 
the event source mapping to 
split batches before retrying, 
and to send invocation records 
for failed batches to a queue or 
topic. For details, see Lambda 
event source mapping.November 25, 2019
Destinations for asynchronous 
invocationYou can now conﬁgure Lambda 
to send records of asynchronous 
invocations to another service. 
Invocation records contain 
details about the event, context, 
and function response. You can 
send invocation records to an 
SQS queue, SNS topic, Lambda 
function, or EventBridge event 
bus. For details, see Conﬁguring 
destinations for asynchronous 
invocation.November 25, 2019
New runtimes for Node.js, 
Python, and JavaNew runtimes are available for 
Node.js 12, Python 3.8, and 
Java 11. For details, see Lambda 
runtimes .November 18, 2019
FIFO queue support for Amazon 
SQS event sourcesYou can now create an event 
source mapping that reads from 
a ﬁrst-in, ﬁrst-out (FIFO) queue. 
Previously, only standard queues 
were supported. For details, see
Using Lambda with Amazon 
SQS.November 18, 2019
Create applications in the 
Lambda consoleApplication creation in the 
Lambda console is now generally 
available. For instructions, see
Creating an application with 
continuous delivery in the 
Lambda console.October 31, 2019
1620AWS Lambda Developer Guide
Create applications in the 
Lambda console (beta)You can now create a Lambda 
application with an integrated 
continuous delivery pipeline 
in the Lambda console. The 
console provides sample 
applications that you can use 
as a starting point for your own 
project. Choose between AWS 
CodeCommit and GitHub for 
source control. Each time you 
push changes to your repository, 
the included pipeline builds and 
deploys them automatically. 
For instructions, see Creating 
an application with continuous 
delivery in the Lambda console.October 3, 2019
Performance improvements for 
VPC-connected functionsLambda now uses a new type 
of elastic network interface 
that is shared by all functions 
in a virtual private cloud (VPC) 
subnet. When you connect a 
function to a VPC, Lambda 
creates a network interface for 
each combination of security 
group and subnet that you 
choose. When the shared 
network interfaces are available, 
the function no longer needs 
to create additional network 
interfaces as it scales up. 
This dramatically improves 
startup times. For details, see
Conﬁguring a Lambda function 
to access resources in a VPC.September 3, 2019
Stream batch settingsYou can now conﬁgure a batch 
window for Amazon DynamoDB
and Amazon Kinesis event 
source mappings. Conﬁgure 
a batch window of up to ﬁve 
minutes to buﬀer incoming 
records until a full batch is 
available. This reduces the 
number of times that your 
function is invoked when the 
stream is less active.August 29, 2019
CloudWatch Logs Insights 
integrationThe monitoring page in 
the Lambda console now 
includes reports from Amazon 
CloudWatch Logs Insights. For 
details, see Monitoring functions 
in the AWS Lambda console.June 18, 2019
1621AWS Lambda Developer Guide
Amazon Linux 2018.03The Lambda execution 
environment is being updated 
to use Amazon Linux 2018.03. 
For details, see Execution 
environment.May 21, 2019
Node.js 10 A new runtime is available for 
Node.js 10, nodejs10.x. This 
runtime uses Node.js 10.15 
and will be updated with the 
latest point release of Node.js 10 
periodically. Node.js 10 is also 
the ﬁrst runtime to use Amazon 
Linux 2. For details, see Building 
Lambda functions with Node.js.May 13, 2019
GetLayerVersionByArn API Use the GetLayerVersionByArn
API to download layer 
version information with 
the version ARN as input. 
Compared to GetLayerVersion, 
GetLayerVersionByArn lets you 
use the ARN directly instead of 
parsing it to get the layer name 
and version number.April 25, 2019
Ruby AWS Lambda now supports 
Ruby 2.5 with a new runtime. 
For details, see Building Lambda 
functions with Ruby.November 29, 2018
Layers With Lambda layers, you can 
package and deploy libraries, 
custom runtimes, and other 
dependencies separately from 
your function code. Share your 
layers with your other accounts 
or the whole world. For details, 
see Lambda layers.November 29, 2018
Custom runtimes Build a custom runtime to 
run Lambda functions in your 
favorite programming language. 
For details, see Custom Lambda 
runtimes .November 29, 2018
Application Load Balancer 
triggersElastic Load Balancing now 
supports Lambda functions as 
a target for Application Load 
Balancers. For details, see Using 
Lambda with application load 
balancers.November 29, 2018
1622AWS Lambda Developer Guide
Use Kinesis HTTP/2 stream 
consumers as a triggerYou can use Kinesis HTTP/2 
data stream consumers to send 
events to AWS Lambda. Stream 
consumers have dedicated read 
throughput from each shard 
in your data stream and use 
HTTP/2 to minimize latency. For 
details, see Using Lambda with 
Kinesis .November 19, 2018
Python 3.7 AWS Lambda now supports 
Python 3.7 with a new runtime. 
For more information, see
Building Lambda functions with 
Python.November 19, 2018
Payload limit increase for 
asynchronous function 
invocationThe maximum payload size 
for asynchronous invocations 
increased from 128 KB to 
256 KB, which matches the 
maximum message size from an 
Amazon SNS trigger. For details, 
see Lambda quotas .November 16, 2018
AWS GovCloud (US-East) RegionAWS Lambda is now available 
in the AWS GovCloud (US-East) 
Region.November 12, 2018
Moved AWS SAM topics to a 
separate Developer GuideA number of topics were 
focused on building serverless 
applications using the AWS 
Serverless Application Model 
(AWS SAM). These topics have 
been moved to AWS Serverless 
Application Model developer 
guide .October 25, 2018
View Lambda applications in the 
consoleYou can view the status of 
your Lambda applications 
on the Applications  page in 
the Lambda console. This 
page shows the status of the 
AWS CloudFormation stack. It 
includes links to pages where 
you can view more information 
about the resources in the stack. 
You can also view aggregate 
metrics for the application 
and create custom monitoring 
dashboards.October 11, 2018
Function execution timeout limitTo allow for long-running 
functions, the maximum 
conﬁgurable execution timeout 
increased from 5 minutes to 15 
minutes. For details, see Lambda 
limits .October 10, 2018
1623AWS Lambda Developer Guide
Earlier updates
Support for PowerShell Core 
language in AWS LambdaAWS Lambda now supports 
the PowerShell Core language. 
For more information, see
Programming model for 
authoring Lambda functions in 
PowerShell.September 11, 2018
Support for .NET Core 2.1.0 
runtime in AWS LambdaAWS Lambda now supports 
the .NET Core 2.1.0 runtime. For 
more information, see .NET Core 
CLI.July 9, 2018
Updates now available over RSSYou can now subscribe to an RSS 
feed to follow releases for this 
guide.July 5, 2018
Support for Amazon SQS as 
event sourceAWS Lambda now supports 
Amazon Simple Queue Service 
(Amazon SQS) as an event 
source. For more information, 
see Invoking Lambda functions.June 28, 2018
China (Ningxia) RegionAWS Lambda is now available 
in the China (Ningxia) Region. 
For more information about 
Lambda Regions and endpoints, 
see Regions and endpoints in the
AWS General Reference.June 28, 2018
Earlier updates
The following table describes the important changes in each release of the AWS Lambda Developer Guide
before June 2018.
Change Description Date
Runtime support for 
Node.js runtime 8.10AWS Lambda now supports Node.js runtime version 8.10. 
For more information, see Building Lambda functions with 
Node.js  (p. 272).April 2, 
2018
Function and alias 
revision IDsAWS Lambda now supports revision IDs on your function 
versions and aliases. You can use these IDs to track and apply 
conditional updates when you are updating your function 
version or alias resources.January 25, 
2018
Runtime support for Go 
and .NET 2.0AWS Lambda has added runtime support for Go and .NET 2.0. 
For more information, see Building Lambda functions with 
Go (p. 512) and Building Lambda functions with C# (p. 556).January 15, 
2018
Console Redesign AWS Lambda has introduced a new Lambda console to 
simplify your experience and added a Cloud9 Code Editor 
to enhance your ability debug and revise your function 
code. For more information, see Edit code using the console 
editor  (p. 25).November 
30,2017
1624AWS Lambda Developer Guide
Earlier updates
Change Description Date
Setting Concurrency 
Limits on Individual 
FunctionsAWS Lambda now supports setting concurrency limits on 
individual functions. For more information, see Conﬁguring 
reserved concurrency (p. 234).November 
30,2017
Shifting Traﬃc with 
AliasesAWS Lambda now supports shifting traﬃc with aliases. For 
more information, see Rolling deployments for Lambda 
functions  (p. 1079 ).November 
28, 2017
Gradual Code 
DeploymentAWS Lambda now supports safely deploying new versions of 
your Lambda function by leveraging Code Deploy. For more 
information, see  Gradual code deployment.November 
28, 2017
China (Beijing) RegionAWS Lambda is now available in the China (Beijing) Region. 
For more information about Lambda regions and endpoints, 
see Regions and endpoints in the AWS General Reference.November 
9, 2017
Introducing SAM LocalAWS Lambda introduces SAM Local (now known as SAM 
CLI), a AWS CLI tool that provides an environment for you 
to develop, test, and analyze your serverless applications 
locally before uploading them to the Lambda runtime. For 
more information, see  Testing and debugging serverless 
applications .August 11, 
2017
Canada (Central) RegionAWS Lambda is now available in the Canada (Central) Region. 
For more information about Lambda regions and endpoints, 
see Regions and endpoints in the AWS General Reference.June 22, 
2017
South America (São 
Paulo) RegionAWS Lambda is now available in the South America (São 
Paulo) Region. For more information about Lambda regions 
and endpoints, see Regions and endpoints in the AWS General 
Reference.June 6, 
2017
AWS Lambda support 
for AWS X-Ray.Lambda introduces support for X-Ray, which allows you to 
detect, analyze, and optimize performance issues with your 
Lambda applications. For more information, see Using AWS 
Lambda with AWS X-Ray (p. 973).April 19, 
2017
Asia Paciﬁc (Mumbai) 
RegionAWS Lambda is now available in the Asia Paciﬁc (Mumbai) 
Region. For more information about Lambda regions and 
endpoints, see Regions and endpoints in the AWS General 
Reference.March 28, 
2017
AWS Lambda now 
supports Node.js 
runtime v6.10AWS Lambda added support for Node.js runtime v6.10. 
For more information, see Building Lambda functions with 
Node.js  (p. 272).March 22, 
2017
Europe (London) RegionAWS Lambda is now available in the Europe (London) Region. 
For more information about Lambda regions and endpoints, 
see Regions and endpoints in the AWS General Reference.February 1, 
2017
AWS Lambda support 
for the .NET runtime, 
Lambda@Edge 
(Preview), Dead Letter 
Queues and automated 
deployment of 
serverless applications.AWS Lambda added support for C#. For more information, see
Building Lambda functions with C# (p. 556).
Lambda@Edge allows you to run Lambda functions at the 
AWS Edge locations in response to CloudFront events. For 
more information, see Using AWS Lambda with CloudFront 
Lambda@Edge (p. 673).December 
3, 2016
1625AWS Lambda Developer Guide
Earlier updates
Change Description Date
AWS Lambda adds 
Amazon Lex as a 
supported event source.Using Lambda and Amazon Lex, you can quickly build 
chat bots for various services like Slack and Facebook. For 
more information, see Using AWS Lambda with Amazon 
Lex (p. 778).November 
30, 2016
US West (N. California) 
RegionAWS Lambda is now available in the US West (N. California) 
Region. For more information about Lambda regions and 
endpoints, see Regions and endpoints in the AWS General 
Reference.November 
21, 2016
Introduced the AWS 
SAM for creating and 
deploying Lambda-
based applications and 
using environment 
variables for Lambda 
function conﬁguration 
settings.AWS SAM: You can now use the AWS SAM to deﬁne the syntax 
for expressing resources within a serverless application. 
In order to deploy your application, simply specify the 
resources you need as part of your application, along with 
their associated permissions policies in a AWS CloudFormation 
template ﬁle (written in either JSON or YAML), package your 
deployment artifacts, and deploy the template. For more 
information, see AWS Lambda applications (p. 1066 ).
Environment variables: You can use environment variables 
to specify conﬁguration settings for your Lambda function 
outside of your function code. For more information, see Using 
Lambda environment variables (p. 77).November 
18, 2016
Asia Paciﬁc (Seoul) 
RegionAWS Lambda is now available in the Asia Paciﬁc (Seoul) 
Region. For more information about Lambda regions and 
endpoints, see Regions and endpoints in the AWS General 
Reference.August 29, 
2016
Asia Paciﬁc (Sydney) 
RegionLambda is now available in the Asia Paciﬁc (Sydney) Region. 
For more information about Lambda regions and endpoints, 
see Regions and endpoints in the AWS General Reference.June 23, 
2016
Updates to the Lambda 
consoleThe Lambda console has been updated to simplify the role-
creation process.June 23, 
2016
AWS Lambda now 
supports Node.js 
runtime v4.3AWS Lambda added support for Node.js runtime v4.3. For 
more information, see Building Lambda functions with 
Node.js  (p. 272).April 07, 
2016
Europe (Frankfurt) 
regionLambda is now available in the Europe (Frankfurt) region. For 
more information about Lambda regions and endpoints, see
Regions and endpoints in the AWS General Reference.March 14, 
2016
VPC supportYou can now conﬁgure a Lambda function to access resources 
in your VPC. For more information, see Connecting outbound 
networking to resources in a VPC (p. 85).February 
11, 2016
Lambda runtime has 
been updated.The execution environment (p. 41) has been updated. November 
4, 2015
1626AWS Lambda Developer Guide
Earlier updates
Change Description Date
Versioning support, 
Python for 
developing code for 
Lambdafunctions, 
scheduled events, and 
increase in execution 
timeYou can now develop your Lambda function code using 
Python. For more information, see Building Lambda functions 
with Python (p. 346).
Versioning: You can maintain one or more versions of your 
Lambda function. Versioning allows you to control which 
Lambda function version is executed in diﬀerent environments 
(for example, development, testing, or production). For more 
information, see Lambda function versions (p. 108).
Scheduled events: You can also set up Lambda to invoke your 
code on a regular, scheduled basis using the Lambda console. 
You can specify a ﬁxed rate (number of hours, days, or weeks) 
or you can specify a cron expression. For an example, see
Using AWS Lambda with Amazon EventBridge (CloudWatch 
Events) (p. 663).
Increase in execution time: You can now set up your Lambda 
functions to run for up to ﬁve minutes allowing longer 
running functions such as large volume data ingestion and 
processing jobs.October 
08, 2015
Support for DynamoDB 
StreamsDynamoDB Streams is now generally available and you can 
use it in all the regions where DynamoDB is available. You can 
enable DynamoDB Streams for your table and use a Lambda 
function as a trigger for the table. Triggers are custom actions 
you take in response to updates made to the DynamoDB table. 
For an example walkthrough, see Tutorial: Using AWS Lambda 
with Amazon DynamoDB streams (p. 720) .July 14, 
2015
Lambda now supports 
invoking Lambda 
functions with REST-
compatible clients.Until now, to invoke your Lambda function from your web, 
mobile, or IoT application you needed the AWS SDKs (for 
example, AWS SDK for Java, AWS SDK for Android, or AWS 
SDK for iOS). Now, Lambda supports invoking a Lambda 
function with REST-compatible clients through a customized 
API that you can create using Amazon API Gateway. You 
can send requests to your Lambda function endpoint URL. 
You can conﬁgure security on the endpoint to allow open 
access, leverage AWS Identity and Access Management (IAM) 
to authorize access, or use API keys to meter access to your 
Lambda functions by others.
For an example Getting Started exercise, see Using AWS 
Lambda with Amazon API Gateway (p. 634).
For more information about the Amazon API Gateway, see
https://aws.amazon.com/api-gateway/.July 09, 
2015
The Lambda console 
now provides blueprints 
to easily create Lambda 
functions and test them.Lambda console provides a set of blueprints . Each blueprint 
provides a sample event source conﬁguration and sample code 
for your Lambda function that you can use to easily create 
Lambda-based applications. All of the Lambda Getting Started 
exercises now use the blueprints. For more information, see
Getting started with Lambda (p. 3).July 09, 
2015
1627AWS Lambda Developer Guide
Earlier updates
Change Description Date
Lambda now supports 
Java to author your 
Lambda functions.You can now author Lambda code in Java. For more 
information, see Building Lambda functions with Java (p. 438).June 15, 
2015
Lambda now supports 
specifying an Amazon 
S3 object as the 
function .zip when 
creating or updating a 
Lambda function.You can upload a Lambda function deployment package (.zip 
ﬁle) to an Amazon S3 bucket in the same region where you 
want to create a Lambda function. Then, you can specify the 
bucket name and object key name when you create or update 
a Lambda function.May 28, 
2015
Lambda now generally 
available with added 
support for mobile 
backendsLambda is now generally available for production use. The 
release also introduces new features that make it easier to 
build mobile, tablet, and Internet of Things (IoT) backends 
using Lambda that scale automatically without provisioning or 
managing infrastructure. Lambda now supports both real-time 
(synchronous) and asynchronous events. Additional features 
include easier event source conﬁguration and management. 
The permission model and the programming model have been 
simpliﬁed by the introduction of resource policies for your 
Lambda functions.
The documentation has been updated accordingly. For 
information, see the following topics:
Getting started with Lambda (p. 3)
AWS LambdaApril 9, 
2015
Preview releasePreview release of the AWS Lambda Developer Guide.November 
13, 2014
1628